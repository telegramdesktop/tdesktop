diff --git a/mkspecs/common/msvc-desktop.conf b/mkspecs/common/msvc-desktop.conf
index eec9e1f..7ae53c7 100644
--- a/mkspecs/common/msvc-desktop.conf
+++ b/mkspecs/common/msvc-desktop.conf
@@ -30,9 +30,10 @@ QMAKE_YACCFLAGS         = -d
 QMAKE_CFLAGS            = -nologo -Zc:wchar_t
 QMAKE_CFLAGS_WARN_ON    = -W3
 QMAKE_CFLAGS_WARN_OFF   = -W0
-QMAKE_CFLAGS_RELEASE    = -O2 -MD
-QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += -O2 -MD -Zi
-QMAKE_CFLAGS_DEBUG      = -Zi -MDd
+# Patch: Make this build use static runtime library.
+QMAKE_CFLAGS_RELEASE    = -O2 -MT
+QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += -O2 -MT -Zi
+QMAKE_CFLAGS_DEBUG      = -Zi -MTd
 QMAKE_CFLAGS_YACC       =
 QMAKE_CFLAGS_LTCG       = -GL
 QMAKE_CFLAGS_SSE2       = -arch:SSE2
diff --git a/src/corelib/io/qfsfileengine_win.cpp b/src/corelib/io/qfsfileengine_win.cpp
index 391fbcc..d07802b 100644
--- a/src/corelib/io/qfsfileengine_win.cpp
+++ b/src/corelib/io/qfsfileengine_win.cpp
@@ -427,11 +427,12 @@ qint64 QFSFileEnginePrivate::nativeWrite(const char *data, qint64 len)
 
     // Writing on Windows fails with ERROR_NO_SYSTEM_RESOURCES when
     // the chunks are too large, so we limit the block size to 32MB.
-    const DWORD blockSize = DWORD(qMin(bytesToWrite, qint64(32 * 1024 * 1024)));
     qint64 totalWritten = 0;
     do {
+        // Patch: backport critical bugfix from '683c9bc4a8' commit.
+        const DWORD currentBlockSize = DWORD(qMin(bytesToWrite, qint64(32 * 1024 * 1024)));
         DWORD bytesWritten;
-        if (!WriteFile(fileHandle, data + totalWritten, blockSize, &bytesWritten, NULL)) {
+        if (!WriteFile(fileHandle, data + totalWritten, currentBlockSize, &bytesWritten, NULL)) {
             if (totalWritten == 0) {
                 // Note: Only return error if the first WriteFile failed.
                 q->setError(QFile::WriteError, qt_error_string());
diff --git a/src/corelib/tools/qunicodetables.cpp b/src/corelib/tools/qunicodetables.cpp
index 14e4fd1..0619a17 100644
--- a/src/corelib/tools/qunicodetables.cpp
+++ b/src/corelib/tools/qunicodetables.cpp
@@ -6227,7 +6227,8 @@ static const Properties uc_properties[] = {
     { 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 7, 4, 4, 21, 11 },
     { 0, 17, 230, 5, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 4, 4, 21, 11 },
     { 18, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 85, 0, 8, 8, 12, 11 },
-    { 25, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 17, 2 },
+    // Patch: Some bad characters appeared in ui in case 2 was here instead of 11.
+    { 25, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 17, 11 },
     { 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 14, 9, 11, 11 },
     { 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 14, 9, 11, 11 },
     { 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 14, 9, 11, 11 },
diff --git a/src/gui/kernel/qhighdpiscaling.cpp b/src/gui/kernel/qhighdpiscaling.cpp
index 2d00b9d..eeba86e 100644
--- a/src/gui/kernel/qhighdpiscaling.cpp
+++ b/src/gui/kernel/qhighdpiscaling.cpp
@@ -51,6 +51,9 @@ static const char screenFactorsEnvVar[] = "QT_SCREEN_SCALE_FACTORS";
 
 static inline qreal initialGlobalScaleFactor()
 {
+    // Patch: Disable environment variable dpi scaling changing.
+    // It is not supported by Telegram Desktop :(
+    return 1.;
 
     qreal result = 1;
     if (qEnvironmentVariableIsSet(scaleFactorEnvVar)) {
diff --git a/src/gui/kernel/qplatformdialoghelper.h b/src/gui/kernel/qplatformdialoghelper.h
index 5b2f4ec..790db46 100644
--- a/src/gui/kernel/qplatformdialoghelper.h
+++ b/src/gui/kernel/qplatformdialoghelper.h
@@ -386,6 +386,10 @@ public:
     virtual QUrl directory() const = 0;
     virtual void selectFile(const QUrl &filename) = 0;
     virtual QList<QUrl> selectedFiles() const = 0;
+
+    // Patch: Adding select-by-url for Windows file dialog.
+    virtual QByteArray selectedRemoteContent() const { return QByteArray(); }
+
     virtual void setFilter() = 0;
     virtual void selectNameFilter(const QString &filter) = 0;
     virtual QString selectedNameFilter() const = 0;
diff --git a/src/gui/kernel/qwindow.cpp b/src/gui/kernel/qwindow.cpp
index bcd29b6..bcb0672 100644
--- a/src/gui/kernel/qwindow.cpp
+++ b/src/gui/kernel/qwindow.cpp
@@ -2525,7 +2525,8 @@ void QWindowPrivate::setCursor(const QCursor *newCursor)
 void QWindowPrivate::applyCursor()
 {
     Q_Q(QWindow);
-    if (platformWindow) {
+    // Patch: Fixing possible crash (crashdumps point on this code line).
+    if (platformWindow && q->screen() && q->screen()->handle()) {
         if (QPlatformCursor *platformCursor = q->screen()->handle()->cursor()) {
             QCursor *c = QGuiApplication::overrideCursor();
             if (!c && hasCursor)
diff --git a/src/gui/painting/qpaintengine_p.h b/src/gui/painting/qpaintengine_p.h
index 918c989..4158259 100644
--- a/src/gui/painting/qpaintengine_p.h
+++ b/src/gui/painting/qpaintengine_p.h
@@ -80,8 +80,18 @@ public:
         if (hasSystemTransform) {
             if (systemTransform.type() <= QTransform::TxTranslate)
                 systemClip.translate(qRound(systemTransform.dx()), qRound(systemTransform.dy()));
-            else
+            // Patch: Transform the system clip region back from device pixels to device-independent pixels before
+            // applying systemTransform, which already has transform from device-independent pixels to device pixels.
+            else {
+#ifdef Q_OS_MAC
+                QTransform scaleTransform;
+                const qreal invDevicePixelRatio = 1. / pdev->devicePixelRatio();
+                scaleTransform.scale(invDevicePixelRatio, invDevicePixelRatio);
+                systemClip = systemTransform.map(scaleTransform.map(systemClip));
+#else
                 systemClip = systemTransform.map(systemClip);
+#endif
+            }
         }
 
         // Make sure we're inside the viewport.
diff --git a/src/gui/text/qtextengine_p.h b/src/gui/text/qtextengine_p.h
index 7e507bb..936e7a9 100644
--- a/src/gui/text/qtextengine_p.h
+++ b/src/gui/text/qtextengine_p.h
@@ -283,7 +283,8 @@ private:
 
 struct QScriptItem;
 /// Internal QTextItem
-class QTextItemInt : public QTextItem
+// Patch: Enable access to QTextItemInt in .dll for WinRT build.
+class Q_GUI_EXPORT QTextItemInt : public QTextItem
 {
 public:
     inline QTextItemInt()
diff --git a/src/gui/text/qtextlayout.cpp b/src/gui/text/qtextlayout.cpp
index aca475a..5fa0be2 100644
--- a/src/gui/text/qtextlayout.cpp
+++ b/src/gui/text/qtextlayout.cpp
@@ -694,6 +694,9 @@ int QTextLayout::nextCursorPosition(int oldPos, CursorMode mode) const
         while (oldPos < len && !attributes[oldPos].graphemeBoundary)
             oldPos++;
     } else {
+        // Patch: Skip to the end of the current word, not to the start of the next one.
+        while (oldPos < len && attributes[oldPos].whiteSpace)
+            oldPos++;
         if (oldPos < len && d->atWordSeparator(oldPos)) {
             oldPos++;
             while (oldPos < len && d->atWordSeparator(oldPos))
@@ -702,8 +705,9 @@ int QTextLayout::nextCursorPosition(int oldPos, CursorMode mode) const
             while (oldPos < len && !attributes[oldPos].whiteSpace && !d->atWordSeparator(oldPos))
                 oldPos++;
         }
-        while (oldPos < len && attributes[oldPos].whiteSpace)
-            oldPos++;
+        // Patch: Skip to the end of the current word, not to the start of the next one.
+        //while (oldPos < len && attributes[oldPos].whiteSpace)
+        //    oldPos++;
     }
 
     return oldPos;
@@ -1645,6 +1649,9 @@ namespace {
         int currentPosition;
         glyph_t previousGlyph;
 
+        // Patch: Fix a crash in right bearing calculation.
+        QFontEngine *previousGlyphFontEngine;
+
         QFixed minw;
         QFixed softHyphenWidth;
         QFixed rightBearing;
@@ -1677,13 +1684,19 @@ namespace {
             if (currentPosition > 0 &&
                 logClusters[currentPosition - 1] < glyphs.numGlyphs) {
                 previousGlyph = currentGlyph(); // needed to calculate right bearing later
+
+                // Patch: Fix a crash in right bearing calculation.
+                previousGlyphFontEngine = fontEngine;
             }
         }
 
-        inline void calculateRightBearing(glyph_t glyph)
+        // Patch: Fix a crash in right bearing calculation.
+        inline void calculateRightBearing(QFontEngine *engine, glyph_t glyph)
         {
             qreal rb;
-            fontEngine->getGlyphBearings(glyph, 0, &rb);
+
+            // Patch: Fix a crash in right bearing calculation.
+            engine->getGlyphBearings(glyph, 0, &rb);
 
             // We only care about negative right bearings, so we limit the range
             // of the bearing here so that we can assume it's negative in the rest
@@ -1696,13 +1709,16 @@ namespace {
         {
             if (currentPosition <= 0)
                 return;
-            calculateRightBearing(currentGlyph());
+
+            // Patch: Fix a crash in right bearing calculation.
+            calculateRightBearing(fontEngine, currentGlyph());
         }
 
         inline void calculateRightBearingForPreviousGlyph()
         {
             if (previousGlyph > 0)
-                calculateRightBearing(previousGlyph);
+                // Patch: Fix a crash in right bearing calculation.
+                calculateRightBearing(previousGlyphFontEngine, previousGlyph);
         }
 
         static const QFixed RightBearingNotCalculated;
diff --git a/src/gui/text/qtextlayout.h b/src/gui/text/qtextlayout.h
index f74d4d4..8ad672c 100644
--- a/src/gui/text/qtextlayout.h
+++ b/src/gui/text/qtextlayout.h
@@ -196,6 +196,9 @@ private:
                                QRectF *brect, int tabstops, int* tabarray, int tabarraylen,
                                QPainter *painter);
     QTextEngine *d;
+
+    // Patch: Allow access to private constructor.
+    friend class TextBlock;
 };
 
 
diff --git a/src/network/socket/qnativesocketengine_win.cpp b/src/network/socket/qnativesocketengine_win.cpp
index 41834b2..8cdf4ab 100644
--- a/src/network/socket/qnativesocketengine_win.cpp
+++ b/src/network/socket/qnativesocketengine_win.cpp
@@ -675,6 +675,13 @@ bool QNativeSocketEnginePrivate::nativeConnect(const QHostAddress &address, quin
                             errorDetected = true;
                             break;
                         }
+                        // Patch: Handle network unreachable the same as host unreachable.
+                        if (value == WSAENETUNREACH) {
+                            setError(QAbstractSocket::NetworkError, NetworkUnreachableErrorString);
+                            socketState = QAbstractSocket::UnconnectedState;
+                            errorDetected = true;
+                            break;
+                        }
                         if (value == WSAEADDRNOTAVAIL) {
                             setError(QAbstractSocket::NetworkError, AddressNotAvailableErrorString);
                             socketState = QAbstractSocket::UnconnectedState;
diff --git a/src/platformsupport/fontdatabases/basic/qbasicfontdatabase.cpp b/src/platformsupport/fontdatabases/basic/qbasicfontdatabase.cpp
index 728b166..1dc6459 100644
--- a/src/platformsupport/fontdatabases/basic/qbasicfontdatabase.cpp
+++ b/src/platformsupport/fontdatabases/basic/qbasicfontdatabase.cpp
@@ -172,6 +172,79 @@ void QBasicFontDatabase::releaseHandle(void *handle)
 
 extern FT_Library qt_getFreetype();
 
+// Patch: Enable Open Sans Semibold font family reading.
+// Copied from freetype with some modifications.
+
+#ifndef FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY
+#define FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY FT_MAKE_TAG('i', 'g', 'p', 'f')
+#endif
+
+#ifndef FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY
+#define FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY FT_MAKE_TAG('i', 'g', 'p', 's')
+#endif
+
+/* there's a Mac-specific extended implementation of FT_New_Face() */
+/* in src/base/ftmac.c                                             */
+
+#if !defined( FT_MACINTOSH ) || defined( DARWIN_NO_CARBON )
+
+/* documentation is in freetype.h */
+
+FT_Error __ft_New_Face(FT_Library library, const char* pathname, FT_Long face_index, FT_Face *aface) {
+    FT_Open_Args args;
+
+    /* test for valid `library' and `aface' delayed to FT_Open_Face() */
+    if (!pathname)
+        return FT_Err_Invalid_Argument;
+
+    FT_Parameter params[2];
+    params[0].tag = FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY;
+    params[0].data = 0;
+    params[1].tag = FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY;
+    params[1].data = 0;
+    args.flags = FT_OPEN_PATHNAME | FT_OPEN_PARAMS;
+    args.pathname = (char*)pathname;
+    args.stream = NULL;
+    args.num_params = 2;
+    args.params = params;
+
+    return FT_Open_Face(library, &args, face_index, aface);
+}
+
+#else
+
+FT_Error __ft_New_Face(FT_Library library, const char* pathname, FT_Long face_index, FT_Face *aface) {
+    return FT_New_Face(library, pathname, face_index, aface);
+}
+
+#endif  /* defined( FT_MACINTOSH ) && !defined( DARWIN_NO_CARBON ) */
+
+/* documentation is in freetype.h */
+
+FT_Error __ft_New_Memory_Face(FT_Library library, const FT_Byte* file_base, FT_Long file_size, FT_Long face_index, FT_Face *aface) {
+    FT_Open_Args  args;
+
+    /* test for valid `library' and `face' delayed to FT_Open_Face() */
+    if (!file_base)
+        return FT_Err_Invalid_Argument;
+
+    FT_Parameter params[2];
+    params[0].tag = FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY;
+    params[0].data = 0;
+    params[1].tag = FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY;
+    params[1].data = 0;
+    args.flags = FT_OPEN_MEMORY | FT_OPEN_PARAMS;
+    args.memory_base = file_base;
+    args.memory_size = file_size;
+    args.stream = NULL;
+    args.num_params = 2;
+    args.params = params;
+
+    return FT_Open_Face(library, &args, face_index, aface);
+}
+
+// end
+
 QStringList QBasicFontDatabase::addTTFile(const QByteArray &fontData, const QByteArray &file)
 {
     FT_Library library = qt_getFreetype();
@@ -183,9 +256,11 @@ QStringList QBasicFontDatabase::addTTFile(const QByteArray &fontData, const QByt
         FT_Face face;
         FT_Error error;
         if (!fontData.isEmpty()) {
-            error = FT_New_Memory_Face(library, (const FT_Byte *)fontData.constData(), fontData.size(), index, &face);
+            // Patch: Enable Open Sans Semibold font family reading.
+            error = __ft_New_Memory_Face(library, (const FT_Byte *)fontData.constData(), fontData.size(), index, &face);
         } else {
-            error = FT_New_Face(library, file.constData(), index, &face);
+            // Patch: Enable Open Sans Semibold font family reading.
+            error = __ft_New_Face(library, file.constData(), index, &face);
         }
         if (error != FT_Err_Ok) {
             qDebug() << "FT_New_Face failed with index" << index << ':' << hex << error;
diff --git a/src/platformsupport/fontdatabases/fontconfig/qfontconfigdatabase.cpp b/src/platformsupport/fontdatabases/fontconfig/qfontconfigdatabase.cpp
index 8ebabf3..7bb8abd 100644
--- a/src/platformsupport/fontdatabases/fontconfig/qfontconfigdatabase.cpp
+++ b/src/platformsupport/fontdatabases/fontconfig/qfontconfigdatabase.cpp
@@ -375,6 +375,17 @@ static void populateFromPattern(FcPattern *pattern)
 
     familyName = QString::fromUtf8((const char *)value);
 
+    // Patch: Enable Open Sans Semibold font family reading.
+    if (familyName == QLatin1String("Open Sans")) {
+        FcChar8 *styl = 0;
+        if (FcPatternGetString(pattern, FC_STYLE, 0, &styl) == FcResultMatch) {
+            QString style = QString::fromUtf8(reinterpret_cast<const char *>(styl));
+            if (style == QLatin1String("Semibold")) {
+                familyName.append(QChar(QChar::Space)).append(style);
+            }
+        }
+    }
+
     slant_value = FC_SLANT_ROMAN;
     weight_value = FC_WEIGHT_REGULAR;
     spacing_value = FC_PROPORTIONAL;
@@ -718,7 +729,19 @@ QStringList QFontconfigDatabase::fallbacksForFamily(const QString &family, QFont
             if (FcPatternGetString(fontSet->fonts[i], FC_FAMILY, 0, &value) != FcResultMatch)
                 continue;
             //         capitalize(value);
-            const QString familyName = QString::fromUtf8((const char *)value);
+
+            // Patch: Enable Open Sans Semibold font family reading.
+            QString familyName = QString::fromUtf8((const char *)value);
+            if (familyName == QLatin1String("Open Sans")) {
+                FcChar8 *styl = 0;
+                if (FcPatternGetString(fontSet->fonts[i], FC_STYLE, 0, &styl) == FcResultMatch) {
+                    QString style = QString::fromUtf8(reinterpret_cast<const char *>(styl));
+                    if (style == QLatin1String("Semibold")) {
+                        familyName.append(QChar(QChar::Space)).append(style);
+                    }
+                }
+            }
+
             const QString familyNameCF = familyName.toCaseFolded();
             if (!duplicates.contains(familyNameCF)) {
                 fallbackFamilies << familyName;
@@ -784,6 +807,18 @@ QStringList QFontconfigDatabase::addApplicationFont(const QByteArray &fontData,
         FcChar8 *fam = 0;
         if (FcPatternGetString(pattern, FC_FAMILY, 0, &fam) == FcResultMatch) {
             QString family = QString::fromUtf8(reinterpret_cast<const char *>(fam));
+
+            // Patch: Enable Open Sans Semibold font family reading.
+            if (family == QLatin1String("Open Sans")) {
+                FcChar8 *styl = 0;
+                if (FcPatternGetString(pattern, FC_STYLE, 0, &styl) == FcResultMatch) {
+                    QString style = QString::fromUtf8(reinterpret_cast<const char *>(styl));
+                    if (style == QLatin1String("Semibold")) {
+                        family.append(QChar(QChar::Space)).append(style);
+                    }
+                }
+            }
+
             families << family;
         }
         populateFromPattern(pattern);
diff --git a/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase.mm b/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase.mm
index 566abf2..5b9c714 100644
--- a/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase.mm
+++ b/src/platformsupport/fontdatabases/mac/qcoretextfontdatabase.mm
@@ -265,6 +265,13 @@ static void getFontDescription(CTFontDescriptorRef font, FontDescription *fd)
 
     fd->foundryName = QStringLiteral("CoreText");
     fd->familyName = (CFStringRef) CTFontDescriptorCopyAttribute(font, kCTFontFamilyNameAttribute);
+
+    // Patch: Enable Open Sans Semibold font family reading.
+    QCFString _displayName = (CFStringRef) CTFontDescriptorCopyAttribute(font, kCTFontDisplayNameAttribute);
+    if (_displayName == QStringLiteral("Open Sans Semibold")) {
+        fd->familyName = _displayName;
+    }
+
     fd->styleName = (CFStringRef)CTFontDescriptorCopyAttribute(font, kCTFontStyleNameAttribute);
     fd->weight = QFont::Normal;
     fd->style = QFont::StyleNormal;
diff --git a/src/plugins/platforminputcontexts/compose/compose.pro b/src/plugins/platforminputcontexts/compose/compose.pro
index 86bdd47..9b9c8de 100644
--- a/src/plugins/platforminputcontexts/compose/compose.pro
+++ b/src/plugins/platforminputcontexts/compose/compose.pro
@@ -15,7 +15,8 @@ HEADERS += $$PWD/qcomposeplatforminputcontext.h \
 contains(QT_CONFIG, xkbcommon-qt): {
     # dont't need x11 dependency for compose key plugin
     QT_CONFIG -= use-xkbcommon-x11support
-    include(../../../3rdparty/xkbcommon.pri)
+    # Patch: Adding fcitx input context plugin to our static build.
+    #include(../../../3rdparty/xkbcommon.pri)
 } else {
     LIBS += $$QMAKE_LIBS_XKBCOMMON
     QMAKE_CXXFLAGS += $$QMAKE_CFLAGS_XKBCOMMON
diff --git a/src/plugins/platforminputcontexts/compose/qcomposeplatforminputcontext.cpp b/src/plugins/platforminputcontexts/compose/qcomposeplatforminputcontext.cpp
index d1bea9a..36a15a6 100644
--- a/src/plugins/platforminputcontexts/compose/qcomposeplatforminputcontext.cpp
+++ b/src/plugins/platforminputcontexts/compose/qcomposeplatforminputcontext.cpp
@@ -232,6 +232,12 @@ bool QComposeInputContext::checkComposeTable()
 
 void QComposeInputContext::commitText(uint character) const
 {
+    // Patch: Crash fix when not focused widget still receives input events.
+    if (!m_focusObject) {
+        qWarning("QComposeInputContext::commitText: m_focusObject == nullptr, cannot commit text");
+        return;
+    }
+
     QInputMethodEvent event;
     event.setCommitString(QChar(character));
     QCoreApplication::sendEvent(m_focusObject, &event);
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitx.json b/src/plugins/platforminputcontexts/fcitx/fcitx.json
new file mode 100644
index 0000000..6d2b389
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitx.json
@@ -0,0 +1,3 @@
+{
+    "Keys": [ "fcitx" ]
+}
\ No newline at end of file
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitx.pro b/src/plugins/platforminputcontexts/fcitx/fcitx.pro
new file mode 100644
index 0000000..6f4f1e5
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitx.pro
@@ -0,0 +1,38 @@
+TARGET = fcitxplatforminputcontextplugin
+
+PLUGIN_TYPE = platforminputcontexts
+PLUGIN_EXTENDS = -
+PLUGIN_CLASS_NAME = QFcitxPlatformInputContextPlugin
+load(qt_plugin)
+
+QT += dbus gui-private
+SOURCES += $$PWD/fcitxqtconnection.cpp \
+     $$PWD/fcitxqtformattedpreedit.cpp \
+     $$PWD/fcitxqtinputcontextproxy.cpp \
+     $$PWD/fcitxqtinputmethoditem.cpp \
+     $$PWD/fcitxqtinputmethodproxy.cpp \
+     $$PWD/fcitxqtkeyboardlayout.cpp \
+     $$PWD/fcitxqtkeyboardproxy.cpp \
+     $$PWD/keyuni.cpp \
+     $$PWD/main.cpp \
+     $$PWD/qfcitxplatforminputcontext.cpp \
+     $$PWD/utils.cpp
+
+HEADERS += $$PWD/fcitxqtconnection.h \
+     $$PWD/fcitxqtconnection_p.h \
+     $$PWD/fcitxqtdbusaddons_export.h \
+     $$PWD/fcitxqtdbusaddons_version.h \
+     $$PWD/fcitxqtformattedpreedit.h \
+     $$PWD/fcitxqtinputcontextproxy.h \
+     $$PWD/fcitxqtinputmethoditem.h \
+     $$PWD/fcitxqtinputmethodproxy.h \
+     $$PWD/fcitxqtkeyboardlayout.h \
+     $$PWD/fcitxqtkeyboardproxy.h \
+     $$PWD/keydata.h \
+     $$PWD/keyserver_x11.h \
+     $$PWD/keyuni.h \
+     $$PWD/main.h \
+     $$PWD/qfcitxplatforminputcontext.h \
+     $$PWD/utils.h
+
+OTHER_FILES += $$PWD/fcitx.json
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtconnection.cpp b/src/plugins/platforminputcontexts/fcitx/fcitxqtconnection.cpp
new file mode 100644
index 0000000..a50178a
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtconnection.cpp
@@ -0,0 +1,369 @@
+/***************************************************************************
+ *   Copyright (C) 2012~2012 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#include "fcitxqtconnection_p.h"
+#include <QDBusConnection>
+#include <QDBusServiceWatcher>
+#include <QDBusReply>
+#include <QDBusConnectionInterface>
+#include <QDebug>
+#include <QFile>
+#include <QTimer>
+#include <QDir>
+
+#include <signal.h>
+#include <errno.h>
+
+// utils function in fcitx-utils and fcitx-config
+bool _pid_exists(pid_t pid) {
+    if (pid <= 0)
+        return 0;
+    return !(kill(pid, 0) && (errno == ESRCH));
+}
+
+
+FcitxQtConnection::FcitxQtConnection(QObject* parent): QObject(parent)
+    ,d_ptr(new FcitxQtConnectionPrivate(this))
+{
+}
+
+void FcitxQtConnection::startConnection()
+{
+    Q_D(FcitxQtConnection);
+    if (!d->m_initialized) {
+        d->initialize();
+        d->createConnection();
+    }
+}
+
+void FcitxQtConnection::endConnection()
+{
+    Q_D(FcitxQtConnection);
+    d->cleanUp();
+    d->finalize();
+    d->m_connectedOnce = false;
+}
+
+bool FcitxQtConnection::autoReconnect()
+{
+    Q_D(FcitxQtConnection);
+    return d->m_autoReconnect;
+}
+
+void FcitxQtConnection::setAutoReconnect(bool a)
+{
+    Q_D(FcitxQtConnection);
+    d->m_autoReconnect = a;
+}
+
+QDBusConnection* FcitxQtConnection::connection()
+{
+    Q_D(FcitxQtConnection);
+    return d->m_connection;
+}
+
+const QString& FcitxQtConnection::serviceName()
+{
+    Q_D(FcitxQtConnection);
+    return d->m_serviceName;
+}
+
+bool FcitxQtConnection::isConnected()
+{
+    Q_D(FcitxQtConnection);
+    return d->isConnected();
+}
+
+
+
+FcitxQtConnection::~FcitxQtConnection()
+{
+}
+
+FcitxQtConnectionPrivate::FcitxQtConnectionPrivate(FcitxQtConnection* conn) : QObject(conn)
+    ,q_ptr(conn)
+    ,m_displayNumber(-1)
+    ,m_serviceName(QString("%1-%2").arg("org.fcitx.Fcitx").arg(displayNumber()))
+    ,m_connection(0)
+    ,m_serviceWatcher(new QDBusServiceWatcher(conn))
+    ,m_watcher(new QFileSystemWatcher(this))
+    ,m_autoReconnect(true)
+    ,m_connectedOnce(false)
+    ,m_initialized(false)
+{
+}
+
+FcitxQtConnectionPrivate::~FcitxQtConnectionPrivate()
+{
+    if (m_connection)
+        delete m_connection;
+}
+
+void FcitxQtConnectionPrivate::initialize() {
+    m_serviceWatcher->setConnection(QDBusConnection::sessionBus());
+    m_serviceWatcher->addWatchedService(m_serviceName);
+
+    QFileInfo info(socketFile());
+    QDir dir(info.path());
+    if (!dir.exists()) {
+        QDir rt(QDir::root());
+        rt.mkpath(info.path());
+    }
+    m_watcher->addPath(info.path());
+    if (info.exists()) {
+        m_watcher->addPath(info.filePath());
+    }
+
+    connect(m_watcher, SIGNAL(fileChanged(QString)), this, SLOT(socketFileChanged()));
+    connect(m_watcher, SIGNAL(directoryChanged(QString)), this, SLOT(socketFileChanged()));
+    m_initialized = true;
+}
+
+void FcitxQtConnectionPrivate::finalize() {
+    m_serviceWatcher->removeWatchedService(m_serviceName);
+    m_watcher->removePaths(m_watcher->files());
+    m_watcher->removePaths(m_watcher->directories());
+    m_watcher->disconnect(SIGNAL(fileChanged(QString)));
+    m_watcher->disconnect(SIGNAL(directoryChanged(QString)));
+    m_initialized = false;
+}
+
+void FcitxQtConnectionPrivate::socketFileChanged() {
+    QFileInfo info(socketFile());
+    if (info.exists()) {
+        if (m_watcher->files().indexOf(info.filePath()) == -1)
+            m_watcher->addPath(info.filePath());
+    }
+
+    QString addr = address();
+    if (addr.isNull())
+        return;
+
+    cleanUp();
+    createConnection();
+}
+
+QByteArray FcitxQtConnectionPrivate::localMachineId()
+{
+#if QT_VERSION >= QT_VERSION_CHECK(4, 8, 0)
+    return QDBusConnection::localMachineId();
+#else
+    QFile file1("/var/lib/dbus/machine-id");
+    QFile file2("/etc/machine-id");
+    QFile* fileToRead = NULL;
+    if (file1.open(QIODevice::ReadOnly)) {
+        fileToRead = &file1;
+    }
+    else if (file2.open(QIODevice::ReadOnly)) {
+        fileToRead = &file2;
+    }
+    if (fileToRead) {
+        QByteArray result = fileToRead->readLine(1024);
+        fileToRead->close();
+        result = result.trimmed();
+        if (!result.isEmpty())
+            return result;
+    }
+    return "machine-id";
+#endif
+}
+
+int FcitxQtConnectionPrivate::displayNumber() {
+    if (m_displayNumber < 0) {
+        QByteArray displayNumber("0");
+        QByteArray display(qgetenv("DISPLAY"));
+        int pos = display.indexOf(':');
+
+        if (pos >= 0) {
+            ++pos;
+            int pos2 = display.indexOf('.', pos);
+            if (pos2 > 0) {
+                displayNumber = display.mid(pos, pos2 - pos);
+            } else {
+                displayNumber = display.mid(pos);
+            }
+        }
+
+        bool ok;
+        int d = displayNumber.toInt(&ok);
+        if (ok) {
+            m_displayNumber = d;
+        } else {
+            m_displayNumber = 0;
+        }
+    }
+
+    return m_displayNumber;
+}
+
+const QString& FcitxQtConnectionPrivate::socketFile()
+{
+    if (!m_socketFile.isEmpty())
+        return m_socketFile;
+
+    QString filename = QString("%1-%2").arg(QString::fromLatin1(QDBusConnection::localMachineId())).arg(displayNumber());
+
+    QString home = QString::fromLocal8Bit(qgetenv("XDG_CONFIG_HOME"));
+    if (home.isEmpty()) {
+        home = QDir::homePath().append(QLatin1Literal("/.config"));
+    }
+    m_socketFile = QString("%1/fcitx/dbus/%2").arg(home).arg(filename);
+
+    return m_socketFile;
+}
+
+QString FcitxQtConnectionPrivate::address()
+{
+    QString addr;
+    QByteArray addrVar = qgetenv("FCITX_DBUS_ADDRESS");
+    if (!addrVar.isNull())
+        return QString::fromLocal8Bit(addrVar);
+
+    QFile file(socketFile());
+    if (!file.open(QIODevice::ReadOnly))
+        return QString();
+
+    const int BUFSIZE = 1024;
+
+    char buffer[BUFSIZE];
+    size_t sz = file.read(buffer, BUFSIZE);
+    file.close();
+    if (sz == 0)
+        return QString();
+    char* p = buffer;
+    while(*p)
+        p++;
+    size_t addrlen = p - buffer;
+    if (sz != addrlen + 2 * sizeof(pid_t) + 1)
+        return QString();
+
+    /* skip '\0' */
+    p++;
+    pid_t *ppid = (pid_t*) p;
+    pid_t daemonpid = ppid[0];
+    pid_t fcitxpid = ppid[1];
+
+    if (!_pid_exists(daemonpid)
+        || !_pid_exists(fcitxpid))
+        return QString();
+
+    addr = QLatin1String(buffer);
+
+    return addr;
+}
+
+void FcitxQtConnectionPrivate::createConnection() {
+    if (m_connectedOnce && !m_autoReconnect) {
+        return;
+    }
+
+    m_serviceWatcher->disconnect(SIGNAL(serviceOwnerChanged(QString,QString,QString)));
+    QString addr = address();
+    if (!addr.isNull()) {
+        QDBusConnection connection(QDBusConnection::connectToBus(addr, "fcitx"));
+        if (connection.isConnected()) {
+            // qDebug() << "create private";
+            m_connection = new QDBusConnection(connection);
+        }
+        else
+            QDBusConnection::disconnectFromBus("fcitx");
+    }
+
+    if (!m_connection) {
+        QDBusConnection* connection = new QDBusConnection(QDBusConnection::sessionBus());
+        connect(m_serviceWatcher, SIGNAL(serviceOwnerChanged(QString,QString,QString)), this, SLOT(imChanged(QString,QString,QString)));
+        QDBusReply<bool> registered = connection->interface()->isServiceRegistered(m_serviceName);
+        if (!registered.isValid() || !registered.value()) {
+            delete connection;
+        }
+        else {
+            m_connection = connection;
+        }
+    }
+
+    Q_Q(FcitxQtConnection);
+    if (m_connection) {
+
+        m_connection->connect ("org.freedesktop.DBus.Local",
+                            "/org/freedesktop/DBus/Local",
+                            "org.freedesktop.DBus.Local",
+                            "Disconnected",
+                            this,
+                            SLOT (dbusDisconnected ()));
+        m_connectedOnce = true;
+        emit q->connected();
+    }
+}
+
+
+void FcitxQtConnectionPrivate::dbusDisconnected()
+{
+    cleanUp();
+
+    createConnection();
+}
+
+void FcitxQtConnectionPrivate::imChanged(const QString& service, const QString& oldowner, const QString& newowner)
+{
+    if (service == m_serviceName) {
+        /* old die */
+        if (oldowner.length() > 0 || newowner.length() > 0)
+            cleanUp();
+
+        /* new rise */
+        if (newowner.length() > 0) {
+            QTimer::singleShot(100, this, SLOT(newServiceAppear()));
+        }
+    }
+}
+
+void FcitxQtConnectionPrivate::cleanUp()
+{
+    Q_Q(FcitxQtConnection);
+    bool doemit = false;
+    QDBusConnection::disconnectFromBus("fcitx");
+    if (m_connection) {
+        delete m_connection;
+        m_connection = 0;
+        doemit = true;
+    }
+
+    if (!m_autoReconnect && m_connectedOnce)
+        finalize();
+
+    /* we want m_connection and finalize being called before the signal
+     * thus isConnected will return false in slot
+     * and startConnection can be called in slot
+     */
+    if (doemit)
+        emit q->disconnected();
+}
+
+bool FcitxQtConnectionPrivate::isConnected()
+{
+    return m_connection && m_connection->isConnected();
+}
+
+void FcitxQtConnectionPrivate::newServiceAppear() {
+    if (!isConnected()) {
+        cleanUp();
+
+        createConnection();
+    }
+}
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtconnection.h b/src/plugins/platforminputcontexts/fcitx/fcitxqtconnection.h
new file mode 100644
index 0000000..efe255f
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtconnection.h
@@ -0,0 +1,111 @@
+/***************************************************************************
+ *   Copyright (C) 2012~2012 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#ifndef FCITXQTCONNECTION_H
+#define FCITXQTCONNECTION_H
+
+#include "fcitxqtdbusaddons_export.h"
+
+#include <QtCore/QObject>
+
+class QDBusConnection;
+
+class FcitxQtConnectionPrivate;
+
+
+/**
+ * dbus connection to fcitx
+ **/
+class FCITXQTDBUSADDONS_EXPORT FcitxQtConnection : public QObject {
+    Q_OBJECT
+    Q_PROPERTY(bool autoReconnect READ autoReconnect WRITE setAutoReconnect)
+    Q_PROPERTY(bool connected READ isConnected)
+    Q_PROPERTY(QDBusConnection* connection READ connection)
+    Q_PROPERTY(QString serviceName READ serviceName)
+public:
+    /**
+     * create a new connection
+     *
+     * @param parent
+     **/
+    explicit FcitxQtConnection(QObject* parent = 0);
+
+    /**
+     * destroy the connection
+     **/
+    virtual ~FcitxQtConnection();
+
+    /**
+     * the connection will not start to work until you call this function
+     * you may want to connect to the signal before you call this function
+     **/
+    void startConnection();
+    void endConnection();
+    /**
+     * automatically reconnect if fcitx disappeared
+     *
+     * @param a ...
+     * @return void
+     **/
+    void setAutoReconnect(bool a);
+
+    /**
+     * check this connection is doing automatical reconnect or not
+     *
+     * default value is true
+     **/
+    bool autoReconnect();
+
+    /**
+     * return the current dbus connection to fcitx, notice, the object return
+     * by this function might be deteled if fcitx disappear, or might return 0
+     * if fcitx is not running
+     *
+     * @return QDBusConnection*
+     **/
+    QDBusConnection* connection();
+    /**
+     * current fcitx dbus service name, can be used for create DBus proxy
+     *
+     * @return service name
+     **/
+    const QString& serviceName();
+    /**
+     * check its connected or not
+     **/
+    bool isConnected();
+
+Q_SIGNALS:
+    /**
+     * this signal will be emitted upon fcitx appears
+     **/
+    void connected();
+    /**
+     * this signal will be emitted upon fcitx disappears
+     *
+     * it will come with connected in pair
+     **/
+    void disconnected();
+
+private:
+    FcitxQtConnectionPrivate * const d_ptr;
+    Q_DECLARE_PRIVATE(FcitxQtConnection);
+};
+
+#endif // FCITXCONNECTION_H
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtconnection_p.h b/src/plugins/platforminputcontexts/fcitx/fcitxqtconnection_p.h
new file mode 100644
index 0000000..dda726a
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtconnection_p.h
@@ -0,0 +1,68 @@
+/***************************************************************************
+ *   Copyright (C) 2012~2012 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#ifndef FCITXQTCONNECTION_P_H
+#define FCITXQTCONNECTION_P_H
+
+#include "fcitxqtconnection.h"
+#include <QtCore/QWeakPointer>
+#include <QtCore/QFileSystemWatcher>
+
+class QDBusConnection;
+class QDBusServiceWatcher;
+
+class FcitxQtConnectionPrivate : public QObject {
+    Q_OBJECT
+public:
+    FcitxQtConnectionPrivate(FcitxQtConnection* conn);
+    virtual ~FcitxQtConnectionPrivate();
+    FcitxQtConnection * const q_ptr;
+    Q_DECLARE_PUBLIC(FcitxQtConnection);
+
+private Q_SLOTS:
+    void imChanged(const QString& service, const QString& oldowner, const QString& newowner);
+    void dbusDisconnected();
+    void cleanUp();
+    void newServiceAppear();
+    void socketFileChanged();
+
+private:
+    bool isConnected();
+
+    static QByteArray localMachineId();
+    const QString& socketFile();
+    void createConnection();
+    QString address();
+    int displayNumber();
+    void initialize();
+    void finalize();
+
+    int m_displayNumber;
+    QString m_serviceName;
+    QDBusConnection* m_connection;
+    QDBusServiceWatcher* m_serviceWatcher;
+    QFileSystemWatcher* m_watcher;
+    QString m_socketFile;
+    bool m_autoReconnect;
+    bool m_connectedOnce;
+    bool m_initialized;
+};
+
+
+#endif // FCITXCONNECTION_P_H
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtdbusaddons_export.h b/src/plugins/platforminputcontexts/fcitx/fcitxqtdbusaddons_export.h
new file mode 100644
index 0000000..3fabfb9
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtdbusaddons_export.h
@@ -0,0 +1,41 @@
+
+#ifndef FCITXQTDBUSADDONS_EXPORT_H
+#define FCITXQTDBUSADDONS_EXPORT_H
+
+#ifdef FCITXQTDBUSADDONS_STATIC_DEFINE
+#  define FCITXQTDBUSADDONS_EXPORT
+#  define FCITXQTDBUSADDONS_NO_EXPORT
+#else
+#  ifndef FCITXQTDBUSADDONS_EXPORT
+#    ifdef FcitxQt5DBusAddons_EXPORTS
+        /* We are building this library */
+#      define FCITXQTDBUSADDONS_EXPORT __attribute__((visibility("default")))
+#    else
+        /* We are using this library */
+#      define FCITXQTDBUSADDONS_EXPORT __attribute__((visibility("default")))
+#    endif
+#  endif
+
+#  ifndef FCITXQTDBUSADDONS_NO_EXPORT
+#    define FCITXQTDBUSADDONS_NO_EXPORT __attribute__((visibility("hidden")))
+#  endif
+#endif
+
+#ifndef FCITXQTDBUSADDONS_DEPRECATED
+#  define FCITXQTDBUSADDONS_DEPRECATED __attribute__ ((__deprecated__))
+#endif
+
+#ifndef FCITXQTDBUSADDONS_DEPRECATED_EXPORT
+#  define FCITXQTDBUSADDONS_DEPRECATED_EXPORT FCITXQTDBUSADDONS_EXPORT FCITXQTDBUSADDONS_DEPRECATED
+#endif
+
+#ifndef FCITXQTDBUSADDONS_DEPRECATED_NO_EXPORT
+#  define FCITXQTDBUSADDONS_DEPRECATED_NO_EXPORT FCITXQTDBUSADDONS_NO_EXPORT FCITXQTDBUSADDONS_DEPRECATED
+#endif
+
+#define DEFINE_NO_DEPRECATED 0
+#if DEFINE_NO_DEPRECATED
+# define FCITXQTDBUSADDONS_NO_DEPRECATED
+#endif
+
+#endif
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtdbusaddons_version.h b/src/plugins/platforminputcontexts/fcitx/fcitxqtdbusaddons_version.h
new file mode 100644
index 0000000..7b6dbf4
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtdbusaddons_version.h
@@ -0,0 +1,11 @@
+
+#ifndef FCITXQT5DBUSADDONS_VERSION_H
+#define FCITXQT5DBUSADDONS_VERSION_H
+
+#define FCITXQT5DBUSADDONS_VERSION_STRING "1.0.0"
+#define FCITXQT5DBUSADDONS_VERSION_MAJOR 1
+#define FCITXQT5DBUSADDONS_VERSION_MINOR 0
+#define FCITXQT5DBUSADDONS_VERSION_PATCH 0
+#define FCITXQT5DBUSADDONS_VERSION ((1<<16)|(0<<8)|(0))
+
+#endif
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtformattedpreedit.cpp b/src/plugins/platforminputcontexts/fcitx/fcitxqtformattedpreedit.cpp
new file mode 100644
index 0000000..c6af845
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtformattedpreedit.cpp
@@ -0,0 +1,78 @@
+/***************************************************************************
+ *   Copyright (C) 2012~2012 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#include <QDBusMetaType>
+
+#include "fcitxqtformattedpreedit.h"
+
+void FcitxQtFormattedPreedit::registerMetaType()
+{
+    qRegisterMetaType<FcitxQtFormattedPreedit>("FcitxQtFormattedPreedit");
+    qDBusRegisterMetaType<FcitxQtFormattedPreedit>();
+    qRegisterMetaType<FcitxQtFormattedPreeditList>("FcitxQtFormattedPreeditList");
+    qDBusRegisterMetaType<FcitxQtFormattedPreeditList>();
+}
+
+qint32 FcitxQtFormattedPreedit::format() const
+{
+    return m_format;
+}
+
+const QString& FcitxQtFormattedPreedit::string() const
+{
+    return m_string;
+}
+
+void FcitxQtFormattedPreedit::setFormat(qint32 format)
+{
+    m_format = format;
+}
+
+void FcitxQtFormattedPreedit::setString(const QString& str)
+{
+    m_string = str;
+}
+
+bool FcitxQtFormattedPreedit::operator==(const FcitxQtFormattedPreedit& preedit) const
+{
+    return (preedit.m_format == m_format) && (preedit.m_string == m_string);
+}
+
+FCITXQTDBUSADDONS_EXPORT
+QDBusArgument& operator<<(QDBusArgument& argument, const FcitxQtFormattedPreedit& preedit)
+{
+    argument.beginStructure();
+    argument << preedit.string();
+    argument << preedit.format();
+    argument.endStructure();
+    return argument;
+}
+
+FCITXQTDBUSADDONS_EXPORT
+const QDBusArgument& operator>>(const QDBusArgument& argument, FcitxQtFormattedPreedit& preedit)
+{
+    QString str;
+    qint32 format;
+    argument.beginStructure();
+    argument >> str >> format;
+    argument.endStructure();
+    preedit.setString(str);
+    preedit.setFormat(format);
+    return argument;
+}
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtformattedpreedit.h b/src/plugins/platforminputcontexts/fcitx/fcitxqtformattedpreedit.h
new file mode 100644
index 0000000..a00355c
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtformattedpreedit.h
@@ -0,0 +1,51 @@
+/***************************************************************************
+ *   Copyright (C) 2012~2012 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#ifndef FCITX_QT_FORMATTED_PREEDIT_H
+#define FCITX_QT_FORMATTED_PREEDIT_H
+
+#include "fcitxqtdbusaddons_export.h"
+
+#include <QtCore/QMetaType>
+#include <QtDBus/QDBusArgument>
+
+class FCITXQTDBUSADDONS_EXPORT FcitxQtFormattedPreedit {
+public:
+    const QString& string() const;
+    qint32 format() const;
+    void setString(const QString& str);
+    void setFormat(qint32 format);
+
+    static void registerMetaType();
+
+    bool operator ==(const FcitxQtFormattedPreedit& preedit) const;
+private:
+    QString m_string;
+    qint32 m_format;
+};
+
+typedef QList<FcitxQtFormattedPreedit> FcitxQtFormattedPreeditList;
+
+QDBusArgument& operator<<(QDBusArgument& argument, const FcitxQtFormattedPreedit& im);
+const QDBusArgument& operator>>(const QDBusArgument& argument, FcitxQtFormattedPreedit& im);
+
+Q_DECLARE_METATYPE(FcitxQtFormattedPreedit)
+Q_DECLARE_METATYPE(FcitxQtFormattedPreeditList)
+
+#endif
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtinputcontextproxy.cpp b/src/plugins/platforminputcontexts/fcitx/fcitxqtinputcontextproxy.cpp
new file mode 100644
index 0000000..ef479b2
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtinputcontextproxy.cpp
@@ -0,0 +1,25 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.8
+ * Command line was: qdbusxml2cpp -N -p fcitxqtinputcontextproxy -c FcitxQtInputContextProxy interfaces/org.fcitx.Fcitx.InputContext.xml -i fcitxqtformattedpreedit.h -i fcitxqt_export.h
+ *
+ * qdbusxml2cpp is Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "fcitxqtinputcontextproxy.h"
+
+/*
+ * Implementation of interface class FcitxQtInputContextProxy
+ */
+
+FcitxQtInputContextProxy::FcitxQtInputContextProxy(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+FcitxQtInputContextProxy::~FcitxQtInputContextProxy()
+{
+}
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtinputcontextproxy.h b/src/plugins/platforminputcontexts/fcitx/fcitxqtinputcontextproxy.h
new file mode 100644
index 0000000..19874dc
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtinputcontextproxy.h
@@ -0,0 +1,136 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.8
+ * Command line was: qdbusxml2cpp -N -p fcitxqtinputcontextproxy -c FcitxQtInputContextProxy interfaces/org.fcitx.Fcitx.InputContext.xml -i fcitxqtformattedpreedit.h -i fcitxqt_export.h
+ *
+ * qdbusxml2cpp is Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef FCITXQTINPUTCONTEXTPROXY_H_1409252990
+#define FCITXQTINPUTCONTEXTPROXY_H_1409252990
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+#include "fcitxqtformattedpreedit.h"
+#include "fcitxqtdbusaddons_export.h"
+
+/*
+ * Proxy class for interface org.fcitx.Fcitx.InputContext
+ */
+class FCITXQTDBUSADDONS_EXPORT FcitxQtInputContextProxy: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.fcitx.Fcitx.InputContext"; }
+
+public:
+    FcitxQtInputContextProxy(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~FcitxQtInputContextProxy();
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<> CloseIC()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("CloseIC"), argumentList);
+    }
+
+    inline QDBusPendingReply<> DestroyIC()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("DestroyIC"), argumentList);
+    }
+
+    inline QDBusPendingReply<> EnableIC()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("EnableIC"), argumentList);
+    }
+
+    inline QDBusPendingReply<> FocusIn()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("FocusIn"), argumentList);
+    }
+
+    inline QDBusPendingReply<> FocusOut()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("FocusOut"), argumentList);
+    }
+
+    inline QDBusPendingReply<> MouseEvent(int x)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(x);
+        return asyncCallWithArgumentList(QLatin1String("MouseEvent"), argumentList);
+    }
+
+    inline QDBusPendingReply<int> ProcessKeyEvent(uint keyval, uint keycode, uint state, int type, uint time)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(keyval) << QVariant::fromValue(keycode) << QVariant::fromValue(state) << QVariant::fromValue(type) << QVariant::fromValue(time);
+        return asyncCallWithArgumentList(QLatin1String("ProcessKeyEvent"), argumentList);
+    }
+
+    inline QDBusPendingReply<> Reset()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("Reset"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SetCapacity(uint caps)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(caps);
+        return asyncCallWithArgumentList(QLatin1String("SetCapacity"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SetCursorLocation(int x, int y)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(x) << QVariant::fromValue(y);
+        return asyncCallWithArgumentList(QLatin1String("SetCursorLocation"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SetCursorRect(int x, int y, int w, int h)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(x) << QVariant::fromValue(y) << QVariant::fromValue(w) << QVariant::fromValue(h);
+        return asyncCallWithArgumentList(QLatin1String("SetCursorRect"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SetSurroundingText(const QString &text, uint cursor, uint anchor)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(text) << QVariant::fromValue(cursor) << QVariant::fromValue(anchor);
+        return asyncCallWithArgumentList(QLatin1String("SetSurroundingText"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SetSurroundingTextPosition(uint cursor, uint anchor)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(cursor) << QVariant::fromValue(anchor);
+        return asyncCallWithArgumentList(QLatin1String("SetSurroundingTextPosition"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+    void CloseIM();
+    void CommitString(const QString &str);
+    void DeleteSurroundingText(int offset, uint nchar);
+    void EnableIM();
+    void ForwardKey(uint keyval, uint state, int type);
+    void UpdateClientSideUI(const QString &auxup, const QString &auxdown, const QString &preedit, const QString &candidateword, const QString &imname, int cursorpos);
+    void UpdateFormattedPreedit(FcitxQtFormattedPreeditList str, int cursorpos);
+};
+
+#endif
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtinputmethoditem.cpp b/src/plugins/platforminputcontexts/fcitx/fcitxqtinputmethoditem.cpp
new file mode 100644
index 0000000..d28ed11
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtinputmethoditem.cpp
@@ -0,0 +1,95 @@
+/***************************************************************************
+ *   Copyright (C) 2011~2012 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+// Qt
+#include <QDBusArgument>
+#include <QDBusMetaType>
+
+// self
+#include "fcitxqtinputmethoditem.h"
+
+bool FcitxQtInputMethodItem::enabled() const
+{
+    return m_enabled;
+}
+const QString& FcitxQtInputMethodItem::langCode() const
+{
+    return m_langCode;
+}
+const QString& FcitxQtInputMethodItem::name() const
+{
+    return m_name;
+}
+const QString& FcitxQtInputMethodItem::uniqueName() const
+{
+    return m_uniqueName;
+}
+void FcitxQtInputMethodItem::setEnabled(bool enable)
+{
+    m_enabled = enable;
+}
+void FcitxQtInputMethodItem::setLangCode(const QString& lang)
+{
+    m_langCode = lang;
+}
+void FcitxQtInputMethodItem::setName(const QString& name)
+{
+    m_name = name;
+}
+void FcitxQtInputMethodItem::setUniqueName(const QString& name)
+{
+    m_uniqueName = name;
+}
+
+void FcitxQtInputMethodItem::registerMetaType()
+{
+    qRegisterMetaType<FcitxQtInputMethodItem>("FcitxQtInputMethodItem");
+    qDBusRegisterMetaType<FcitxQtInputMethodItem>();
+    qRegisterMetaType<FcitxQtInputMethodItemList>("FcitxQtInputMethodItemList");
+    qDBusRegisterMetaType<FcitxQtInputMethodItemList>();
+}
+
+FCITXQTDBUSADDONS_EXPORT
+QDBusArgument& operator<<(QDBusArgument& argument, const FcitxQtInputMethodItem& im)
+{
+    argument.beginStructure();
+    argument << im.name();
+    argument << im.uniqueName();
+    argument << im.langCode();
+    argument << im.enabled();
+    argument.endStructure();
+    return argument;
+}
+
+FCITXQTDBUSADDONS_EXPORT
+const QDBusArgument& operator>>(const QDBusArgument& argument, FcitxQtInputMethodItem& im)
+{
+    QString name;
+    QString uniqueName;
+    QString langCode;
+    bool enabled;
+    argument.beginStructure();
+    argument >> name >> uniqueName >> langCode >> enabled;
+    argument.endStructure();
+    im.setName(name);
+    im.setUniqueName(uniqueName);
+    im.setLangCode(langCode);
+    im.setEnabled(enabled);
+    return argument;
+}
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtinputmethoditem.h b/src/plugins/platforminputcontexts/fcitx/fcitxqtinputmethoditem.h
new file mode 100644
index 0000000..6b8c780
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtinputmethoditem.h
@@ -0,0 +1,64 @@
+/***************************************************************************
+ *   Copyright (C) 2011~2012 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#ifndef FCITX_QT_INPUT_METHOD_ITEM_H
+#define FCITX_QT_INPUT_METHOD_ITEM_H
+
+#include "fcitxqtdbusaddons_export.h"
+
+// Qt
+#include <QtCore/QString>
+#include <QtCore/QMetaType>
+#include <QtDBus/QDBusArgument>
+
+class FCITXQTDBUSADDONS_EXPORT FcitxQtInputMethodItem
+{
+public:
+    const QString& name() const;
+    const QString& uniqueName() const;
+    const QString& langCode() const;
+    bool enabled() const;
+
+    void setName(const QString& name);
+    void setUniqueName(const QString& name);
+    void setLangCode(const QString& name);
+    void setEnabled(bool name);
+    static void registerMetaType();
+
+    inline bool operator < (const FcitxQtInputMethodItem& im) const {
+        if (m_enabled == true && im.m_enabled == false)
+            return true;
+        return false;
+    }
+private:
+    QString m_name;
+    QString m_uniqueName;
+    QString m_langCode;
+    bool m_enabled;
+};
+
+typedef QList<FcitxQtInputMethodItem> FcitxQtInputMethodItemList;
+
+QDBusArgument& operator<<(QDBusArgument& argument, const FcitxQtInputMethodItem& im);
+const QDBusArgument& operator>>(const QDBusArgument& argument, FcitxQtInputMethodItem& im);
+
+Q_DECLARE_METATYPE(FcitxQtInputMethodItem)
+Q_DECLARE_METATYPE(FcitxQtInputMethodItemList)
+
+#endif
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtinputmethodproxy.cpp b/src/plugins/platforminputcontexts/fcitx/fcitxqtinputmethodproxy.cpp
new file mode 100644
index 0000000..cb7e4cf
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtinputmethodproxy.cpp
@@ -0,0 +1,25 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.8
+ * Command line was: qdbusxml2cpp -N -p fcitxqtinputmethodproxy -c FcitxQtInputMethodProxy interfaces/org.fcitx.Fcitx.InputMethod.xml -i fcitxqtinputmethoditem.h -i fcitxqt_export.h
+ *
+ * qdbusxml2cpp is Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "fcitxqtinputmethodproxy.h"
+
+/*
+ * Implementation of interface class FcitxQtInputMethodProxy
+ */
+
+FcitxQtInputMethodProxy::FcitxQtInputMethodProxy(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+FcitxQtInputMethodProxy::~FcitxQtInputMethodProxy()
+{
+}
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtinputmethodproxy.h b/src/plugins/platforminputcontexts/fcitx/fcitxqtinputmethodproxy.h
new file mode 100644
index 0000000..7aa37e2
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtinputmethodproxy.h
@@ -0,0 +1,217 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.8
+ * Command line was: qdbusxml2cpp -N -p fcitxqtinputmethodproxy -c FcitxQtInputMethodProxy interfaces/org.fcitx.Fcitx.InputMethod.xml -i fcitxqtinputmethoditem.h -i fcitxqt_export.h
+ *
+ * qdbusxml2cpp is Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef FCITXQTINPUTMETHODPROXY_H_1409252990
+#define FCITXQTINPUTMETHODPROXY_H_1409252990
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+#include "fcitxqtinputmethoditem.h"
+#include "fcitxqtdbusaddons_export.h"
+
+/*
+ * Proxy class for interface org.fcitx.Fcitx.InputMethod
+ */
+class FCITXQTDBUSADDONS_EXPORT FcitxQtInputMethodProxy: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.fcitx.Fcitx.InputMethod"; }
+
+public:
+    FcitxQtInputMethodProxy(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~FcitxQtInputMethodProxy();
+
+    Q_PROPERTY(QString CurrentIM READ currentIM WRITE setCurrentIM)
+    inline QString currentIM() const
+    { return qvariant_cast< QString >(property("CurrentIM")); }
+    inline void setCurrentIM(const QString &value)
+    { setProperty("CurrentIM", QVariant::fromValue(value)); }
+
+    Q_PROPERTY(FcitxQtInputMethodItemList IMList READ iMList WRITE setIMList)
+    inline FcitxQtInputMethodItemList iMList() const
+    { return qvariant_cast< FcitxQtInputMethodItemList >(property("IMList")); }
+    inline void setIMList(FcitxQtInputMethodItemList value)
+    { setProperty("IMList", QVariant::fromValue(value)); }
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<> ActivateIM()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("ActivateIM"), argumentList);
+    }
+
+    inline QDBusPendingReply<> Configure()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("Configure"), argumentList);
+    }
+
+    inline QDBusPendingReply<> ConfigureAddon(const QString &addon)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(addon);
+        return asyncCallWithArgumentList(QLatin1String("ConfigureAddon"), argumentList);
+    }
+
+    inline QDBusPendingReply<> ConfigureIM(const QString &im)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(im);
+        return asyncCallWithArgumentList(QLatin1String("ConfigureIM"), argumentList);
+    }
+
+    inline QDBusPendingReply<int, uint, uint, uint, uint> CreateIC()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("CreateIC"), argumentList);
+    }
+    inline QDBusReply<int> CreateIC(uint &keyval1, uint &state1, uint &keyval2, uint &state2)
+    {
+        QList<QVariant> argumentList;
+        QDBusMessage reply = callWithArgumentList(QDBus::Block, QLatin1String("CreateIC"), argumentList);
+        if (reply.type() == QDBusMessage::ReplyMessage && reply.arguments().count() == 5) {
+            keyval1 = qdbus_cast<uint>(reply.arguments().at(1));
+            state1 = qdbus_cast<uint>(reply.arguments().at(2));
+            keyval2 = qdbus_cast<uint>(reply.arguments().at(3));
+            state2 = qdbus_cast<uint>(reply.arguments().at(4));
+        }
+        return reply;
+    }
+
+    inline QDBusPendingReply<int, bool, uint, uint, uint, uint> CreateICv2(const QString &appname)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(appname);
+        return asyncCallWithArgumentList(QLatin1String("CreateICv2"), argumentList);
+    }
+    inline QDBusReply<int> CreateICv2(const QString &appname, bool &enable, uint &keyval1, uint &state1, uint &keyval2, uint &state2)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(appname);
+        QDBusMessage reply = callWithArgumentList(QDBus::Block, QLatin1String("CreateICv2"), argumentList);
+        if (reply.type() == QDBusMessage::ReplyMessage && reply.arguments().count() == 6) {
+            enable = qdbus_cast<bool>(reply.arguments().at(1));
+            keyval1 = qdbus_cast<uint>(reply.arguments().at(2));
+            state1 = qdbus_cast<uint>(reply.arguments().at(3));
+            keyval2 = qdbus_cast<uint>(reply.arguments().at(4));
+            state2 = qdbus_cast<uint>(reply.arguments().at(5));
+        }
+        return reply;
+    }
+
+    inline QDBusPendingReply<int, bool, uint, uint, uint, uint> CreateICv3(const QString &appname, int pid)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(appname) << QVariant::fromValue(pid);
+        return asyncCallWithArgumentList(QLatin1String("CreateICv3"), argumentList);
+    }
+    inline QDBusReply<int> CreateICv3(const QString &appname, int pid, bool &enable, uint &keyval1, uint &state1, uint &keyval2, uint &state2)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(appname) << QVariant::fromValue(pid);
+        QDBusMessage reply = callWithArgumentList(QDBus::Block, QLatin1String("CreateICv3"), argumentList);
+        if (reply.type() == QDBusMessage::ReplyMessage && reply.arguments().count() == 6) {
+            enable = qdbus_cast<bool>(reply.arguments().at(1));
+            keyval1 = qdbus_cast<uint>(reply.arguments().at(2));
+            state1 = qdbus_cast<uint>(reply.arguments().at(3));
+            keyval2 = qdbus_cast<uint>(reply.arguments().at(4));
+            state2 = qdbus_cast<uint>(reply.arguments().at(5));
+        }
+        return reply;
+    }
+
+    inline QDBusPendingReply<> Exit()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("Exit"), argumentList);
+    }
+
+    inline QDBusPendingReply<QString> GetCurrentIM()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetCurrentIM"), argumentList);
+    }
+
+    inline QDBusPendingReply<int> GetCurrentState()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetCurrentState"), argumentList);
+    }
+
+    inline QDBusPendingReply<QString> GetCurrentUI()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetCurrentUI"), argumentList);
+    }
+
+    inline QDBusPendingReply<QString> GetIMAddon(const QString &im)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(im);
+        return asyncCallWithArgumentList(QLatin1String("GetIMAddon"), argumentList);
+    }
+
+    inline QDBusPendingReply<> InactivateIM()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("InactivateIM"), argumentList);
+    }
+
+    inline QDBusPendingReply<> ReloadAddonConfig(const QString &addon)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(addon);
+        return asyncCallWithArgumentList(QLatin1String("ReloadAddonConfig"), argumentList);
+    }
+
+    inline QDBusPendingReply<> ReloadConfig()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("ReloadConfig"), argumentList);
+    }
+
+    inline QDBusPendingReply<> ResetIMList()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("ResetIMList"), argumentList);
+    }
+
+    inline QDBusPendingReply<> Restart()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("Restart"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SetCurrentIM(const QString &im)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(im);
+        return asyncCallWithArgumentList(QLatin1String("SetCurrentIM"), argumentList);
+    }
+
+    inline QDBusPendingReply<> ToggleIM()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("ToggleIM"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+};
+
+#endif
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtkeyboardlayout.cpp b/src/plugins/platforminputcontexts/fcitx/fcitxqtkeyboardlayout.cpp
new file mode 100644
index 0000000..32cd981
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtkeyboardlayout.cpp
@@ -0,0 +1,100 @@
+/***************************************************************************
+ *   Copyright (C) 2011~2012 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+// Qt
+#include <QDBusArgument>
+#include <QDBusMetaType>
+
+// self
+#include "fcitxqtkeyboardlayout.h"
+
+const QString& FcitxQtKeyboardLayout::layout() const
+{
+    return m_layout;
+}
+const QString& FcitxQtKeyboardLayout::langCode() const
+{
+    return m_langCode;
+}
+const QString& FcitxQtKeyboardLayout::name() const
+{
+    return m_name;
+}
+
+const QString& FcitxQtKeyboardLayout::variant() const
+{
+    return m_variant;
+}
+
+void FcitxQtKeyboardLayout::setLayout(const QString& layout)
+{
+    m_layout = layout;
+}
+
+void FcitxQtKeyboardLayout::setLangCode(const QString& lang)
+{
+    m_langCode = lang;
+}
+
+void FcitxQtKeyboardLayout::setName(const QString& name)
+{
+    m_name = name;
+}
+
+void FcitxQtKeyboardLayout::setVariant(const QString& variant)
+{
+    m_variant = variant;
+}
+
+void FcitxQtKeyboardLayout::registerMetaType()
+{
+    qRegisterMetaType<FcitxQtKeyboardLayout>("FcitxQtKeyboardLayout");
+    qDBusRegisterMetaType<FcitxQtKeyboardLayout>();
+    qRegisterMetaType<FcitxQtKeyboardLayoutList>("FcitxQtKeyboardLayoutList");
+    qDBusRegisterMetaType<FcitxQtKeyboardLayoutList>();
+}
+
+FCITXQTDBUSADDONS_EXPORT
+QDBusArgument& operator<<(QDBusArgument& argument, const FcitxQtKeyboardLayout& layout)
+{
+    argument.beginStructure();
+    argument << layout.layout();
+    argument << layout.variant();
+    argument << layout.name();
+    argument << layout.langCode();
+    argument.endStructure();
+    return argument;
+}
+
+FCITXQTDBUSADDONS_EXPORT
+const QDBusArgument& operator>>(const QDBusArgument& argument, FcitxQtKeyboardLayout& layout)
+{
+    QString l;
+    QString variant;
+    QString name;
+    QString langCode;
+    argument.beginStructure();
+    argument >> l >> variant >> name >> langCode;
+    argument.endStructure();
+    layout.setLayout(l);
+    layout.setVariant(variant);
+    layout.setName(name);
+    layout.setLangCode(langCode);
+    return argument;
+}
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtkeyboardlayout.h b/src/plugins/platforminputcontexts/fcitx/fcitxqtkeyboardlayout.h
new file mode 100644
index 0000000..d33438d
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtkeyboardlayout.h
@@ -0,0 +1,58 @@
+/***************************************************************************
+ *   Copyright (C) 2011~2012 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#ifndef FCITX_QT_KEYBOARD_LAYOUT_H
+#define FCITX_QT_KEYBOARD_LAYOUT_H
+
+#include "fcitxqtdbusaddons_export.h"
+
+// Qt
+#include <QtCore/QString>
+#include <QtCore/QMetaType>
+#include <QtDBus/QDBusArgument>
+
+class FCITXQTDBUSADDONS_EXPORT FcitxQtKeyboardLayout
+{
+public:
+    const QString& layout() const;
+    const QString& variant() const;
+    const QString& name() const;
+    const QString& langCode() const;
+    void setLayout(const QString& layout);
+    void setLangCode(const QString& lang);
+    void setName(const QString& name);
+    void setVariant(const QString& variant);
+
+    static void registerMetaType();
+private:
+    QString m_layout;
+    QString m_variant;
+    QString m_name;
+    QString m_langCode;
+};
+
+typedef QList<FcitxQtKeyboardLayout> FcitxQtKeyboardLayoutList;
+
+QDBusArgument& operator<<(QDBusArgument& argument, const FcitxQtKeyboardLayout& l);
+const QDBusArgument& operator>>(const QDBusArgument& argument, FcitxQtKeyboardLayout& l);
+
+Q_DECLARE_METATYPE(FcitxQtKeyboardLayout)
+Q_DECLARE_METATYPE(FcitxQtKeyboardLayoutList)
+
+#endif
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtkeyboardproxy.cpp b/src/plugins/platforminputcontexts/fcitx/fcitxqtkeyboardproxy.cpp
new file mode 100644
index 0000000..fa97ab6
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtkeyboardproxy.cpp
@@ -0,0 +1,25 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.8
+ * Command line was: qdbusxml2cpp -N -p fcitxqtkeyboardproxy -c FcitxQtKeyboardProxy interfaces/org.fcitx.Fcitx.Keyboard.xml -i fcitxqtkeyboardlayout.h -i fcitxqt_export.h
+ *
+ * qdbusxml2cpp is Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "fcitxqtkeyboardproxy.h"
+
+/*
+ * Implementation of interface class FcitxQtKeyboardProxy
+ */
+
+FcitxQtKeyboardProxy::FcitxQtKeyboardProxy(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+FcitxQtKeyboardProxy::~FcitxQtKeyboardProxy()
+{
+}
diff --git a/src/plugins/platforminputcontexts/fcitx/fcitxqtkeyboardproxy.h b/src/plugins/platforminputcontexts/fcitx/fcitxqtkeyboardproxy.h
new file mode 100644
index 0000000..42a6561
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/fcitxqtkeyboardproxy.h
@@ -0,0 +1,74 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.8
+ * Command line was: qdbusxml2cpp -N -p fcitxqtkeyboardproxy -c FcitxQtKeyboardProxy interfaces/org.fcitx.Fcitx.Keyboard.xml -i fcitxqtkeyboardlayout.h -i fcitxqt_export.h
+ *
+ * qdbusxml2cpp is Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef FCITXQTKEYBOARDPROXY_H_1409252990
+#define FCITXQTKEYBOARDPROXY_H_1409252990
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+#include "fcitxqtkeyboardlayout.h"
+#include "fcitxqtdbusaddons_export.h"
+
+/*
+ * Proxy class for interface org.fcitx.Fcitx.Keyboard
+ */
+class FCITXQTDBUSADDONS_EXPORT FcitxQtKeyboardProxy: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "org.fcitx.Fcitx.Keyboard"; }
+
+public:
+    FcitxQtKeyboardProxy(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~FcitxQtKeyboardProxy();
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<QString, QString> GetLayoutForIM(const QString &im)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(im);
+        return asyncCallWithArgumentList(QLatin1String("GetLayoutForIM"), argumentList);
+    }
+    inline QDBusReply<QString> GetLayoutForIM(const QString &im, QString &variant)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(im);
+        QDBusMessage reply = callWithArgumentList(QDBus::Block, QLatin1String("GetLayoutForIM"), argumentList);
+        if (reply.type() == QDBusMessage::ReplyMessage && reply.arguments().count() == 2) {
+            variant = qdbus_cast<QString>(reply.arguments().at(1));
+        }
+        return reply;
+    }
+
+    inline QDBusPendingReply<FcitxQtKeyboardLayoutList> GetLayouts()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetLayouts"), argumentList);
+    }
+
+    inline QDBusPendingReply<> SetLayoutForIM(const QString &im, const QString &layout, const QString &variant)
+    {
+        QList<QVariant> argumentList;
+        argumentList << QVariant::fromValue(im) << QVariant::fromValue(layout) << QVariant::fromValue(variant);
+        return asyncCallWithArgumentList(QLatin1String("SetLayoutForIM"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+};
+
+#endif
diff --git a/src/plugins/platforminputcontexts/fcitx/interfaces/org.fcitx.Fcitx.InputContext.xml b/src/plugins/platforminputcontexts/fcitx/interfaces/org.fcitx.Fcitx.InputContext.xml
new file mode 100644
index 0000000..1423d69
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/interfaces/org.fcitx.Fcitx.InputContext.xml
@@ -0,0 +1,81 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+  <interface name="org.fcitx.Fcitx.InputContext">
+    <method name="EnableIC">
+    </method>
+    <method name="CloseIC">
+    </method>
+    <method name="FocusIn">
+    </method>
+    <method name="FocusOut">
+    </method>
+    <method name="Reset">
+    </method>
+    <method name="MouseEvent">
+      <arg name="x" direction="in" type="i" />
+    </method>
+    <method name="SetCursorLocation">
+      <arg name="x" direction="in" type="i"/>
+      <arg name="y" direction="in" type="i"/>
+    </method>
+    <method name="SetCursorRect">
+      <arg name="x" direction="in" type="i"/>
+      <arg name="y" direction="in" type="i"/>
+      <arg name="w" direction="in" type="i"/>
+      <arg name="h" direction="in" type="i"/>
+    </method>
+    <method name="SetCapacity">
+       <arg name="caps" direction="in" type="u"/>
+    </method>
+    <method name="SetSurroundingText">
+      <arg name="text" direction="in" type="s"/>
+      <arg name="cursor" direction="in" type="u"/>
+      <arg name="anchor" direction="in" type="u"/>
+    </method>
+    <method name="SetSurroundingTextPosition">
+      <arg name="cursor" direction="in" type="u"/>
+      <arg name="anchor" direction="in" type="u"/>
+    </method>
+    <method name="DestroyIC">
+    </method>
+    <method name="ProcessKeyEvent">
+      <arg name="keyval" direction="in" type="u"/>
+      <arg name="keycode" direction="in" type="u"/>
+      <arg name="state" direction="in" type="u"/>
+      <arg name="type" direction="in" type="i"/>
+      <arg name="time" direction="in" type="u"/>
+      <arg name="ret" direction="out" type="i"/>
+    </method>
+    <signal name="EnableIM">
+    </signal>
+    <signal name="CloseIM">
+    </signal>
+    <signal name="CommitString">
+      <arg name="str" type="s"/>
+    </signal>
+    <signal name="UpdateFormattedPreedit">
+      <arg name="str" type="a(si)" />
+      <arg name="cursorpos" type="i"/>
+      <annotation name="com.trolltech.QtDBus.QtTypeName.In0" value="FcitxQtFormattedPreeditList" />
+      <annotation name="org.qtproject.QtDBus.QtTypeName.In0" value="FcitxQtFormattedPreeditList" />
+    </signal>
+    <signal name="UpdateClientSideUI">
+      <arg name="auxup" type="s"/>
+      <arg name="auxdown" type="s"/>
+      <arg name="preedit" type="s"/>
+      <arg name="candidateword" type="s"/>
+      <arg name="imname" type="s"/>
+      <arg name="cursorpos" type="i"/>
+    </signal>
+    <signal name="ForwardKey">
+      <arg name="keyval" type="u"/>
+      <arg name="state" type="u"/>
+      <arg name="type" type="i"/>
+    </signal>
+    <signal name="DeleteSurroundingText">
+      <arg name="offset" type="i"/>
+      <arg name="nchar" type="u"/>
+    </signal>
+  </interface>
+</node>
diff --git a/src/plugins/platforminputcontexts/fcitx/interfaces/org.fcitx.Fcitx.InputMethod.xml b/src/plugins/platforminputcontexts/fcitx/interfaces/org.fcitx.Fcitx.InputMethod.xml
new file mode 100644
index 0000000..00dc20a
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/interfaces/org.fcitx.Fcitx.InputMethod.xml
@@ -0,0 +1,81 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
+"http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+  <interface name="org.fcitx.Fcitx.InputMethod">
+    <method name="CreateIC">
+      <arg name="icid" direction="out" type="i"/>
+      <arg name="keyval1" direction="out" type="u"/>
+      <arg name="state1" direction="out" type="u"/>
+      <arg name="keyval2" direction="out" type="u"/>
+      <arg name="state2" direction="out" type="u"/>
+    </method>
+    <method name="CreateICv2">
+      <arg name="appname" direction="in" type="s"/>
+      <arg name="icid" direction="out" type="i"/>
+      <arg name="enable" direction="out" type="b"/>
+      <arg name="keyval1" direction="out" type="u"/>
+      <arg name="state1" direction="out" type="u"/>
+      <arg name="keyval2" direction="out" type="u"/>
+      <arg name="state2" direction="out" type="u"/>
+    </method>
+    <method name="CreateICv3">
+      <arg name="appname" direction="in" type="s"/>
+      <arg name="pid" direction="in" type="i"/>
+      <arg name="icid" direction="out" type="i"/>
+      <arg name="enable" direction="out" type="b"/>
+      <arg name="keyval1" direction="out" type="u"/>
+      <arg name="state1" direction="out" type="u"/>
+      <arg name="keyval2" direction="out" type="u"/>
+      <arg name="state2" direction="out" type="u"/>
+    </method>
+    <method name="Exit">
+    </method>
+    <method name="GetCurrentIM">
+      <arg name="im" direction="out" type="s"/>
+    </method>
+    <method name="SetCurrentIM">
+      <arg name="im" direction="in" type="s"/>
+    </method>
+    <method name="ReloadConfig">
+    </method>
+    <method name="ReloadAddonConfig">
+      <arg name="addon" direction="in" type="s"/>
+    </method>
+    <method name="Restart">
+    </method>
+    <method name="Configure">
+    </method>
+    <method name="ConfigureAddon">
+      <arg name="addon" direction="in" type="s"/>
+    </method>
+    <method name="ConfigureIM">
+      <arg name="im" direction="in" type="s"/>
+    </method>
+    <method name="GetCurrentUI">
+      <arg name="addon" direction="out" type="s"/>
+    </method>
+    <method name="GetIMAddon">
+      <arg name="im" direction="in" type="s"/>
+      <arg name="addon" direction="out" type="s"/>
+    </method>
+    <method name="ActivateIM">
+    </method>
+    <method name="InactivateIM">
+    </method>
+    <method name="ToggleIM">
+    </method>
+    <method name="ResetIMList">
+    </method>
+    <method name="GetCurrentState">
+      <arg name="state" direction="out" type="i"/>
+    </method>
+    <property access="readwrite" type="a(sssb)" name="IMList">
+      <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
+      <annotation name="com.trolltech.QtDBus.QtTypeName" value="FcitxQtInputMethodItemList" />
+      <annotation name="org.qtproject.QtDBus.QtTypeName" value="FcitxQtInputMethodItemList" />
+    </property>
+    <property access="readwrite" type="s" name="CurrentIM">
+    <annotation name="org.freedesktop.DBus.Property.EmitsChangedSignal" value="true"/>
+    </property>
+  </interface>
+</node>
diff --git a/src/plugins/platforminputcontexts/fcitx/interfaces/org.fcitx.Fcitx.Keyboard.xml b/src/plugins/platforminputcontexts/fcitx/interfaces/org.fcitx.Fcitx.Keyboard.xml
new file mode 100644
index 0000000..28ffa53
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/interfaces/org.fcitx.Fcitx.Keyboard.xml
@@ -0,0 +1,20 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node>
+    <interface name="org.fcitx.Fcitx.Keyboard">
+        <method name="GetLayouts">
+            <arg name="layouts" direction="out" type="a(ssss)"/>
+            <annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="FcitxQtKeyboardLayoutList" />
+            <annotation name="org.qtproject.QtDBus.QtTypeName.Out0" value="FcitxQtKeyboardLayoutList" />
+        </method>
+        <method name="GetLayoutForIM">
+            <arg name="im" direction="in" type="s"/>
+            <arg name="layout" direction="out" type="s"/>
+            <arg name="variant" direction="out" type="s"/>
+        </method>
+        <method name="SetLayoutForIM">
+            <arg name="im" direction="in" type="s"/>
+            <arg name="layout" direction="in" type="s"/>
+            <arg name="variant" direction="in" type="s"/>
+        </method>
+    </interface>
+</node>
\ No newline at end of file
diff --git a/src/plugins/platforminputcontexts/fcitx/keydata.h b/src/plugins/platforminputcontexts/fcitx/keydata.h
new file mode 100644
index 0000000..5cee565
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/keydata.h
@@ -0,0 +1,1612 @@
+/***************************************************************************
+ *   Copyright (C) 2012~2013 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#ifndef KEYDATA_H
+#define KEYDATA_H
+
+struct _FcitxKeySymToUnicode{
+    uint16_t keysym;
+    uint16_t ucs;
+};
+
+struct _FcitxUnicodeToKeySym {
+    uint16_t keysym;
+    uint16_t ucs;
+};
+
+static const struct _FcitxKeySymToUnicode gdk_keysym_to_unicode_tab[] = {
+    { 0x01a1, 0x0104 }, /* Aogonek  LATIN CAPITAL LETTER A WITH OGONEK */
+    { 0x01a2, 0x02d8 }, /* breve  BREVE */
+    { 0x01a3, 0x0141 }, /* Lstroke  LATIN CAPITAL LETTER L WITH STROKE */
+    { 0x01a5, 0x013d }, /* Lcaron  LATIN CAPITAL LETTER L WITH CARON */
+    { 0x01a6, 0x015a }, /* Sacute  LATIN CAPITAL LETTER S WITH ACUTE */
+    { 0x01a9, 0x0160 }, /* Scaron  LATIN CAPITAL LETTER S WITH CARON */
+    { 0x01aa, 0x015e }, /* Scedilla  LATIN CAPITAL LETTER S WITH CEDILLA */
+    { 0x01ab, 0x0164 }, /* Tcaron  LATIN CAPITAL LETTER T WITH CARON */
+    { 0x01ac, 0x0179 }, /* Zacute  LATIN CAPITAL LETTER Z WITH ACUTE */
+    { 0x01ae, 0x017d }, /* Zcaron  LATIN CAPITAL LETTER Z WITH CARON */
+    { 0x01af, 0x017b }, /* Zabovedot  LATIN CAPITAL LETTER Z WITH DOT ABOVE */
+    { 0x01b1, 0x0105 }, /* aogonek  LATIN SMALL LETTER A WITH OGONEK */
+    { 0x01b2, 0x02db }, /* ogonek  OGONEK */
+    { 0x01b3, 0x0142 }, /* lstroke  LATIN SMALL LETTER L WITH STROKE */
+    { 0x01b5, 0x013e }, /* lcaron  LATIN SMALL LETTER L WITH CARON */
+    { 0x01b6, 0x015b }, /* sacute  LATIN SMALL LETTER S WITH ACUTE */
+    { 0x01b7, 0x02c7 }, /* caron  CARON */
+    { 0x01b9, 0x0161 }, /* scaron  LATIN SMALL LETTER S WITH CARON */
+    { 0x01ba, 0x015f }, /* scedilla  LATIN SMALL LETTER S WITH CEDILLA */
+    { 0x01bb, 0x0165 }, /* tcaron  LATIN SMALL LETTER T WITH CARON */
+    { 0x01bc, 0x017a }, /* zacute  LATIN SMALL LETTER Z WITH ACUTE */
+    { 0x01bd, 0x02dd }, /* doubleacute  DOUBLE ACUTE ACCENT */
+    { 0x01be, 0x017e }, /* zcaron  LATIN SMALL LETTER Z WITH CARON */
+    { 0x01bf, 0x017c }, /* zabovedot  LATIN SMALL LETTER Z WITH DOT ABOVE */
+    { 0x01c0, 0x0154 }, /* Racute  LATIN CAPITAL LETTER R WITH ACUTE */
+    { 0x01c3, 0x0102 }, /* Abreve  LATIN CAPITAL LETTER A WITH BREVE */
+    { 0x01c5, 0x0139 }, /* Lacute  LATIN CAPITAL LETTER L WITH ACUTE */
+    { 0x01c6, 0x0106 }, /* Cacute  LATIN CAPITAL LETTER C WITH ACUTE */
+    { 0x01c8, 0x010c }, /* Ccaron  LATIN CAPITAL LETTER C WITH CARON */
+    { 0x01ca, 0x0118 }, /* Eogonek  LATIN CAPITAL LETTER E WITH OGONEK */
+    { 0x01cc, 0x011a }, /* Ecaron  LATIN CAPITAL LETTER E WITH CARON */
+    { 0x01cf, 0x010e }, /* Dcaron  LATIN CAPITAL LETTER D WITH CARON */
+    { 0x01d0, 0x0110 }, /* Dstroke  LATIN CAPITAL LETTER D WITH STROKE */
+    { 0x01d1, 0x0143 }, /* Nacute  LATIN CAPITAL LETTER N WITH ACUTE */
+    { 0x01d2, 0x0147 }, /* Ncaron  LATIN CAPITAL LETTER N WITH CARON */
+    { 0x01d5, 0x0150 }, /* Odoubleacute  LATIN CAPITAL LETTER O WITH DOUBLE ACUTE */
+    { 0x01d8, 0x0158 }, /* Rcaron  LATIN CAPITAL LETTER R WITH CARON */
+    { 0x01d9, 0x016e }, /* Uring  LATIN CAPITAL LETTER U WITH RING ABOVE */
+    { 0x01db, 0x0170 }, /* Udoubleacute  LATIN CAPITAL LETTER U WITH DOUBLE ACUTE */
+    { 0x01de, 0x0162 }, /* Tcedilla  LATIN CAPITAL LETTER T WITH CEDILLA */
+    { 0x01e0, 0x0155 }, /* racute  LATIN SMALL LETTER R WITH ACUTE */
+    { 0x01e3, 0x0103 }, /* abreve  LATIN SMALL LETTER A WITH BREVE */
+    { 0x01e5, 0x013a }, /* lacute  LATIN SMALL LETTER L WITH ACUTE */
+    { 0x01e6, 0x0107 }, /* cacute  LATIN SMALL LETTER C WITH ACUTE */
+    { 0x01e8, 0x010d }, /* ccaron  LATIN SMALL LETTER C WITH CARON */
+    { 0x01ea, 0x0119 }, /* eogonek  LATIN SMALL LETTER E WITH OGONEK */
+    { 0x01ec, 0x011b }, /* ecaron  LATIN SMALL LETTER E WITH CARON */
+    { 0x01ef, 0x010f }, /* dcaron  LATIN SMALL LETTER D WITH CARON */
+    { 0x01f0, 0x0111 }, /* dstroke  LATIN SMALL LETTER D WITH STROKE */
+    { 0x01f1, 0x0144 }, /* nacute  LATIN SMALL LETTER N WITH ACUTE */
+    { 0x01f2, 0x0148 }, /* ncaron  LATIN SMALL LETTER N WITH CARON */
+    { 0x01f5, 0x0151 }, /* odoubleacute  LATIN SMALL LETTER O WITH DOUBLE ACUTE */
+    { 0x01f8, 0x0159 }, /* rcaron  LATIN SMALL LETTER R WITH CARON */
+    { 0x01f9, 0x016f }, /* uring  LATIN SMALL LETTER U WITH RING ABOVE */
+    { 0x01fb, 0x0171 }, /* udoubleacute  LATIN SMALL LETTER U WITH DOUBLE ACUTE */
+    { 0x01fe, 0x0163 }, /* tcedilla  LATIN SMALL LETTER T WITH CEDILLA */
+    { 0x01ff, 0x02d9 }, /* abovedot  DOT ABOVE */
+    { 0x02a1, 0x0126 }, /* Hstroke  LATIN CAPITAL LETTER H WITH STROKE */
+    { 0x02a6, 0x0124 }, /* Hcircumflex  LATIN CAPITAL LETTER H WITH CIRCUMFLEX */
+    { 0x02a9, 0x0130 }, /* Iabovedot  LATIN CAPITAL LETTER I WITH DOT ABOVE */
+    { 0x02ab, 0x011e }, /* Gbreve  LATIN CAPITAL LETTER G WITH BREVE */
+    { 0x02ac, 0x0134 }, /* Jcircumflex  LATIN CAPITAL LETTER J WITH CIRCUMFLEX */
+    { 0x02b1, 0x0127 }, /* hstroke  LATIN SMALL LETTER H WITH STROKE */
+    { 0x02b6, 0x0125 }, /* hcircumflex  LATIN SMALL LETTER H WITH CIRCUMFLEX */
+    { 0x02b9, 0x0131 }, /* idotless  LATIN SMALL LETTER DOTLESS I */
+    { 0x02bb, 0x011f }, /* gbreve  LATIN SMALL LETTER G WITH BREVE */
+    { 0x02bc, 0x0135 }, /* jcircumflex  LATIN SMALL LETTER J WITH CIRCUMFLEX */
+    { 0x02c5, 0x010a }, /* Cabovedot  LATIN CAPITAL LETTER C WITH DOT ABOVE */
+    { 0x02c6, 0x0108 }, /* Ccircumflex  LATIN CAPITAL LETTER C WITH CIRCUMFLEX */
+    { 0x02d5, 0x0120 }, /* Gabovedot  LATIN CAPITAL LETTER G WITH DOT ABOVE */
+    { 0x02d8, 0x011c }, /* Gcircumflex  LATIN CAPITAL LETTER G WITH CIRCUMFLEX */
+    { 0x02dd, 0x016c }, /* Ubreve  LATIN CAPITAL LETTER U WITH BREVE */
+    { 0x02de, 0x015c }, /* Scircumflex  LATIN CAPITAL LETTER S WITH CIRCUMFLEX */
+    { 0x02e5, 0x010b }, /* cabovedot  LATIN SMALL LETTER C WITH DOT ABOVE */
+    { 0x02e6, 0x0109 }, /* ccircumflex  LATIN SMALL LETTER C WITH CIRCUMFLEX */
+    { 0x02f5, 0x0121 }, /* gabovedot  LATIN SMALL LETTER G WITH DOT ABOVE */
+    { 0x02f8, 0x011d }, /* gcircumflex  LATIN SMALL LETTER G WITH CIRCUMFLEX */
+    { 0x02fd, 0x016d }, /* ubreve  LATIN SMALL LETTER U WITH BREVE */
+    { 0x02fe, 0x015d }, /* scircumflex  LATIN SMALL LETTER S WITH CIRCUMFLEX */
+    { 0x03a2, 0x0138 }, /* kra  LATIN SMALL LETTER KRA */
+    { 0x03a3, 0x0156 }, /* Rcedilla  LATIN CAPITAL LETTER R WITH CEDILLA */
+    { 0x03a5, 0x0128 }, /* Itilde  LATIN CAPITAL LETTER I WITH TILDE */
+    { 0x03a6, 0x013b }, /* Lcedilla  LATIN CAPITAL LETTER L WITH CEDILLA */
+    { 0x03aa, 0x0112 }, /* Emacron  LATIN CAPITAL LETTER E WITH MACRON */
+    { 0x03ab, 0x0122 }, /* Gcedilla  LATIN CAPITAL LETTER G WITH CEDILLA */
+    { 0x03ac, 0x0166 }, /* Tslash  LATIN CAPITAL LETTER T WITH STROKE */
+    { 0x03b3, 0x0157 }, /* rcedilla  LATIN SMALL LETTER R WITH CEDILLA */
+    { 0x03b5, 0x0129 }, /* itilde  LATIN SMALL LETTER I WITH TILDE */
+    { 0x03b6, 0x013c }, /* lcedilla  LATIN SMALL LETTER L WITH CEDILLA */
+    { 0x03ba, 0x0113 }, /* emacron  LATIN SMALL LETTER E WITH MACRON */
+    { 0x03bb, 0x0123 }, /* gcedilla  LATIN SMALL LETTER G WITH CEDILLA */
+    { 0x03bc, 0x0167 }, /* tslash  LATIN SMALL LETTER T WITH STROKE */
+    { 0x03bd, 0x014a }, /* ENG  LATIN CAPITAL LETTER ENG */
+    { 0x03bf, 0x014b }, /* eng  LATIN SMALL LETTER ENG */
+    { 0x03c0, 0x0100 }, /* Amacron  LATIN CAPITAL LETTER A WITH MACRON */
+    { 0x03c7, 0x012e }, /* Iogonek  LATIN CAPITAL LETTER I WITH OGONEK */
+    { 0x03cc, 0x0116 }, /* Eabovedot  LATIN CAPITAL LETTER E WITH DOT ABOVE */
+    { 0x03cf, 0x012a }, /* Imacron  LATIN CAPITAL LETTER I WITH MACRON */
+    { 0x03d1, 0x0145 }, /* Ncedilla  LATIN CAPITAL LETTER N WITH CEDILLA */
+    { 0x03d2, 0x014c }, /* Omacron  LATIN CAPITAL LETTER O WITH MACRON */
+    { 0x03d3, 0x0136 }, /* Kcedilla  LATIN CAPITAL LETTER K WITH CEDILLA */
+    { 0x03d9, 0x0172 }, /* Uogonek  LATIN CAPITAL LETTER U WITH OGONEK */
+    { 0x03dd, 0x0168 }, /* Utilde  LATIN CAPITAL LETTER U WITH TILDE */
+    { 0x03de, 0x016a }, /* Umacron  LATIN CAPITAL LETTER U WITH MACRON */
+    { 0x03e0, 0x0101 }, /* amacron  LATIN SMALL LETTER A WITH MACRON */
+    { 0x03e7, 0x012f }, /* iogonek  LATIN SMALL LETTER I WITH OGONEK */
+    { 0x03ec, 0x0117 }, /* eabovedot  LATIN SMALL LETTER E WITH DOT ABOVE */
+    { 0x03ef, 0x012b }, /* imacron  LATIN SMALL LETTER I WITH MACRON */
+    { 0x03f1, 0x0146 }, /* ncedilla  LATIN SMALL LETTER N WITH CEDILLA */
+    { 0x03f2, 0x014d }, /* omacron  LATIN SMALL LETTER O WITH MACRON */
+    { 0x03f3, 0x0137 }, /* kcedilla  LATIN SMALL LETTER K WITH CEDILLA */
+    { 0x03f9, 0x0173 }, /* uogonek  LATIN SMALL LETTER U WITH OGONEK */
+    { 0x03fd, 0x0169 }, /* utilde  LATIN SMALL LETTER U WITH TILDE */
+    { 0x03fe, 0x016b }, /* umacron  LATIN SMALL LETTER U WITH MACRON */
+    { 0x047e, 0x203e }, /* overline  OVERLINE */
+    { 0x04a1, 0x3002 }, /* kana_fullstop  IDEOGRAPHIC FULL STOP */
+    { 0x04a2, 0x300c }, /* kana_openingbracket  LEFT CORNER BRACKET */
+    { 0x04a3, 0x300d }, /* kana_closingbracket  RIGHT CORNER BRACKET */
+    { 0x04a4, 0x3001 }, /* kana_comma  IDEOGRAPHIC COMMA */
+    { 0x04a5, 0x30fb }, /* kana_conjunctive  KATAKANA MIDDLE DOT */
+    { 0x04a6, 0x30f2 }, /* kana_WO  KATAKANA LETTER WO */
+    { 0x04a7, 0x30a1 }, /* kana_a  KATAKANA LETTER SMALL A */
+    { 0x04a8, 0x30a3 }, /* kana_i  KATAKANA LETTER SMALL I */
+    { 0x04a9, 0x30a5 }, /* kana_u  KATAKANA LETTER SMALL U */
+    { 0x04aa, 0x30a7 }, /* kana_e  KATAKANA LETTER SMALL E */
+    { 0x04ab, 0x30a9 }, /* kana_o  KATAKANA LETTER SMALL O */
+    { 0x04ac, 0x30e3 }, /* kana_ya  KATAKANA LETTER SMALL YA */
+    { 0x04ad, 0x30e5 }, /* kana_yu  KATAKANA LETTER SMALL YU */
+    { 0x04ae, 0x30e7 }, /* kana_yo  KATAKANA LETTER SMALL YO */
+    { 0x04af, 0x30c3 }, /* kana_tsu  KATAKANA LETTER SMALL TU */
+    { 0x04b0, 0x30fc }, /* prolongedsound  KATAKANA-HIRAGANA PROLONGED SOUND MARK */
+    { 0x04b1, 0x30a2 }, /* kana_A  KATAKANA LETTER A */
+    { 0x04b2, 0x30a4 }, /* kana_I  KATAKANA LETTER I */
+    { 0x04b3, 0x30a6 }, /* kana_U  KATAKANA LETTER U */
+    { 0x04b4, 0x30a8 }, /* kana_E  KATAKANA LETTER E */
+    { 0x04b5, 0x30aa }, /* kana_O  KATAKANA LETTER O */
+    { 0x04b6, 0x30ab }, /* kana_KA  KATAKANA LETTER KA */
+    { 0x04b7, 0x30ad }, /* kana_KI  KATAKANA LETTER KI */
+    { 0x04b8, 0x30af }, /* kana_KU  KATAKANA LETTER KU */
+    { 0x04b9, 0x30b1 }, /* kana_KE  KATAKANA LETTER KE */
+    { 0x04ba, 0x30b3 }, /* kana_KO  KATAKANA LETTER KO */
+    { 0x04bb, 0x30b5 }, /* kana_SA  KATAKANA LETTER SA */
+    { 0x04bc, 0x30b7 }, /* kana_SHI  KATAKANA LETTER SI */
+    { 0x04bd, 0x30b9 }, /* kana_SU  KATAKANA LETTER SU */
+    { 0x04be, 0x30bb }, /* kana_SE  KATAKANA LETTER SE */
+    { 0x04bf, 0x30bd }, /* kana_SO  KATAKANA LETTER SO */
+    { 0x04c0, 0x30bf }, /* kana_TA  KATAKANA LETTER TA */
+    { 0x04c1, 0x30c1 }, /* kana_CHI  KATAKANA LETTER TI */
+    { 0x04c2, 0x30c4 }, /* kana_TSU  KATAKANA LETTER TU */
+    { 0x04c3, 0x30c6 }, /* kana_TE  KATAKANA LETTER TE */
+    { 0x04c4, 0x30c8 }, /* kana_TO  KATAKANA LETTER TO */
+    { 0x04c5, 0x30ca }, /* kana_NA  KATAKANA LETTER NA */
+    { 0x04c6, 0x30cb }, /* kana_NI  KATAKANA LETTER NI */
+    { 0x04c7, 0x30cc }, /* kana_NU  KATAKANA LETTER NU */
+    { 0x04c8, 0x30cd }, /* kana_NE  KATAKANA LETTER NE */
+    { 0x04c9, 0x30ce }, /* kana_NO  KATAKANA LETTER NO */
+    { 0x04ca, 0x30cf }, /* kana_HA  KATAKANA LETTER HA */
+    { 0x04cb, 0x30d2 }, /* kana_HI  KATAKANA LETTER HI */
+    { 0x04cc, 0x30d5 }, /* kana_FU  KATAKANA LETTER HU */
+    { 0x04cd, 0x30d8 }, /* kana_HE  KATAKANA LETTER HE */
+    { 0x04ce, 0x30db }, /* kana_HO  KATAKANA LETTER HO */
+    { 0x04cf, 0x30de }, /* kana_MA  KATAKANA LETTER MA */
+    { 0x04d0, 0x30df }, /* kana_MI  KATAKANA LETTER MI */
+    { 0x04d1, 0x30e0 }, /* kana_MU  KATAKANA LETTER MU */
+    { 0x04d2, 0x30e1 }, /* kana_ME  KATAKANA LETTER ME */
+    { 0x04d3, 0x30e2 }, /* kana_MO  KATAKANA LETTER MO */
+    { 0x04d4, 0x30e4 }, /* kana_YA  KATAKANA LETTER YA */
+    { 0x04d5, 0x30e6 }, /* kana_YU  KATAKANA LETTER YU */
+    { 0x04d6, 0x30e8 }, /* kana_YO  KATAKANA LETTER YO */
+    { 0x04d7, 0x30e9 }, /* kana_RA  KATAKANA LETTER RA */
+    { 0x04d8, 0x30ea }, /* kana_RI  KATAKANA LETTER RI */
+    { 0x04d9, 0x30eb }, /* kana_RU  KATAKANA LETTER RU */
+    { 0x04da, 0x30ec }, /* kana_RE  KATAKANA LETTER RE */
+    { 0x04db, 0x30ed }, /* kana_RO  KATAKANA LETTER RO */
+    { 0x04dc, 0x30ef }, /* kana_WA  KATAKANA LETTER WA */
+    { 0x04dd, 0x30f3 }, /* kana_N  KATAKANA LETTER N */
+    { 0x04de, 0x309b }, /* voicedsound  KATAKANA-HIRAGANA VOICED SOUND MARK */
+    { 0x04df, 0x309c }, /* semivoicedsound  KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK */
+    { 0x05ac, 0x060c }, /* Arabic_comma  ARABIC COMMA */
+    { 0x05bb, 0x061b }, /* Arabic_semicolon  ARABIC SEMICOLON */
+    { 0x05bf, 0x061f }, /* Arabic_question_mark  ARABIC QUESTION MARK */
+    { 0x05c1, 0x0621 }, /* Arabic_hamza  ARABIC LETTER HAMZA */
+    { 0x05c2, 0x0622 }, /* Arabic_maddaonalef  ARABIC LETTER ALEF WITH MADDA ABOVE */
+    { 0x05c3, 0x0623 }, /* Arabic_hamzaonalef  ARABIC LETTER ALEF WITH HAMZA ABOVE */
+    { 0x05c4, 0x0624 }, /* Arabic_hamzaonwaw  ARABIC LETTER WAW WITH HAMZA ABOVE */
+    { 0x05c5, 0x0625 }, /* Arabic_hamzaunderalef  ARABIC LETTER ALEF WITH HAMZA BELOW */
+    { 0x05c6, 0x0626 }, /* Arabic_hamzaonyeh  ARABIC LETTER YEH WITH HAMZA ABOVE */
+    { 0x05c7, 0x0627 }, /* Arabic_alef  ARABIC LETTER ALEF */
+    { 0x05c8, 0x0628 }, /* Arabic_beh  ARABIC LETTER BEH */
+    { 0x05c9, 0x0629 }, /* Arabic_tehmarbuta  ARABIC LETTER TEH MARBUTA */
+    { 0x05ca, 0x062a }, /* Arabic_teh  ARABIC LETTER TEH */
+    { 0x05cb, 0x062b }, /* Arabic_theh  ARABIC LETTER THEH */
+    { 0x05cc, 0x062c }, /* Arabic_jeem  ARABIC LETTER JEEM */
+    { 0x05cd, 0x062d }, /* Arabic_hah  ARABIC LETTER HAH */
+    { 0x05ce, 0x062e }, /* Arabic_khah  ARABIC LETTER KHAH */
+    { 0x05cf, 0x062f }, /* Arabic_dal  ARABIC LETTER DAL */
+    { 0x05d0, 0x0630 }, /* Arabic_thal  ARABIC LETTER THAL */
+    { 0x05d1, 0x0631 }, /* Arabic_ra  ARABIC LETTER REH */
+    { 0x05d2, 0x0632 }, /* Arabic_zain  ARABIC LETTER ZAIN */
+    { 0x05d3, 0x0633 }, /* Arabic_seen  ARABIC LETTER SEEN */
+    { 0x05d4, 0x0634 }, /* Arabic_sheen  ARABIC LETTER SHEEN */
+    { 0x05d5, 0x0635 }, /* Arabic_sad  ARABIC LETTER SAD */
+    { 0x05d6, 0x0636 }, /* Arabic_dad  ARABIC LETTER DAD */
+    { 0x05d7, 0x0637 }, /* Arabic_tah  ARABIC LETTER TAH */
+    { 0x05d8, 0x0638 }, /* Arabic_zah  ARABIC LETTER ZAH */
+    { 0x05d9, 0x0639 }, /* Arabic_ain  ARABIC LETTER AIN */
+    { 0x05da, 0x063a }, /* Arabic_ghain  ARABIC LETTER GHAIN */
+    { 0x05e0, 0x0640 }, /* Arabic_tatweel  ARABIC TATWEEL */
+    { 0x05e1, 0x0641 }, /* Arabic_feh  ARABIC LETTER FEH */
+    { 0x05e2, 0x0642 }, /* Arabic_qaf  ARABIC LETTER QAF */
+    { 0x05e3, 0x0643 }, /* Arabic_kaf  ARABIC LETTER KAF */
+    { 0x05e4, 0x0644 }, /* Arabic_lam  ARABIC LETTER LAM */
+    { 0x05e5, 0x0645 }, /* Arabic_meem  ARABIC LETTER MEEM */
+    { 0x05e6, 0x0646 }, /* Arabic_noon  ARABIC LETTER NOON */
+    { 0x05e7, 0x0647 }, /* Arabic_ha  ARABIC LETTER HEH */
+    { 0x05e8, 0x0648 }, /* Arabic_waw  ARABIC LETTER WAW */
+    { 0x05e9, 0x0649 }, /* Arabic_alefmaksura  ARABIC LETTER ALEF MAKSURA */
+    { 0x05ea, 0x064a }, /* Arabic_yeh  ARABIC LETTER YEH */
+    { 0x05eb, 0x064b }, /* Arabic_fathatan  ARABIC FATHATAN */
+    { 0x05ec, 0x064c }, /* Arabic_dammatan  ARABIC DAMMATAN */
+    { 0x05ed, 0x064d }, /* Arabic_kasratan  ARABIC KASRATAN */
+    { 0x05ee, 0x064e }, /* Arabic_fatha  ARABIC FATHA */
+    { 0x05ef, 0x064f }, /* Arabic_damma  ARABIC DAMMA */
+    { 0x05f0, 0x0650 }, /* Arabic_kasra  ARABIC KASRA */
+    { 0x05f1, 0x0651 }, /* Arabic_shadda  ARABIC SHADDA */
+    { 0x05f2, 0x0652 }, /* Arabic_sukun  ARABIC SUKUN */
+    { 0x06a1, 0x0452 }, /* Serbian_dje  CYRILLIC SMALL LETTER DJE */
+    { 0x06a2, 0x0453 }, /* Macedonia_gje  CYRILLIC SMALL LETTER GJE */
+    { 0x06a3, 0x0451 }, /* Cyrillic_io  CYRILLIC SMALL LETTER IO */
+    { 0x06a4, 0x0454 }, /* Ukrainian_ie  CYRILLIC SMALL LETTER UKRAINIAN IE */
+    { 0x06a5, 0x0455 }, /* Macedonia_dse  CYRILLIC SMALL LETTER DZE */
+    { 0x06a6, 0x0456 }, /* Ukrainian_i  CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I */
+    { 0x06a7, 0x0457 }, /* Ukrainian_yi  CYRILLIC SMALL LETTER YI */
+    { 0x06a8, 0x0458 }, /* Cyrillic_je  CYRILLIC SMALL LETTER JE */
+    { 0x06a9, 0x0459 }, /* Cyrillic_lje  CYRILLIC SMALL LETTER LJE */
+    { 0x06aa, 0x045a }, /* Cyrillic_nje  CYRILLIC SMALL LETTER NJE */
+    { 0x06ab, 0x045b }, /* Serbian_tshe  CYRILLIC SMALL LETTER TSHE */
+    { 0x06ac, 0x045c }, /* Macedonia_kje  CYRILLIC SMALL LETTER KJE */
+    { 0x06ad, 0x0491 }, /* Ukrainian_ghe_with_upturn  CYRILLIC SMALL LETTER GHE WITH UPTURN */
+    { 0x06ae, 0x045e }, /* Byelorussian_shortu  CYRILLIC SMALL LETTER SHORT U */
+    { 0x06af, 0x045f }, /* Cyrillic_dzhe  CYRILLIC SMALL LETTER DZHE */
+    { 0x06b0, 0x2116 }, /* numerosign  NUMERO SIGN */
+    { 0x06b1, 0x0402 }, /* Serbian_DJE  CYRILLIC CAPITAL LETTER DJE */
+    { 0x06b2, 0x0403 }, /* Macedonia_GJE  CYRILLIC CAPITAL LETTER GJE */
+    { 0x06b3, 0x0401 }, /* Cyrillic_IO  CYRILLIC CAPITAL LETTER IO */
+    { 0x06b4, 0x0404 }, /* Ukrainian_IE  CYRILLIC CAPITAL LETTER UKRAINIAN IE */
+    { 0x06b5, 0x0405 }, /* Macedonia_DSE  CYRILLIC CAPITAL LETTER DZE */
+    { 0x06b6, 0x0406 }, /* Ukrainian_I  CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I */
+    { 0x06b7, 0x0407 }, /* Ukrainian_YI  CYRILLIC CAPITAL LETTER YI */
+    { 0x06b8, 0x0408 }, /* Cyrillic_JE  CYRILLIC CAPITAL LETTER JE */
+    { 0x06b9, 0x0409 }, /* Cyrillic_LJE  CYRILLIC CAPITAL LETTER LJE */
+    { 0x06ba, 0x040a }, /* Cyrillic_NJE  CYRILLIC CAPITAL LETTER NJE */
+    { 0x06bb, 0x040b }, /* Serbian_TSHE  CYRILLIC CAPITAL LETTER TSHE */
+    { 0x06bc, 0x040c }, /* Macedonia_KJE  CYRILLIC CAPITAL LETTER KJE */
+    { 0x06bd, 0x0490 }, /* Ukrainian_GHE_WITH_UPTURN  CYRILLIC CAPITAL LETTER GHE WITH UPTURN */
+    { 0x06be, 0x040e }, /* Byelorussian_SHORTU  CYRILLIC CAPITAL LETTER SHORT U */
+    { 0x06bf, 0x040f }, /* Cyrillic_DZHE  CYRILLIC CAPITAL LETTER DZHE */
+    { 0x06c0, 0x044e }, /* Cyrillic_yu  CYRILLIC SMALL LETTER YU */
+    { 0x06c1, 0x0430 }, /* Cyrillic_a  CYRILLIC SMALL LETTER A */
+    { 0x06c2, 0x0431 }, /* Cyrillic_be  CYRILLIC SMALL LETTER BE */
+    { 0x06c3, 0x0446 }, /* Cyrillic_tse  CYRILLIC SMALL LETTER TSE */
+    { 0x06c4, 0x0434 }, /* Cyrillic_de  CYRILLIC SMALL LETTER DE */
+    { 0x06c5, 0x0435 }, /* Cyrillic_ie  CYRILLIC SMALL LETTER IE */
+    { 0x06c6, 0x0444 }, /* Cyrillic_ef  CYRILLIC SMALL LETTER EF */
+    { 0x06c7, 0x0433 }, /* Cyrillic_ghe  CYRILLIC SMALL LETTER GHE */
+    { 0x06c8, 0x0445 }, /* Cyrillic_ha  CYRILLIC SMALL LETTER HA */
+    { 0x06c9, 0x0438 }, /* Cyrillic_i  CYRILLIC SMALL LETTER I */
+    { 0x06ca, 0x0439 }, /* Cyrillic_shorti  CYRILLIC SMALL LETTER SHORT I */
+    { 0x06cb, 0x043a }, /* Cyrillic_ka  CYRILLIC SMALL LETTER KA */
+    { 0x06cc, 0x043b }, /* Cyrillic_el  CYRILLIC SMALL LETTER EL */
+    { 0x06cd, 0x043c }, /* Cyrillic_em  CYRILLIC SMALL LETTER EM */
+    { 0x06ce, 0x043d }, /* Cyrillic_en  CYRILLIC SMALL LETTER EN */
+    { 0x06cf, 0x043e }, /* Cyrillic_o  CYRILLIC SMALL LETTER O */
+    { 0x06d0, 0x043f }, /* Cyrillic_pe  CYRILLIC SMALL LETTER PE */
+    { 0x06d1, 0x044f }, /* Cyrillic_ya  CYRILLIC SMALL LETTER YA */
+    { 0x06d2, 0x0440 }, /* Cyrillic_er  CYRILLIC SMALL LETTER ER */
+    { 0x06d3, 0x0441 }, /* Cyrillic_es  CYRILLIC SMALL LETTER ES */
+    { 0x06d4, 0x0442 }, /* Cyrillic_te  CYRILLIC SMALL LETTER TE */
+    { 0x06d5, 0x0443 }, /* Cyrillic_u  CYRILLIC SMALL LETTER U */
+    { 0x06d6, 0x0436 }, /* Cyrillic_zhe  CYRILLIC SMALL LETTER ZHE */
+    { 0x06d7, 0x0432 }, /* Cyrillic_ve  CYRILLIC SMALL LETTER VE */
+    { 0x06d8, 0x044c }, /* Cyrillic_softsign  CYRILLIC SMALL LETTER SOFT SIGN */
+    { 0x06d9, 0x044b }, /* Cyrillic_yeru  CYRILLIC SMALL LETTER YERU */
+    { 0x06da, 0x0437 }, /* Cyrillic_ze  CYRILLIC SMALL LETTER ZE */
+    { 0x06db, 0x0448 }, /* Cyrillic_sha  CYRILLIC SMALL LETTER SHA */
+    { 0x06dc, 0x044d }, /* Cyrillic_e  CYRILLIC SMALL LETTER E */
+    { 0x06dd, 0x0449 }, /* Cyrillic_shcha  CYRILLIC SMALL LETTER SHCHA */
+    { 0x06de, 0x0447 }, /* Cyrillic_che  CYRILLIC SMALL LETTER CHE */
+    { 0x06df, 0x044a }, /* Cyrillic_hardsign  CYRILLIC SMALL LETTER HARD SIGN */
+    { 0x06e0, 0x042e }, /* Cyrillic_YU  CYRILLIC CAPITAL LETTER YU */
+    { 0x06e1, 0x0410 }, /* Cyrillic_A  CYRILLIC CAPITAL LETTER A */
+    { 0x06e2, 0x0411 }, /* Cyrillic_BE  CYRILLIC CAPITAL LETTER BE */
+    { 0x06e3, 0x0426 }, /* Cyrillic_TSE  CYRILLIC CAPITAL LETTER TSE */
+    { 0x06e4, 0x0414 }, /* Cyrillic_DE  CYRILLIC CAPITAL LETTER DE */
+    { 0x06e5, 0x0415 }, /* Cyrillic_IE  CYRILLIC CAPITAL LETTER IE */
+    { 0x06e6, 0x0424 }, /* Cyrillic_EF  CYRILLIC CAPITAL LETTER EF */
+    { 0x06e7, 0x0413 }, /* Cyrillic_GHE  CYRILLIC CAPITAL LETTER GHE */
+    { 0x06e8, 0x0425 }, /* Cyrillic_HA  CYRILLIC CAPITAL LETTER HA */
+    { 0x06e9, 0x0418 }, /* Cyrillic_I  CYRILLIC CAPITAL LETTER I */
+    { 0x06ea, 0x0419 }, /* Cyrillic_SHORTI  CYRILLIC CAPITAL LETTER SHORT I */
+    { 0x06eb, 0x041a }, /* Cyrillic_KA  CYRILLIC CAPITAL LETTER KA */
+    { 0x06ec, 0x041b }, /* Cyrillic_EL  CYRILLIC CAPITAL LETTER EL */
+    { 0x06ed, 0x041c }, /* Cyrillic_EM  CYRILLIC CAPITAL LETTER EM */
+    { 0x06ee, 0x041d }, /* Cyrillic_EN  CYRILLIC CAPITAL LETTER EN */
+    { 0x06ef, 0x041e }, /* Cyrillic_O  CYRILLIC CAPITAL LETTER O */
+    { 0x06f0, 0x041f }, /* Cyrillic_PE  CYRILLIC CAPITAL LETTER PE */
+    { 0x06f1, 0x042f }, /* Cyrillic_YA  CYRILLIC CAPITAL LETTER YA */
+    { 0x06f2, 0x0420 }, /* Cyrillic_ER  CYRILLIC CAPITAL LETTER ER */
+    { 0x06f3, 0x0421 }, /* Cyrillic_ES  CYRILLIC CAPITAL LETTER ES */
+    { 0x06f4, 0x0422 }, /* Cyrillic_TE  CYRILLIC CAPITAL LETTER TE */
+    { 0x06f5, 0x0423 }, /* Cyrillic_U  CYRILLIC CAPITAL LETTER U */
+    { 0x06f6, 0x0416 }, /* Cyrillic_ZHE  CYRILLIC CAPITAL LETTER ZHE */
+    { 0x06f7, 0x0412 }, /* Cyrillic_VE  CYRILLIC CAPITAL LETTER VE */
+    { 0x06f8, 0x042c }, /* Cyrillic_SOFTSIGN  CYRILLIC CAPITAL LETTER SOFT SIGN */
+    { 0x06f9, 0x042b }, /* Cyrillic_YERU  CYRILLIC CAPITAL LETTER YERU */
+    { 0x06fa, 0x0417 }, /* Cyrillic_ZE  CYRILLIC CAPITAL LETTER ZE */
+    { 0x06fb, 0x0428 }, /* Cyrillic_SHA  CYRILLIC CAPITAL LETTER SHA */
+    { 0x06fc, 0x042d }, /* Cyrillic_E  CYRILLIC CAPITAL LETTER E */
+    { 0x06fd, 0x0429 }, /* Cyrillic_SHCHA  CYRILLIC CAPITAL LETTER SHCHA */
+    { 0x06fe, 0x0427 }, /* Cyrillic_CHE  CYRILLIC CAPITAL LETTER CHE */
+    { 0x06ff, 0x042a }, /* Cyrillic_HARDSIGN  CYRILLIC CAPITAL LETTER HARD SIGN */
+    { 0x07a1, 0x0386 }, /* Greek_ALPHAaccent  GREEK CAPITAL LETTER ALPHA WITH TONOS */
+    { 0x07a2, 0x0388 }, /* Greek_EPSILONaccent  GREEK CAPITAL LETTER EPSILON WITH TONOS */
+    { 0x07a3, 0x0389 }, /* Greek_ETAaccent  GREEK CAPITAL LETTER ETA WITH TONOS */
+    { 0x07a4, 0x038a }, /* Greek_IOTAaccent  GREEK CAPITAL LETTER IOTA WITH TONOS */
+    { 0x07a5, 0x03aa }, /* Greek_IOTAdieresis  GREEK CAPITAL LETTER IOTA WITH DIALYTIKA */
+    { 0x07a7, 0x038c }, /* Greek_OMICRONaccent  GREEK CAPITAL LETTER OMICRON WITH TONOS */
+    { 0x07a8, 0x038e }, /* Greek_UPSILONaccent  GREEK CAPITAL LETTER UPSILON WITH TONOS */
+    { 0x07a9, 0x03ab }, /* Greek_UPSILONdieresis  GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA */
+    { 0x07ab, 0x038f }, /* Greek_OMEGAaccent  GREEK CAPITAL LETTER OMEGA WITH TONOS */
+    { 0x07ae, 0x0385 }, /* Greek_accentdieresis  GREEK DIALYTIKA TONOS */
+    { 0x07af, 0x2015 }, /* Greek_horizbar  HORIZONTAL BAR */
+    { 0x07b1, 0x03ac }, /* Greek_alphaaccent  GREEK SMALL LETTER ALPHA WITH TONOS */
+    { 0x07b2, 0x03ad }, /* Greek_epsilonaccent  GREEK SMALL LETTER EPSILON WITH TONOS */
+    { 0x07b3, 0x03ae }, /* Greek_etaaccent  GREEK SMALL LETTER ETA WITH TONOS */
+    { 0x07b4, 0x03af }, /* Greek_iotaaccent  GREEK SMALL LETTER IOTA WITH TONOS */
+    { 0x07b5, 0x03ca }, /* Greek_iotadieresis  GREEK SMALL LETTER IOTA WITH DIALYTIKA */
+    { 0x07b6, 0x0390 }, /* Greek_iotaaccentdieresis  GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */
+    { 0x07b7, 0x03cc }, /* Greek_omicronaccent  GREEK SMALL LETTER OMICRON WITH TONOS */
+    { 0x07b8, 0x03cd }, /* Greek_upsilonaccent  GREEK SMALL LETTER UPSILON WITH TONOS */
+    { 0x07b9, 0x03cb }, /* Greek_upsilondieresis  GREEK SMALL LETTER UPSILON WITH DIALYTIKA */
+    { 0x07ba, 0x03b0 }, /* Greek_upsilonaccentdieresis  GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS */
+    { 0x07bb, 0x03ce }, /* Greek_omegaaccent  GREEK SMALL LETTER OMEGA WITH TONOS */
+    { 0x07c1, 0x0391 }, /* Greek_ALPHA  GREEK CAPITAL LETTER ALPHA */
+    { 0x07c2, 0x0392 }, /* Greek_BETA  GREEK CAPITAL LETTER BETA */
+    { 0x07c3, 0x0393 }, /* Greek_GAMMA  GREEK CAPITAL LETTER GAMMA */
+    { 0x07c4, 0x0394 }, /* Greek_DELTA  GREEK CAPITAL LETTER DELTA */
+    { 0x07c5, 0x0395 }, /* Greek_EPSILON  GREEK CAPITAL LETTER EPSILON */
+    { 0x07c6, 0x0396 }, /* Greek_ZETA  GREEK CAPITAL LETTER ZETA */
+    { 0x07c7, 0x0397 }, /* Greek_ETA  GREEK CAPITAL LETTER ETA */
+    { 0x07c8, 0x0398 }, /* Greek_THETA  GREEK CAPITAL LETTER THETA */
+    { 0x07c9, 0x0399 }, /* Greek_IOTA  GREEK CAPITAL LETTER IOTA */
+    { 0x07ca, 0x039a }, /* Greek_KAPPA  GREEK CAPITAL LETTER KAPPA */
+    { 0x07cb, 0x039b }, /* Greek_LAMBDA  GREEK CAPITAL LETTER LAMDA */
+    { 0x07cc, 0x039c }, /* Greek_MU  GREEK CAPITAL LETTER MU */
+    { 0x07cd, 0x039d }, /* Greek_NU  GREEK CAPITAL LETTER NU */
+    { 0x07ce, 0x039e }, /* Greek_XI  GREEK CAPITAL LETTER XI */
+    { 0x07cf, 0x039f }, /* Greek_OMICRON  GREEK CAPITAL LETTER OMICRON */
+    { 0x07d0, 0x03a0 }, /* Greek_PI  GREEK CAPITAL LETTER PI */
+    { 0x07d1, 0x03a1 }, /* Greek_RHO  GREEK CAPITAL LETTER RHO */
+    { 0x07d2, 0x03a3 }, /* Greek_SIGMA  GREEK CAPITAL LETTER SIGMA */
+    { 0x07d4, 0x03a4 }, /* Greek_TAU  GREEK CAPITAL LETTER TAU */
+    { 0x07d5, 0x03a5 }, /* Greek_UPSILON  GREEK CAPITAL LETTER UPSILON */
+    { 0x07d6, 0x03a6 }, /* Greek_PHI  GREEK CAPITAL LETTER PHI */
+    { 0x07d7, 0x03a7 }, /* Greek_CHI  GREEK CAPITAL LETTER CHI */
+    { 0x07d8, 0x03a8 }, /* Greek_PSI  GREEK CAPITAL LETTER PSI */
+    { 0x07d9, 0x03a9 }, /* Greek_OMEGA  GREEK CAPITAL LETTER OMEGA */
+    { 0x07e1, 0x03b1 }, /* Greek_alpha  GREEK SMALL LETTER ALPHA */
+    { 0x07e2, 0x03b2 }, /* Greek_beta  GREEK SMALL LETTER BETA */
+    { 0x07e3, 0x03b3 }, /* Greek_gamma  GREEK SMALL LETTER GAMMA */
+    { 0x07e4, 0x03b4 }, /* Greek_delta  GREEK SMALL LETTER DELTA */
+    { 0x07e5, 0x03b5 }, /* Greek_epsilon  GREEK SMALL LETTER EPSILON */
+    { 0x07e6, 0x03b6 }, /* Greek_zeta  GREEK SMALL LETTER ZETA */
+    { 0x07e7, 0x03b7 }, /* Greek_eta  GREEK SMALL LETTER ETA */
+    { 0x07e8, 0x03b8 }, /* Greek_theta  GREEK SMALL LETTER THETA */
+    { 0x07e9, 0x03b9 }, /* Greek_iota  GREEK SMALL LETTER IOTA */
+    { 0x07ea, 0x03ba }, /* Greek_kappa  GREEK SMALL LETTER KAPPA */
+    { 0x07eb, 0x03bb }, /* Greek_lambda  GREEK SMALL LETTER LAMDA */
+    { 0x07ec, 0x03bc }, /* Greek_mu  GREEK SMALL LETTER MU */
+    { 0x07ed, 0x03bd }, /* Greek_nu  GREEK SMALL LETTER NU */
+    { 0x07ee, 0x03be }, /* Greek_xi  GREEK SMALL LETTER XI */
+    { 0x07ef, 0x03bf }, /* Greek_omicron  GREEK SMALL LETTER OMICRON */
+    { 0x07f0, 0x03c0 }, /* Greek_pi  GREEK SMALL LETTER PI */
+    { 0x07f1, 0x03c1 }, /* Greek_rho  GREEK SMALL LETTER RHO */
+    { 0x07f2, 0x03c3 }, /* Greek_sigma  GREEK SMALL LETTER SIGMA */
+    { 0x07f3, 0x03c2 }, /* Greek_finalsmallsigma  GREEK SMALL LETTER FINAL SIGMA */
+    { 0x07f4, 0x03c4 }, /* Greek_tau  GREEK SMALL LETTER TAU */
+    { 0x07f5, 0x03c5 }, /* Greek_upsilon  GREEK SMALL LETTER UPSILON */
+    { 0x07f6, 0x03c6 }, /* Greek_phi  GREEK SMALL LETTER PHI */
+    { 0x07f7, 0x03c7 }, /* Greek_chi  GREEK SMALL LETTER CHI */
+    { 0x07f8, 0x03c8 }, /* Greek_psi  GREEK SMALL LETTER PSI */
+    { 0x07f9, 0x03c9 }, /* Greek_omega  GREEK SMALL LETTER OMEGA */
+    /* 0x08a1 leftradical ? ??? */
+    /* 0x08a2 topleftradical ? ??? */
+    /* 0x08a3 horizconnector ? ??? */
+    { 0x08a4, 0x2320 }, /* topintegral  TOP HALF INTEGRAL */
+    { 0x08a5, 0x2321 }, /* botintegral  BOTTOM HALF INTEGRAL */
+    { 0x08a6, 0x2502 }, /* vertconnector  BOX DRAWINGS LIGHT VERTICAL */
+    /* 0x08a7 topleftsqbracket ? ??? */
+    /* 0x08a8 botleftsqbracket ? ??? */
+    /* 0x08a9 toprightsqbracket ? ??? */
+    /* 0x08aa botrightsqbracket ? ??? */
+    /* 0x08ab topleftparens ? ??? */
+    /* 0x08ac botleftparens ? ??? */
+    /* 0x08ad toprightparens ? ??? */
+    /* 0x08ae botrightparens ? ??? */
+    /* 0x08af leftmiddlecurlybrace ? ??? */
+    /* 0x08b0 rightmiddlecurlybrace ? ??? */
+    /* 0x08b1 topleftsummation ? ??? */
+    /* 0x08b2 botleftsummation ? ??? */
+    /* 0x08b3 topvertsummationconnector ? ??? */
+    /* 0x08b4 botvertsummationconnector ? ??? */
+    /* 0x08b5 toprightsummation ? ??? */
+    /* 0x08b6 botrightsummation ? ??? */
+    /* 0x08b7 rightmiddlesummation ? ??? */
+    { 0x08bc, 0x2264 }, /* lessthanequal  LESS-THAN OR EQUAL TO */
+    { 0x08bd, 0x2260 }, /* notequal  NOT EQUAL TO */
+    { 0x08be, 0x2265 }, /* greaterthanequal  GREATER-THAN OR EQUAL TO */
+    { 0x08bf, 0x222b }, /* integral  INTEGRAL */
+    { 0x08c0, 0x2234 }, /* therefore  THEREFORE */
+    { 0x08c1, 0x221d }, /* variation  PROPORTIONAL TO */
+    { 0x08c2, 0x221e }, /* infinity  INFINITY */
+    { 0x08c5, 0x2207 }, /* nabla  NABLA */
+    { 0x08c8, 0x2245 }, /* approximate  APPROXIMATELY EQUAL TO */
+    /* 0x08c9 similarequal ? ??? */
+    { 0x08cd, 0x21d4 }, /* ifonlyif  LEFT RIGHT DOUBLE ARROW */
+    { 0x08ce, 0x21d2 }, /* implies  RIGHTWARDS DOUBLE ARROW */
+    { 0x08cf, 0x2261 }, /* identical  IDENTICAL TO */
+    { 0x08d6, 0x221a }, /* radical  SQUARE ROOT */
+    { 0x08da, 0x2282 }, /* includedin  SUBSET OF */
+    { 0x08db, 0x2283 }, /* includes  SUPERSET OF */
+    { 0x08dc, 0x2229 }, /* intersection  INTERSECTION */
+    { 0x08dd, 0x222a }, /* union  UNION */
+    { 0x08de, 0x2227 }, /* logicaland  LOGICAL AND */
+    { 0x08df, 0x2228 }, /* logicalor  LOGICAL OR */
+    { 0x08ef, 0x2202 }, /* partialderivative  PARTIAL DIFFERENTIAL */
+    { 0x08f6, 0x0192 }, /* function  LATIN SMALL LETTER F WITH HOOK */
+    { 0x08fb, 0x2190 }, /* leftarrow  LEFTWARDS ARROW */
+    { 0x08fc, 0x2191 }, /* uparrow  UPWARDS ARROW */
+    { 0x08fd, 0x2192 }, /* rightarrow  RIGHTWARDS ARROW */
+    { 0x08fe, 0x2193 }, /* downarrow  DOWNWARDS ARROW */
+    { 0x09df, 0x2422 }, /* blank  BLANK SYMBOL */
+    { 0x09e0, 0x25c6 }, /* soliddiamond  BLACK DIAMOND */
+    { 0x09e1, 0x2592 }, /* checkerboard  MEDIUM SHADE */
+    { 0x09e2, 0x2409 }, /* ht  SYMBOL FOR HORIZONTAL TABULATION */
+    { 0x09e3, 0x240c }, /* ff  SYMBOL FOR FORM FEED */
+    { 0x09e4, 0x240d }, /* cr  SYMBOL FOR CARRIAGE RETURN */
+    { 0x09e5, 0x240a }, /* lf  SYMBOL FOR LINE FEED */
+    { 0x09e8, 0x2424 }, /* nl  SYMBOL FOR NEWLINE */
+    { 0x09e9, 0x240b }, /* vt  SYMBOL FOR VERTICAL TABULATION */
+    { 0x09ea, 0x2518 }, /* lowrightcorner  BOX DRAWINGS LIGHT UP AND LEFT */
+    { 0x09eb, 0x2510 }, /* uprightcorner  BOX DRAWINGS LIGHT DOWN AND LEFT */
+    { 0x09ec, 0x250c }, /* upleftcorner  BOX DRAWINGS LIGHT DOWN AND RIGHT */
+    { 0x09ed, 0x2514 }, /* lowleftcorner  BOX DRAWINGS LIGHT UP AND RIGHT */
+    { 0x09ee, 0x253c }, /* crossinglines  BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL */
+    /* 0x09ef horizlinescan1 ? ??? */
+    /* 0x09f0 horizlinescan3 ? ??? */
+    { 0x09f1, 0x2500 }, /* horizlinescan5  BOX DRAWINGS LIGHT HORIZONTAL */
+    /* 0x09f2 horizlinescan7 ? ??? */
+    /* 0x09f3 horizlinescan9 ? ??? */
+    { 0x09f4, 0x251c }, /* leftt  BOX DRAWINGS LIGHT VERTICAL AND RIGHT */
+    { 0x09f5, 0x2524 }, /* rightt  BOX DRAWINGS LIGHT VERTICAL AND LEFT */
+    { 0x09f6, 0x2534 }, /* bott  BOX DRAWINGS LIGHT UP AND HORIZONTAL */
+    { 0x09f7, 0x252c }, /* topt  BOX DRAWINGS LIGHT DOWN AND HORIZONTAL */
+    { 0x09f8, 0x2502 }, /* vertbar  BOX DRAWINGS LIGHT VERTICAL */
+    { 0x0aa1, 0x2003 }, /* emspace  EM SPACE */
+    { 0x0aa2, 0x2002 }, /* enspace  EN SPACE */
+    { 0x0aa3, 0x2004 }, /* em3space  THREE-PER-EM SPACE */
+    { 0x0aa4, 0x2005 }, /* em4space  FOUR-PER-EM SPACE */
+    { 0x0aa5, 0x2007 }, /* digitspace  FIGURE SPACE */
+    { 0x0aa6, 0x2008 }, /* punctspace  PUNCTUATION SPACE */
+    { 0x0aa7, 0x2009 }, /* thinspace  THIN SPACE */
+    { 0x0aa8, 0x200a }, /* hairspace  HAIR SPACE */
+    { 0x0aa9, 0x2014 }, /* emdash  EM DASH */
+    { 0x0aaa, 0x2013 }, /* endash  EN DASH */
+    /* 0x0aac signifblank ? ??? */
+    { 0x0aae, 0x2026 }, /* ellipsis  HORIZONTAL ELLIPSIS */
+    /* 0x0aaf doubbaselinedot ? ??? */
+    { 0x0ab0, 0x2153 }, /* onethird  VULGAR FRACTION ONE THIRD */
+    { 0x0ab1, 0x2154 }, /* twothirds  VULGAR FRACTION TWO THIRDS */
+    { 0x0ab2, 0x2155 }, /* onefifth  VULGAR FRACTION ONE FIFTH */
+    { 0x0ab3, 0x2156 }, /* twofifths  VULGAR FRACTION TWO FIFTHS */
+    { 0x0ab4, 0x2157 }, /* threefifths  VULGAR FRACTION THREE FIFTHS */
+    { 0x0ab5, 0x2158 }, /* fourfifths  VULGAR FRACTION FOUR FIFTHS */
+    { 0x0ab6, 0x2159 }, /* onesixth  VULGAR FRACTION ONE SIXTH */
+    { 0x0ab7, 0x215a }, /* fivesixths  VULGAR FRACTION FIVE SIXTHS */
+    { 0x0ab8, 0x2105 }, /* careof  CARE OF */
+    { 0x0abb, 0x2012 }, /* figdash  FIGURE DASH */
+    { 0x0abc, 0x2329 }, /* leftanglebracket  LEFT-POINTING ANGLE BRACKET */
+    { 0x0abd, 0x002e }, /* decimalpoint . FULL STOP */
+    { 0x0abe, 0x232a }, /* rightanglebracket  RIGHT-POINTING ANGLE BRACKET */
+    /* 0x0abf marker ? ??? */
+    { 0x0ac3, 0x215b }, /* oneeighth  VULGAR FRACTION ONE EIGHTH */
+    { 0x0ac4, 0x215c }, /* threeeighths  VULGAR FRACTION THREE EIGHTHS */
+    { 0x0ac5, 0x215d }, /* fiveeighths  VULGAR FRACTION FIVE EIGHTHS */
+    { 0x0ac6, 0x215e }, /* seveneighths  VULGAR FRACTION SEVEN EIGHTHS */
+    { 0x0ac9, 0x2122 }, /* trademark  TRADE MARK SIGN */
+    { 0x0aca, 0x2613 }, /* signaturemark  SALTIRE */
+    /* 0x0acb trademarkincircle ? ??? */
+    { 0x0acc, 0x25c1 }, /* leftopentriangle  WHITE LEFT-POINTING TRIANGLE */
+    { 0x0acd, 0x25b7 }, /* rightopentriangle  WHITE RIGHT-POINTING TRIANGLE */
+    { 0x0ace, 0x25cb }, /* emopencircle  WHITE CIRCLE */
+    { 0x0acf, 0x25a1 }, /* emopenrectangle  WHITE SQUARE */
+    { 0x0ad0, 0x2018 }, /* leftsinglequotemark  LEFT SINGLE QUOTATION MARK */
+    { 0x0ad1, 0x2019 }, /* rightsinglequotemark  RIGHT SINGLE QUOTATION MARK */
+    { 0x0ad2, 0x201c }, /* leftdoublequotemark  LEFT DOUBLE QUOTATION MARK */
+    { 0x0ad3, 0x201d }, /* rightdoublequotemark  RIGHT DOUBLE QUOTATION MARK */
+    { 0x0ad4, 0x211e }, /* prescription  PRESCRIPTION TAKE */
+    { 0x0ad6, 0x2032 }, /* minutes  PRIME */
+    { 0x0ad7, 0x2033 }, /* seconds  DOUBLE PRIME */
+    { 0x0ad9, 0x271d }, /* latincross  LATIN CROSS */
+    /* 0x0ada hexagram ? ??? */
+    { 0x0adb, 0x25ac }, /* filledrectbullet  BLACK RECTANGLE */
+    { 0x0adc, 0x25c0 }, /* filledlefttribullet  BLACK LEFT-POINTING TRIANGLE */
+    { 0x0add, 0x25b6 }, /* filledrighttribullet  BLACK RIGHT-POINTING TRIANGLE */
+    { 0x0ade, 0x25cf }, /* emfilledcircle  BLACK CIRCLE */
+    { 0x0adf, 0x25a0 }, /* emfilledrect  BLACK SQUARE */
+    { 0x0ae0, 0x25e6 }, /* enopencircbullet  WHITE BULLET */
+    { 0x0ae1, 0x25ab }, /* enopensquarebullet  WHITE SMALL SQUARE */
+    { 0x0ae2, 0x25ad }, /* openrectbullet  WHITE RECTANGLE */
+    { 0x0ae3, 0x25b3 }, /* opentribulletup  WHITE UP-POINTING TRIANGLE */
+    { 0x0ae4, 0x25bd }, /* opentribulletdown  WHITE DOWN-POINTING TRIANGLE */
+    { 0x0ae5, 0x2606 }, /* openstar  WHITE STAR */
+    { 0x0ae6, 0x2022 }, /* enfilledcircbullet  BULLET */
+    { 0x0ae7, 0x25aa }, /* enfilledsqbullet  BLACK SMALL SQUARE */
+    { 0x0ae8, 0x25b2 }, /* filledtribulletup  BLACK UP-POINTING TRIANGLE */
+    { 0x0ae9, 0x25bc }, /* filledtribulletdown  BLACK DOWN-POINTING TRIANGLE */
+    { 0x0aea, 0x261c }, /* leftpointer  WHITE LEFT POINTING INDEX */
+    { 0x0aeb, 0x261e }, /* rightpointer  WHITE RIGHT POINTING INDEX */
+    { 0x0aec, 0x2663 }, /* club  BLACK CLUB SUIT */
+    { 0x0aed, 0x2666 }, /* diamond  BLACK DIAMOND SUIT */
+    { 0x0aee, 0x2665 }, /* heart  BLACK HEART SUIT */
+    { 0x0af0, 0x2720 }, /* maltesecross  MALTESE CROSS */
+    { 0x0af1, 0x2020 }, /* dagger  DAGGER */
+    { 0x0af2, 0x2021 }, /* doubledagger  DOUBLE DAGGER */
+    { 0x0af3, 0x2713 }, /* checkmark  CHECK MARK */
+    { 0x0af4, 0x2717 }, /* ballotcross  BALLOT X */
+    { 0x0af5, 0x266f }, /* musicalsharp  MUSIC SHARP SIGN */
+    { 0x0af6, 0x266d }, /* musicalflat  MUSIC FLAT SIGN */
+    { 0x0af7, 0x2642 }, /* malesymbol  MALE SIGN */
+    { 0x0af8, 0x2640 }, /* femalesymbol  FEMALE SIGN */
+    { 0x0af9, 0x260e }, /* telephone  BLACK TELEPHONE */
+    { 0x0afa, 0x2315 }, /* telephonerecorder  TELEPHONE RECORDER */
+    { 0x0afb, 0x2117 }, /* phonographcopyright  SOUND RECORDING COPYRIGHT */
+    { 0x0afc, 0x2038 }, /* caret  CARET */
+    { 0x0afd, 0x201a }, /* singlelowquotemark  SINGLE LOW-9 QUOTATION MARK */
+    { 0x0afe, 0x201e }, /* doublelowquotemark  DOUBLE LOW-9 QUOTATION MARK */
+    /* 0x0aff cursor ? ??? */
+    { 0x0ba3, 0x003c }, /* leftcaret < LESS-THAN SIGN */
+    { 0x0ba6, 0x003e }, /* rightcaret > GREATER-THAN SIGN */
+    { 0x0ba8, 0x2228 }, /* downcaret  LOGICAL OR */
+    { 0x0ba9, 0x2227 }, /* upcaret  LOGICAL AND */
+    { 0x0bc0, 0x00af }, /* overbar  MACRON */
+    { 0x0bc2, 0x22a4 }, /* downtack  DOWN TACK */
+    { 0x0bc3, 0x2229 }, /* upshoe  INTERSECTION */
+    { 0x0bc4, 0x230a }, /* downstile  LEFT FLOOR */
+    { 0x0bc6, 0x005f }, /* underbar _ LOW LINE */
+    { 0x0bca, 0x2218 }, /* jot  RING OPERATOR */
+    { 0x0bcc, 0x2395 }, /* quad  APL FUNCTIONAL SYMBOL QUAD (Unicode 3.0) */
+    { 0x0bce, 0x22a5 }, /* uptack  UP TACK */
+    { 0x0bcf, 0x25cb }, /* circle  WHITE CIRCLE */
+    { 0x0bd3, 0x2308 }, /* upstile  LEFT CEILING */
+    { 0x0bd6, 0x222a }, /* downshoe  UNION */
+    { 0x0bd8, 0x2283 }, /* rightshoe  SUPERSET OF */
+    { 0x0bda, 0x2282 }, /* leftshoe  SUBSET OF */
+    { 0x0bdc, 0x22a3 }, /* lefttack  LEFT TACK */
+    { 0x0bfc, 0x22a2 }, /* righttack  RIGHT TACK */
+    { 0x0cdf, 0x2017 }, /* hebrew_doublelowline  DOUBLE LOW LINE */
+    { 0x0ce0, 0x05d0 }, /* hebrew_aleph  HEBREW LETTER ALEF */
+    { 0x0ce1, 0x05d1 }, /* hebrew_bet  HEBREW LETTER BET */
+    { 0x0ce2, 0x05d2 }, /* hebrew_gimel  HEBREW LETTER GIMEL */
+    { 0x0ce3, 0x05d3 }, /* hebrew_dalet  HEBREW LETTER DALET */
+    { 0x0ce4, 0x05d4 }, /* hebrew_he  HEBREW LETTER HE */
+    { 0x0ce5, 0x05d5 }, /* hebrew_waw  HEBREW LETTER VAV */
+    { 0x0ce6, 0x05d6 }, /* hebrew_zain  HEBREW LETTER ZAYIN */
+    { 0x0ce7, 0x05d7 }, /* hebrew_chet  HEBREW LETTER HET */
+    { 0x0ce8, 0x05d8 }, /* hebrew_tet  HEBREW LETTER TET */
+    { 0x0ce9, 0x05d9 }, /* hebrew_yod  HEBREW LETTER YOD */
+    { 0x0cea, 0x05da }, /* hebrew_finalkaph  HEBREW LETTER FINAL KAF */
+    { 0x0ceb, 0x05db }, /* hebrew_kaph  HEBREW LETTER KAF */
+    { 0x0cec, 0x05dc }, /* hebrew_lamed  HEBREW LETTER LAMED */
+    { 0x0ced, 0x05dd }, /* hebrew_finalmem  HEBREW LETTER FINAL MEM */
+    { 0x0cee, 0x05de }, /* hebrew_mem  HEBREW LETTER MEM */
+    { 0x0cef, 0x05df }, /* hebrew_finalnun  HEBREW LETTER FINAL NUN */
+    { 0x0cf0, 0x05e0 }, /* hebrew_nun  HEBREW LETTER NUN */
+    { 0x0cf1, 0x05e1 }, /* hebrew_samech  HEBREW LETTER SAMEKH */
+    { 0x0cf2, 0x05e2 }, /* hebrew_ayin  HEBREW LETTER AYIN */
+    { 0x0cf3, 0x05e3 }, /* hebrew_finalpe  HEBREW LETTER FINAL PE */
+    { 0x0cf4, 0x05e4 }, /* hebrew_pe  HEBREW LETTER PE */
+    { 0x0cf5, 0x05e5 }, /* hebrew_finalzade  HEBREW LETTER FINAL TSADI */
+    { 0x0cf6, 0x05e6 }, /* hebrew_zade  HEBREW LETTER TSADI */
+    { 0x0cf7, 0x05e7 }, /* hebrew_qoph  HEBREW LETTER QOF */
+    { 0x0cf8, 0x05e8 }, /* hebrew_resh  HEBREW LETTER RESH */
+    { 0x0cf9, 0x05e9 }, /* hebrew_shin  HEBREW LETTER SHIN */
+    { 0x0cfa, 0x05ea }, /* hebrew_taw  HEBREW LETTER TAV */
+    { 0x0da1, 0x0e01 }, /* Thai_kokai  THAI CHARACTER KO KAI */
+    { 0x0da2, 0x0e02 }, /* Thai_khokhai  THAI CHARACTER KHO KHAI */
+    { 0x0da3, 0x0e03 }, /* Thai_khokhuat  THAI CHARACTER KHO KHUAT */
+    { 0x0da4, 0x0e04 }, /* Thai_khokhwai  THAI CHARACTER KHO KHWAI */
+    { 0x0da5, 0x0e05 }, /* Thai_khokhon  THAI CHARACTER KHO KHON */
+    { 0x0da6, 0x0e06 }, /* Thai_khorakhang  THAI CHARACTER KHO RAKHANG */
+    { 0x0da7, 0x0e07 }, /* Thai_ngongu  THAI CHARACTER NGO NGU */
+    { 0x0da8, 0x0e08 }, /* Thai_chochan  THAI CHARACTER CHO CHAN */
+    { 0x0da9, 0x0e09 }, /* Thai_choching  THAI CHARACTER CHO CHING */
+    { 0x0daa, 0x0e0a }, /* Thai_chochang  THAI CHARACTER CHO CHANG */
+    { 0x0dab, 0x0e0b }, /* Thai_soso  THAI CHARACTER SO SO */
+    { 0x0dac, 0x0e0c }, /* Thai_chochoe  THAI CHARACTER CHO CHOE */
+    { 0x0dad, 0x0e0d }, /* Thai_yoying  THAI CHARACTER YO YING */
+    { 0x0dae, 0x0e0e }, /* Thai_dochada  THAI CHARACTER DO CHADA */
+    { 0x0daf, 0x0e0f }, /* Thai_topatak  THAI CHARACTER TO PATAK */
+    { 0x0db0, 0x0e10 }, /* Thai_thothan  THAI CHARACTER THO THAN */
+    { 0x0db1, 0x0e11 }, /* Thai_thonangmontho  THAI CHARACTER THO NANGMONTHO */
+    { 0x0db2, 0x0e12 }, /* Thai_thophuthao  THAI CHARACTER THO PHUTHAO */
+    { 0x0db3, 0x0e13 }, /* Thai_nonen  THAI CHARACTER NO NEN */
+    { 0x0db4, 0x0e14 }, /* Thai_dodek  THAI CHARACTER DO DEK */
+    { 0x0db5, 0x0e15 }, /* Thai_totao  THAI CHARACTER TO TAO */
+    { 0x0db6, 0x0e16 }, /* Thai_thothung  THAI CHARACTER THO THUNG */
+    { 0x0db7, 0x0e17 }, /* Thai_thothahan  THAI CHARACTER THO THAHAN */
+    { 0x0db8, 0x0e18 }, /* Thai_thothong  THAI CHARACTER THO THONG */
+    { 0x0db9, 0x0e19 }, /* Thai_nonu  THAI CHARACTER NO NU */
+    { 0x0dba, 0x0e1a }, /* Thai_bobaimai  THAI CHARACTER BO BAIMAI */
+    { 0x0dbb, 0x0e1b }, /* Thai_popla  THAI CHARACTER PO PLA */
+    { 0x0dbc, 0x0e1c }, /* Thai_phophung  THAI CHARACTER PHO PHUNG */
+    { 0x0dbd, 0x0e1d }, /* Thai_fofa  THAI CHARACTER FO FA */
+    { 0x0dbe, 0x0e1e }, /* Thai_phophan  THAI CHARACTER PHO PHAN */
+    { 0x0dbf, 0x0e1f }, /* Thai_fofan  THAI CHARACTER FO FAN */
+    { 0x0dc0, 0x0e20 }, /* Thai_phosamphao  THAI CHARACTER PHO SAMPHAO */
+    { 0x0dc1, 0x0e21 }, /* Thai_moma  THAI CHARACTER MO MA */
+    { 0x0dc2, 0x0e22 }, /* Thai_yoyak  THAI CHARACTER YO YAK */
+    { 0x0dc3, 0x0e23 }, /* Thai_rorua  THAI CHARACTER RO RUA */
+    { 0x0dc4, 0x0e24 }, /* Thai_ru  THAI CHARACTER RU */
+    { 0x0dc5, 0x0e25 }, /* Thai_loling  THAI CHARACTER LO LING */
+    { 0x0dc6, 0x0e26 }, /* Thai_lu  THAI CHARACTER LU */
+    { 0x0dc7, 0x0e27 }, /* Thai_wowaen  THAI CHARACTER WO WAEN */
+    { 0x0dc8, 0x0e28 }, /* Thai_sosala  THAI CHARACTER SO SALA */
+    { 0x0dc9, 0x0e29 }, /* Thai_sorusi  THAI CHARACTER SO RUSI */
+    { 0x0dca, 0x0e2a }, /* Thai_sosua  THAI CHARACTER SO SUA */
+    { 0x0dcb, 0x0e2b }, /* Thai_hohip  THAI CHARACTER HO HIP */
+    { 0x0dcc, 0x0e2c }, /* Thai_lochula  THAI CHARACTER LO CHULA */
+    { 0x0dcd, 0x0e2d }, /* Thai_oang  THAI CHARACTER O ANG */
+    { 0x0dce, 0x0e2e }, /* Thai_honokhuk  THAI CHARACTER HO NOKHUK */
+    { 0x0dcf, 0x0e2f }, /* Thai_paiyannoi  THAI CHARACTER PAIYANNOI */
+    { 0x0dd0, 0x0e30 }, /* Thai_saraa  THAI CHARACTER SARA A */
+    { 0x0dd1, 0x0e31 }, /* Thai_maihanakat  THAI CHARACTER MAI HAN-AKAT */
+    { 0x0dd2, 0x0e32 }, /* Thai_saraaa  THAI CHARACTER SARA AA */
+    { 0x0dd3, 0x0e33 }, /* Thai_saraam  THAI CHARACTER SARA AM */
+    { 0x0dd4, 0x0e34 }, /* Thai_sarai  THAI CHARACTER SARA I */
+    { 0x0dd5, 0x0e35 }, /* Thai_saraii  THAI CHARACTER SARA II */
+    { 0x0dd6, 0x0e36 }, /* Thai_saraue  THAI CHARACTER SARA UE */
+    { 0x0dd7, 0x0e37 }, /* Thai_sarauee  THAI CHARACTER SARA UEE */
+    { 0x0dd8, 0x0e38 }, /* Thai_sarau  THAI CHARACTER SARA U */
+    { 0x0dd9, 0x0e39 }, /* Thai_sarauu  THAI CHARACTER SARA UU */
+    { 0x0dda, 0x0e3a }, /* Thai_phinthu  THAI CHARACTER PHINTHU */
+    { 0x0dde, 0x0e3e }, /* Thai_maihanakat_maitho  ??? */
+    { 0x0ddf, 0x0e3f }, /* Thai_baht  THAI CURRENCY SYMBOL BAHT */
+    { 0x0de0, 0x0e40 }, /* Thai_sarae  THAI CHARACTER SARA E */
+    { 0x0de1, 0x0e41 }, /* Thai_saraae  THAI CHARACTER SARA AE */
+    { 0x0de2, 0x0e42 }, /* Thai_sarao  THAI CHARACTER SARA O */
+    { 0x0de3, 0x0e43 }, /* Thai_saraaimaimuan  THAI CHARACTER SARA AI MAIMUAN */
+    { 0x0de4, 0x0e44 }, /* Thai_saraaimaimalai  THAI CHARACTER SARA AI MAIMALAI */
+    { 0x0de5, 0x0e45 }, /* Thai_lakkhangyao  THAI CHARACTER LAKKHANGYAO */
+    { 0x0de6, 0x0e46 }, /* Thai_maiyamok  THAI CHARACTER MAIYAMOK */
+    { 0x0de7, 0x0e47 }, /* Thai_maitaikhu  THAI CHARACTER MAITAIKHU */
+    { 0x0de8, 0x0e48 }, /* Thai_maiek  THAI CHARACTER MAI EK */
+    { 0x0de9, 0x0e49 }, /* Thai_maitho  THAI CHARACTER MAI THO */
+    { 0x0dea, 0x0e4a }, /* Thai_maitri  THAI CHARACTER MAI TRI */
+    { 0x0deb, 0x0e4b }, /* Thai_maichattawa  THAI CHARACTER MAI CHATTAWA */
+    { 0x0dec, 0x0e4c }, /* Thai_thanthakhat  THAI CHARACTER THANTHAKHAT */
+    { 0x0ded, 0x0e4d }, /* Thai_nikhahit  THAI CHARACTER NIKHAHIT */
+    { 0x0df0, 0x0e50 }, /* Thai_leksun  THAI DIGIT ZERO */
+    { 0x0df1, 0x0e51 }, /* Thai_leknung  THAI DIGIT ONE */
+    { 0x0df2, 0x0e52 }, /* Thai_leksong  THAI DIGIT TWO */
+    { 0x0df3, 0x0e53 }, /* Thai_leksam  THAI DIGIT THREE */
+    { 0x0df4, 0x0e54 }, /* Thai_leksi  THAI DIGIT FOUR */
+    { 0x0df5, 0x0e55 }, /* Thai_lekha  THAI DIGIT FIVE */
+    { 0x0df6, 0x0e56 }, /* Thai_lekhok  THAI DIGIT SIX */
+    { 0x0df7, 0x0e57 }, /* Thai_lekchet  THAI DIGIT SEVEN */
+    { 0x0df8, 0x0e58 }, /* Thai_lekpaet  THAI DIGIT EIGHT */
+    { 0x0df9, 0x0e59 }, /* Thai_lekkao  THAI DIGIT NINE */
+    { 0x0ea1, 0x3131 }, /* Hangul_Kiyeog  HANGUL LETTER KIYEOK */
+    { 0x0ea2, 0x3132 }, /* Hangul_SsangKiyeog  HANGUL LETTER SSANGKIYEOK */
+    { 0x0ea3, 0x3133 }, /* Hangul_KiyeogSios  HANGUL LETTER KIYEOK-SIOS */
+    { 0x0ea4, 0x3134 }, /* Hangul_Nieun  HANGUL LETTER NIEUN */
+    { 0x0ea5, 0x3135 }, /* Hangul_NieunJieuj  HANGUL LETTER NIEUN-CIEUC */
+    { 0x0ea6, 0x3136 }, /* Hangul_NieunHieuh  HANGUL LETTER NIEUN-HIEUH */
+    { 0x0ea7, 0x3137 }, /* Hangul_Dikeud  HANGUL LETTER TIKEUT */
+    { 0x0ea8, 0x3138 }, /* Hangul_SsangDikeud  HANGUL LETTER SSANGTIKEUT */
+    { 0x0ea9, 0x3139 }, /* Hangul_Rieul  HANGUL LETTER RIEUL */
+    { 0x0eaa, 0x313a }, /* Hangul_RieulKiyeog  HANGUL LETTER RIEUL-KIYEOK */
+    { 0x0eab, 0x313b }, /* Hangul_RieulMieum  HANGUL LETTER RIEUL-MIEUM */
+    { 0x0eac, 0x313c }, /* Hangul_RieulPieub  HANGUL LETTER RIEUL-PIEUP */
+    { 0x0ead, 0x313d }, /* Hangul_RieulSios  HANGUL LETTER RIEUL-SIOS */
+    { 0x0eae, 0x313e }, /* Hangul_RieulTieut  HANGUL LETTER RIEUL-THIEUTH */
+    { 0x0eaf, 0x313f }, /* Hangul_RieulPhieuf  HANGUL LETTER RIEUL-PHIEUPH */
+    { 0x0eb0, 0x3140 }, /* Hangul_RieulHieuh  HANGUL LETTER RIEUL-HIEUH */
+    { 0x0eb1, 0x3141 }, /* Hangul_Mieum  HANGUL LETTER MIEUM */
+    { 0x0eb2, 0x3142 }, /* Hangul_Pieub  HANGUL LETTER PIEUP */
+    { 0x0eb3, 0x3143 }, /* Hangul_SsangPieub  HANGUL LETTER SSANGPIEUP */
+    { 0x0eb4, 0x3144 }, /* Hangul_PieubSios  HANGUL LETTER PIEUP-SIOS */
+    { 0x0eb5, 0x3145 }, /* Hangul_Sios  HANGUL LETTER SIOS */
+    { 0x0eb6, 0x3146 }, /* Hangul_SsangSios  HANGUL LETTER SSANGSIOS */
+    { 0x0eb7, 0x3147 }, /* Hangul_Ieung  HANGUL LETTER IEUNG */
+    { 0x0eb8, 0x3148 }, /* Hangul_Jieuj  HANGUL LETTER CIEUC */
+    { 0x0eb9, 0x3149 }, /* Hangul_SsangJieuj  HANGUL LETTER SSANGCIEUC */
+    { 0x0eba, 0x314a }, /* Hangul_Cieuc  HANGUL LETTER CHIEUCH */
+    { 0x0ebb, 0x314b }, /* Hangul_Khieuq  HANGUL LETTER KHIEUKH */
+    { 0x0ebc, 0x314c }, /* Hangul_Tieut  HANGUL LETTER THIEUTH */
+    { 0x0ebd, 0x314d }, /* Hangul_Phieuf  HANGUL LETTER PHIEUPH */
+    { 0x0ebe, 0x314e }, /* Hangul_Hieuh  HANGUL LETTER HIEUH */
+    { 0x0ebf, 0x314f }, /* Hangul_A  HANGUL LETTER A */
+    { 0x0ec0, 0x3150 }, /* Hangul_AE  HANGUL LETTER AE */
+    { 0x0ec1, 0x3151 }, /* Hangul_YA  HANGUL LETTER YA */
+    { 0x0ec2, 0x3152 }, /* Hangul_YAE  HANGUL LETTER YAE */
+    { 0x0ec3, 0x3153 }, /* Hangul_EO  HANGUL LETTER EO */
+    { 0x0ec4, 0x3154 }, /* Hangul_E  HANGUL LETTER E */
+    { 0x0ec5, 0x3155 }, /* Hangul_YEO  HANGUL LETTER YEO */
+    { 0x0ec6, 0x3156 }, /* Hangul_YE  HANGUL LETTER YE */
+    { 0x0ec7, 0x3157 }, /* Hangul_O  HANGUL LETTER O */
+    { 0x0ec8, 0x3158 }, /* Hangul_WA  HANGUL LETTER WA */
+    { 0x0ec9, 0x3159 }, /* Hangul_WAE  HANGUL LETTER WAE */
+    { 0x0eca, 0x315a }, /* Hangul_OE  HANGUL LETTER OE */
+    { 0x0ecb, 0x315b }, /* Hangul_YO  HANGUL LETTER YO */
+    { 0x0ecc, 0x315c }, /* Hangul_U  HANGUL LETTER U */
+    { 0x0ecd, 0x315d }, /* Hangul_WEO  HANGUL LETTER WEO */
+    { 0x0ece, 0x315e }, /* Hangul_WE  HANGUL LETTER WE */
+    { 0x0ecf, 0x315f }, /* Hangul_WI  HANGUL LETTER WI */
+    { 0x0ed0, 0x3160 }, /* Hangul_YU  HANGUL LETTER YU */
+    { 0x0ed1, 0x3161 }, /* Hangul_EU  HANGUL LETTER EU */
+    { 0x0ed2, 0x3162 }, /* Hangul_YI  HANGUL LETTER YI */
+    { 0x0ed3, 0x3163 }, /* Hangul_I  HANGUL LETTER I */
+    { 0x0ed4, 0x11a8 }, /* Hangul_J_Kiyeog  HANGUL JONGSEONG KIYEOK */
+    { 0x0ed5, 0x11a9 }, /* Hangul_J_SsangKiyeog  HANGUL JONGSEONG SSANGKIYEOK */
+    { 0x0ed6, 0x11aa }, /* Hangul_J_KiyeogSios  HANGUL JONGSEONG KIYEOK-SIOS */
+    { 0x0ed7, 0x11ab }, /* Hangul_J_Nieun  HANGUL JONGSEONG NIEUN */
+    { 0x0ed8, 0x11ac }, /* Hangul_J_NieunJieuj  HANGUL JONGSEONG NIEUN-CIEUC */
+    { 0x0ed9, 0x11ad }, /* Hangul_J_NieunHieuh  HANGUL JONGSEONG NIEUN-HIEUH */
+    { 0x0eda, 0x11ae }, /* Hangul_J_Dikeud  HANGUL JONGSEONG TIKEUT */
+    { 0x0edb, 0x11af }, /* Hangul_J_Rieul  HANGUL JONGSEONG RIEUL */
+    { 0x0edc, 0x11b0 }, /* Hangul_J_RieulKiyeog  HANGUL JONGSEONG RIEUL-KIYEOK */
+    { 0x0edd, 0x11b1 }, /* Hangul_J_RieulMieum  HANGUL JONGSEONG RIEUL-MIEUM */
+    { 0x0ede, 0x11b2 }, /* Hangul_J_RieulPieub  HANGUL JONGSEONG RIEUL-PIEUP */
+    { 0x0edf, 0x11b3 }, /* Hangul_J_RieulSios  HANGUL JONGSEONG RIEUL-SIOS */
+    { 0x0ee0, 0x11b4 }, /* Hangul_J_RieulTieut  HANGUL JONGSEONG RIEUL-THIEUTH */
+    { 0x0ee1, 0x11b5 }, /* Hangul_J_RieulPhieuf  HANGUL JONGSEONG RIEUL-PHIEUPH */
+    { 0x0ee2, 0x11b6 }, /* Hangul_J_RieulHieuh  HANGUL JONGSEONG RIEUL-HIEUH */
+    { 0x0ee3, 0x11b7 }, /* Hangul_J_Mieum  HANGUL JONGSEONG MIEUM */
+    { 0x0ee4, 0x11b8 }, /* Hangul_J_Pieub  HANGUL JONGSEONG PIEUP */
+    { 0x0ee5, 0x11b9 }, /* Hangul_J_PieubSios  HANGUL JONGSEONG PIEUP-SIOS */
+    { 0x0ee6, 0x11ba }, /* Hangul_J_Sios  HANGUL JONGSEONG SIOS */
+    { 0x0ee7, 0x11bb }, /* Hangul_J_SsangSios  HANGUL JONGSEONG SSANGSIOS */
+    { 0x0ee8, 0x11bc }, /* Hangul_J_Ieung  HANGUL JONGSEONG IEUNG */
+    { 0x0ee9, 0x11bd }, /* Hangul_J_Jieuj  HANGUL JONGSEONG CIEUC */
+    { 0x0eea, 0x11be }, /* Hangul_J_Cieuc  HANGUL JONGSEONG CHIEUCH */
+    { 0x0eeb, 0x11bf }, /* Hangul_J_Khieuq  HANGUL JONGSEONG KHIEUKH */
+    { 0x0eec, 0x11c0 }, /* Hangul_J_Tieut  HANGUL JONGSEONG THIEUTH */
+    { 0x0eed, 0x11c1 }, /* Hangul_J_Phieuf  HANGUL JONGSEONG PHIEUPH */
+    { 0x0eee, 0x11c2 }, /* Hangul_J_Hieuh  HANGUL JONGSEONG HIEUH */
+    { 0x0eef, 0x316d }, /* Hangul_RieulYeorinHieuh  HANGUL LETTER RIEUL-YEORINHIEUH */
+    { 0x0ef0, 0x3171 }, /* Hangul_SunkyeongeumMieum  HANGUL LETTER KAPYEOUNMIEUM */
+    { 0x0ef1, 0x3178 }, /* Hangul_SunkyeongeumPieub  HANGUL LETTER KAPYEOUNPIEUP */
+    { 0x0ef2, 0x317f }, /* Hangul_PanSios  HANGUL LETTER PANSIOS */
+    /* 0x0ef3 Hangul_KkogjiDalrinIeung ? ??? */
+    { 0x0ef4, 0x3184 }, /* Hangul_SunkyeongeumPhieuf  HANGUL LETTER KAPYEOUNPHIEUPH */
+    { 0x0ef5, 0x3186 }, /* Hangul_YeorinHieuh  HANGUL LETTER YEORINHIEUH */
+    { 0x0ef6, 0x318d }, /* Hangul_AraeA  HANGUL LETTER ARAEA */
+    { 0x0ef7, 0x318e }, /* Hangul_AraeAE  HANGUL LETTER ARAEAE */
+    { 0x0ef8, 0x11eb }, /* Hangul_J_PanSios  HANGUL JONGSEONG PANSIOS */
+    /* 0x0ef9 Hangul_J_KkogjiDalrinIeung ? ??? */
+    { 0x0efa, 0x11f9 }, /* Hangul_J_YeorinHieuh  HANGUL JONGSEONG YEORINHIEUH */
+    { 0x0eff, 0x20a9 }, /* Korean_Won  WON SIGN */
+    { 0x13bc, 0x0152 }, /* OE  LATIN CAPITAL LIGATURE OE */
+    { 0x13bd, 0x0153 }, /* oe  LATIN SMALL LIGATURE OE */
+    { 0x13be, 0x0178 }, /* Ydiaeresis  LATIN CAPITAL LETTER Y WITH DIAERESIS */
+    { 0x20a0, 0x20a0 }, /* EcuSign  EURO-CURRENCY SIGN */
+    { 0x20a1, 0x20a1 }, /* ColonSign  COLON SIGN */
+    { 0x20a2, 0x20a2 }, /* CruzeiroSign  CRUZEIRO SIGN */
+    { 0x20a3, 0x20a3 }, /* FFrancSign  FRENCH FRANC SIGN */
+    { 0x20a4, 0x20a4 }, /* LiraSign  LIRA SIGN */
+    { 0x20a5, 0x20a5 }, /* MillSign  MILL SIGN */
+    { 0x20a6, 0x20a6 }, /* NairaSign  NAIRA SIGN */
+    { 0x20a7, 0x20a7 }, /* PesetaSign  PESETA SIGN */
+    { 0x20a8, 0x20a8 }, /* RupeeSign  RUPEE SIGN */
+    { 0x20a9, 0x20a9 }, /* WonSign  WON SIGN */
+    { 0x20aa, 0x20aa }, /* NewSheqelSign  NEW SHEQEL SIGN */
+    { 0x20ab, 0x20ab }, /* DongSign  DONG SIGN */
+    { 0x20ac, 0x20ac }, /* EuroSign  EURO SIGN */
+
+
+    /* Following items added to GTK, not in the xterm table */
+
+    /* A few ASCII control characters */
+
+    { 0xFF08 /* Backspace */, '\b' },
+    { 0xFF09 /* Tab */, '\t' },
+    { 0xFF0A /* Linefeed */, '\n' },
+    { 0xFF0B /* Vert. Tab */, '\v' },
+    { 0xFF0D /* Return */, '\r' },
+    { 0xFF1B /* Escape */, '\033' },
+
+    /* Numeric keypad */
+
+    { 0xFF80 /* Space */, ' ' },
+    { 0xFFAA /* Multiply */, '*' },
+    { 0xFFAB /* Add */, '+' },
+    { 0xFFAC /* Separator */, ',' },
+    { 0xFFAD /* Subtract */, '-' },
+    { 0xFFAE /* Decimal */, '.' },
+    { 0xFFAF /* Divide */, '/' },
+    { 0xFFB0 /* 0 */, '0' },
+    { 0xFFB1 /* 1 */, '1' },
+    { 0xFFB2 /* 2 */, '2' },
+    { 0xFFB3 /* 3 */, '3' },
+    { 0xFFB4 /* 4 */, '4' },
+    { 0xFFB5 /* 5 */, '5' },
+    { 0xFFB6 /* 6 */, '6' },
+    { 0xFFB7 /* 7 */, '7' },
+    { 0xFFB8 /* 8 */, '8' },
+    { 0xFFB9 /* 9 */, '9' },
+    { 0xFFBD /* Equal */, '=' },
+
+    /* End numeric keypad */
+
+    { 0xFFFF /* Delete */, '\177' }
+};
+
+static const struct _FcitxUnicodeToKeySym gdk_unicode_to_keysym_tab[] = {
+    { 0x0abd, 0x002e }, /* decimalpoint . FULL STOP */
+    { 0x0ba3, 0x003c }, /* leftcaret < LESS-THAN SIGN */
+    { 0x0ba6, 0x003e }, /* rightcaret > GREATER-THAN SIGN */
+    { 0x0bc6, 0x005f }, /* underbar _ LOW LINE */
+    { 0x0bc0, 0x00af }, /* overbar  MACRON */
+    { 0x03c0, 0x0100 }, /* Amacron  LATIN CAPITAL LETTER A WITH MACRON */
+    { 0x03e0, 0x0101 }, /* amacron  LATIN SMALL LETTER A WITH MACRON */
+    { 0x01c3, 0x0102 }, /* Abreve  LATIN CAPITAL LETTER A WITH BREVE */
+    { 0x01e3, 0x0103 }, /* abreve  LATIN SMALL LETTER A WITH BREVE */
+    { 0x01a1, 0x0104 }, /* Aogonek  LATIN CAPITAL LETTER A WITH OGONEK */
+    { 0x01b1, 0x0105 }, /* aogonek  LATIN SMALL LETTER A WITH OGONEK */
+    { 0x01c6, 0x0106 }, /* Cacute  LATIN CAPITAL LETTER C WITH ACUTE */
+    { 0x01e6, 0x0107 }, /* cacute  LATIN SMALL LETTER C WITH ACUTE */
+    { 0x02c6, 0x0108 }, /* Ccircumflex  LATIN CAPITAL LETTER C WITH CIRCUMFLEX */
+    { 0x02e6, 0x0109 }, /* ccircumflex  LATIN SMALL LETTER C WITH CIRCUMFLEX */
+    { 0x02c5, 0x010a }, /* Cabovedot  LATIN CAPITAL LETTER C WITH DOT ABOVE */
+    { 0x02e5, 0x010b }, /* cabovedot  LATIN SMALL LETTER C WITH DOT ABOVE */
+    { 0x01c8, 0x010c }, /* Ccaron  LATIN CAPITAL LETTER C WITH CARON */
+    { 0x01e8, 0x010d }, /* ccaron  LATIN SMALL LETTER C WITH CARON */
+    { 0x01cf, 0x010e }, /* Dcaron  LATIN CAPITAL LETTER D WITH CARON */
+    { 0x01ef, 0x010f }, /* dcaron  LATIN SMALL LETTER D WITH CARON */
+    { 0x01d0, 0x0110 }, /* Dstroke  LATIN CAPITAL LETTER D WITH STROKE */
+    { 0x01f0, 0x0111 }, /* dstroke  LATIN SMALL LETTER D WITH STROKE */
+    { 0x03aa, 0x0112 }, /* Emacron  LATIN CAPITAL LETTER E WITH MACRON */
+    { 0x03ba, 0x0113 }, /* emacron  LATIN SMALL LETTER E WITH MACRON */
+    { 0x03cc, 0x0116 }, /* Eabovedot  LATIN CAPITAL LETTER E WITH DOT ABOVE */
+    { 0x03ec, 0x0117 }, /* eabovedot  LATIN SMALL LETTER E WITH DOT ABOVE */
+    { 0x01ca, 0x0118 }, /* Eogonek  LATIN CAPITAL LETTER E WITH OGONEK */
+    { 0x01ea, 0x0119 }, /* eogonek  LATIN SMALL LETTER E WITH OGONEK */
+    { 0x01cc, 0x011a }, /* Ecaron  LATIN CAPITAL LETTER E WITH CARON */
+    { 0x01ec, 0x011b }, /* ecaron  LATIN SMALL LETTER E WITH CARON */
+    { 0x02d8, 0x011c }, /* Gcircumflex  LATIN CAPITAL LETTER G WITH CIRCUMFLEX */
+    { 0x02f8, 0x011d }, /* gcircumflex  LATIN SMALL LETTER G WITH CIRCUMFLEX */
+    { 0x02ab, 0x011e }, /* Gbreve  LATIN CAPITAL LETTER G WITH BREVE */
+    { 0x02bb, 0x011f }, /* gbreve  LATIN SMALL LETTER G WITH BREVE */
+    { 0x02d5, 0x0120 }, /* Gabovedot  LATIN CAPITAL LETTER G WITH DOT ABOVE */
+    { 0x02f5, 0x0121 }, /* gabovedot  LATIN SMALL LETTER G WITH DOT ABOVE */
+    { 0x03ab, 0x0122 }, /* Gcedilla  LATIN CAPITAL LETTER G WITH CEDILLA */
+    { 0x03bb, 0x0123 }, /* gcedilla  LATIN SMALL LETTER G WITH CEDILLA */
+    { 0x02a6, 0x0124 }, /* Hcircumflex  LATIN CAPITAL LETTER H WITH CIRCUMFLEX */
+    { 0x02b6, 0x0125 }, /* hcircumflex  LATIN SMALL LETTER H WITH CIRCUMFLEX */
+    { 0x02a1, 0x0126 }, /* Hstroke  LATIN CAPITAL LETTER H WITH STROKE */
+    { 0x02b1, 0x0127 }, /* hstroke  LATIN SMALL LETTER H WITH STROKE */
+    { 0x03a5, 0x0128 }, /* Itilde  LATIN CAPITAL LETTER I WITH TILDE */
+    { 0x03b5, 0x0129 }, /* itilde  LATIN SMALL LETTER I WITH TILDE */
+    { 0x03cf, 0x012a }, /* Imacron  LATIN CAPITAL LETTER I WITH MACRON */
+    { 0x03ef, 0x012b }, /* imacron  LATIN SMALL LETTER I WITH MACRON */
+    { 0x03c7, 0x012e }, /* Iogonek  LATIN CAPITAL LETTER I WITH OGONEK */
+    { 0x03e7, 0x012f }, /* iogonek  LATIN SMALL LETTER I WITH OGONEK */
+    { 0x02a9, 0x0130 }, /* Iabovedot  LATIN CAPITAL LETTER I WITH DOT ABOVE */
+    { 0x02b9, 0x0131 }, /* idotless  LATIN SMALL LETTER DOTLESS I */
+    { 0x02ac, 0x0134 }, /* Jcircumflex  LATIN CAPITAL LETTER J WITH CIRCUMFLEX */
+    { 0x02bc, 0x0135 }, /* jcircumflex  LATIN SMALL LETTER J WITH CIRCUMFLEX */
+    { 0x03d3, 0x0136 }, /* Kcedilla  LATIN CAPITAL LETTER K WITH CEDILLA */
+    { 0x03f3, 0x0137 }, /* kcedilla  LATIN SMALL LETTER K WITH CEDILLA */
+    { 0x03a2, 0x0138 }, /* kra  LATIN SMALL LETTER KRA */
+    { 0x01c5, 0x0139 }, /* Lacute  LATIN CAPITAL LETTER L WITH ACUTE */
+    { 0x01e5, 0x013a }, /* lacute  LATIN SMALL LETTER L WITH ACUTE */
+    { 0x03a6, 0x013b }, /* Lcedilla  LATIN CAPITAL LETTER L WITH CEDILLA */
+    { 0x03b6, 0x013c }, /* lcedilla  LATIN SMALL LETTER L WITH CEDILLA */
+    { 0x01a5, 0x013d }, /* Lcaron  LATIN CAPITAL LETTER L WITH CARON */
+    { 0x01b5, 0x013e }, /* lcaron  LATIN SMALL LETTER L WITH CARON */
+    { 0x01a3, 0x0141 }, /* Lstroke  LATIN CAPITAL LETTER L WITH STROKE */
+    { 0x01b3, 0x0142 }, /* lstroke  LATIN SMALL LETTER L WITH STROKE */
+    { 0x01d1, 0x0143 }, /* Nacute  LATIN CAPITAL LETTER N WITH ACUTE */
+    { 0x01f1, 0x0144 }, /* nacute  LATIN SMALL LETTER N WITH ACUTE */
+    { 0x03d1, 0x0145 }, /* Ncedilla  LATIN CAPITAL LETTER N WITH CEDILLA */
+    { 0x03f1, 0x0146 }, /* ncedilla  LATIN SMALL LETTER N WITH CEDILLA */
+    { 0x01d2, 0x0147 }, /* Ncaron  LATIN CAPITAL LETTER N WITH CARON */
+    { 0x01f2, 0x0148 }, /* ncaron  LATIN SMALL LETTER N WITH CARON */
+    { 0x03bd, 0x014a }, /* ENG  LATIN CAPITAL LETTER ENG */
+    { 0x03bf, 0x014b }, /* eng  LATIN SMALL LETTER ENG */
+    { 0x03d2, 0x014c }, /* Omacron  LATIN CAPITAL LETTER O WITH MACRON */
+    { 0x03f2, 0x014d }, /* omacron  LATIN SMALL LETTER O WITH MACRON */
+    { 0x01d5, 0x0150 }, /* Odoubleacute  LATIN CAPITAL LETTER O WITH DOUBLE ACUTE */
+    { 0x01f5, 0x0151 }, /* odoubleacute  LATIN SMALL LETTER O WITH DOUBLE ACUTE */
+    { 0x13bc, 0x0152 }, /* OE  LATIN CAPITAL LIGATURE OE */
+    { 0x13bd, 0x0153 }, /* oe  LATIN SMALL LIGATURE OE */
+    { 0x01c0, 0x0154 }, /* Racute  LATIN CAPITAL LETTER R WITH ACUTE */
+    { 0x01e0, 0x0155 }, /* racute  LATIN SMALL LETTER R WITH ACUTE */
+    { 0x03a3, 0x0156 }, /* Rcedilla  LATIN CAPITAL LETTER R WITH CEDILLA */
+    { 0x03b3, 0x0157 }, /* rcedilla  LATIN SMALL LETTER R WITH CEDILLA */
+    { 0x01d8, 0x0158 }, /* Rcaron  LATIN CAPITAL LETTER R WITH CARON */
+    { 0x01f8, 0x0159 }, /* rcaron  LATIN SMALL LETTER R WITH CARON */
+    { 0x01a6, 0x015a }, /* Sacute  LATIN CAPITAL LETTER S WITH ACUTE */
+    { 0x01b6, 0x015b }, /* sacute  LATIN SMALL LETTER S WITH ACUTE */
+    { 0x02de, 0x015c }, /* Scircumflex  LATIN CAPITAL LETTER S WITH CIRCUMFLEX */
+    { 0x02fe, 0x015d }, /* scircumflex  LATIN SMALL LETTER S WITH CIRCUMFLEX */
+    { 0x01aa, 0x015e }, /* Scedilla  LATIN CAPITAL LETTER S WITH CEDILLA */
+    { 0x01ba, 0x015f }, /* scedilla  LATIN SMALL LETTER S WITH CEDILLA */
+    { 0x01a9, 0x0160 }, /* Scaron  LATIN CAPITAL LETTER S WITH CARON */
+    { 0x01b9, 0x0161 }, /* scaron  LATIN SMALL LETTER S WITH CARON */
+    { 0x01de, 0x0162 }, /* Tcedilla  LATIN CAPITAL LETTER T WITH CEDILLA */
+    { 0x01fe, 0x0163 }, /* tcedilla  LATIN SMALL LETTER T WITH CEDILLA */
+    { 0x01ab, 0x0164 }, /* Tcaron  LATIN CAPITAL LETTER T WITH CARON */
+    { 0x01bb, 0x0165 }, /* tcaron  LATIN SMALL LETTER T WITH CARON */
+    { 0x03ac, 0x0166 }, /* Tslash  LATIN CAPITAL LETTER T WITH STROKE */
+    { 0x03bc, 0x0167 }, /* tslash  LATIN SMALL LETTER T WITH STROKE */
+    { 0x03dd, 0x0168 }, /* Utilde  LATIN CAPITAL LETTER U WITH TILDE */
+    { 0x03fd, 0x0169 }, /* utilde  LATIN SMALL LETTER U WITH TILDE */
+    { 0x03de, 0x016a }, /* Umacron  LATIN CAPITAL LETTER U WITH MACRON */
+    { 0x03fe, 0x016b }, /* umacron  LATIN SMALL LETTER U WITH MACRON */
+    { 0x02dd, 0x016c }, /* Ubreve  LATIN CAPITAL LETTER U WITH BREVE */
+    { 0x02fd, 0x016d }, /* ubreve  LATIN SMALL LETTER U WITH BREVE */
+    { 0x01d9, 0x016e }, /* Uring  LATIN CAPITAL LETTER U WITH RING ABOVE */
+    { 0x01f9, 0x016f }, /* uring  LATIN SMALL LETTER U WITH RING ABOVE */
+    { 0x01db, 0x0170 }, /* Udoubleacute  LATIN CAPITAL LETTER U WITH DOUBLE ACUTE */
+    { 0x01fb, 0x0171 }, /* udoubleacute  LATIN SMALL LETTER U WITH DOUBLE ACUTE */
+    { 0x03d9, 0x0172 }, /* Uogonek  LATIN CAPITAL LETTER U WITH OGONEK */
+    { 0x03f9, 0x0173 }, /* uogonek  LATIN SMALL LETTER U WITH OGONEK */
+    { 0x13be, 0x0178 }, /* Ydiaeresis  LATIN CAPITAL LETTER Y WITH DIAERESIS */
+    { 0x01ac, 0x0179 }, /* Zacute  LATIN CAPITAL LETTER Z WITH ACUTE */
+    { 0x01bc, 0x017a }, /* zacute  LATIN SMALL LETTER Z WITH ACUTE */
+    { 0x01af, 0x017b }, /* Zabovedot  LATIN CAPITAL LETTER Z WITH DOT ABOVE */
+    { 0x01bf, 0x017c }, /* zabovedot  LATIN SMALL LETTER Z WITH DOT ABOVE */
+    { 0x01ae, 0x017d }, /* Zcaron  LATIN CAPITAL LETTER Z WITH CARON */
+    { 0x01be, 0x017e }, /* zcaron  LATIN SMALL LETTER Z WITH CARON */
+    { 0x08f6, 0x0192 }, /* function  LATIN SMALL LETTER F WITH HOOK */
+    { 0x01b7, 0x02c7 }, /* caron  CARON */
+    { 0x01a2, 0x02d8 }, /* breve  BREVE */
+    { 0x01ff, 0x02d9 }, /* abovedot  DOT ABOVE */
+    { 0x01b2, 0x02db }, /* ogonek  OGONEK */
+    { 0x01bd, 0x02dd }, /* doubleacute  DOUBLE ACUTE ACCENT */
+    { 0x07ae, 0x0385 }, /* Greek_accentdieresis  GREEK DIALYTIKA TONOS */
+    { 0x07a1, 0x0386 }, /* Greek_ALPHAaccent  GREEK CAPITAL LETTER ALPHA WITH TONOS */
+    { 0x07a2, 0x0388 }, /* Greek_EPSILONaccent  GREEK CAPITAL LETTER EPSILON WITH TONOS */
+    { 0x07a3, 0x0389 }, /* Greek_ETAaccent  GREEK CAPITAL LETTER ETA WITH TONOS */
+    { 0x07a4, 0x038a }, /* Greek_IOTAaccent  GREEK CAPITAL LETTER IOTA WITH TONOS */
+    { 0x07a7, 0x038c }, /* Greek_OMICRONaccent  GREEK CAPITAL LETTER OMICRON WITH TONOS */
+    { 0x07a8, 0x038e }, /* Greek_UPSILONaccent  GREEK CAPITAL LETTER UPSILON WITH TONOS */
+    { 0x07ab, 0x038f }, /* Greek_OMEGAaccent  GREEK CAPITAL LETTER OMEGA WITH TONOS */
+    { 0x07b6, 0x0390 }, /* Greek_iotaaccentdieresis  GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */
+    { 0x07c1, 0x0391 }, /* Greek_ALPHA  GREEK CAPITAL LETTER ALPHA */
+    { 0x07c2, 0x0392 }, /* Greek_BETA  GREEK CAPITAL LETTER BETA */
+    { 0x07c3, 0x0393 }, /* Greek_GAMMA  GREEK CAPITAL LETTER GAMMA */
+    { 0x07c4, 0x0394 }, /* Greek_DELTA  GREEK CAPITAL LETTER DELTA */
+    { 0x07c5, 0x0395 }, /* Greek_EPSILON  GREEK CAPITAL LETTER EPSILON */
+    { 0x07c6, 0x0396 }, /* Greek_ZETA  GREEK CAPITAL LETTER ZETA */
+    { 0x07c7, 0x0397 }, /* Greek_ETA  GREEK CAPITAL LETTER ETA */
+    { 0x07c8, 0x0398 }, /* Greek_THETA  GREEK CAPITAL LETTER THETA */
+    { 0x07c9, 0x0399 }, /* Greek_IOTA  GREEK CAPITAL LETTER IOTA */
+    { 0x07ca, 0x039a }, /* Greek_KAPPA  GREEK CAPITAL LETTER KAPPA */
+    { 0x07cb, 0x039b }, /* Greek_LAMBDA  GREEK CAPITAL LETTER LAMDA */
+    { 0x07cc, 0x039c }, /* Greek_MU  GREEK CAPITAL LETTER MU */
+    { 0x07cd, 0x039d }, /* Greek_NU  GREEK CAPITAL LETTER NU */
+    { 0x07ce, 0x039e }, /* Greek_XI  GREEK CAPITAL LETTER XI */
+    { 0x07cf, 0x039f }, /* Greek_OMICRON  GREEK CAPITAL LETTER OMICRON */
+    { 0x07d0, 0x03a0 }, /* Greek_PI  GREEK CAPITAL LETTER PI */
+    { 0x07d1, 0x03a1 }, /* Greek_RHO  GREEK CAPITAL LETTER RHO */
+    { 0x07d2, 0x03a3 }, /* Greek_SIGMA  GREEK CAPITAL LETTER SIGMA */
+    { 0x07d4, 0x03a4 }, /* Greek_TAU  GREEK CAPITAL LETTER TAU */
+    { 0x07d5, 0x03a5 }, /* Greek_UPSILON  GREEK CAPITAL LETTER UPSILON */
+    { 0x07d6, 0x03a6 }, /* Greek_PHI  GREEK CAPITAL LETTER PHI */
+    { 0x07d7, 0x03a7 }, /* Greek_CHI  GREEK CAPITAL LETTER CHI */
+    { 0x07d8, 0x03a8 }, /* Greek_PSI  GREEK CAPITAL LETTER PSI */
+    { 0x07d9, 0x03a9 }, /* Greek_OMEGA  GREEK CAPITAL LETTER OMEGA */
+    { 0x07a5, 0x03aa }, /* Greek_IOTAdieresis  GREEK CAPITAL LETTER IOTA WITH DIALYTIKA */
+    { 0x07a9, 0x03ab }, /* Greek_UPSILONdieresis  GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA */
+    { 0x07b1, 0x03ac }, /* Greek_alphaaccent  GREEK SMALL LETTER ALPHA WITH TONOS */
+    { 0x07b2, 0x03ad }, /* Greek_epsilonaccent  GREEK SMALL LETTER EPSILON WITH TONOS */
+    { 0x07b3, 0x03ae }, /* Greek_etaaccent  GREEK SMALL LETTER ETA WITH TONOS */
+    { 0x07b4, 0x03af }, /* Greek_iotaaccent  GREEK SMALL LETTER IOTA WITH TONOS */
+    { 0x07ba, 0x03b0 }, /* Greek_upsilonaccentdieresis  GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS */
+    { 0x07e1, 0x03b1 }, /* Greek_alpha  GREEK SMALL LETTER ALPHA */
+    { 0x07e2, 0x03b2 }, /* Greek_beta  GREEK SMALL LETTER BETA */
+    { 0x07e3, 0x03b3 }, /* Greek_gamma  GREEK SMALL LETTER GAMMA */
+    { 0x07e4, 0x03b4 }, /* Greek_delta  GREEK SMALL LETTER DELTA */
+    { 0x07e5, 0x03b5 }, /* Greek_epsilon  GREEK SMALL LETTER EPSILON */
+    { 0x07e6, 0x03b6 }, /* Greek_zeta  GREEK SMALL LETTER ZETA */
+    { 0x07e7, 0x03b7 }, /* Greek_eta  GREEK SMALL LETTER ETA */
+    { 0x07e8, 0x03b8 }, /* Greek_theta  GREEK SMALL LETTER THETA */
+    { 0x07e9, 0x03b9 }, /* Greek_iota  GREEK SMALL LETTER IOTA */
+    { 0x07ea, 0x03ba }, /* Greek_kappa  GREEK SMALL LETTER KAPPA */
+    { 0x07eb, 0x03bb }, /* Greek_lambda  GREEK SMALL LETTER LAMDA */
+    { 0x07ec, 0x03bc }, /* Greek_mu  GREEK SMALL LETTER MU */
+    { 0x07ed, 0x03bd }, /* Greek_nu  GREEK SMALL LETTER NU */
+    { 0x07ee, 0x03be }, /* Greek_xi  GREEK SMALL LETTER XI */
+    { 0x07ef, 0x03bf }, /* Greek_omicron  GREEK SMALL LETTER OMICRON */
+    { 0x07f0, 0x03c0 }, /* Greek_pi  GREEK SMALL LETTER PI */
+    { 0x07f1, 0x03c1 }, /* Greek_rho  GREEK SMALL LETTER RHO */
+    { 0x07f3, 0x03c2 }, /* Greek_finalsmallsigma  GREEK SMALL LETTER FINAL SIGMA */
+    { 0x07f2, 0x03c3 }, /* Greek_sigma  GREEK SMALL LETTER SIGMA */
+    { 0x07f4, 0x03c4 }, /* Greek_tau  GREEK SMALL LETTER TAU */
+    { 0x07f5, 0x03c5 }, /* Greek_upsilon  GREEK SMALL LETTER UPSILON */
+    { 0x07f6, 0x03c6 }, /* Greek_phi  GREEK SMALL LETTER PHI */
+    { 0x07f7, 0x03c7 }, /* Greek_chi  GREEK SMALL LETTER CHI */
+    { 0x07f8, 0x03c8 }, /* Greek_psi  GREEK SMALL LETTER PSI */
+    { 0x07f9, 0x03c9 }, /* Greek_omega  GREEK SMALL LETTER OMEGA */
+    { 0x07b5, 0x03ca }, /* Greek_iotadieresis  GREEK SMALL LETTER IOTA WITH DIALYTIKA */
+    { 0x07b9, 0x03cb }, /* Greek_upsilondieresis  GREEK SMALL LETTER UPSILON WITH DIALYTIKA */
+    { 0x07b7, 0x03cc }, /* Greek_omicronaccent  GREEK SMALL LETTER OMICRON WITH TONOS */
+    { 0x07b8, 0x03cd }, /* Greek_upsilonaccent  GREEK SMALL LETTER UPSILON WITH TONOS */
+    { 0x07bb, 0x03ce }, /* Greek_omegaaccent  GREEK SMALL LETTER OMEGA WITH TONOS */
+    { 0x06b3, 0x0401 }, /* Cyrillic_IO  CYRILLIC CAPITAL LETTER IO */
+    { 0x06b1, 0x0402 }, /* Serbian_DJE  CYRILLIC CAPITAL LETTER DJE */
+    { 0x06b2, 0x0403 }, /* Macedonia_GJE  CYRILLIC CAPITAL LETTER GJE */
+    { 0x06b4, 0x0404 }, /* Ukrainian_IE  CYRILLIC CAPITAL LETTER UKRAINIAN IE */
+    { 0x06b5, 0x0405 }, /* Macedonia_DSE  CYRILLIC CAPITAL LETTER DZE */
+    { 0x06b6, 0x0406 }, /* Ukrainian_I  CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I */
+    { 0x06b7, 0x0407 }, /* Ukrainian_YI  CYRILLIC CAPITAL LETTER YI */
+    { 0x06b8, 0x0408 }, /* Cyrillic_JE  CYRILLIC CAPITAL LETTER JE */
+    { 0x06b9, 0x0409 }, /* Cyrillic_LJE  CYRILLIC CAPITAL LETTER LJE */
+    { 0x06ba, 0x040a }, /* Cyrillic_NJE  CYRILLIC CAPITAL LETTER NJE */
+    { 0x06bb, 0x040b }, /* Serbian_TSHE  CYRILLIC CAPITAL LETTER TSHE */
+    { 0x06bc, 0x040c }, /* Macedonia_KJE  CYRILLIC CAPITAL LETTER KJE */
+    { 0x06be, 0x040e }, /* Byelorussian_SHORTU  CYRILLIC CAPITAL LETTER SHORT U */
+    { 0x06bf, 0x040f }, /* Cyrillic_DZHE  CYRILLIC CAPITAL LETTER DZHE */
+    { 0x06e1, 0x0410 }, /* Cyrillic_A  CYRILLIC CAPITAL LETTER A */
+    { 0x06e2, 0x0411 }, /* Cyrillic_BE  CYRILLIC CAPITAL LETTER BE */
+    { 0x06f7, 0x0412 }, /* Cyrillic_VE  CYRILLIC CAPITAL LETTER VE */
+    { 0x06e7, 0x0413 }, /* Cyrillic_GHE  CYRILLIC CAPITAL LETTER GHE */
+    { 0x06e4, 0x0414 }, /* Cyrillic_DE  CYRILLIC CAPITAL LETTER DE */
+    { 0x06e5, 0x0415 }, /* Cyrillic_IE  CYRILLIC CAPITAL LETTER IE */
+    { 0x06f6, 0x0416 }, /* Cyrillic_ZHE  CYRILLIC CAPITAL LETTER ZHE */
+    { 0x06fa, 0x0417 }, /* Cyrillic_ZE  CYRILLIC CAPITAL LETTER ZE */
+    { 0x06e9, 0x0418 }, /* Cyrillic_I  CYRILLIC CAPITAL LETTER I */
+    { 0x06ea, 0x0419 }, /* Cyrillic_SHORTI  CYRILLIC CAPITAL LETTER SHORT I */
+    { 0x06eb, 0x041a }, /* Cyrillic_KA  CYRILLIC CAPITAL LETTER KA */
+    { 0x06ec, 0x041b }, /* Cyrillic_EL  CYRILLIC CAPITAL LETTER EL */
+    { 0x06ed, 0x041c }, /* Cyrillic_EM  CYRILLIC CAPITAL LETTER EM */
+    { 0x06ee, 0x041d }, /* Cyrillic_EN  CYRILLIC CAPITAL LETTER EN */
+    { 0x06ef, 0x041e }, /* Cyrillic_O  CYRILLIC CAPITAL LETTER O */
+    { 0x06f0, 0x041f }, /* Cyrillic_PE  CYRILLIC CAPITAL LETTER PE */
+    { 0x06f2, 0x0420 }, /* Cyrillic_ER  CYRILLIC CAPITAL LETTER ER */
+    { 0x06f3, 0x0421 }, /* Cyrillic_ES  CYRILLIC CAPITAL LETTER ES */
+    { 0x06f4, 0x0422 }, /* Cyrillic_TE  CYRILLIC CAPITAL LETTER TE */
+    { 0x06f5, 0x0423 }, /* Cyrillic_U  CYRILLIC CAPITAL LETTER U */
+    { 0x06e6, 0x0424 }, /* Cyrillic_EF  CYRILLIC CAPITAL LETTER EF */
+    { 0x06e8, 0x0425 }, /* Cyrillic_HA  CYRILLIC CAPITAL LETTER HA */
+    { 0x06e3, 0x0426 }, /* Cyrillic_TSE  CYRILLIC CAPITAL LETTER TSE */
+    { 0x06fe, 0x0427 }, /* Cyrillic_CHE  CYRILLIC CAPITAL LETTER CHE */
+    { 0x06fb, 0x0428 }, /* Cyrillic_SHA  CYRILLIC CAPITAL LETTER SHA */
+    { 0x06fd, 0x0429 }, /* Cyrillic_SHCHA  CYRILLIC CAPITAL LETTER SHCHA */
+    { 0x06ff, 0x042a }, /* Cyrillic_HARDSIGN  CYRILLIC CAPITAL LETTER HARD SIGN */
+    { 0x06f9, 0x042b }, /* Cyrillic_YERU  CYRILLIC CAPITAL LETTER YERU */
+    { 0x06f8, 0x042c }, /* Cyrillic_SOFTSIGN  CYRILLIC CAPITAL LETTER SOFT SIGN */
+    { 0x06fc, 0x042d }, /* Cyrillic_E  CYRILLIC CAPITAL LETTER E */
+    { 0x06e0, 0x042e }, /* Cyrillic_YU  CYRILLIC CAPITAL LETTER YU */
+    { 0x06f1, 0x042f }, /* Cyrillic_YA  CYRILLIC CAPITAL LETTER YA */
+    { 0x06c1, 0x0430 }, /* Cyrillic_a  CYRILLIC SMALL LETTER A */
+    { 0x06c2, 0x0431 }, /* Cyrillic_be  CYRILLIC SMALL LETTER BE */
+    { 0x06d7, 0x0432 }, /* Cyrillic_ve  CYRILLIC SMALL LETTER VE */
+    { 0x06c7, 0x0433 }, /* Cyrillic_ghe  CYRILLIC SMALL LETTER GHE */
+    { 0x06c4, 0x0434 }, /* Cyrillic_de  CYRILLIC SMALL LETTER DE */
+    { 0x06c5, 0x0435 }, /* Cyrillic_ie  CYRILLIC SMALL LETTER IE */
+    { 0x06d6, 0x0436 }, /* Cyrillic_zhe  CYRILLIC SMALL LETTER ZHE */
+    { 0x06da, 0x0437 }, /* Cyrillic_ze  CYRILLIC SMALL LETTER ZE */
+    { 0x06c9, 0x0438 }, /* Cyrillic_i  CYRILLIC SMALL LETTER I */
+    { 0x06ca, 0x0439 }, /* Cyrillic_shorti  CYRILLIC SMALL LETTER SHORT I */
+    { 0x06cb, 0x043a }, /* Cyrillic_ka  CYRILLIC SMALL LETTER KA */
+    { 0x06cc, 0x043b }, /* Cyrillic_el  CYRILLIC SMALL LETTER EL */
+    { 0x06cd, 0x043c }, /* Cyrillic_em  CYRILLIC SMALL LETTER EM */
+    { 0x06ce, 0x043d }, /* Cyrillic_en  CYRILLIC SMALL LETTER EN */
+    { 0x06cf, 0x043e }, /* Cyrillic_o  CYRILLIC SMALL LETTER O */
+    { 0x06d0, 0x043f }, /* Cyrillic_pe  CYRILLIC SMALL LETTER PE */
+    { 0x06d2, 0x0440 }, /* Cyrillic_er  CYRILLIC SMALL LETTER ER */
+    { 0x06d3, 0x0441 }, /* Cyrillic_es  CYRILLIC SMALL LETTER ES */
+    { 0x06d4, 0x0442 }, /* Cyrillic_te  CYRILLIC SMALL LETTER TE */
+    { 0x06d5, 0x0443 }, /* Cyrillic_u  CYRILLIC SMALL LETTER U */
+    { 0x06c6, 0x0444 }, /* Cyrillic_ef  CYRILLIC SMALL LETTER EF */
+    { 0x06c8, 0x0445 }, /* Cyrillic_ha  CYRILLIC SMALL LETTER HA */
+    { 0x06c3, 0x0446 }, /* Cyrillic_tse  CYRILLIC SMALL LETTER TSE */
+    { 0x06de, 0x0447 }, /* Cyrillic_che  CYRILLIC SMALL LETTER CHE */
+    { 0x06db, 0x0448 }, /* Cyrillic_sha  CYRILLIC SMALL LETTER SHA */
+    { 0x06dd, 0x0449 }, /* Cyrillic_shcha  CYRILLIC SMALL LETTER SHCHA */
+    { 0x06df, 0x044a }, /* Cyrillic_hardsign  CYRILLIC SMALL LETTER HARD SIGN */
+    { 0x06d9, 0x044b }, /* Cyrillic_yeru  CYRILLIC SMALL LETTER YERU */
+    { 0x06d8, 0x044c }, /* Cyrillic_softsign  CYRILLIC SMALL LETTER SOFT SIGN */
+    { 0x06dc, 0x044d }, /* Cyrillic_e  CYRILLIC SMALL LETTER E */
+    { 0x06c0, 0x044e }, /* Cyrillic_yu  CYRILLIC SMALL LETTER YU */
+    { 0x06d1, 0x044f }, /* Cyrillic_ya  CYRILLIC SMALL LETTER YA */
+    { 0x06a3, 0x0451 }, /* Cyrillic_io  CYRILLIC SMALL LETTER IO */
+    { 0x06a1, 0x0452 }, /* Serbian_dje  CYRILLIC SMALL LETTER DJE */
+    { 0x06a2, 0x0453 }, /* Macedonia_gje  CYRILLIC SMALL LETTER GJE */
+    { 0x06a4, 0x0454 }, /* Ukrainian_ie  CYRILLIC SMALL LETTER UKRAINIAN IE */
+    { 0x06a5, 0x0455 }, /* Macedonia_dse  CYRILLIC SMALL LETTER DZE */
+    { 0x06a6, 0x0456 }, /* Ukrainian_i  CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I */
+    { 0x06a7, 0x0457 }, /* Ukrainian_yi  CYRILLIC SMALL LETTER YI */
+    { 0x06a8, 0x0458 }, /* Cyrillic_je  CYRILLIC SMALL LETTER JE */
+    { 0x06a9, 0x0459 }, /* Cyrillic_lje  CYRILLIC SMALL LETTER LJE */
+    { 0x06aa, 0x045a }, /* Cyrillic_nje  CYRILLIC SMALL LETTER NJE */
+    { 0x06ab, 0x045b }, /* Serbian_tshe  CYRILLIC SMALL LETTER TSHE */
+    { 0x06ac, 0x045c }, /* Macedonia_kje  CYRILLIC SMALL LETTER KJE */
+    { 0x06ae, 0x045e }, /* Byelorussian_shortu  CYRILLIC SMALL LETTER SHORT U */
+    { 0x06af, 0x045f }, /* Cyrillic_dzhe  CYRILLIC SMALL LETTER DZHE */
+    { 0x0ce0, 0x05d0 }, /* hebrew_aleph  HEBREW LETTER ALEF */
+    { 0x0ce1, 0x05d1 }, /* hebrew_bet  HEBREW LETTER BET */
+    { 0x0ce2, 0x05d2 }, /* hebrew_gimel  HEBREW LETTER GIMEL */
+    { 0x0ce3, 0x05d3 }, /* hebrew_dalet  HEBREW LETTER DALET */
+    { 0x0ce4, 0x05d4 }, /* hebrew_he  HEBREW LETTER HE */
+    { 0x0ce5, 0x05d5 }, /* hebrew_waw  HEBREW LETTER VAV */
+    { 0x0ce6, 0x05d6 }, /* hebrew_zain  HEBREW LETTER ZAYIN */
+    { 0x0ce7, 0x05d7 }, /* hebrew_chet  HEBREW LETTER HET */
+    { 0x0ce8, 0x05d8 }, /* hebrew_tet  HEBREW LETTER TET */
+    { 0x0ce9, 0x05d9 }, /* hebrew_yod  HEBREW LETTER YOD */
+    { 0x0cea, 0x05da }, /* hebrew_finalkaph  HEBREW LETTER FINAL KAF */
+    { 0x0ceb, 0x05db }, /* hebrew_kaph  HEBREW LETTER KAF */
+    { 0x0cec, 0x05dc }, /* hebrew_lamed  HEBREW LETTER LAMED */
+    { 0x0ced, 0x05dd }, /* hebrew_finalmem  HEBREW LETTER FINAL MEM */
+    { 0x0cee, 0x05de }, /* hebrew_mem  HEBREW LETTER MEM */
+    { 0x0cef, 0x05df }, /* hebrew_finalnun  HEBREW LETTER FINAL NUN */
+    { 0x0cf0, 0x05e0 }, /* hebrew_nun  HEBREW LETTER NUN */
+    { 0x0cf1, 0x05e1 }, /* hebrew_samech  HEBREW LETTER SAMEKH */
+    { 0x0cf2, 0x05e2 }, /* hebrew_ayin  HEBREW LETTER AYIN */
+    { 0x0cf3, 0x05e3 }, /* hebrew_finalpe  HEBREW LETTER FINAL PE */
+    { 0x0cf4, 0x05e4 }, /* hebrew_pe  HEBREW LETTER PE */
+    { 0x0cf5, 0x05e5 }, /* hebrew_finalzade  HEBREW LETTER FINAL TSADI */
+    { 0x0cf6, 0x05e6 }, /* hebrew_zade  HEBREW LETTER TSADI */
+    { 0x0cf7, 0x05e7 }, /* hebrew_qoph  HEBREW LETTER QOF */
+    { 0x0cf8, 0x05e8 }, /* hebrew_resh  HEBREW LETTER RESH */
+    { 0x0cf9, 0x05e9 }, /* hebrew_shin  HEBREW LETTER SHIN */
+    { 0x0cfa, 0x05ea }, /* hebrew_taw  HEBREW LETTER TAV */
+    { 0x05ac, 0x060c }, /* Arabic_comma  ARABIC COMMA */
+    { 0x05bb, 0x061b }, /* Arabic_semicolon  ARABIC SEMICOLON */
+    { 0x05bf, 0x061f }, /* Arabic_question_mark  ARABIC QUESTION MARK */
+    { 0x05c1, 0x0621 }, /* Arabic_hamza  ARABIC LETTER HAMZA */
+    { 0x05c2, 0x0622 }, /* Arabic_maddaonalef  ARABIC LETTER ALEF WITH MADDA ABOVE */
+    { 0x05c3, 0x0623 }, /* Arabic_hamzaonalef  ARABIC LETTER ALEF WITH HAMZA ABOVE */
+    { 0x05c4, 0x0624 }, /* Arabic_hamzaonwaw  ARABIC LETTER WAW WITH HAMZA ABOVE */
+    { 0x05c5, 0x0625 }, /* Arabic_hamzaunderalef  ARABIC LETTER ALEF WITH HAMZA BELOW */
+    { 0x05c6, 0x0626 }, /* Arabic_hamzaonyeh  ARABIC LETTER YEH WITH HAMZA ABOVE */
+    { 0x05c7, 0x0627 }, /* Arabic_alef  ARABIC LETTER ALEF */
+    { 0x05c8, 0x0628 }, /* Arabic_beh  ARABIC LETTER BEH */
+    { 0x05c9, 0x0629 }, /* Arabic_tehmarbuta  ARABIC LETTER TEH MARBUTA */
+    { 0x05ca, 0x062a }, /* Arabic_teh  ARABIC LETTER TEH */
+    { 0x05cb, 0x062b }, /* Arabic_theh  ARABIC LETTER THEH */
+    { 0x05cc, 0x062c }, /* Arabic_jeem  ARABIC LETTER JEEM */
+    { 0x05cd, 0x062d }, /* Arabic_hah  ARABIC LETTER HAH */
+    { 0x05ce, 0x062e }, /* Arabic_khah  ARABIC LETTER KHAH */
+    { 0x05cf, 0x062f }, /* Arabic_dal  ARABIC LETTER DAL */
+    { 0x05d0, 0x0630 }, /* Arabic_thal  ARABIC LETTER THAL */
+    { 0x05d1, 0x0631 }, /* Arabic_ra  ARABIC LETTER REH */
+    { 0x05d2, 0x0632 }, /* Arabic_zain  ARABIC LETTER ZAIN */
+    { 0x05d3, 0x0633 }, /* Arabic_seen  ARABIC LETTER SEEN */
+    { 0x05d4, 0x0634 }, /* Arabic_sheen  ARABIC LETTER SHEEN */
+    { 0x05d5, 0x0635 }, /* Arabic_sad  ARABIC LETTER SAD */
+    { 0x05d6, 0x0636 }, /* Arabic_dad  ARABIC LETTER DAD */
+    { 0x05d7, 0x0637 }, /* Arabic_tah  ARABIC LETTER TAH */
+    { 0x05d8, 0x0638 }, /* Arabic_zah  ARABIC LETTER ZAH */
+    { 0x05d9, 0x0639 }, /* Arabic_ain  ARABIC LETTER AIN */
+    { 0x05da, 0x063a }, /* Arabic_ghain  ARABIC LETTER GHAIN */
+    { 0x05e0, 0x0640 }, /* Arabic_tatweel  ARABIC TATWEEL */
+    { 0x05e1, 0x0641 }, /* Arabic_feh  ARABIC LETTER FEH */
+    { 0x05e2, 0x0642 }, /* Arabic_qaf  ARABIC LETTER QAF */
+    { 0x05e3, 0x0643 }, /* Arabic_kaf  ARABIC LETTER KAF */
+    { 0x05e4, 0x0644 }, /* Arabic_lam  ARABIC LETTER LAM */
+    { 0x05e5, 0x0645 }, /* Arabic_meem  ARABIC LETTER MEEM */
+    { 0x05e6, 0x0646 }, /* Arabic_noon  ARABIC LETTER NOON */
+    { 0x05e7, 0x0647 }, /* Arabic_ha  ARABIC LETTER HEH */
+    { 0x05e8, 0x0648 }, /* Arabic_waw  ARABIC LETTER WAW */
+    { 0x05e9, 0x0649 }, /* Arabic_alefmaksura  ARABIC LETTER ALEF MAKSURA */
+    { 0x05ea, 0x064a }, /* Arabic_yeh  ARABIC LETTER YEH */
+    { 0x05eb, 0x064b }, /* Arabic_fathatan  ARABIC FATHATAN */
+    { 0x05ec, 0x064c }, /* Arabic_dammatan  ARABIC DAMMATAN */
+    { 0x05ed, 0x064d }, /* Arabic_kasratan  ARABIC KASRATAN */
+    { 0x05ee, 0x064e }, /* Arabic_fatha  ARABIC FATHA */
+    { 0x05ef, 0x064f }, /* Arabic_damma  ARABIC DAMMA */
+    { 0x05f0, 0x0650 }, /* Arabic_kasra  ARABIC KASRA */
+    { 0x05f1, 0x0651 }, /* Arabic_shadda  ARABIC SHADDA */
+    { 0x05f2, 0x0652 }, /* Arabic_sukun  ARABIC SUKUN */
+    { 0x0da1, 0x0e01 }, /* Thai_kokai  THAI CHARACTER KO KAI */
+    { 0x0da2, 0x0e02 }, /* Thai_khokhai  THAI CHARACTER KHO KHAI */
+    { 0x0da3, 0x0e03 }, /* Thai_khokhuat  THAI CHARACTER KHO KHUAT */
+    { 0x0da4, 0x0e04 }, /* Thai_khokhwai  THAI CHARACTER KHO KHWAI */
+    { 0x0da5, 0x0e05 }, /* Thai_khokhon  THAI CHARACTER KHO KHON */
+    { 0x0da6, 0x0e06 }, /* Thai_khorakhang  THAI CHARACTER KHO RAKHANG */
+    { 0x0da7, 0x0e07 }, /* Thai_ngongu  THAI CHARACTER NGO NGU */
+    { 0x0da8, 0x0e08 }, /* Thai_chochan  THAI CHARACTER CHO CHAN */
+    { 0x0da9, 0x0e09 }, /* Thai_choching  THAI CHARACTER CHO CHING */
+    { 0x0daa, 0x0e0a }, /* Thai_chochang  THAI CHARACTER CHO CHANG */
+    { 0x0dab, 0x0e0b }, /* Thai_soso  THAI CHARACTER SO SO */
+    { 0x0dac, 0x0e0c }, /* Thai_chochoe  THAI CHARACTER CHO CHOE */
+    { 0x0dad, 0x0e0d }, /* Thai_yoying  THAI CHARACTER YO YING */
+    { 0x0dae, 0x0e0e }, /* Thai_dochada  THAI CHARACTER DO CHADA */
+    { 0x0daf, 0x0e0f }, /* Thai_topatak  THAI CHARACTER TO PATAK */
+    { 0x0db0, 0x0e10 }, /* Thai_thothan  THAI CHARACTER THO THAN */
+    { 0x0db1, 0x0e11 }, /* Thai_thonangmontho  THAI CHARACTER THO NANGMONTHO */
+    { 0x0db2, 0x0e12 }, /* Thai_thophuthao  THAI CHARACTER THO PHUTHAO */
+    { 0x0db3, 0x0e13 }, /* Thai_nonen  THAI CHARACTER NO NEN */
+    { 0x0db4, 0x0e14 }, /* Thai_dodek  THAI CHARACTER DO DEK */
+    { 0x0db5, 0x0e15 }, /* Thai_totao  THAI CHARACTER TO TAO */
+    { 0x0db6, 0x0e16 }, /* Thai_thothung  THAI CHARACTER THO THUNG */
+    { 0x0db7, 0x0e17 }, /* Thai_thothahan  THAI CHARACTER THO THAHAN */
+    { 0x0db8, 0x0e18 }, /* Thai_thothong  THAI CHARACTER THO THONG */
+    { 0x0db9, 0x0e19 }, /* Thai_nonu  THAI CHARACTER NO NU */
+    { 0x0dba, 0x0e1a }, /* Thai_bobaimai  THAI CHARACTER BO BAIMAI */
+    { 0x0dbb, 0x0e1b }, /* Thai_popla  THAI CHARACTER PO PLA */
+    { 0x0dbc, 0x0e1c }, /* Thai_phophung  THAI CHARACTER PHO PHUNG */
+    { 0x0dbd, 0x0e1d }, /* Thai_fofa  THAI CHARACTER FO FA */
+    { 0x0dbe, 0x0e1e }, /* Thai_phophan  THAI CHARACTER PHO PHAN */
+    { 0x0dbf, 0x0e1f }, /* Thai_fofan  THAI CHARACTER FO FAN */
+    { 0x0dc0, 0x0e20 }, /* Thai_phosamphao  THAI CHARACTER PHO SAMPHAO */
+    { 0x0dc1, 0x0e21 }, /* Thai_moma  THAI CHARACTER MO MA */
+    { 0x0dc2, 0x0e22 }, /* Thai_yoyak  THAI CHARACTER YO YAK */
+    { 0x0dc3, 0x0e23 }, /* Thai_rorua  THAI CHARACTER RO RUA */
+    { 0x0dc4, 0x0e24 }, /* Thai_ru  THAI CHARACTER RU */
+    { 0x0dc5, 0x0e25 }, /* Thai_loling  THAI CHARACTER LO LING */
+    { 0x0dc6, 0x0e26 }, /* Thai_lu  THAI CHARACTER LU */
+    { 0x0dc7, 0x0e27 }, /* Thai_wowaen  THAI CHARACTER WO WAEN */
+    { 0x0dc8, 0x0e28 }, /* Thai_sosala  THAI CHARACTER SO SALA */
+    { 0x0dc9, 0x0e29 }, /* Thai_sorusi  THAI CHARACTER SO RUSI */
+    { 0x0dca, 0x0e2a }, /* Thai_sosua  THAI CHARACTER SO SUA */
+    { 0x0dcb, 0x0e2b }, /* Thai_hohip  THAI CHARACTER HO HIP */
+    { 0x0dcc, 0x0e2c }, /* Thai_lochula  THAI CHARACTER LO CHULA */
+    { 0x0dcd, 0x0e2d }, /* Thai_oang  THAI CHARACTER O ANG */
+    { 0x0dce, 0x0e2e }, /* Thai_honokhuk  THAI CHARACTER HO NOKHUK */
+    { 0x0dcf, 0x0e2f }, /* Thai_paiyannoi  THAI CHARACTER PAIYANNOI */
+    { 0x0dd0, 0x0e30 }, /* Thai_saraa  THAI CHARACTER SARA A */
+    { 0x0dd1, 0x0e31 }, /* Thai_maihanakat  THAI CHARACTER MAI HAN-AKAT */
+    { 0x0dd2, 0x0e32 }, /* Thai_saraaa  THAI CHARACTER SARA AA */
+    { 0x0dd3, 0x0e33 }, /* Thai_saraam  THAI CHARACTER SARA AM */
+    { 0x0dd4, 0x0e34 }, /* Thai_sarai  THAI CHARACTER SARA I */
+    { 0x0dd5, 0x0e35 }, /* Thai_saraii  THAI CHARACTER SARA II */
+    { 0x0dd6, 0x0e36 }, /* Thai_saraue  THAI CHARACTER SARA UE */
+    { 0x0dd7, 0x0e37 }, /* Thai_sarauee  THAI CHARACTER SARA UEE */
+    { 0x0dd8, 0x0e38 }, /* Thai_sarau  THAI CHARACTER SARA U */
+    { 0x0dd9, 0x0e39 }, /* Thai_sarauu  THAI CHARACTER SARA UU */
+    { 0x0dda, 0x0e3a }, /* Thai_phinthu  THAI CHARACTER PHINTHU */
+    { 0x0ddf, 0x0e3f }, /* Thai_baht  THAI CURRENCY SYMBOL BAHT */
+    { 0x0de0, 0x0e40 }, /* Thai_sarae  THAI CHARACTER SARA E */
+    { 0x0de1, 0x0e41 }, /* Thai_saraae  THAI CHARACTER SARA AE */
+    { 0x0de2, 0x0e42 }, /* Thai_sarao  THAI CHARACTER SARA O */
+    { 0x0de3, 0x0e43 }, /* Thai_saraaimaimuan  THAI CHARACTER SARA AI MAIMUAN */
+    { 0x0de4, 0x0e44 }, /* Thai_saraaimaimalai  THAI CHARACTER SARA AI MAIMALAI */
+    { 0x0de5, 0x0e45 }, /* Thai_lakkhangyao  THAI CHARACTER LAKKHANGYAO */
+    { 0x0de6, 0x0e46 }, /* Thai_maiyamok  THAI CHARACTER MAIYAMOK */
+    { 0x0de7, 0x0e47 }, /* Thai_maitaikhu  THAI CHARACTER MAITAIKHU */
+    { 0x0de8, 0x0e48 }, /* Thai_maiek  THAI CHARACTER MAI EK */
+    { 0x0de9, 0x0e49 }, /* Thai_maitho  THAI CHARACTER MAI THO */
+    { 0x0dea, 0x0e4a }, /* Thai_maitri  THAI CHARACTER MAI TRI */
+    { 0x0deb, 0x0e4b }, /* Thai_maichattawa  THAI CHARACTER MAI CHATTAWA */
+    { 0x0dec, 0x0e4c }, /* Thai_thanthakhat  THAI CHARACTER THANTHAKHAT */
+    { 0x0ded, 0x0e4d }, /* Thai_nikhahit  THAI CHARACTER NIKHAHIT */
+    { 0x0df0, 0x0e50 }, /* Thai_leksun  THAI DIGIT ZERO */
+    { 0x0df1, 0x0e51 }, /* Thai_leknung  THAI DIGIT ONE */
+    { 0x0df2, 0x0e52 }, /* Thai_leksong  THAI DIGIT TWO */
+    { 0x0df3, 0x0e53 }, /* Thai_leksam  THAI DIGIT THREE */
+    { 0x0df4, 0x0e54 }, /* Thai_leksi  THAI DIGIT FOUR */
+    { 0x0df5, 0x0e55 }, /* Thai_lekha  THAI DIGIT FIVE */
+    { 0x0df6, 0x0e56 }, /* Thai_lekhok  THAI DIGIT SIX */
+    { 0x0df7, 0x0e57 }, /* Thai_lekchet  THAI DIGIT SEVEN */
+    { 0x0df8, 0x0e58 }, /* Thai_lekpaet  THAI DIGIT EIGHT */
+    { 0x0df9, 0x0e59 }, /* Thai_lekkao  THAI DIGIT NINE */
+    { 0x0ed4, 0x11a8 }, /* Hangul_J_Kiyeog  HANGUL JONGSEONG KIYEOK */
+    { 0x0ed5, 0x11a9 }, /* Hangul_J_SsangKiyeog  HANGUL JONGSEONG SSANGKIYEOK */
+    { 0x0ed6, 0x11aa }, /* Hangul_J_KiyeogSios  HANGUL JONGSEONG KIYEOK-SIOS */
+    { 0x0ed7, 0x11ab }, /* Hangul_J_Nieun  HANGUL JONGSEONG NIEUN */
+    { 0x0ed8, 0x11ac }, /* Hangul_J_NieunJieuj  HANGUL JONGSEONG NIEUN-CIEUC */
+    { 0x0ed9, 0x11ad }, /* Hangul_J_NieunHieuh  HANGUL JONGSEONG NIEUN-HIEUH */
+    { 0x0eda, 0x11ae }, /* Hangul_J_Dikeud  HANGUL JONGSEONG TIKEUT */
+    { 0x0edb, 0x11af }, /* Hangul_J_Rieul  HANGUL JONGSEONG RIEUL */
+    { 0x0edc, 0x11b0 }, /* Hangul_J_RieulKiyeog  HANGUL JONGSEONG RIEUL-KIYEOK */
+    { 0x0edd, 0x11b1 }, /* Hangul_J_RieulMieum  HANGUL JONGSEONG RIEUL-MIEUM */
+    { 0x0ede, 0x11b2 }, /* Hangul_J_RieulPieub  HANGUL JONGSEONG RIEUL-PIEUP */
+    { 0x0edf, 0x11b3 }, /* Hangul_J_RieulSios  HANGUL JONGSEONG RIEUL-SIOS */
+    { 0x0ee0, 0x11b4 }, /* Hangul_J_RieulTieut  HANGUL JONGSEONG RIEUL-THIEUTH */
+    { 0x0ee1, 0x11b5 }, /* Hangul_J_RieulPhieuf  HANGUL JONGSEONG RIEUL-PHIEUPH */
+    { 0x0ee2, 0x11b6 }, /* Hangul_J_RieulHieuh  HANGUL JONGSEONG RIEUL-HIEUH */
+    { 0x0ee3, 0x11b7 }, /* Hangul_J_Mieum  HANGUL JONGSEONG MIEUM */
+    { 0x0ee4, 0x11b8 }, /* Hangul_J_Pieub  HANGUL JONGSEONG PIEUP */
+    { 0x0ee5, 0x11b9 }, /* Hangul_J_PieubSios  HANGUL JONGSEONG PIEUP-SIOS */
+    { 0x0ee6, 0x11ba }, /* Hangul_J_Sios  HANGUL JONGSEONG SIOS */
+    { 0x0ee7, 0x11bb }, /* Hangul_J_SsangSios  HANGUL JONGSEONG SSANGSIOS */
+    { 0x0ee8, 0x11bc }, /* Hangul_J_Ieung  HANGUL JONGSEONG IEUNG */
+    { 0x0ee9, 0x11bd }, /* Hangul_J_Jieuj  HANGUL JONGSEONG CIEUC */
+    { 0x0eea, 0x11be }, /* Hangul_J_Cieuc  HANGUL JONGSEONG CHIEUCH */
+    { 0x0eeb, 0x11bf }, /* Hangul_J_Khieuq  HANGUL JONGSEONG KHIEUKH */
+    { 0x0eec, 0x11c0 }, /* Hangul_J_Tieut  HANGUL JONGSEONG THIEUTH */
+    { 0x0eed, 0x11c1 }, /* Hangul_J_Phieuf  HANGUL JONGSEONG PHIEUPH */
+    { 0x0eee, 0x11c2 }, /* Hangul_J_Hieuh  HANGUL JONGSEONG HIEUH */
+    { 0x0ef8, 0x11eb }, /* Hangul_J_PanSios  HANGUL JONGSEONG PANSIOS */
+    { 0x0efa, 0x11f9 }, /* Hangul_J_YeorinHieuh  HANGUL JONGSEONG YEORINHIEUH */
+    { 0x0aa2, 0x2002 }, /* enspace  EN SPACE */
+    { 0x0aa1, 0x2003 }, /* emspace  EM SPACE */
+    { 0x0aa3, 0x2004 }, /* em3space  THREE-PER-EM SPACE */
+    { 0x0aa4, 0x2005 }, /* em4space  FOUR-PER-EM SPACE */
+    { 0x0aa5, 0x2007 }, /* digitspace  FIGURE SPACE */
+    { 0x0aa6, 0x2008 }, /* punctspace  PUNCTUATION SPACE */
+    { 0x0aa7, 0x2009 }, /* thinspace  THIN SPACE */
+    { 0x0aa8, 0x200a }, /* hairspace  HAIR SPACE */
+    { 0x0abb, 0x2012 }, /* figdash  FIGURE DASH */
+    { 0x0aaa, 0x2013 }, /* endash  EN DASH */
+    { 0x0aa9, 0x2014 }, /* emdash  EM DASH */
+    { 0x07af, 0x2015 }, /* Greek_horizbar  HORIZONTAL BAR */
+    { 0x0cdf, 0x2017 }, /* hebrew_doublelowline  DOUBLE LOW LINE */
+    { 0x0ad0, 0x2018 }, /* leftsinglequotemark  LEFT SINGLE QUOTATION MARK */
+    { 0x0ad1, 0x2019 }, /* rightsinglequotemark  RIGHT SINGLE QUOTATION MARK */
+    { 0x0afd, 0x201a }, /* singlelowquotemark  SINGLE LOW-9 QUOTATION MARK */
+    { 0x0ad2, 0x201c }, /* leftdoublequotemark  LEFT DOUBLE QUOTATION MARK */
+    { 0x0ad3, 0x201d }, /* rightdoublequotemark  RIGHT DOUBLE QUOTATION MARK */
+    { 0x0afe, 0x201e }, /* doublelowquotemark  DOUBLE LOW-9 QUOTATION MARK */
+    { 0x0af1, 0x2020 }, /* dagger  DAGGER */
+    { 0x0af2, 0x2021 }, /* doubledagger  DOUBLE DAGGER */
+    { 0x0ae6, 0x2022 }, /* enfilledcircbullet  BULLET */
+    { 0x0aae, 0x2026 }, /* ellipsis  HORIZONTAL ELLIPSIS */
+    { 0x0ad6, 0x2032 }, /* minutes  PRIME */
+    { 0x0ad7, 0x2033 }, /* seconds  DOUBLE PRIME */
+    { 0x0afc, 0x2038 }, /* caret  CARET */
+    { 0x047e, 0x203e }, /* overline  OVERLINE */
+    { 0x20a0, 0x20a0 }, /* EcuSign  EURO-CURRENCY SIGN */
+    { 0x20a1, 0x20a1 }, /* ColonSign  COLON SIGN */
+    { 0x20a2, 0x20a2 }, /* CruzeiroSign  CRUZEIRO SIGN */
+    { 0x20a3, 0x20a3 }, /* FFrancSign  FRENCH FRANC SIGN */
+    { 0x20a4, 0x20a4 }, /* LiraSign  LIRA SIGN */
+    { 0x20a5, 0x20a5 }, /* MillSign  MILL SIGN */
+    { 0x20a6, 0x20a6 }, /* NairaSign  NAIRA SIGN */
+    { 0x20a7, 0x20a7 }, /* PesetaSign  PESETA SIGN */
+    { 0x20a8, 0x20a8 }, /* RupeeSign  RUPEE SIGN */
+    { 0x0eff, 0x20a9 }, /* Korean_Won  WON SIGN */
+    { 0x20a9, 0x20a9 }, /* WonSign  WON SIGN */
+    { 0x20aa, 0x20aa }, /* NewSheqelSign  NEW SHEQEL SIGN */
+    { 0x20ab, 0x20ab }, /* DongSign  DONG SIGN */
+    { 0x20ac, 0x20ac }, /* EuroSign  EURO SIGN */
+    { 0x0ab8, 0x2105 }, /* careof  CARE OF */
+    { 0x06b0, 0x2116 }, /* numerosign  NUMERO SIGN */
+    { 0x0afb, 0x2117 }, /* phonographcopyright  SOUND RECORDING COPYRIGHT */
+    { 0x0ad4, 0x211e }, /* prescription  PRESCRIPTION TAKE */
+    { 0x0ac9, 0x2122 }, /* trademark  TRADE MARK SIGN */
+    { 0x0ab0, 0x2153 }, /* onethird  VULGAR FRACTION ONE THIRD */
+    { 0x0ab1, 0x2154 }, /* twothirds  VULGAR FRACTION TWO THIRDS */
+    { 0x0ab2, 0x2155 }, /* onefifth  VULGAR FRACTION ONE FIFTH */
+    { 0x0ab3, 0x2156 }, /* twofifths  VULGAR FRACTION TWO FIFTHS */
+    { 0x0ab4, 0x2157 }, /* threefifths  VULGAR FRACTION THREE FIFTHS */
+    { 0x0ab5, 0x2158 }, /* fourfifths  VULGAR FRACTION FOUR FIFTHS */
+    { 0x0ab6, 0x2159 }, /* onesixth  VULGAR FRACTION ONE SIXTH */
+    { 0x0ab7, 0x215a }, /* fivesixths  VULGAR FRACTION FIVE SIXTHS */
+    { 0x0ac3, 0x215b }, /* oneeighth  VULGAR FRACTION ONE EIGHTH */
+    { 0x0ac4, 0x215c }, /* threeeighths  VULGAR FRACTION THREE EIGHTHS */
+    { 0x0ac5, 0x215d }, /* fiveeighths  VULGAR FRACTION FIVE EIGHTHS */
+    { 0x0ac6, 0x215e }, /* seveneighths  VULGAR FRACTION SEVEN EIGHTHS */
+    { 0x08fb, 0x2190 }, /* leftarrow  LEFTWARDS ARROW */
+    { 0x08fc, 0x2191 }, /* uparrow  UPWARDS ARROW */
+    { 0x08fd, 0x2192 }, /* rightarrow  RIGHTWARDS ARROW */
+    { 0x08fe, 0x2193 }, /* downarrow  DOWNWARDS ARROW */
+    { 0x08ce, 0x21d2 }, /* implies  RIGHTWARDS DOUBLE ARROW */
+    { 0x08cd, 0x21d4 }, /* ifonlyif  LEFT RIGHT DOUBLE ARROW */
+    { 0x08ef, 0x2202 }, /* partialderivative  PARTIAL DIFFERENTIAL */
+    { 0x08c5, 0x2207 }, /* nabla  NABLA */
+    { 0x0bca, 0x2218 }, /* jot  RING OPERATOR */
+    { 0x08d6, 0x221a }, /* radical  SQUARE ROOT */
+    { 0x08c1, 0x221d }, /* variation  PROPORTIONAL TO */
+    { 0x08c2, 0x221e }, /* infinity  INFINITY */
+    { 0x08de, 0x2227 }, /* logicaland  LOGICAL AND */
+    { 0x0ba9, 0x2227 }, /* upcaret  LOGICAL AND */
+    { 0x08df, 0x2228 }, /* logicalor  LOGICAL OR */
+    { 0x0ba8, 0x2228 }, /* downcaret  LOGICAL OR */
+    { 0x08dc, 0x2229 }, /* intersection  INTERSECTION */
+    { 0x0bc3, 0x2229 }, /* upshoe  INTERSECTION */
+    { 0x08dd, 0x222a }, /* union  UNION */
+    { 0x0bd6, 0x222a }, /* downshoe  UNION */
+    { 0x08bf, 0x222b }, /* integral  INTEGRAL */
+    { 0x08c0, 0x2234 }, /* therefore  THEREFORE */
+    { 0x08c8, 0x2245 }, /* approximate  APPROXIMATELY EQUAL TO */
+    { 0x08bd, 0x2260 }, /* notequal  NOT EQUAL TO */
+    { 0x08cf, 0x2261 }, /* identical  IDENTICAL TO */
+    { 0x08bc, 0x2264 }, /* lessthanequal  LESS-THAN OR EQUAL TO */
+    { 0x08be, 0x2265 }, /* greaterthanequal  GREATER-THAN OR EQUAL TO */
+    { 0x08da, 0x2282 }, /* includedin  SUBSET OF */
+    { 0x0bda, 0x2282 }, /* leftshoe  SUBSET OF */
+    { 0x08db, 0x2283 }, /* includes  SUPERSET OF */
+    { 0x0bd8, 0x2283 }, /* rightshoe  SUPERSET OF */
+    { 0x0bfc, 0x22a2 }, /* righttack  RIGHT TACK */
+    { 0x0bdc, 0x22a3 }, /* lefttack  LEFT TACK */
+    { 0x0bc2, 0x22a4 }, /* downtack  DOWN TACK */
+    { 0x0bce, 0x22a5 }, /* uptack  UP TACK */
+    { 0x0bd3, 0x2308 }, /* upstile  LEFT CEILING */
+    { 0x0bc4, 0x230a }, /* downstile  LEFT FLOOR */
+    { 0x0afa, 0x2315 }, /* telephonerecorder  TELEPHONE RECORDER */
+    { 0x08a4, 0x2320 }, /* topintegral  TOP HALF INTEGRAL */
+    { 0x08a5, 0x2321 }, /* botintegral  BOTTOM HALF INTEGRAL */
+    { 0x0abc, 0x2329 }, /* leftanglebracket  LEFT-POINTING ANGLE BRACKET */
+    { 0x0abe, 0x232a }, /* rightanglebracket  RIGHT-POINTING ANGLE BRACKET */
+    { 0x0bcc, 0x2395 }, /* quad  APL FUNCTIONAL SYMBOL QUAD (Unicode 3.0) */
+    { 0x09e2, 0x2409 }, /* ht  SYMBOL FOR HORIZONTAL TABULATION */
+    { 0x09e5, 0x240a }, /* lf  SYMBOL FOR LINE FEED */
+    { 0x09e9, 0x240b }, /* vt  SYMBOL FOR VERTICAL TABULATION */
+    { 0x09e3, 0x240c }, /* ff  SYMBOL FOR FORM FEED */
+    { 0x09e4, 0x240d }, /* cr  SYMBOL FOR CARRIAGE RETURN */
+    { 0x09df, 0x2422 }, /* blank  BLANK SYMBOL */
+    { 0x09e8, 0x2424 }, /* nl  SYMBOL FOR NEWLINE */
+    { 0x09f1, 0x2500 }, /* horizlinescan5  BOX DRAWINGS LIGHT HORIZONTAL */
+    { 0x08a6, 0x2502 }, /* vertconnector  BOX DRAWINGS LIGHT VERTICAL */
+    { 0x09f8, 0x2502 }, /* vertbar  BOX DRAWINGS LIGHT VERTICAL */
+    { 0x09ec, 0x250c }, /* upleftcorner  BOX DRAWINGS LIGHT DOWN AND RIGHT */
+    { 0x09eb, 0x2510 }, /* uprightcorner  BOX DRAWINGS LIGHT DOWN AND LEFT */
+    { 0x09ed, 0x2514 }, /* lowleftcorner  BOX DRAWINGS LIGHT UP AND RIGHT */
+    { 0x09ea, 0x2518 }, /* lowrightcorner  BOX DRAWINGS LIGHT UP AND LEFT */
+    { 0x09f4, 0x251c }, /* leftt  BOX DRAWINGS LIGHT VERTICAL AND RIGHT */
+    { 0x09f5, 0x2524 }, /* rightt  BOX DRAWINGS LIGHT VERTICAL AND LEFT */
+    { 0x09f7, 0x252c }, /* topt  BOX DRAWINGS LIGHT DOWN AND HORIZONTAL */
+    { 0x09f6, 0x2534 }, /* bott  BOX DRAWINGS LIGHT UP AND HORIZONTAL */
+    { 0x09ee, 0x253c }, /* crossinglines  BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL */
+    { 0x09e1, 0x2592 }, /* checkerboard  MEDIUM SHADE */
+    { 0x0adf, 0x25a0 }, /* emfilledrect  BLACK SQUARE */
+    { 0x0acf, 0x25a1 }, /* emopenrectangle  WHITE SQUARE */
+    { 0x0ae7, 0x25aa }, /* enfilledsqbullet  BLACK SMALL SQUARE */
+    { 0x0ae1, 0x25ab }, /* enopensquarebullet  WHITE SMALL SQUARE */
+    { 0x0adb, 0x25ac }, /* filledrectbullet  BLACK RECTANGLE */
+    { 0x0ae2, 0x25ad }, /* openrectbullet  WHITE RECTANGLE */
+    { 0x0ae8, 0x25b2 }, /* filledtribulletup  BLACK UP-POINTING TRIANGLE */
+    { 0x0ae3, 0x25b3 }, /* opentribulletup  WHITE UP-POINTING TRIANGLE */
+    { 0x0add, 0x25b6 }, /* filledrighttribullet  BLACK RIGHT-POINTING TRIANGLE */
+    { 0x0acd, 0x25b7 }, /* rightopentriangle  WHITE RIGHT-POINTING TRIANGLE */
+    { 0x0ae9, 0x25bc }, /* filledtribulletdown  BLACK DOWN-POINTING TRIANGLE */
+    { 0x0ae4, 0x25bd }, /* opentribulletdown  WHITE DOWN-POINTING TRIANGLE */
+    { 0x0adc, 0x25c0 }, /* filledlefttribullet  BLACK LEFT-POINTING TRIANGLE */
+    { 0x0acc, 0x25c1 }, /* leftopentriangle  WHITE LEFT-POINTING TRIANGLE */
+    { 0x09e0, 0x25c6 }, /* soliddiamond  BLACK DIAMOND */
+    { 0x0ace, 0x25cb }, /* emopencircle  WHITE CIRCLE */
+    { 0x0bcf, 0x25cb }, /* circle  WHITE CIRCLE */
+    { 0x0ade, 0x25cf }, /* emfilledcircle  BLACK CIRCLE */
+    { 0x0ae0, 0x25e6 }, /* enopencircbullet  WHITE BULLET */
+    { 0x0ae5, 0x2606 }, /* openstar  WHITE STAR */
+    { 0x0af9, 0x260e }, /* telephone  BLACK TELEPHONE */
+    { 0x0aca, 0x2613 }, /* signaturemark  SALTIRE */
+    { 0x0aea, 0x261c }, /* leftpointer  WHITE LEFT POINTING INDEX */
+    { 0x0aeb, 0x261e }, /* rightpointer  WHITE RIGHT POINTING INDEX */
+    { 0x0af8, 0x2640 }, /* femalesymbol  FEMALE SIGN */
+    { 0x0af7, 0x2642 }, /* malesymbol  MALE SIGN */
+    { 0x0aec, 0x2663 }, /* club  BLACK CLUB SUIT */
+    { 0x0aee, 0x2665 }, /* heart  BLACK HEART SUIT */
+    { 0x0aed, 0x2666 }, /* diamond  BLACK DIAMOND SUIT */
+    { 0x0af6, 0x266d }, /* musicalflat  MUSIC FLAT SIGN */
+    { 0x0af5, 0x266f }, /* musicalsharp  MUSIC SHARP SIGN */
+    { 0x0af3, 0x2713 }, /* checkmark  CHECK MARK */
+    { 0x0af4, 0x2717 }, /* ballotcross  BALLOT X */
+    { 0x0ad9, 0x271d }, /* latincross  LATIN CROSS */
+    { 0x0af0, 0x2720 }, /* maltesecross  MALTESE CROSS */
+    { 0x04a4, 0x3001 }, /* kana_comma  IDEOGRAPHIC COMMA */
+    { 0x04a1, 0x3002 }, /* kana_fullstop  IDEOGRAPHIC FULL STOP */
+    { 0x04a2, 0x300c }, /* kana_openingbracket  LEFT CORNER BRACKET */
+    { 0x04a3, 0x300d }, /* kana_closingbracket  RIGHT CORNER BRACKET */
+    { 0x04de, 0x309b }, /* voicedsound  KATAKANA-HIRAGANA VOICED SOUND MARK */
+    { 0x04df, 0x309c }, /* semivoicedsound  KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK */
+    { 0x04a7, 0x30a1 }, /* kana_a  KATAKANA LETTER SMALL A */
+    { 0x04b1, 0x30a2 }, /* kana_A  KATAKANA LETTER A */
+    { 0x04a8, 0x30a3 }, /* kana_i  KATAKANA LETTER SMALL I */
+    { 0x04b2, 0x30a4 }, /* kana_I  KATAKANA LETTER I */
+    { 0x04a9, 0x30a5 }, /* kana_u  KATAKANA LETTER SMALL U */
+    { 0x04b3, 0x30a6 }, /* kana_U  KATAKANA LETTER U */
+    { 0x04aa, 0x30a7 }, /* kana_e  KATAKANA LETTER SMALL E */
+    { 0x04b4, 0x30a8 }, /* kana_E  KATAKANA LETTER E */
+    { 0x04ab, 0x30a9 }, /* kana_o  KATAKANA LETTER SMALL O */
+    { 0x04b5, 0x30aa }, /* kana_O  KATAKANA LETTER O */
+    { 0x04b6, 0x30ab }, /* kana_KA  KATAKANA LETTER KA */
+    { 0x04b7, 0x30ad }, /* kana_KI  KATAKANA LETTER KI */
+    { 0x04b8, 0x30af }, /* kana_KU  KATAKANA LETTER KU */
+    { 0x04b9, 0x30b1 }, /* kana_KE  KATAKANA LETTER KE */
+    { 0x04ba, 0x30b3 }, /* kana_KO  KATAKANA LETTER KO */
+    { 0x04bb, 0x30b5 }, /* kana_SA  KATAKANA LETTER SA */
+    { 0x04bc, 0x30b7 }, /* kana_SHI  KATAKANA LETTER SI */
+    { 0x04bd, 0x30b9 }, /* kana_SU  KATAKANA LETTER SU */
+    { 0x04be, 0x30bb }, /* kana_SE  KATAKANA LETTER SE */
+    { 0x04bf, 0x30bd }, /* kana_SO  KATAKANA LETTER SO */
+    { 0x04c0, 0x30bf }, /* kana_TA  KATAKANA LETTER TA */
+    { 0x04c1, 0x30c1 }, /* kana_CHI  KATAKANA LETTER TI */
+    { 0x04af, 0x30c3 }, /* kana_tsu  KATAKANA LETTER SMALL TU */
+    { 0x04c2, 0x30c4 }, /* kana_TSU  KATAKANA LETTER TU */
+    { 0x04c3, 0x30c6 }, /* kana_TE  KATAKANA LETTER TE */
+    { 0x04c4, 0x30c8 }, /* kana_TO  KATAKANA LETTER TO */
+    { 0x04c5, 0x30ca }, /* kana_NA  KATAKANA LETTER NA */
+    { 0x04c6, 0x30cb }, /* kana_NI  KATAKANA LETTER NI */
+    { 0x04c7, 0x30cc }, /* kana_NU  KATAKANA LETTER NU */
+    { 0x04c8, 0x30cd }, /* kana_NE  KATAKANA LETTER NE */
+    { 0x04c9, 0x30ce }, /* kana_NO  KATAKANA LETTER NO */
+    { 0x04ca, 0x30cf }, /* kana_HA  KATAKANA LETTER HA */
+    { 0x04cb, 0x30d2 }, /* kana_HI  KATAKANA LETTER HI */
+    { 0x04cc, 0x30d5 }, /* kana_FU  KATAKANA LETTER HU */
+    { 0x04cd, 0x30d8 }, /* kana_HE  KATAKANA LETTER HE */
+    { 0x04ce, 0x30db }, /* kana_HO  KATAKANA LETTER HO */
+    { 0x04cf, 0x30de }, /* kana_MA  KATAKANA LETTER MA */
+    { 0x04d0, 0x30df }, /* kana_MI  KATAKANA LETTER MI */
+    { 0x04d1, 0x30e0 }, /* kana_MU  KATAKANA LETTER MU */
+    { 0x04d2, 0x30e1 }, /* kana_ME  KATAKANA LETTER ME */
+    { 0x04d3, 0x30e2 }, /* kana_MO  KATAKANA LETTER MO */
+    { 0x04ac, 0x30e3 }, /* kana_ya  KATAKANA LETTER SMALL YA */
+    { 0x04d4, 0x30e4 }, /* kana_YA  KATAKANA LETTER YA */
+    { 0x04ad, 0x30e5 }, /* kana_yu  KATAKANA LETTER SMALL YU */
+    { 0x04d5, 0x30e6 }, /* kana_YU  KATAKANA LETTER YU */
+    { 0x04ae, 0x30e7 }, /* kana_yo  KATAKANA LETTER SMALL YO */
+    { 0x04d6, 0x30e8 }, /* kana_YO  KATAKANA LETTER YO */
+    { 0x04d7, 0x30e9 }, /* kana_RA  KATAKANA LETTER RA */
+    { 0x04d8, 0x30ea }, /* kana_RI  KATAKANA LETTER RI */
+    { 0x04d9, 0x30eb }, /* kana_RU  KATAKANA LETTER RU */
+    { 0x04da, 0x30ec }, /* kana_RE  KATAKANA LETTER RE */
+    { 0x04db, 0x30ed }, /* kana_RO  KATAKANA LETTER RO */
+    { 0x04dc, 0x30ef }, /* kana_WA  KATAKANA LETTER WA */
+    { 0x04a6, 0x30f2 }, /* kana_WO  KATAKANA LETTER WO */
+    { 0x04dd, 0x30f3 }, /* kana_N  KATAKANA LETTER N */
+    { 0x04a5, 0x30fb }, /* kana_conjunctive  KATAKANA MIDDLE DOT */
+    { 0x04b0, 0x30fc }, /* prolongedsound  KATAKANA-HIRAGANA PROLONGED SOUND MARK */
+    { 0x0ea1, 0x3131 }, /* Hangul_Kiyeog  HANGUL LETTER KIYEOK */
+    { 0x0ea2, 0x3132 }, /* Hangul_SsangKiyeog  HANGUL LETTER SSANGKIYEOK */
+    { 0x0ea3, 0x3133 }, /* Hangul_KiyeogSios  HANGUL LETTER KIYEOK-SIOS */
+    { 0x0ea4, 0x3134 }, /* Hangul_Nieun  HANGUL LETTER NIEUN */
+    { 0x0ea5, 0x3135 }, /* Hangul_NieunJieuj  HANGUL LETTER NIEUN-CIEUC */
+    { 0x0ea6, 0x3136 }, /* Hangul_NieunHieuh  HANGUL LETTER NIEUN-HIEUH */
+    { 0x0ea7, 0x3137 }, /* Hangul_Dikeud  HANGUL LETTER TIKEUT */
+    { 0x0ea8, 0x3138 }, /* Hangul_SsangDikeud  HANGUL LETTER SSANGTIKEUT */
+    { 0x0ea9, 0x3139 }, /* Hangul_Rieul  HANGUL LETTER RIEUL */
+    { 0x0eaa, 0x313a }, /* Hangul_RieulKiyeog  HANGUL LETTER RIEUL-KIYEOK */
+    { 0x0eab, 0x313b }, /* Hangul_RieulMieum  HANGUL LETTER RIEUL-MIEUM */
+    { 0x0eac, 0x313c }, /* Hangul_RieulPieub  HANGUL LETTER RIEUL-PIEUP */
+    { 0x0ead, 0x313d }, /* Hangul_RieulSios  HANGUL LETTER RIEUL-SIOS */
+    { 0x0eae, 0x313e }, /* Hangul_RieulTieut  HANGUL LETTER RIEUL-THIEUTH */
+    { 0x0eaf, 0x313f }, /* Hangul_RieulPhieuf  HANGUL LETTER RIEUL-PHIEUPH */
+    { 0x0eb0, 0x3140 }, /* Hangul_RieulHieuh  HANGUL LETTER RIEUL-HIEUH */
+    { 0x0eb1, 0x3141 }, /* Hangul_Mieum  HANGUL LETTER MIEUM */
+    { 0x0eb2, 0x3142 }, /* Hangul_Pieub  HANGUL LETTER PIEUP */
+    { 0x0eb3, 0x3143 }, /* Hangul_SsangPieub  HANGUL LETTER SSANGPIEUP */
+    { 0x0eb4, 0x3144 }, /* Hangul_PieubSios  HANGUL LETTER PIEUP-SIOS */
+    { 0x0eb5, 0x3145 }, /* Hangul_Sios  HANGUL LETTER SIOS */
+    { 0x0eb6, 0x3146 }, /* Hangul_SsangSios  HANGUL LETTER SSANGSIOS */
+    { 0x0eb7, 0x3147 }, /* Hangul_Ieung  HANGUL LETTER IEUNG */
+    { 0x0eb8, 0x3148 }, /* Hangul_Jieuj  HANGUL LETTER CIEUC */
+    { 0x0eb9, 0x3149 }, /* Hangul_SsangJieuj  HANGUL LETTER SSANGCIEUC */
+    { 0x0eba, 0x314a }, /* Hangul_Cieuc  HANGUL LETTER CHIEUCH */
+    { 0x0ebb, 0x314b }, /* Hangul_Khieuq  HANGUL LETTER KHIEUKH */
+    { 0x0ebc, 0x314c }, /* Hangul_Tieut  HANGUL LETTER THIEUTH */
+    { 0x0ebd, 0x314d }, /* Hangul_Phieuf  HANGUL LETTER PHIEUPH */
+    { 0x0ebe, 0x314e }, /* Hangul_Hieuh  HANGUL LETTER HIEUH */
+    { 0x0ebf, 0x314f }, /* Hangul_A  HANGUL LETTER A */
+    { 0x0ec0, 0x3150 }, /* Hangul_AE  HANGUL LETTER AE */
+    { 0x0ec1, 0x3151 }, /* Hangul_YA  HANGUL LETTER YA */
+    { 0x0ec2, 0x3152 }, /* Hangul_YAE  HANGUL LETTER YAE */
+    { 0x0ec3, 0x3153 }, /* Hangul_EO  HANGUL LETTER EO */
+    { 0x0ec4, 0x3154 }, /* Hangul_E  HANGUL LETTER E */
+    { 0x0ec5, 0x3155 }, /* Hangul_YEO  HANGUL LETTER YEO */
+    { 0x0ec6, 0x3156 }, /* Hangul_YE  HANGUL LETTER YE */
+    { 0x0ec7, 0x3157 }, /* Hangul_O  HANGUL LETTER O */
+    { 0x0ec8, 0x3158 }, /* Hangul_WA  HANGUL LETTER WA */
+    { 0x0ec9, 0x3159 }, /* Hangul_WAE  HANGUL LETTER WAE */
+    { 0x0eca, 0x315a }, /* Hangul_OE  HANGUL LETTER OE */
+    { 0x0ecb, 0x315b }, /* Hangul_YO  HANGUL LETTER YO */
+    { 0x0ecc, 0x315c }, /* Hangul_U  HANGUL LETTER U */
+    { 0x0ecd, 0x315d }, /* Hangul_WEO  HANGUL LETTER WEO */
+    { 0x0ece, 0x315e }, /* Hangul_WE  HANGUL LETTER WE */
+    { 0x0ecf, 0x315f }, /* Hangul_WI  HANGUL LETTER WI */
+    { 0x0ed0, 0x3160 }, /* Hangul_YU  HANGUL LETTER YU */
+    { 0x0ed1, 0x3161 }, /* Hangul_EU  HANGUL LETTER EU */
+    { 0x0ed2, 0x3162 }, /* Hangul_YI  HANGUL LETTER YI */
+    { 0x0ed3, 0x3163 }, /* Hangul_I  HANGUL LETTER I */
+    { 0x0eef, 0x316d }, /* Hangul_RieulYeorinHieuh  HANGUL LETTER RIEUL-YEORINHIEUH */
+    { 0x0ef0, 0x3171 }, /* Hangul_SunkyeongeumMieum  HANGUL LETTER KAPYEOUNMIEUM */
+    { 0x0ef1, 0x3178 }, /* Hangul_SunkyeongeumPieub  HANGUL LETTER KAPYEOUNPIEUP */
+    { 0x0ef2, 0x317f }, /* Hangul_PanSios  HANGUL LETTER PANSIOS */
+    { 0x0ef4, 0x3184 }, /* Hangul_SunkyeongeumPhieuf  HANGUL LETTER KAPYEOUNPHIEUPH */
+    { 0x0ef5, 0x3186 }, /* Hangul_YeorinHieuh  HANGUL LETTER YEORINHIEUH */
+    { 0x0ef6, 0x318d }, /* Hangul_AraeA  HANGUL LETTER ARAEA */
+    { 0x0ef7, 0x318e }, /* Hangul_AraeAE  HANGUL LETTER ARAEAE */
+};
+
+#endif // KEYDATA_H
diff --git a/src/plugins/platforminputcontexts/fcitx/keyserver_x11.h b/src/plugins/platforminputcontexts/fcitx/keyserver_x11.h
new file mode 100644
index 0000000..e735210
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/keyserver_x11.h
@@ -0,0 +1,173 @@
+/*
+    Copyright (C) 2001 Ellis Whitehead <ellis@kde.org>
+
+    Win32 port:
+    Copyright (C) 2004 Jaroslaw Staniek <js@iidea.pl>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+ */
+
+#ifndef KEYSERVER_X11_H
+#define KEYSERVER_X11_H
+
+#include <X11/keysym.h>
+
+struct TransKey {
+    int keySymQt;
+    uint keySymX;
+};
+
+static const TransKey g_rgQtToSymX[] = {
+    { Qt::Key_Escape,     XK_Escape },
+    { Qt::Key_Tab,        XK_Tab },
+    { Qt::Key_Backtab,    XK_ISO_Left_Tab },
+    { Qt::Key_Backspace,  XK_BackSpace },
+    { Qt::Key_Return,     XK_Return },
+    { Qt::Key_Enter,      XK_KP_Enter },
+    { Qt::Key_Insert,     XK_Insert },
+    { Qt::Key_Delete,     XK_Delete },
+    { Qt::Key_Pause,      XK_Pause },
+#ifdef sun
+    { Qt::Key_Print,      XK_F22 },
+#else
+    { Qt::Key_Print,      XK_Print },
+#endif
+    { Qt::Key_SysReq,     XK_Sys_Req },
+    { Qt::Key_Home,       XK_Home },
+    { Qt::Key_End,        XK_End },
+    { Qt::Key_Left,       XK_Left },
+    { Qt::Key_Up,         XK_Up },
+    { Qt::Key_Right,      XK_Right },
+    { Qt::Key_Down,       XK_Down },
+    //{ Qt::Key_Shift,      0 },
+    //{ Qt::Key_Control,    0 },
+    //{ Qt::Key_Meta,       0 },
+    //{ Qt::Key_Alt,        0 },
+    { Qt::Key_CapsLock,   XK_Caps_Lock },
+    { Qt::Key_NumLock,    XK_Num_Lock },
+    { Qt::Key_ScrollLock, XK_Scroll_Lock },
+    { Qt::Key_F1,         XK_F1 },
+    { Qt::Key_F2,         XK_F2 },
+    { Qt::Key_F3,         XK_F3 },
+    { Qt::Key_F4,         XK_F4 },
+    { Qt::Key_F5,         XK_F5 },
+    { Qt::Key_F6,         XK_F6 },
+    { Qt::Key_F7,         XK_F7 },
+    { Qt::Key_F8,         XK_F8 },
+    { Qt::Key_F9,         XK_F9 },
+    { Qt::Key_F10,        XK_F10 },
+    { Qt::Key_F11,        XK_F11 },
+    { Qt::Key_F12,        XK_F12 },
+    { Qt::Key_F13,        XK_F13 },
+    { Qt::Key_F14,        XK_F14 },
+    { Qt::Key_F15,        XK_F15 },
+    { Qt::Key_F16,        XK_F16 },
+    { Qt::Key_F17,        XK_F17 },
+    { Qt::Key_F18,        XK_F18 },
+    { Qt::Key_F19,        XK_F19 },
+    { Qt::Key_F20,        XK_F20 },
+    { Qt::Key_F21,        XK_F21 },
+    { Qt::Key_F22,        XK_F22 },
+    { Qt::Key_F23,        XK_F23 },
+    { Qt::Key_F24,        XK_F24 },
+    { Qt::Key_F25,        XK_F25 },
+    { Qt::Key_F26,        XK_F26 },
+    { Qt::Key_F27,        XK_F27 },
+    { Qt::Key_F28,        XK_F28 },
+    { Qt::Key_F29,        XK_F29 },
+    { Qt::Key_F30,        XK_F30 },
+    { Qt::Key_F31,        XK_F31 },
+    { Qt::Key_F32,        XK_F32 },
+    { Qt::Key_F33,        XK_F33 },
+    { Qt::Key_F34,        XK_F34 },
+    { Qt::Key_F35,        XK_F35 },
+    { Qt::Key_Super_L,    XK_Super_L },
+    { Qt::Key_Super_R,    XK_Super_R },
+    { Qt::Key_Menu,       XK_Menu },
+    { Qt::Key_Hyper_L,    XK_Hyper_L },
+    { Qt::Key_Hyper_R,    XK_Hyper_R },
+    { Qt::Key_Help,       XK_Help },
+
+    { '/',                XK_KP_Divide },
+    { '*',                XK_KP_Multiply },
+    { '-',                XK_KP_Subtract },
+    { '+',                XK_KP_Add },
+    { Qt::Key_Return,     XK_KP_Enter },
+    {Qt::Key_Multi_key, XK_Multi_key},
+    {Qt::Key_Codeinput, XK_Codeinput},
+    {Qt::Key_SingleCandidate,   XK_SingleCandidate},
+    {Qt::Key_MultipleCandidate, XK_MultipleCandidate},
+    {Qt::Key_PreviousCandidate, XK_PreviousCandidate},
+    {Qt::Key_Mode_switch,   XK_Mode_switch},
+    {Qt::Key_Kanji, XK_Kanji},
+    {Qt::Key_Muhenkan,  XK_Muhenkan},
+    {Qt::Key_Henkan,    XK_Henkan},
+    {Qt::Key_Romaji,    XK_Romaji},
+    {Qt::Key_Hiragana,  XK_Hiragana},
+    {Qt::Key_Katakana,  XK_Katakana},
+    {Qt::Key_Hiragana_Katakana, XK_Hiragana_Katakana},
+    {Qt::Key_Zenkaku,   XK_Zenkaku},
+    {Qt::Key_Hankaku,   XK_Hankaku},
+    {Qt::Key_Zenkaku_Hankaku,   XK_Zenkaku_Hankaku},
+    {Qt::Key_Touroku,   XK_Touroku},
+    {Qt::Key_Massyo,    XK_Massyo},
+    {Qt::Key_Kana_Lock, XK_Kana_Lock},
+    {Qt::Key_Kana_Shift,    XK_Kana_Shift},
+    {Qt::Key_Eisu_Shift,    XK_Eisu_Shift},
+    {Qt::Key_Eisu_toggle,   XK_Eisu_toggle},
+    {Qt::Key_Hangul,    XK_Hangul},
+    {Qt::Key_Hangul_Start,  XK_Hangul_Start},
+    {Qt::Key_Hangul_End,    XK_Hangul_End},
+    {Qt::Key_Hangul_Hanja,  XK_Hangul_Hanja},
+    {Qt::Key_Hangul_Jamo,   XK_Hangul_Jamo},
+    {Qt::Key_Hangul_Romaja, XK_Hangul_Romaja},
+    {Qt::Key_Hangul_Jeonja, XK_Hangul_Jeonja},
+    {Qt::Key_Hangul_Banja,  XK_Hangul_Banja},
+    {Qt::Key_Hangul_PreHanja,   XK_Hangul_PreHanja},
+    {Qt::Key_Hangul_PostHanja,  XK_Hangul_PostHanja},
+    {Qt::Key_Hangul_Special,    XK_Hangul_Special},
+};
+
+#include <qstring.h>
+
+inline int map_sym_to_qt(uint keySym)
+{
+    if (keySym < 0x1000) {
+        if (keySym >= 'a' && keySym <= 'z')
+            return QChar(keySym).toUpper().unicode();
+        return keySym;
+    }
+#ifdef Q_WS_WIN
+    if (keySym < 0x3000)
+        return keySym;
+#else
+    if (keySym < 0x3000)
+        return keySym | Qt::UNICODE_ACCEL;
+
+    for (uint i = 0; i < sizeof(g_rgQtToSymX) / sizeof(TransKey); i++)
+        if (g_rgQtToSymX[i].keySymX == keySym)
+            return g_rgQtToSymX[i].keySymQt;
+#endif
+    return Qt::Key_unknown;
+}
+
+static bool symToKeyQt(uint keySym, int& keyQt)
+{
+    keyQt = map_sym_to_qt(keySym);
+    return (keyQt != Qt::Key_unknown);
+}
+
+#endif
diff --git a/src/plugins/platforminputcontexts/fcitx/keyuni.cpp b/src/plugins/platforminputcontexts/fcitx/keyuni.cpp
new file mode 100644
index 0000000..a4dec94
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/keyuni.cpp
@@ -0,0 +1,56 @@
+/***************************************************************************
+ *   Copyright (C) 2012~2013 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#include <stdint.h>
+#include "keyuni.h"
+#include "keydata.h"
+
+uint32_t
+FcitxKeySymToUnicode (uint32_t keyval)
+{
+    int min = 0;
+    int max = sizeof (gdk_keysym_to_unicode_tab) / sizeof(gdk_keysym_to_unicode_tab[0]) - 1;
+    int mid;
+
+    /* First check for Latin-1 characters (1:1 mapping) */
+    if ((keyval >= 0x0020 && keyval <= 0x007e) ||
+            (keyval >= 0x00a0 && keyval <= 0x00ff))
+        return keyval;
+
+    /* Also check for directly encoded 24-bit UCS characters:
+    */
+    if ((keyval & 0xff000000) == 0x01000000)
+        return keyval & 0x00ffffff;
+
+    /* binary search in table */
+    while (max >= min) {
+        mid = (min + max) / 2;
+        if (gdk_keysym_to_unicode_tab[mid].keysym < keyval)
+            min = mid + 1;
+        else if (gdk_keysym_to_unicode_tab[mid].keysym > keyval)
+            max = mid - 1;
+        else {
+            /* found it */
+            return gdk_keysym_to_unicode_tab[mid].ucs;
+        }
+    }
+
+    /* No matching Unicode value found */
+    return 0;
+}
diff --git a/src/plugins/platforminputcontexts/fcitx/keyuni.h b/src/plugins/platforminputcontexts/fcitx/keyuni.h
new file mode 100644
index 0000000..02af14d
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/keyuni.h
@@ -0,0 +1,29 @@
+/***************************************************************************
+ *   Copyright (C) 2012~2013 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#ifndef KEYUNI_H
+#define KEYUNI_H
+
+#include <qglobal.h>
+
+quint32
+FcitxKeySymToUnicode (quint32 keyval);
+
+
+#endif // KEYUNI_H
diff --git a/src/plugins/platforminputcontexts/fcitx/main.cpp b/src/plugins/platforminputcontexts/fcitx/main.cpp
new file mode 100644
index 0000000..d522818
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/main.cpp
@@ -0,0 +1,35 @@
+/***************************************************************************
+ *   Copyright (C) 2012~2013 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#include "main.h"
+
+
+QStringList QFcitxPlatformInputContextPlugin::keys() const
+{
+    return QStringList(QStringLiteral("fcitx"));
+
+}
+
+QFcitxPlatformInputContext *QFcitxPlatformInputContextPlugin::create(const QString& system, const QStringList& paramList)
+{
+    Q_UNUSED(paramList);
+    if (system.compare(system, QStringLiteral("fcitx"), Qt::CaseInsensitive) == 0)
+        return new QFcitxPlatformInputContext;
+    return 0;
+}
diff --git a/src/plugins/platforminputcontexts/fcitx/main.h b/src/plugins/platforminputcontexts/fcitx/main.h
new file mode 100644
index 0000000..9938da1
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/main.h
@@ -0,0 +1,37 @@
+/***************************************************************************
+ *   Copyright (C) 2012~2013 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#ifndef MAIN_H
+#define MAIN_H
+
+#include <qpa/qplatforminputcontextplugin_p.h>
+#include <QtCore/QStringList>
+
+#include "qfcitxplatforminputcontext.h"
+
+class QFcitxPlatformInputContextPlugin : public QPlatformInputContextPlugin
+{
+    Q_OBJECT
+public:
+    Q_PLUGIN_METADATA(IID QPlatformInputContextFactoryInterface_iid FILE "fcitx.json")
+    QStringList keys() const;
+    QFcitxPlatformInputContext *create(const QString& system, const QStringList& paramList);
+};
+
+#endif // MAIN_H
diff --git a/src/plugins/platforminputcontexts/fcitx/qfcitxplatforminputcontext.cpp b/src/plugins/platforminputcontexts/fcitx/qfcitxplatforminputcontext.cpp
new file mode 100644
index 0000000..adbf1bd
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/qfcitxplatforminputcontext.cpp
@@ -0,0 +1,770 @@
+/***************************************************************************
+ *   Copyright (C) 2011~2013 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#include <QKeyEvent>
+#include <QDBusConnection>
+#include <QGuiApplication>
+#include <QInputMethod>
+#include <QTextCharFormat>
+#include <QPalette>
+#include <QWindow>
+#include <qpa/qplatformscreen.h>
+#include <qpa/qplatformcursor.h>
+#include <qpa/qwindowsysteminterface.h>
+
+#include <unistd.h>
+#include <errno.h>
+#include <signal.h>
+
+#include "keyserver_x11.h"
+
+#include "qfcitxplatforminputcontext.h"
+#include "fcitxqtinputcontextproxy.h"
+#include "fcitxqtinputmethodproxy.h"
+#include "fcitxqtconnection.h"
+#include "keyuni.h"
+#include "utils.h"
+
+static bool key_filtered = false;
+
+static bool
+get_boolean_env(const char *name,
+                 bool defval)
+{
+    const char *value = getenv(name);
+
+    if (value == NULL)
+        return defval;
+
+    if (strcmp(value, "") == 0 ||
+        strcmp(value, "0") == 0 ||
+        strcmp(value, "false") == 0 ||
+        strcmp(value, "False") == 0 ||
+        strcmp(value, "FALSE") == 0)
+        return false;
+
+    return true;
+}
+
+static inline const char*
+get_locale()
+{
+    const char* locale = getenv("LC_ALL");
+    if (!locale)
+        locale = getenv("LC_CTYPE");
+    if (!locale)
+        locale = getenv("LANG");
+    if (!locale)
+        locale = "C";
+
+    return locale;
+}
+
+struct xkb_context* _xkb_context_new_helper()
+{
+    struct xkb_context* context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
+    if (context) {
+        xkb_context_set_log_level(context, XKB_LOG_LEVEL_CRITICAL);
+    }
+
+    return context;
+}
+
+QFcitxPlatformInputContext::QFcitxPlatformInputContext() :
+    m_connection(new FcitxQtConnection(this)),
+    m_improxy(0),
+    m_n_compose(0),
+    m_cursorPos(0),
+    m_useSurroundingText(false),
+    m_syncMode(true),
+    m_lastWId(0),
+    m_destroy(false),
+    m_xkbContext(_xkb_context_new_helper()),
+    m_xkbComposeTable(m_xkbContext ? xkb_compose_table_new_from_locale(m_xkbContext.data(), get_locale(), XKB_COMPOSE_COMPILE_NO_FLAGS) : 0),
+    m_xkbComposeState(m_xkbComposeTable ? xkb_compose_state_new(m_xkbComposeTable.data(), XKB_COMPOSE_STATE_NO_FLAGS) : 0)
+{
+    FcitxQtFormattedPreedit::registerMetaType();
+
+    memset(m_compose_buffer, 0, sizeof(uint) * (MAX_COMPOSE_LEN + 1));
+    connect(m_connection, SIGNAL(connected()), this, SLOT(connected()));
+    connect(m_connection, SIGNAL(disconnected()), this, SLOT(cleanUp()));
+
+    m_connection->startConnection();
+}
+
+QFcitxPlatformInputContext::~QFcitxPlatformInputContext()
+{
+    m_destroy = true;
+    cleanUp();
+}
+
+void QFcitxPlatformInputContext::connected()
+{
+    if (!m_connection->isConnected())
+        return;
+
+    // qDebug() << "create Input Context" << m_connection->name();
+    if (m_improxy) {
+        delete m_improxy;
+        m_improxy = 0;
+    }
+    m_improxy = new FcitxQtInputMethodProxy(m_connection->serviceName(), QLatin1String("/inputmethod"), *m_connection->connection(), this);
+
+    QWindow* w = qApp->focusWindow();
+    if (w)
+        createICData(w);
+}
+
+void QFcitxPlatformInputContext::cleanUp()
+{
+    for(QHash<WId, FcitxQtICData *>::const_iterator i = m_icMap.constBegin(),
+                                             e = m_icMap.constEnd(); i != e; ++i) {
+        FcitxQtICData* data = i.value();
+
+        if (data->proxy)
+            delete data->proxy;
+    }
+
+    m_icMap.clear();
+
+    if (m_improxy) {
+        delete m_improxy;
+        m_improxy = 0;
+    }
+
+    if (!m_destroy) {
+        commitPreedit();
+    }
+}
+
+bool QFcitxPlatformInputContext::isValid() const
+{
+    return true;
+}
+
+void QFcitxPlatformInputContext::invokeAction(QInputMethod::Action action, int cursorPosition)
+{
+    if (action == QInputMethod::Click
+        && (cursorPosition <= 0 || cursorPosition >= m_preedit.length())
+    )
+    {
+        // qDebug() << action << cursorPosition;
+        commitPreedit();
+    }
+}
+
+void QFcitxPlatformInputContext::commitPreedit()
+{
+    QObject *input = qApp->focusObject();
+    if (!input)
+        return;
+    if (m_commitPreedit.length() <= 0)
+        return;
+    QInputMethodEvent e;
+    e.setCommitString(m_commitPreedit);
+    QCoreApplication::sendEvent(input, &e);
+    m_commitPreedit.clear();
+}
+
+
+void QFcitxPlatformInputContext::reset()
+{
+    commitPreedit();
+    FcitxQtInputContextProxy* proxy = validIC();
+    if (proxy)
+        proxy->Reset();
+    if (m_xkbComposeState) {
+        xkb_compose_state_reset(m_xkbComposeState.data());
+    }
+    QPlatformInputContext::reset();
+}
+
+void QFcitxPlatformInputContext::update(Qt::InputMethodQueries queries )
+{
+    QWindow* window = qApp->focusWindow();
+    FcitxQtInputContextProxy* proxy = validICByWindow(window);
+    if (!proxy)
+        return;
+
+    FcitxQtICData* data = m_icMap.value(window->winId());
+
+    QInputMethod *method = qApp->inputMethod();
+    QObject *input = qApp->focusObject();
+    if (!input)
+        return;
+
+    QInputMethodQueryEvent query(queries);
+    QGuiApplication::sendEvent(input, &query);
+
+    if (queries & Qt::ImCursorRectangle) {
+        cursorRectChanged();
+    }
+
+    if (queries & Qt::ImHints) {
+        Qt::InputMethodHints hints = Qt::InputMethodHints(query.value(Qt::ImHints).toUInt());
+
+
+#define CHECK_HINTS(_HINTS, _CAPACITY) \
+    if (hints & _HINTS) \
+        addCapacity(data, _CAPACITY); \
+    else \
+        removeCapacity(data, _CAPACITY);
+
+        CHECK_HINTS(Qt::ImhNoAutoUppercase, CAPACITY_NOAUTOUPPERCASE)
+        CHECK_HINTS(Qt::ImhPreferNumbers, CAPACITY_NUMBER)
+        CHECK_HINTS(Qt::ImhPreferUppercase, CAPACITY_UPPERCASE)
+        CHECK_HINTS(Qt::ImhPreferLowercase, CAPACITY_LOWERCASE)
+        CHECK_HINTS(Qt::ImhNoPredictiveText, CAPACITY_NO_SPELLCHECK)
+        CHECK_HINTS(Qt::ImhDigitsOnly, CAPACITY_DIGIT)
+        CHECK_HINTS(Qt::ImhFormattedNumbersOnly, CAPACITY_NUMBER)
+        CHECK_HINTS(Qt::ImhUppercaseOnly, CAPACITY_UPPERCASE)
+        CHECK_HINTS(Qt::ImhLowercaseOnly, CAPACITY_LOWERCASE)
+        CHECK_HINTS(Qt::ImhDialableCharactersOnly, CAPACITY_DIALABLE)
+        CHECK_HINTS(Qt::ImhEmailCharactersOnly, CAPACITY_EMAIL)
+    }
+
+    bool setSurrounding = false;
+    do {
+        if (!m_useSurroundingText)
+            break;
+        if (!((queries & Qt::ImSurroundingText) && (queries & Qt::ImCursorPosition)))
+            break;
+        if (data->capacity.testFlag(CAPACITY_PASSWORD))
+            break;
+        QVariant var = query.value(Qt::ImSurroundingText);
+        QVariant var1 = query.value(Qt::ImCursorPosition);
+        QVariant var2 = query.value(Qt::ImAnchorPosition);
+        if (!var.isValid() || !var1.isValid())
+            break;
+        QString text = var.toString();
+        /* we don't want to waste too much memory here */
+#define SURROUNDING_THRESHOLD 4096
+        if (text.length() < SURROUNDING_THRESHOLD) {
+            if (_utf8_check_string(text.toUtf8().data())) {
+                addCapacity(data, CAPACITY_SURROUNDING_TEXT);
+
+                int cursor = var1.toInt();
+                int anchor;
+                if (var2.isValid())
+                    anchor = var2.toInt();
+                else
+                    anchor = cursor;
+                if (data->surroundingText != text) {
+                    data->surroundingText = text;
+                    proxy->SetSurroundingText(text, cursor, anchor);
+                }
+                else {
+                    if (data->surroundingAnchor != anchor ||
+                        data->surroundingCursor != cursor)
+                        proxy->SetSurroundingTextPosition(cursor, anchor);
+                }
+                data->surroundingCursor = cursor;
+                data->surroundingAnchor = anchor;
+                setSurrounding = true;
+            }
+        }
+        if (!setSurrounding) {
+            data->surroundingAnchor = -1;
+            data->surroundingCursor = -1;
+            data->surroundingText = QString::null;
+            removeCapacity(data, CAPACITY_SURROUNDING_TEXT);
+        }
+    } while(0);
+}
+
+void QFcitxPlatformInputContext::commit()
+{
+    QPlatformInputContext::commit();
+}
+
+void QFcitxPlatformInputContext::setFocusObject(QObject* object)
+{
+    FcitxQtInputContextProxy* proxy = validICByWId(m_lastWId);
+    if (proxy) {
+        proxy->FocusOut();
+    }
+
+    QWindow *window = qApp->focusWindow();
+    if (window) {
+        m_lastWId = window->winId();
+    } else {
+        m_lastWId = 0;
+        return;
+    }
+    proxy = validICByWindow(window);
+    if (proxy)
+        proxy->FocusIn();
+    else {
+        FcitxQtICData* data = m_icMap.value(window->winId());
+        if (!data) {
+            createICData(window);
+            return;
+        }
+    }
+}
+
+void QFcitxPlatformInputContext::windowDestroyed(QObject* object)
+{
+    /* access QWindow is not possible here, so we use our own map to do so */
+    WId wid = m_windowToWidMap.take(object);
+    if (!wid)
+        return;
+    FcitxQtICData* data = m_icMap.take(wid);
+    if (!data)
+        return;
+
+    delete data;
+    // qDebug() << "Window Destroyed and we destroy IC correctly, horray!";
+}
+
+void QFcitxPlatformInputContext::cursorRectChanged()
+{
+    QWindow *inputWindow = qApp->focusWindow();
+    if (!inputWindow)
+        return;
+    FcitxQtInputContextProxy* proxy = validICByWindow(inputWindow);
+    if (!proxy)
+        return;
+
+    FcitxQtICData* data = m_icMap.value(inputWindow->winId());
+
+    QRect r = qApp->inputMethod()->cursorRectangle().toRect();
+    if(!r.isValid())
+        return;
+
+    r.moveTopLeft(inputWindow->mapToGlobal(r.topLeft()));
+
+    qreal scale = inputWindow->devicePixelRatio();
+    if (data->rect != r) {
+        data->rect = r;
+        proxy->SetCursorRect(r.x() * scale, r.y() * scale,
+                             r.width() * scale, r.height() * scale);
+    }
+}
+
+void QFcitxPlatformInputContext::createInputContext(WId w)
+{
+    if (!m_connection->isConnected())
+        return;
+
+    // qDebug() << "create Input Context" << m_connection->connection()->name();
+
+    if (m_improxy) {
+        delete m_improxy;
+        m_improxy = NULL;
+    }
+    m_improxy = new FcitxQtInputMethodProxy(m_connection->serviceName(), QLatin1String("/inputmethod"), *m_connection->connection(), this);
+
+    if (!m_improxy->isValid())
+        return;
+
+    QFileInfo info(QCoreApplication::applicationFilePath());
+    QDBusPendingReply< int, bool, uint, uint, uint, uint > result = m_improxy->CreateICv3(info.fileName(), QCoreApplication::applicationPid());
+    QDBusPendingCallWatcher* watcher = new QDBusPendingCallWatcher(result);
+    watcher->setProperty("wid", (qulonglong) w);
+    connect(watcher, SIGNAL(finished(QDBusPendingCallWatcher*)), this, SLOT(createInputContextFinished(QDBusPendingCallWatcher*)));
+}
+
+void QFcitxPlatformInputContext::createInputContextFinished(QDBusPendingCallWatcher* watcher)
+{
+    WId w = watcher->property("wid").toULongLong();
+    FcitxQtICData* data = m_icMap.value(w);
+    if (!data)
+        return;
+
+    QDBusPendingReply< int, bool, uint, uint, uint, uint > result = *watcher;
+
+    do {
+        if (result.isError()) {
+            break;
+        }
+
+        if (!m_connection->isConnected())
+            break;
+
+        int id = qdbus_cast<int>(result.argumentAt(0));
+        QString path = QString("/inputcontext_%1").arg(id);
+        if (data->proxy) {
+            delete data->proxy;
+        }
+        data->proxy = new FcitxQtInputContextProxy(m_connection->serviceName(), path, *m_connection->connection(), this);
+        connect(data->proxy, SIGNAL(CommitString(QString)), this, SLOT(commitString(QString)));
+        connect(data->proxy, SIGNAL(ForwardKey(uint, uint, int)), this, SLOT(forwardKey(uint, uint, int)));
+        connect(data->proxy, SIGNAL(UpdateFormattedPreedit(FcitxQtFormattedPreeditList,int)), this, SLOT(updateFormattedPreedit(FcitxQtFormattedPreeditList,int)));
+        connect(data->proxy, SIGNAL(DeleteSurroundingText(int,uint)), this, SLOT(deleteSurroundingText(int,uint)));
+
+        if (data->proxy->isValid()) {
+            QWindow* window = qApp->focusWindow();
+            if (window && window->winId() == w)
+                data->proxy->FocusIn();
+        }
+
+        QFlags<FcitxCapacityFlags> flag;
+        flag |= CAPACITY_PREEDIT;
+        flag |= CAPACITY_FORMATTED_PREEDIT;
+        flag |= CAPACITY_CLIENT_UNFOCUS_COMMIT;
+        m_useSurroundingText = get_boolean_env("FCITX_QT_ENABLE_SURROUNDING_TEXT", true);
+        if (m_useSurroundingText)
+            flag |= CAPACITY_SURROUNDING_TEXT;
+
+        /*
+         * event loop will cause some problem, so we tries to use async way.
+         */
+        m_syncMode = get_boolean_env("FCITX_QT_USE_SYNC", false);
+
+        addCapacity(data, flag, true);
+    } while(0);
+    delete watcher;
+}
+
+void QFcitxPlatformInputContext::updateCapacity(FcitxQtICData* data)
+{
+    if (!data->proxy || !data->proxy->isValid())
+        return;
+
+    QDBusPendingReply< void > result = data->proxy->SetCapacity((uint) data->capacity);
+}
+
+void QFcitxPlatformInputContext::commitString(const QString& str)
+{
+    m_cursorPos = 0;
+    m_preeditList.clear();
+    m_commitPreedit.clear();
+    QObject *input = qApp->focusObject();
+    if (!input)
+        return;
+
+    QInputMethodEvent event;
+    event.setCommitString(str);
+    QCoreApplication::sendEvent(input, &event);
+}
+
+void QFcitxPlatformInputContext::updateFormattedPreedit(const FcitxQtFormattedPreeditList& preeditList, int cursorPos)
+{
+    QObject *input = qApp->focusObject();
+    if (!input)
+        return;
+    if (cursorPos == m_cursorPos && preeditList == m_preeditList)
+        return;
+    m_preeditList = preeditList;
+    m_cursorPos = cursorPos;
+    QString str, commitStr;
+    int pos = 0;
+    QList<QInputMethodEvent::Attribute> attrList;
+    Q_FOREACH(const FcitxQtFormattedPreedit& preedit, preeditList)
+    {
+        str += preedit.string();
+        if (!(preedit.format() & MSG_DONOT_COMMIT_WHEN_UNFOCUS))
+            commitStr += preedit.string();
+        QTextCharFormat format;
+        if ((preedit.format() & MSG_NOUNDERLINE) == 0) {
+            format.setUnderlineStyle(QTextCharFormat::DashUnderline);
+        }
+        if (preedit.format() & MSG_HIGHLIGHT) {
+            QBrush brush;
+            QPalette palette;
+            palette = QGuiApplication::palette();
+            format.setBackground(QBrush(QColor(palette.color(QPalette::Active, QPalette::Highlight))));
+            format.setForeground(QBrush(QColor(palette.color(QPalette::Active, QPalette::HighlightedText))));
+        }
+        attrList.append(QInputMethodEvent::Attribute(QInputMethodEvent::TextFormat, pos, preedit.string().length(), format));
+        pos += preedit.string().length();
+    }
+
+    QByteArray array = str.toUtf8();
+    array.truncate(cursorPos);
+    cursorPos = QString::fromUtf8(array).length();
+
+    attrList.append(QInputMethodEvent::Attribute(QInputMethodEvent::Cursor, cursorPos, 1, 0));
+    m_preedit = str;
+    m_commitPreedit = commitStr;
+    QInputMethodEvent event(str, attrList);
+    QCoreApplication::sendEvent(input, &event);
+    update(Qt::ImCursorRectangle);
+}
+
+void QFcitxPlatformInputContext::deleteSurroundingText(int offset, uint nchar)
+{
+    QObject *input = qApp->focusObject();
+    if (!input)
+        return;
+
+    QInputMethodEvent event;
+    event.setCommitString("", offset, nchar);
+    QCoreApplication::sendEvent(input, &event);
+}
+
+void QFcitxPlatformInputContext::forwardKey(uint keyval, uint state, int type)
+{
+    QObject *input = qApp->focusObject();
+    if (input != NULL) {
+        key_filtered = true;
+        QKeyEvent *keyevent = createKeyEvent(keyval, state, type);
+        QCoreApplication::sendEvent(input, keyevent);
+        delete keyevent;
+        key_filtered = false;
+    }
+}
+
+void QFcitxPlatformInputContext::createICData(QWindow* w)
+{
+    FcitxQtICData* data = m_icMap.value(w->winId());
+    if (!data) {
+        data = new FcitxQtICData;
+        m_icMap[w->winId()] = data;
+        m_windowToWidMap[w] = w->winId();
+        connect(w, SIGNAL(destroyed(QObject*)), this, SLOT(windowDestroyed(QObject*)));
+    }
+    createInputContext(w->winId());
+}
+
+QKeyEvent* QFcitxPlatformInputContext::createKeyEvent(uint keyval, uint state, int type)
+{
+    Qt::KeyboardModifiers qstate = Qt::NoModifier;
+
+    int count = 1;
+    if (state & FcitxKeyState_Alt) {
+        qstate |= Qt::AltModifier;
+        count ++;
+    }
+
+    if (state & FcitxKeyState_Shift) {
+        qstate |= Qt::ShiftModifier;
+        count ++;
+    }
+
+    if (state & FcitxKeyState_Ctrl) {
+        qstate |= Qt::ControlModifier;
+        count ++;
+    }
+
+    int key;
+    symToKeyQt(keyval, key);
+
+    QKeyEvent* keyevent = new QKeyEvent(
+        (type == FCITX_PRESS_KEY) ? (QEvent::KeyPress) : (QEvent::KeyRelease),
+        key,
+        qstate,
+        QString(),
+        false,
+        count
+    );
+
+    return keyevent;
+}
+
+bool QFcitxPlatformInputContext::filterEvent(const QEvent* event)
+{
+    do {
+        if (event->type() != QEvent::KeyPress && event->type() != QEvent::KeyRelease) {
+            break;
+        }
+
+        const QKeyEvent* keyEvent = static_cast<const QKeyEvent*>(event);
+        quint32 keyval = keyEvent->nativeVirtualKey();
+        quint32 keycode = keyEvent->nativeScanCode();
+        quint32 state = keyEvent->nativeModifiers();
+        bool press = keyEvent->type() == QEvent::KeyPress;
+
+        if (key_filtered) {
+            break;
+        }
+
+        if (!inputMethodAccepted())
+            break;
+
+        QObject *input = qApp->focusObject();
+
+        if (!input) {
+            break;
+        }
+
+        FcitxQtInputContextProxy* proxy = validICByWindow(qApp->focusWindow());
+
+        if (!proxy) {
+            if (filterEventFallback(keyval, keycode, state, press)) {
+                return true;
+            } else {
+                break;
+            }
+        }
+
+        proxy->FocusIn();
+
+        QDBusPendingReply< int > reply = proxy->ProcessKeyEvent(keyval,
+                                                                keycode,
+                                                                state,
+                                                                (press) ? FCITX_PRESS_KEY : FCITX_RELEASE_KEY,
+                                                                QDateTime::currentDateTime().toTime_t());
+
+
+        if (Q_UNLIKELY(m_syncMode)) {
+            reply.waitForFinished();
+
+            if (!m_connection->isConnected() || !reply.isFinished() || reply.isError() || reply.value() <= 0) {
+                if (filterEventFallback(keyval, keycode, state, press)) {
+                    return true;
+                } else {
+                    break;
+                }
+            } else {
+                update(Qt::ImCursorRectangle);
+                return true;
+            }
+        }
+        else {
+            ProcessKeyWatcher* watcher = new ProcessKeyWatcher(*keyEvent, qApp->focusWindow(), reply, this);
+            connect(watcher, SIGNAL(finished(QDBusPendingCallWatcher*)),
+                    this, SLOT(processKeyEventFinished(QDBusPendingCallWatcher*)));
+            return true;
+        }
+    } while(0);
+    return QPlatformInputContext::filterEvent(event);
+}
+
+void QFcitxPlatformInputContext::processKeyEventFinished(QDBusPendingCallWatcher* w)
+{
+    ProcessKeyWatcher* watcher = static_cast<ProcessKeyWatcher*>(w);
+    QDBusPendingReply< int > result(*watcher);
+    bool filtered = false;
+
+    QWindow* window = watcher->window();
+    // if window is already destroyed, we can only throw this event away.
+    if (!window) {
+        return;
+    }
+
+    const QKeyEvent& keyEvent = watcher->event();
+
+    // use same variable name as in QXcbKeyboard::handleKeyEvent
+    QEvent::Type type = keyEvent.type();
+    int qtcode = keyEvent.key();
+    Qt::KeyboardModifiers modifiers = keyEvent.modifiers();
+    quint32 code = keyEvent.nativeScanCode();
+    quint32 sym = keyEvent.nativeVirtualKey();
+    quint32 state = keyEvent.nativeModifiers();
+    QString string = keyEvent.text();
+    bool isAutoRepeat = keyEvent.isAutoRepeat();
+    ulong time = keyEvent.timestamp();
+
+    if (result.isError() || result.value() <= 0) {
+        filtered = filterEventFallback(sym, code, state, type == QEvent::KeyPress);
+    } else {
+        filtered = true;
+    }
+
+    if (!result.isError()) {
+        update(Qt::ImCursorRectangle);
+    }
+
+    if (!filtered) {
+        // copied from QXcbKeyboard::handleKeyEvent()
+        if (type == QEvent::KeyPress && qtcode == Qt::Key_Menu) {
+            const QPoint globalPos = window->screen()->handle()->cursor()->pos();
+            const QPoint pos = window->mapFromGlobal(globalPos);            QWindowSystemInterface::handleContextMenuEvent(window, false, pos, globalPos, modifiers);
+        }
+        QWindowSystemInterface::handleExtendedKeyEvent(window, time, type, qtcode, modifiers,
+                                                       code, sym, state, string, isAutoRepeat);
+    }
+
+    delete watcher;
+}
+
+
+bool QFcitxPlatformInputContext::filterEventFallback(uint keyval, uint keycode, uint state, bool press)
+{
+    Q_UNUSED(keycode);
+    if (processCompose(keyval, state, (press) ? FCITX_PRESS_KEY : FCITX_RELEASE_KEY)) {
+        return true;
+    }
+    return false;
+}
+
+FcitxQtInputContextProxy* QFcitxPlatformInputContext::validIC()
+{
+    if (m_icMap.isEmpty()) {
+        return 0;
+    }
+    QWindow* window = qApp->focusWindow();
+    return validICByWindow(window);
+}
+
+FcitxQtInputContextProxy* QFcitxPlatformInputContext::validICByWId(WId wid)
+{
+    if (m_icMap.isEmpty()) {
+        return 0;
+    }
+    FcitxQtICData* icData = m_icMap.value(wid);
+    if (!icData)
+        return 0;
+    if (icData->proxy.isNull()) {
+        return 0;
+    } else if (icData->proxy->isValid()) {
+        return icData->proxy.data();
+    }
+    return 0;
+}
+
+FcitxQtInputContextProxy* QFcitxPlatformInputContext::validICByWindow(QWindow* w)
+{
+    if (!w) {
+        return 0;
+    }
+
+    if (m_icMap.isEmpty()) {
+        return 0;
+    }
+    return validICByWId(w->winId());
+}
+
+
+bool QFcitxPlatformInputContext::processCompose(uint keyval, uint state, FcitxKeyEventType event)
+{
+    Q_UNUSED(state);
+
+    if (!m_xkbComposeTable || event == FCITX_RELEASE_KEY)
+        return false;
+
+    struct xkb_compose_state* xkbComposeState = m_xkbComposeState.data();
+
+    enum xkb_compose_feed_result result = xkb_compose_state_feed(xkbComposeState, keyval);
+    if (result == XKB_COMPOSE_FEED_IGNORED) {
+        return false;
+    }
+
+    enum xkb_compose_status status = xkb_compose_state_get_status(xkbComposeState);
+    if (status == XKB_COMPOSE_NOTHING) {
+        return 0;
+    } else if (status == XKB_COMPOSE_COMPOSED) {
+        char buffer[] = {'\0', '\0', '\0', '\0', '\0', '\0', '\0'};
+        int length = xkb_compose_state_get_utf8(xkbComposeState, buffer, sizeof(buffer));
+        xkb_compose_state_reset(xkbComposeState);
+        if (length != 0) {
+            commitString(QString::fromUtf8(buffer));
+        }
+
+    } else if (status == XKB_COMPOSE_CANCELLED) {
+        xkb_compose_state_reset(xkbComposeState);
+    }
+
+    return true;
+}
+
+
+// kate: indent-mode cstyle; space-indent on; indent-width 0;
diff --git a/src/plugins/platforminputcontexts/fcitx/qfcitxplatforminputcontext.h b/src/plugins/platforminputcontexts/fcitx/qfcitxplatforminputcontext.h
new file mode 100644
index 0000000..1371278
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/qfcitxplatforminputcontext.h
@@ -0,0 +1,269 @@
+/***************************************************************************
+ *   Copyright (C) 2012~2013 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#ifndef QFCITXPLATFORMINPUTCONTEXT_H
+#define QFCITXPLATFORMINPUTCONTEXT_H
+
+#include <qpa/qplatforminputcontext.h>
+#include <QWindow>
+#include <QKeyEvent>
+#include <QDBusConnection>
+#include <QDBusServiceWatcher>
+#include <QPointer>
+#include <QFileSystemWatcher>
+#include <QRect>
+#include <xkbcommon/xkbcommon-compose.h>
+#include "fcitxqtformattedpreedit.h"
+#include "fcitxqtinputcontextproxy.h"
+
+#define MAX_COMPOSE_LEN 7
+
+class FcitxQtConnection;
+class QFileSystemWatcher;
+enum FcitxKeyEventType {
+    FCITX_PRESS_KEY,
+    FCITX_RELEASE_KEY
+};
+
+enum FcitxCapacityFlags {
+    CAPACITY_NONE = 0,
+    CAPACITY_CLIENT_SIDE_UI = (1 << 0),
+    CAPACITY_PREEDIT = (1 << 1),
+    CAPACITY_CLIENT_SIDE_CONTROL_STATE =  (1 << 2),
+    CAPACITY_PASSWORD = (1 << 3),
+    CAPACITY_FORMATTED_PREEDIT = (1 << 4),
+    CAPACITY_CLIENT_UNFOCUS_COMMIT = (1 << 5),
+    CAPACITY_SURROUNDING_TEXT = (1 << 6),
+    CAPACITY_EMAIL = (1 << 7),
+    CAPACITY_DIGIT = (1 << 8),
+    CAPACITY_UPPERCASE = (1 << 9),
+    CAPACITY_LOWERCASE = (1 << 10),
+    CAPACITY_NOAUTOUPPERCASE = (1 << 11),
+    CAPACITY_URL = (1 << 12),
+    CAPACITY_DIALABLE = (1 << 13),
+    CAPACITY_NUMBER = (1 << 14),
+    CAPACITY_NO_ON_SCREEN_KEYBOARD = (1 << 15),
+    CAPACITY_SPELLCHECK = (1 << 16),
+    CAPACITY_NO_SPELLCHECK = (1 << 17),
+    CAPACITY_WORD_COMPLETION = (1 << 18),
+    CAPACITY_UPPERCASE_WORDS = (1 << 19),
+    CAPACITY_UPPERCASE_SENTENCES = (1 << 20),
+    CAPACITY_ALPHA = (1 << 21),
+    CAPACITY_NAME = (1 << 22)
+} ;
+
+/** message type and flags */
+enum FcitxMessageType {
+    MSG_TYPE_FIRST = 0,
+    MSG_TYPE_LAST = 6,
+    MSG_TIPS = 0,           /**< Hint Text */
+    MSG_INPUT = 1,          /**< User Input */
+    MSG_INDEX = 2,          /**< Index Number */
+    MSG_FIRSTCAND = 3,      /**< First candidate */
+    MSG_USERPHR = 4,        /**< User Phrase */
+    MSG_CODE = 5,           /**< Typed character */
+    MSG_OTHER = 6,          /**< Other Text */
+    MSG_NOUNDERLINE = (1 << 3), /**< backward compatible, no underline is a flag */
+    MSG_HIGHLIGHT = (1 << 4), /**< highlight the preedit */
+    MSG_DONOT_COMMIT_WHEN_UNFOCUS = (1 << 5), /**< backward compatible */
+    MSG_REGULAR_MASK = 0x7 /**< regular color type mask */
+};
+
+
+enum FcitxKeyState {
+    FcitxKeyState_None = 0,
+    FcitxKeyState_Shift = 1 << 0,
+    FcitxKeyState_CapsLock = 1 << 1,
+    FcitxKeyState_Ctrl = 1 << 2,
+    FcitxKeyState_Alt = 1 << 3,
+    FcitxKeyState_Alt_Shift = FcitxKeyState_Alt | FcitxKeyState_Shift,
+    FcitxKeyState_Ctrl_Shift = FcitxKeyState_Ctrl | FcitxKeyState_Shift,
+    FcitxKeyState_Ctrl_Alt = FcitxKeyState_Ctrl | FcitxKeyState_Alt,
+    FcitxKeyState_Ctrl_Alt_Shift = FcitxKeyState_Ctrl | FcitxKeyState_Alt | FcitxKeyState_Shift,
+    FcitxKeyState_NumLock = 1 << 4,
+    FcitxKeyState_Super = 1 << 6,
+    FcitxKeyState_ScrollLock = 1 << 7,
+    FcitxKeyState_MousePressed = 1 << 8,
+    FcitxKeyState_HandledMask = 1 << 24,
+    FcitxKeyState_IgnoredMask = 1 << 25,
+    FcitxKeyState_Super2    = 1 << 26,
+    FcitxKeyState_Hyper    = 1 << 27,
+    FcitxKeyState_Meta     = 1 << 28,
+    FcitxKeyState_UsedMask = 0x5c001fff
+};
+
+struct FcitxQtICData {
+    FcitxQtICData() : capacity(0), proxy(0), surroundingAnchor(-1), surroundingCursor(-1) {}
+    ~FcitxQtICData() {
+        if (proxy && proxy->isValid()) {
+            proxy->DestroyIC();
+            delete proxy;
+        }
+    }
+    QFlags<FcitxCapacityFlags> capacity;
+    QPointer<FcitxQtInputContextProxy> proxy;
+    QRect rect;
+    QString surroundingText;
+    int surroundingAnchor;
+    int surroundingCursor;
+};
+
+
+class ProcessKeyWatcher : public QDBusPendingCallWatcher
+{
+    Q_OBJECT
+public:
+    ProcessKeyWatcher(const QKeyEvent& event, QWindow* window, const QDBusPendingCall &call, QObject *parent = 0) :
+        QDBusPendingCallWatcher(call, parent)
+       ,m_event(event.type(), event.key(), event.modifiers(),
+                event.nativeScanCode(), event.nativeVirtualKey(), event.nativeModifiers(),
+                event.text(), event.isAutoRepeat(), event.count())
+       ,m_window(window)
+    {
+    }
+
+    virtual ~ProcessKeyWatcher() {
+    }
+
+    const QKeyEvent& event() {
+        return m_event;
+    }
+
+    QWindow* window() {
+        return m_window.data();
+    }
+
+private:
+    QKeyEvent m_event;
+    QPointer<QWindow> m_window;
+};
+
+struct XkbContextDeleter
+{
+    static inline void cleanup(struct xkb_context* pointer)
+    {
+        if (pointer) xkb_context_unref(pointer);
+    }
+};
+
+struct XkbComposeTableDeleter
+{
+    static inline void cleanup(struct xkb_compose_table* pointer)
+    {
+        if (pointer) xkb_compose_table_unref(pointer);
+    }
+};
+
+struct XkbComposeStateDeleter
+{
+    static inline void cleanup(struct xkb_compose_state* pointer)
+    {
+        if (pointer) xkb_compose_state_unref(pointer);
+    }
+};
+
+class FcitxQtInputMethodProxy;
+
+class QFcitxPlatformInputContext : public QPlatformInputContext
+{
+    Q_OBJECT
+public:
+    QFcitxPlatformInputContext();
+    virtual ~QFcitxPlatformInputContext();
+
+    virtual bool filterEvent(const QEvent* event);
+    virtual bool isValid() const;
+    virtual void invokeAction(QInputMethod::Action , int cursorPosition);
+    virtual void reset();
+    virtual void commit();
+    virtual void update(Qt::InputMethodQueries quries );
+    virtual void setFocusObject(QObject* object);
+
+
+public Q_SLOTS:
+    void cursorRectChanged();
+    void commitString(const QString& str);
+    void updateFormattedPreedit(const FcitxQtFormattedPreeditList& preeditList, int cursorPos);
+    void deleteSurroundingText(int offset, uint nchar);
+    void forwardKey(uint keyval, uint state, int type);
+    void createInputContextFinished(QDBusPendingCallWatcher* watcher);
+    void connected();
+    void cleanUp();
+    void windowDestroyed(QObject* object);
+
+
+private:
+    void createInputContext(WId w);
+    bool processCompose(uint keyval, uint state, FcitxKeyEventType event);
+    bool checkAlgorithmically();
+    bool checkCompactTable(const struct _FcitxComposeTableCompact *table);
+    QKeyEvent* createKeyEvent(uint keyval, uint state, int type);
+
+
+    void addCapacity(FcitxQtICData* data, QFlags<FcitxCapacityFlags> capacity, bool forceUpdate = false)
+    {
+        QFlags< FcitxCapacityFlags > newcaps = data->capacity | capacity;
+        if (data->capacity != newcaps || forceUpdate) {
+            data->capacity = newcaps;
+            updateCapacity(data);
+        }
+    }
+
+    void removeCapacity(FcitxQtICData* data, QFlags<FcitxCapacityFlags> capacity, bool forceUpdate = false)
+    {
+        QFlags< FcitxCapacityFlags > newcaps = data->capacity & (~capacity);
+        if (data->capacity != newcaps || forceUpdate) {
+            data->capacity = newcaps;
+            updateCapacity(data);
+        }
+    }
+
+    void updateCapacity(FcitxQtICData* data);
+    void commitPreedit();
+    void createICData(QWindow* w);
+    FcitxQtInputContextProxy* validIC();
+    FcitxQtInputContextProxy* validICByWindow(QWindow* window);
+    FcitxQtInputContextProxy* validICByWId(WId wid);
+    bool filterEventFallback(uint keyval, uint keycode, uint state, bool press);
+
+    FcitxQtInputMethodProxy* m_improxy;
+    uint m_compose_buffer[MAX_COMPOSE_LEN + 1];
+    int m_n_compose;
+    QString m_preedit;
+    QString m_commitPreedit;
+    FcitxQtFormattedPreeditList m_preeditList;
+    int m_cursorPos;
+    bool m_useSurroundingText;
+    bool m_syncMode;
+    FcitxQtConnection* m_connection;
+    QString m_lastSurroundingText;
+    int m_lastSurroundingAnchor;
+    int m_lastSurroundingCursor;
+    QHash<WId, FcitxQtICData*> m_icMap;
+    QHash<QObject*, WId> m_windowToWidMap;
+    WId m_lastWId;
+    bool m_destroy;
+    QScopedPointer<struct xkb_context, XkbContextDeleter> m_xkbContext;
+    QScopedPointer<struct xkb_compose_table, XkbComposeTableDeleter>  m_xkbComposeTable;
+    QScopedPointer<struct xkb_compose_state, XkbComposeStateDeleter> m_xkbComposeState;
+private slots:
+    void processKeyEventFinished(QDBusPendingCallWatcher*);
+};
+
+#endif // QFCITXPLATFORMINPUTCONTEXT_H
diff --git a/src/plugins/platforminputcontexts/fcitx/utils.cpp b/src/plugins/platforminputcontexts/fcitx/utils.cpp
new file mode 100644
index 0000000..fe4eda1
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/utils.cpp
@@ -0,0 +1,177 @@
+/***************************************************************************
+ *   Copyright (C) 2012~2013 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#include "utils.h"
+/** check utf8 character */
+#define ISUTF8_CB(c)  (((c)&0xc0) == 0x80)
+
+#define CONT(i)   ISUTF8_CB(in[i])
+#define VAL(i, s) ((in[i]&0x3f) << s)
+
+#define UTF8_LENGTH(Char)                       \
+    ((Char) < 0x80 ? 1 :                        \
+     ((Char) < 0x800 ? 2 :                      \
+      ((Char) < 0x10000 ? 3 :                   \
+       ((Char) < 0x200000 ? 4 :                 \
+        ((Char) < 0x4000000 ? 5 : 6)))))
+
+#define UNICODE_VALID(Char)                     \
+    ((Char) < 0x110000 &&                       \
+     (((Char) & 0xFFFFF800) != 0xD800) &&       \
+     ((Char) < 0xFDD0 || (Char) > 0xFDEF) &&    \
+     ((Char) & 0xFFFE) != 0xFFFE)
+
+int
+_utf8_get_char_extended(const char *s,
+                             int max_len)
+{
+    const unsigned char*p = (const unsigned char*)s;
+    int i, len;
+    unsigned int wc = (unsigned char) * p;
+
+    if (wc < 0x80) {
+        return wc;
+    } else if (wc < 0xc0) {
+        return (unsigned int) - 1;
+    } else if (wc < 0xe0) {
+        len = 2;
+        wc &= 0x1f;
+    } else if (wc < 0xf0) {
+        len = 3;
+        wc &= 0x0f;
+    } else if (wc < 0xf8) {
+        len = 4;
+        wc &= 0x07;
+    } else if (wc < 0xfc) {
+        len = 5;
+        wc &= 0x03;
+    } else if (wc < 0xfe) {
+        len = 6;
+        wc &= 0x01;
+    } else {
+        return (unsigned int) - 1;
+    }
+
+    if (max_len >= 0 && len > max_len) {
+        for (i = 1; i < max_len; i++) {
+            if ((((unsigned char *)p)[i] & 0xc0) != 0x80)
+                return (unsigned int) - 1;
+        }
+
+        return (unsigned int) - 2;
+    }
+
+    for (i = 1; i < len; ++i) {
+        unsigned int ch = ((unsigned char *)p)[i];
+
+        if ((ch & 0xc0) != 0x80) {
+            if (ch)
+                return (unsigned int) - 1;
+            else
+                return (unsigned int) - 2;
+        }
+
+        wc <<= 6;
+
+        wc |= (ch & 0x3f);
+    }
+
+    if (UTF8_LENGTH(wc) != len)
+        return (unsigned int) - 1;
+
+    return wc;
+}
+
+int _utf8_get_char_validated(const char *p,
+                                  int max_len)
+{
+    int result;
+
+    if (max_len == 0)
+        return -2;
+
+    result = _utf8_get_char_extended(p, max_len);
+
+    if (result & 0x80000000)
+        return result;
+    else if (!UNICODE_VALID(result))
+        return -1;
+    else
+        return result;
+}
+
+
+char *
+_utf8_get_char(const char *i, uint32_t *chr)
+{
+    const unsigned char* in = (const unsigned char *)i;
+    if (!(in[0] & 0x80)) {
+        *(chr) = *(in);
+        return (char *)in + 1;
+    }
+
+    /* 2-byte, 0x80-0x7ff */
+    if ((in[0] & 0xe0) == 0xc0 && CONT(1)) {
+        *chr = ((in[0] & 0x1f) << 6) | VAL(1, 0);
+        return (char *)in + 2;
+    }
+
+    /* 3-byte, 0x800-0xffff */
+    if ((in[0] & 0xf0) == 0xe0 && CONT(1) && CONT(2)) {
+        *chr = ((in[0] & 0xf) << 12) | VAL(1, 6) | VAL(2, 0);
+        return (char *)in + 3;
+    }
+
+    /* 4-byte, 0x10000-0x1FFFFF */
+    if ((in[0] & 0xf8) == 0xf0 && CONT(1) && CONT(2) && CONT(3)) {
+        *chr = ((in[0] & 0x7) << 18) | VAL(1, 12) | VAL(2, 6) | VAL(3, 0);
+        return (char *)in + 4;
+    }
+
+    /* 5-byte, 0x200000-0x3FFFFFF */
+    if ((in[0] & 0xfc) == 0xf8 && CONT(1) && CONT(2) && CONT(3) && CONT(4)) {
+        *chr = ((in[0] & 0x3) << 24) | VAL(1, 18) | VAL(2, 12) | VAL(3, 6) | VAL(4, 0);
+        return (char *)in + 5;
+    }
+
+    /* 6-byte, 0x400000-0x7FFFFFF */
+    if ((in[0] & 0xfe) == 0xfc && CONT(1) && CONT(2) && CONT(3) && CONT(4) && CONT(5)) {
+        *chr = ((in[0] & 0x1) << 30) | VAL(1, 24) | VAL(2, 18) | VAL(3, 12) | VAL(4, 6) | VAL(5, 0);
+        return (char *)in + 6;
+    }
+
+    *chr = *in;
+
+    return (char *)in + 1;
+}
+
+
+int _utf8_check_string(const char *s)
+{
+    while (*s) {
+        uint32_t chr;
+
+        if (_utf8_get_char_validated(s, 6) < 0)
+            return 0;
+
+        s = _utf8_get_char(s, &chr);
+    }
+
+    return 1;
+}
diff --git a/src/plugins/platforminputcontexts/fcitx/utils.h b/src/plugins/platforminputcontexts/fcitx/utils.h
new file mode 100644
index 0000000..ae0c79c
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/utils.h
@@ -0,0 +1,35 @@
+/***************************************************************************
+ *   Copyright (C) 2012~2013 by CSSlayer                                   *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.              *
+ ***************************************************************************/
+
+#ifndef UTILS_H
+#define UTILS_H
+
+#include <stdint.h>
+
+int
+_utf8_get_char_extended(const char *s,
+                             int max_len);
+int _utf8_get_char_validated(const char *p,
+                                  int max_len);
+char *
+_utf8_get_char(const char *i, uint32_t *chr);
+int _utf8_check_string(const char *s);
+
+
+#endif // UTILS_H
diff --git a/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-compat.h b/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-compat.h
new file mode 100644
index 0000000..299732f
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-compat.h
@@ -0,0 +1,98 @@
+/*
+ * Copyright  2012 Daniel Stone
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Daniel Stone <daniel@fooishbar.org>
+ */
+
+#ifndef _XKBCOMMON_COMPAT_H
+#define _XKBCOMMON_COMPAT_H
+
+/**
+ * Renamed keymap API.
+ */
+#define xkb_group_index_t xkb_layout_index_t
+#define xkb_group_mask_t xkb_layout_mask_t
+#define xkb_map_compile_flags xkb_keymap_compile_flags
+#define XKB_GROUP_INVALID XKB_LAYOUT_INVALID
+
+#define XKB_STATE_DEPRESSED \
+    (XKB_STATE_MODS_DEPRESSED | XKB_STATE_LAYOUT_DEPRESSED)
+#define XKB_STATE_LATCHED \
+    (XKB_STATE_MODS_LATCHED | XKB_STATE_LAYOUT_LATCHED)
+#define XKB_STATE_LOCKED \
+    (XKB_STATE_MODS_LOCKED | XKB_STATE_LAYOUT_LOCKED)
+#define XKB_STATE_EFFECTIVE \
+    (XKB_STATE_DEPRESSED | XKB_STATE_LATCHED | XKB_STATE_LOCKED | \
+     XKB_STATE_MODS_EFFECTIVE | XKB_STATE_LAYOUT_EFFECTIVE)
+
+#define xkb_map_new_from_names(context, names, flags) \
+        xkb_keymap_new_from_names(context, names, flags)
+#define xkb_map_new_from_file(context, file, format, flags) \
+        xkb_keymap_new_from_file(context, file, format, flags)
+#define xkb_map_new_from_string(context, string, format, flags) \
+        xkb_keymap_new_from_string(context, string, format, flags)
+#define xkb_map_get_as_string(keymap) \
+        xkb_keymap_get_as_string(keymap, XKB_KEYMAP_FORMAT_TEXT_V1)
+#define xkb_map_ref(keymap) xkb_keymap_ref(keymap)
+#define xkb_map_unref(keymap) xkb_keymap_unref(keymap)
+
+#define xkb_map_num_mods(keymap) xkb_keymap_num_mods(keymap)
+#define xkb_map_mod_get_name(keymap, idx) xkb_keymap_mod_get_name(keymap, idx)
+#define xkb_map_mod_get_index(keymap, str) xkb_keymap_mod_get_index(keymap, str)
+#define xkb_key_mod_index_is_consumed(state, key, mod) \
+        xkb_state_mod_index_is_consumed(state, key, mod)
+#define xkb_key_mod_mask_remove_consumed(state, key, modmask) \
+        xkb_state_mod_mask_remove_consumed(state, key, modmask)
+
+#define xkb_map_num_groups(keymap) xkb_keymap_num_layouts(keymap)
+#define xkb_key_num_groups(keymap, key) \
+        xkb_keymap_num_layouts_for_key(keymap, key)
+#define xkb_map_group_get_name(keymap, idx) \
+        xkb_keymap_layout_get_name(keymap, idx)
+#define xkb_map_group_get_index(keymap, str) \
+        xkb_keymap_layout_get_index(keymap, str)
+
+#define xkb_map_num_leds(keymap) xkb_keymap_num_leds(keymap)
+#define xkb_map_led_get_name(keymap, idx) xkb_keymap_led_get_name(keymap, idx)
+#define xkb_map_led_get_index(keymap, str) \
+        xkb_keymap_led_get_index(keymap, str)
+
+#define xkb_key_repeats(keymap, key) xkb_keymap_key_repeats(keymap, key)
+
+#define xkb_key_get_syms(state, key, syms_out) \
+        xkb_state_key_get_syms(state, key, syms_out)
+
+#define xkb_state_group_name_is_active(state, name, type) \
+        xkb_state_layout_name_is_active(state, name, type)
+#define xkb_state_group_index_is_active(state, idx, type) \
+        xkb_state_layout_index_is_active(state, idx, type)
+
+#define xkb_state_serialize_group(state, component) \
+        xkb_state_serialize_layout(state, component)
+
+#define xkb_state_get_map(state) xkb_state_get_keymap(state)
+
+/* Not needed anymore, since there's NO_FLAGS. */
+#define XKB_MAP_COMPILE_PLACEHOLDER XKB_KEYMAP_COMPILE_NO_FLAGS
+#define XKB_MAP_COMPILE_NO_FLAGS XKB_KEYMAP_COMPILE_NO_FLAGS
+
+#endif
diff --git a/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-compose.h b/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-compose.h
new file mode 100644
index 0000000..7414c37
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-compose.h
@@ -0,0 +1,488 @@
+/*
+ * Copyright  2013 Ran Benita
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _XKBCOMMON_COMPOSE_H
+#define _XKBCOMMON_COMPOSE_H
+
+#include <xkbcommon/xkbcommon.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @file
+ * libxkbcommon Compose API - support for Compose and dead-keys.
+ */
+
+/**
+ * @defgroup compose Compose and dead-keys support
+ * Support for Compose and dead-keys.
+ * @since 0.5.0
+ *
+ * @{
+ */
+
+/**
+ * @page compose-overview Overview
+ * @parblock
+ *
+ * Compose and dead-keys are a common feature of many keyboard input
+ * systems.  They extend the range of the keysysm that can be produced
+ * directly from a keyboard by using a sequence of key strokes, instead
+ * of just one.
+ *
+ * Here are some example sequences, in the libX11 Compose file format:
+ *
+ *     <dead_acute> <a>         : ""   aacute # LATIN SMALL LETTER A WITH ACUTE
+ *     <Multi_key> <A> <T>      : "@"   at     # COMMERCIAL AT
+ *
+ * When the user presses a key which produces the `<dead_acute>` keysym,
+ * nothing initially happens (thus the key is dubbed a "dead-key").  But
+ * when the user enters `<a>`, "" is "composed", in place of "a".  If
+ * instead the user had entered a keysym which does not follow
+ * `<dead_acute>` in any compose sequence, the sequence is said to be
+ * "cancelled".
+ *
+ * Compose files define many such sequences.  For a description of the
+ * common file format for Compose files, see the Compose(5) man page.
+ *
+ * A successfuly-composed sequence has two results: a keysym and a UTF-8
+ * string.  At least one of the two is defined for each sequence.  If only
+ * a keysym is given, the keysym's string representation is used for the
+ * result string (using xkb_keysym_to_utf8()).
+ *
+ * This library provides low-level support for Compose file parsing and
+ * processing.  Higher-level APIs (such as libX11's `Xutf8LookupString`(3))
+ * may be built upon it, or it can be used directly.
+ *
+ * @endparblock
+ */
+
+/**
+ * @page compose-conflicting Conflicting Sequences
+ * @parblock
+ *
+ * To avoid ambiguity, a sequence is not allowed to be a prefix of another.
+ * In such a case, the conflict is resolved thus:
+ *
+ * 1. A longer sequence overrides a shorter one.
+ * 2. An equal sequence overrides an existing one.
+ * 3. A shorter sequence does not override a longer one.
+ *
+ * Sequences of length 1 are allowed.
+ *
+ * @endparblock
+ */
+
+/**
+ * @page compose-cancellation Cancellation Behavior
+ * @parblock
+ *
+ * What should happen when a sequence is cancelled?  For example, consider
+ * there are only the above sequences, and the input keysyms are
+ * `<dead_acute> <b>`.  There are a few approaches:
+ *
+ * 1. Swallow the cancelling keysym; that is, no keysym is produced.
+ *    This is the approach taken by libX11.
+ * 2. Let the cancelling keysym through; that is, `<b>` is produced.
+ * 3. Replay the entire sequence; that is, `<dead_acute> <b>` is produced.
+ *    This is the approach taken by Microsoft Windows (approximately;
+ *    instead of `<dead_acute>`, the underlying key is used.  This is
+ *    difficult to simulate with XKB keymaps).
+ *
+ * You can program whichever approach best fits users' expectations.
+ *
+ * @endparblock
+ */
+
+/**
+ * @struct xkb_compose_table
+ * Opaque Compose table object.
+ *
+ * The compose table holds the definitions of the Compose sequences, as
+ * gathered from Compose files.  It is immutable.
+ */
+struct xkb_compose_table;
+
+/**
+ * @struct xkb_compose_state
+ * Opaque Compose state object.
+ *
+ * The compose state maintains state for compose sequence matching, such
+ * as which possible sequences are being matched, and the position within
+ * these sequences.  It acts as a simple state machine wherein keysyms are
+ * the input, and composed keysyms and strings are the output.
+ *
+ * The compose state is usually associated with a keyboard device.
+ */
+struct xkb_compose_state;
+
+/** Flags affecting Compose file compilation. */
+enum xkb_compose_compile_flags {
+    /** Do not apply any flags. */
+    XKB_COMPOSE_COMPILE_NO_FLAGS = 0
+};
+
+/** The recognized Compose file formats. */
+enum xkb_compose_format {
+    /** The classic libX11 Compose text format, described in Compose(5). */
+    XKB_COMPOSE_FORMAT_TEXT_V1 = 1
+};
+
+/**
+ * @page compose-locale Compose Locale
+ * @parblock
+ *
+ * Compose files are locale dependent:
+ * - Compose files are written for a locale, and the locale is used when
+ *   searching for the appropriate file to use.
+ * - Compose files may reference the locale internally, with directives
+ *   such as \%L.
+ *
+ * As such, functions like xkb_compose_table_new_from_locale() require
+ * a `locale` parameter.  This will usually be the current locale (see
+ * locale(7) for more details).  You may also want to allow the user to
+ * explicitly configure it, so he can use the Compose file of a given
+ * locale, but not use that locale for other things.
+ *
+ * You may query the current locale as follows:
+ * @code
+ *     const char *locale;
+ *     locale = setlocale(LC_CTYPE, NULL);
+ * @endcode
+ *
+ * This will only give useful results if the program had previously set
+ * the current locale using setlocale(3), with `LC_CTYPE` or `LC_ALL`
+ * and a non-NULL argument.
+ *
+ * If you prefer not to use the locale system of the C runtime library,
+ * you may nevertheless obtain the user's locale directly using
+ * environment variables, as described in locale(7).  For example,
+ * @code
+ *     locale = getenv("LC_ALL");
+ *     if (!locale)
+ *         locale = getenv("LC_CTYPE");
+ *     if (!locale)
+ *         locale = getenv("LANG");
+ *     if (!locale)
+ *         locale = "C";
+ * @endcode
+ *
+ * Note that some locales supported by the C standard library may not
+ * have a Compose file assigned.
+ *
+ * @endparblock
+ */
+
+/**
+ * Create a compose table for a given locale.
+ *
+ * The locale is used for searching the file-system for an appropriate
+ * Compose file.  The search order is described in Compose(5).  It is
+ * affected by the following environment variables:
+ *
+ * 1. `XCOMPOSEFILE` - see Compose(5).
+ * 2. `HOME` - see Compose(5).
+ * 3. `XLOCALEDIR` - if set, used as the base directory for the system's
+ *    X locale files, e.g. `/usr/share/X11/locale`, instead of the
+ *    preconfigured directory.
+ *
+ * @param context
+ *     The library context in which to create the compose table.
+ * @param locale
+ *     The current locale.  See @ref compose-locale.
+ * @param flags
+ *     Optional flags for the compose table, or 0.
+ *
+ * @returns A compose table for the given locale, or NULL if the
+ * compilation failed or a Compose file was not found.
+ *
+ * @memberof xkb_compose_table
+ */
+struct xkb_compose_table *
+xkb_compose_table_new_from_locale(struct xkb_context *context,
+                                  const char *locale,
+                                  enum xkb_compose_compile_flags flags);
+
+/**
+ * Create a new compose table from a Compose file.
+ *
+ * @param context
+ *     The library context in which to create the compose table.
+ * @param file
+ *     The Compose file to compile.
+ * @param locale
+ *     The current locale.  See @ref compose-locale.
+ * @param format
+ *     The text format of the Compose file to compile.
+ * @param flags
+ *     Optional flags for the compose table, or 0.
+ *
+ * @returns A compose table compiled from the given file, or NULL if
+ * the compilation failed.
+ *
+ * @memberof xkb_compose_table
+ */
+struct xkb_compose_table *
+xkb_compose_table_new_from_file(struct xkb_context *context,
+                                FILE *file,
+                                const char *locale,
+                                enum xkb_compose_format format,
+                                enum xkb_compose_compile_flags flags);
+
+/**
+ * Create a new compose table from a memory buffer.
+ *
+ * This is just like xkb_compose_table_new_from_file(), but instead of
+ * a file, gets the table as one enormous string.
+ *
+ * @see xkb_compose_table_new_from_file()
+ * @memberof xkb_compose_table
+ */
+struct xkb_compose_table *
+xkb_compose_table_new_from_buffer(struct xkb_context *context,
+                                  const char *buffer, size_t length,
+                                  const char *locale,
+                                  enum xkb_compose_format format,
+                                  enum xkb_compose_compile_flags flags);
+
+/**
+ * Take a new reference on a compose table.
+ *
+ * @returns The passed in object.
+ *
+ * @memberof xkb_compose_table
+ */
+struct xkb_compose_table *
+xkb_compose_table_ref(struct xkb_compose_table *table);
+
+/**
+ * Release a reference on a compose table, and possibly free it.
+ *
+ * @param table The object.  If it is NULL, this function does nothing.
+ *
+ * @memberof xkb_compose_table
+ */
+void
+xkb_compose_table_unref(struct xkb_compose_table *table);
+
+/** Flags for compose state creation. */
+enum xkb_compose_state_flags {
+    /** Do not apply any flags. */
+    XKB_COMPOSE_STATE_NO_FLAGS = 0
+};
+
+/**
+ * Create a new compose state object.
+ *
+ * @param table
+ *     The compose table the state will use.
+ * @param flags
+ *     Optional flags for the compose state, or 0.
+ *
+ * @returns A new compose state, or NULL on failure.
+ *
+ * @memberof xkb_compose_state
+ */
+struct xkb_compose_state *
+xkb_compose_state_new(struct xkb_compose_table *table,
+                      enum xkb_compose_state_flags flags);
+
+/**
+ * Take a new reference on a compose state object.
+ *
+ * @returns The passed in object.
+ *
+ * @memberof xkb_compose_state
+ */
+struct xkb_compose_state *
+xkb_compose_state_ref(struct xkb_compose_state *state);
+
+/**
+ * Release a reference on a compose state object, and possibly free it.
+ *
+ * @param state The object.  If NULL, do nothing.
+ *
+ * @memberof xkb_compose_state
+ */
+void
+xkb_compose_state_unref(struct xkb_compose_state *state);
+
+/**
+ * Get the compose table which a compose state object is using.
+ *
+ * @returns The compose table which was passed to xkb_compose_state_new()
+ * when creating this state object.
+ *
+ * This function does not take a new reference on the compose table; you
+ * must explicitly reference it yourself if you plan to use it beyond the
+ * lifetime of the state.
+ *
+ * @memberof xkb_compose_state
+ */
+struct xkb_compose_table *
+xkb_compose_state_get_compose_table(struct xkb_compose_state *state);
+
+/** Status of the Compose sequence state machine. */
+enum xkb_compose_status {
+    /** The initial state; no sequence has started yet. */
+    XKB_COMPOSE_NOTHING,
+    /** In the middle of a sequence. */
+    XKB_COMPOSE_COMPOSING,
+    /** A complete sequence has been matched. */
+    XKB_COMPOSE_COMPOSED,
+    /** The last sequence was cancelled due to an unmatched keysym. */
+    XKB_COMPOSE_CANCELLED
+};
+
+/** The effect of a keysym fed to xkb_compose_state_feed(). */
+enum xkb_compose_feed_result {
+    /** The keysym had no effect - it did not affect the status. */
+    XKB_COMPOSE_FEED_IGNORED,
+    /** The keysym started, advanced or cancelled a sequence. */
+    XKB_COMPOSE_FEED_ACCEPTED
+};
+
+/**
+ * Feed one keysym to the Compose sequence state machine.
+ *
+ * This function can advance into a compose sequence, cancel a sequence,
+ * start a new sequence, or do nothing in particular.  The resulting
+ * status may be observed with xkb_compose_state_get_status().
+ *
+ * Some keysyms, such as keysyms for modifier keys, are ignored - they
+ * have no effect on the status or otherwise.
+ *
+ * The following is a description of the possible status transitions, in
+ * the format CURRENT STATUS => NEXT STATUS, given a non-ignored input
+ * keysym `keysym`:
+ *
+   @verbatim
+   NOTHING or CANCELLED or COMPOSED =>
+      NOTHING   if keysym does not start a sequence.
+      COMPOSING if keysym starts a sequence.
+      COMPOSED  if keysym starts and terminates a single-keysym sequence.
+
+   COMPOSING =>
+      COMPOSING if keysym advances any of the currently possible
+                sequences but does not terminate any of them.
+      COMPOSED  if keysym terminates one of the currently possible
+                sequences.
+      CANCELLED if keysym does not advance any of the currently
+                possible sequences.
+   @endverbatim
+ *
+ * The current Compose formats do not support multiple-keysyms.
+ * Therefore, if you are using a function such as xkb_state_key_get_syms()
+ * and it returns more than one keysym, consider feeding XKB_KEY_NoSymbol
+ * instead.
+ *
+ * @param state
+ *     The compose state object.
+ * @param keysym
+ *     A keysym, usually obtained after a key-press event, with a
+ *     function such as xkb_state_key_get_one_sym().
+ *
+ * @returns Whether the keysym was ignored.  This is useful, for example,
+ * if you want to keep a record of the sequence matched thus far.
+ *
+ * @memberof xkb_compose_state
+ */
+enum xkb_compose_feed_result
+xkb_compose_state_feed(struct xkb_compose_state *state,
+                       xkb_keysym_t keysym);
+
+/**
+ * Reset the Compose sequence state machine.
+ *
+ * The status is set to XKB_COMPOSE_NOTHING, and the current sequence
+ * is discarded.
+ *
+ * @memberof xkb_compose_state
+ */
+void
+xkb_compose_state_reset(struct xkb_compose_state *state);
+
+/**
+ * Get the current status of the compose state machine.
+ *
+ * @see xkb_compose_status
+ * @memberof xkb_compose_state
+ **/
+enum xkb_compose_status
+xkb_compose_state_get_status(struct xkb_compose_state *state);
+
+/**
+ * Get the result Unicode/UTF-8 string for a composed sequence.
+ *
+ * See @ref compose-overview for more details.  This function is only
+ * useful when the status is XKB_COMPOSE_COMPOSED.
+ *
+ * @param[in] state
+ *     The compose state.
+ * @param[out] buffer
+ *     A buffer to write the string into.
+ * @param[in] size
+ *     Size of the buffer.
+ *
+ * @warning If the buffer passed is too small, the string is truncated
+ * (though still NUL-terminated).
+ *
+ * @returns
+ *   The number of bytes required for the string, excluding the NUL byte.
+ *   If the sequence is not complete, or does not have a viable result
+ *   string, returns 0, and sets `buffer` to the empty string (if possible).
+ * @returns
+ *   You may check if truncation has occurred by comparing the return value
+ *   with the size of `buffer`, similarly to the `snprintf`(3) function.
+ *   You may safely pass NULL and 0 to `buffer` and `size` to find the
+ *   required size (without the NUL-byte).
+ *
+ * @memberof xkb_compose_state
+ **/
+int
+xkb_compose_state_get_utf8(struct xkb_compose_state *state,
+                           char *buffer, size_t size);
+
+/**
+ * Get the result keysym for a composed sequence.
+ *
+ * See @ref compose-overview for more details.  This function is only
+ * useful when the status is XKB_COMPOSE_COMPOSED.
+ *
+ * @returns The result keysym.  If the sequence is not complete, or does
+ * not specify a result keysym, returns XKB_KEY_NoSymbol.
+ *
+ * @memberof xkb_compose_state
+ **/
+xkb_keysym_t
+xkb_compose_state_get_one_sym(struct xkb_compose_state *state);
+
+/** @} */
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* _XKBCOMMON_COMPOSE_H */
diff --git a/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-keysyms.h b/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-keysyms.h
new file mode 100644
index 0000000..3e8d644
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-keysyms.h
@@ -0,0 +1,3012 @@
+#ifndef _XKBCOMMON_KEYSYMS_H
+#define _XKBCOMMON_KEYSYMS_H
+
+/* This file is autogenerated from Makefile.am; please do not commit directly. */
+
+#define XKB_KEY_NoSymbol                    0x000000  /* Special KeySym */
+
+/***********************************************************
+Copyright 1987, 1994, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+/*
+ * The "X11 Window System Protocol" standard defines in Appendix A the
+ * keysym codes. These 29-bit integer values identify characters or
+ * functions associated with each key (e.g., via the visible
+ * engraving) of a keyboard layout. This file assigns mnemonic macro
+ * names for these keysyms.
+ *
+ * This file is also compiled (by src/util/makekeys.c in libX11) into
+ * hash tables that can be accessed with X11 library functions such as
+ * XStringToKeysym() and XKeysymToString().
+ *
+ * Where a keysym corresponds one-to-one to an ISO 10646 / Unicode
+ * character, this is noted in a comment that provides both the U+xxxx
+ * Unicode position, as well as the official Unicode name of the
+ * character.
+ *
+ * Where the correspondence is either not one-to-one or semantically
+ * unclear, the Unicode position and name are enclosed in
+ * parentheses. Such legacy keysyms should be considered deprecated
+ * and are not recommended for use in future keyboard mappings.
+ *
+ * For any future extension of the keysyms with characters already
+ * found in ISO 10646 / Unicode, the following algorithm shall be
+ * used. The new keysym code position will simply be the character's
+ * Unicode number plus 0x01000000. The keysym values in the range
+ * 0x01000100 to 0x0110ffff are reserved to represent Unicode
+ * characters in the range U+0100 to U+10FFFF.
+ *
+ * While most newer Unicode-based X11 clients do already accept
+ * Unicode-mapped keysyms in the range 0x01000100 to 0x0110ffff, it
+ * will remain necessary for clients -- in the interest of
+ * compatibility with existing servers -- to also understand the
+ * existing legacy keysym values in the range 0x0100 to 0x20ff.
+ *
+ * Where several mnemonic names are defined for the same keysym in this
+ * file, all but the first one listed should be considered deprecated.
+ *
+ * Mnemonic names for keysyms are defined in this file with lines
+ * that match one of these Perl regular expressions:
+ *
+ *    /^\#define XKB_KEY_([a-zA-Z_0-9]+)\s+0x([0-9a-f]+)\s*\/\* U+([0-9A-F]{4,6}) (.*) \*\/\s*$/
+ *    /^\#define XKB_KEY_([a-zA-Z_0-9]+)\s+0x([0-9a-f]+)\s*\/\*\(U+([0-9A-F]{4,6}) (.*)\)\*\/\s*$/
+ *    /^\#define XKB_KEY_([a-zA-Z_0-9]+)\s+0x([0-9a-f]+)\s*(\/\*\s*(.*)\s*\*\/)?\s*$/
+ *
+ * Before adding new keysyms, please do consider the following: In
+ * addition to the keysym names defined in this file, the
+ * XStringToKeysym() and XKeysymToString() functions will also handle
+ * any keysym string of the form "U0020" to "U007E" and "U00A0" to
+ * "U10FFFF" for all possible Unicode characters. In other words,
+ * every possible Unicode character has already a keysym string
+ * defined algorithmically, even if it is not listed here. Therefore,
+ * defining an additional keysym macro is only necessary where a
+ * non-hexadecimal mnemonic name is needed, or where the new keysym
+ * does not represent any existing Unicode character.
+ *
+ * When adding new keysyms to this file, do not forget to also update the
+ * following as needed:
+ *
+ *   - the mappings in src/KeyBind.c in the repo
+ *     git://anongit.freedesktop.org/xorg/lib/libX11.git
+ *
+ *   - the protocol specification in specs/keysyms.xml
+ *     in the repo git://anongit.freedesktop.org/xorg/proto/x11proto.git
+ *
+ */
+
+#define XKB_KEY_VoidSymbol                  0xffffff  /* Void symbol */
+
+/*
+ * TTY function keys, cleverly chosen to map to ASCII, for convenience of
+ * programming, but could have been arbitrary (at the cost of lookup
+ * tables in client code).
+ */
+
+#define XKB_KEY_BackSpace                     0xff08  /* Back space, back char */
+#define XKB_KEY_Tab                           0xff09
+#define XKB_KEY_Linefeed                      0xff0a  /* Linefeed, LF */
+#define XKB_KEY_Clear                         0xff0b
+#define XKB_KEY_Return                        0xff0d  /* Return, enter */
+#define XKB_KEY_Pause                         0xff13  /* Pause, hold */
+#define XKB_KEY_Scroll_Lock                   0xff14
+#define XKB_KEY_Sys_Req                       0xff15
+#define XKB_KEY_Escape                        0xff1b
+#define XKB_KEY_Delete                        0xffff  /* Delete, rubout */
+
+
+
+/* International & multi-key character composition */
+
+#define XKB_KEY_Multi_key                     0xff20  /* Multi-key character compose */
+#define XKB_KEY_Codeinput                     0xff37
+#define XKB_KEY_SingleCandidate               0xff3c
+#define XKB_KEY_MultipleCandidate             0xff3d
+#define XKB_KEY_PreviousCandidate             0xff3e
+
+/* Japanese keyboard support */
+
+#define XKB_KEY_Kanji                         0xff21  /* Kanji, Kanji convert */
+#define XKB_KEY_Muhenkan                      0xff22  /* Cancel Conversion */
+#define XKB_KEY_Henkan_Mode                   0xff23  /* Start/Stop Conversion */
+#define XKB_KEY_Henkan                        0xff23  /* Alias for Henkan_Mode */
+#define XKB_KEY_Romaji                        0xff24  /* to Romaji */
+#define XKB_KEY_Hiragana                      0xff25  /* to Hiragana */
+#define XKB_KEY_Katakana                      0xff26  /* to Katakana */
+#define XKB_KEY_Hiragana_Katakana             0xff27  /* Hiragana/Katakana toggle */
+#define XKB_KEY_Zenkaku                       0xff28  /* to Zenkaku */
+#define XKB_KEY_Hankaku                       0xff29  /* to Hankaku */
+#define XKB_KEY_Zenkaku_Hankaku               0xff2a  /* Zenkaku/Hankaku toggle */
+#define XKB_KEY_Touroku                       0xff2b  /* Add to Dictionary */
+#define XKB_KEY_Massyo                        0xff2c  /* Delete from Dictionary */
+#define XKB_KEY_Kana_Lock                     0xff2d  /* Kana Lock */
+#define XKB_KEY_Kana_Shift                    0xff2e  /* Kana Shift */
+#define XKB_KEY_Eisu_Shift                    0xff2f  /* Alphanumeric Shift */
+#define XKB_KEY_Eisu_toggle                   0xff30  /* Alphanumeric toggle */
+#define XKB_KEY_Kanji_Bangou                  0xff37  /* Codeinput */
+#define XKB_KEY_Zen_Koho                      0xff3d  /* Multiple/All Candidate(s) */
+#define XKB_KEY_Mae_Koho                      0xff3e  /* Previous Candidate */
+
+/* 0xff31 thru 0xff3f are under XK_KOREAN */
+
+/* Cursor control & motion */
+
+#define XKB_KEY_Home                          0xff50
+#define XKB_KEY_Left                          0xff51  /* Move left, left arrow */
+#define XKB_KEY_Up                            0xff52  /* Move up, up arrow */
+#define XKB_KEY_Right                         0xff53  /* Move right, right arrow */
+#define XKB_KEY_Down                          0xff54  /* Move down, down arrow */
+#define XKB_KEY_Prior                         0xff55  /* Prior, previous */
+#define XKB_KEY_Page_Up                       0xff55
+#define XKB_KEY_Next                          0xff56  /* Next */
+#define XKB_KEY_Page_Down                     0xff56
+#define XKB_KEY_End                           0xff57  /* EOL */
+#define XKB_KEY_Begin                         0xff58  /* BOL */
+
+
+/* Misc functions */
+
+#define XKB_KEY_Select                        0xff60  /* Select, mark */
+#define XKB_KEY_Print                         0xff61
+#define XKB_KEY_Execute                       0xff62  /* Execute, run, do */
+#define XKB_KEY_Insert                        0xff63  /* Insert, insert here */
+#define XKB_KEY_Undo                          0xff65
+#define XKB_KEY_Redo                          0xff66  /* Redo, again */
+#define XKB_KEY_Menu                          0xff67
+#define XKB_KEY_Find                          0xff68  /* Find, search */
+#define XKB_KEY_Cancel                        0xff69  /* Cancel, stop, abort, exit */
+#define XKB_KEY_Help                          0xff6a  /* Help */
+#define XKB_KEY_Break                         0xff6b
+#define XKB_KEY_Mode_switch                   0xff7e  /* Character set switch */
+#define XKB_KEY_script_switch                 0xff7e  /* Alias for mode_switch */
+#define XKB_KEY_Num_Lock                      0xff7f
+
+/* Keypad functions, keypad numbers cleverly chosen to map to ASCII */
+
+#define XKB_KEY_KP_Space                      0xff80  /* Space */
+#define XKB_KEY_KP_Tab                        0xff89
+#define XKB_KEY_KP_Enter                      0xff8d  /* Enter */
+#define XKB_KEY_KP_F1                         0xff91  /* PF1, KP_A, ... */
+#define XKB_KEY_KP_F2                         0xff92
+#define XKB_KEY_KP_F3                         0xff93
+#define XKB_KEY_KP_F4                         0xff94
+#define XKB_KEY_KP_Home                       0xff95
+#define XKB_KEY_KP_Left                       0xff96
+#define XKB_KEY_KP_Up                         0xff97
+#define XKB_KEY_KP_Right                      0xff98
+#define XKB_KEY_KP_Down                       0xff99
+#define XKB_KEY_KP_Prior                      0xff9a
+#define XKB_KEY_KP_Page_Up                    0xff9a
+#define XKB_KEY_KP_Next                       0xff9b
+#define XKB_KEY_KP_Page_Down                  0xff9b
+#define XKB_KEY_KP_End                        0xff9c
+#define XKB_KEY_KP_Begin                      0xff9d
+#define XKB_KEY_KP_Insert                     0xff9e
+#define XKB_KEY_KP_Delete                     0xff9f
+#define XKB_KEY_KP_Equal                      0xffbd  /* Equals */
+#define XKB_KEY_KP_Multiply                   0xffaa
+#define XKB_KEY_KP_Add                        0xffab
+#define XKB_KEY_KP_Separator                  0xffac  /* Separator, often comma */
+#define XKB_KEY_KP_Subtract                   0xffad
+#define XKB_KEY_KP_Decimal                    0xffae
+#define XKB_KEY_KP_Divide                     0xffaf
+
+#define XKB_KEY_KP_0                          0xffb0
+#define XKB_KEY_KP_1                          0xffb1
+#define XKB_KEY_KP_2                          0xffb2
+#define XKB_KEY_KP_3                          0xffb3
+#define XKB_KEY_KP_4                          0xffb4
+#define XKB_KEY_KP_5                          0xffb5
+#define XKB_KEY_KP_6                          0xffb6
+#define XKB_KEY_KP_7                          0xffb7
+#define XKB_KEY_KP_8                          0xffb8
+#define XKB_KEY_KP_9                          0xffb9
+
+
+
+/*
+ * Auxiliary functions; note the duplicate definitions for left and right
+ * function keys;  Sun keyboards and a few other manufacturers have such
+ * function key groups on the left and/or right sides of the keyboard.
+ * We've not found a keyboard with more than 35 function keys total.
+ */
+
+#define XKB_KEY_F1                            0xffbe
+#define XKB_KEY_F2                            0xffbf
+#define XKB_KEY_F3                            0xffc0
+#define XKB_KEY_F4                            0xffc1
+#define XKB_KEY_F5                            0xffc2
+#define XKB_KEY_F6                            0xffc3
+#define XKB_KEY_F7                            0xffc4
+#define XKB_KEY_F8                            0xffc5
+#define XKB_KEY_F9                            0xffc6
+#define XKB_KEY_F10                           0xffc7
+#define XKB_KEY_F11                           0xffc8
+#define XKB_KEY_L1                            0xffc8
+#define XKB_KEY_F12                           0xffc9
+#define XKB_KEY_L2                            0xffc9
+#define XKB_KEY_F13                           0xffca
+#define XKB_KEY_L3                            0xffca
+#define XKB_KEY_F14                           0xffcb
+#define XKB_KEY_L4                            0xffcb
+#define XKB_KEY_F15                           0xffcc
+#define XKB_KEY_L5                            0xffcc
+#define XKB_KEY_F16                           0xffcd
+#define XKB_KEY_L6                            0xffcd
+#define XKB_KEY_F17                           0xffce
+#define XKB_KEY_L7                            0xffce
+#define XKB_KEY_F18                           0xffcf
+#define XKB_KEY_L8                            0xffcf
+#define XKB_KEY_F19                           0xffd0
+#define XKB_KEY_L9                            0xffd0
+#define XKB_KEY_F20                           0xffd1
+#define XKB_KEY_L10                           0xffd1
+#define XKB_KEY_F21                           0xffd2
+#define XKB_KEY_R1                            0xffd2
+#define XKB_KEY_F22                           0xffd3
+#define XKB_KEY_R2                            0xffd3
+#define XKB_KEY_F23                           0xffd4
+#define XKB_KEY_R3                            0xffd4
+#define XKB_KEY_F24                           0xffd5
+#define XKB_KEY_R4                            0xffd5
+#define XKB_KEY_F25                           0xffd6
+#define XKB_KEY_R5                            0xffd6
+#define XKB_KEY_F26                           0xffd7
+#define XKB_KEY_R6                            0xffd7
+#define XKB_KEY_F27                           0xffd8
+#define XKB_KEY_R7                            0xffd8
+#define XKB_KEY_F28                           0xffd9
+#define XKB_KEY_R8                            0xffd9
+#define XKB_KEY_F29                           0xffda
+#define XKB_KEY_R9                            0xffda
+#define XKB_KEY_F30                           0xffdb
+#define XKB_KEY_R10                           0xffdb
+#define XKB_KEY_F31                           0xffdc
+#define XKB_KEY_R11                           0xffdc
+#define XKB_KEY_F32                           0xffdd
+#define XKB_KEY_R12                           0xffdd
+#define XKB_KEY_F33                           0xffde
+#define XKB_KEY_R13                           0xffde
+#define XKB_KEY_F34                           0xffdf
+#define XKB_KEY_R14                           0xffdf
+#define XKB_KEY_F35                           0xffe0
+#define XKB_KEY_R15                           0xffe0
+
+/* Modifiers */
+
+#define XKB_KEY_Shift_L                       0xffe1  /* Left shift */
+#define XKB_KEY_Shift_R                       0xffe2  /* Right shift */
+#define XKB_KEY_Control_L                     0xffe3  /* Left control */
+#define XKB_KEY_Control_R                     0xffe4  /* Right control */
+#define XKB_KEY_Caps_Lock                     0xffe5  /* Caps lock */
+#define XKB_KEY_Shift_Lock                    0xffe6  /* Shift lock */
+
+#define XKB_KEY_Meta_L                        0xffe7  /* Left meta */
+#define XKB_KEY_Meta_R                        0xffe8  /* Right meta */
+#define XKB_KEY_Alt_L                         0xffe9  /* Left alt */
+#define XKB_KEY_Alt_R                         0xffea  /* Right alt */
+#define XKB_KEY_Super_L                       0xffeb  /* Left super */
+#define XKB_KEY_Super_R                       0xffec  /* Right super */
+#define XKB_KEY_Hyper_L                       0xffed  /* Left hyper */
+#define XKB_KEY_Hyper_R                       0xffee  /* Right hyper */
+
+/*
+ * Keyboard (XKB) Extension function and modifier keys
+ * (from Appendix C of "The X Keyboard Extension: Protocol Specification")
+ * Byte 3 = 0xfe
+ */
+
+#define XKB_KEY_ISO_Lock                      0xfe01
+#define XKB_KEY_ISO_Level2_Latch              0xfe02
+#define XKB_KEY_ISO_Level3_Shift              0xfe03
+#define XKB_KEY_ISO_Level3_Latch              0xfe04
+#define XKB_KEY_ISO_Level3_Lock               0xfe05
+#define XKB_KEY_ISO_Level5_Shift              0xfe11
+#define XKB_KEY_ISO_Level5_Latch              0xfe12
+#define XKB_KEY_ISO_Level5_Lock               0xfe13
+#define XKB_KEY_ISO_Group_Shift               0xff7e  /* Alias for mode_switch */
+#define XKB_KEY_ISO_Group_Latch               0xfe06
+#define XKB_KEY_ISO_Group_Lock                0xfe07
+#define XKB_KEY_ISO_Next_Group                0xfe08
+#define XKB_KEY_ISO_Next_Group_Lock           0xfe09
+#define XKB_KEY_ISO_Prev_Group                0xfe0a
+#define XKB_KEY_ISO_Prev_Group_Lock           0xfe0b
+#define XKB_KEY_ISO_First_Group               0xfe0c
+#define XKB_KEY_ISO_First_Group_Lock          0xfe0d
+#define XKB_KEY_ISO_Last_Group                0xfe0e
+#define XKB_KEY_ISO_Last_Group_Lock           0xfe0f
+
+#define XKB_KEY_ISO_Left_Tab                  0xfe20
+#define XKB_KEY_ISO_Move_Line_Up              0xfe21
+#define XKB_KEY_ISO_Move_Line_Down            0xfe22
+#define XKB_KEY_ISO_Partial_Line_Up           0xfe23
+#define XKB_KEY_ISO_Partial_Line_Down         0xfe24
+#define XKB_KEY_ISO_Partial_Space_Left        0xfe25
+#define XKB_KEY_ISO_Partial_Space_Right       0xfe26
+#define XKB_KEY_ISO_Set_Margin_Left           0xfe27
+#define XKB_KEY_ISO_Set_Margin_Right          0xfe28
+#define XKB_KEY_ISO_Release_Margin_Left       0xfe29
+#define XKB_KEY_ISO_Release_Margin_Right      0xfe2a
+#define XKB_KEY_ISO_Release_Both_Margins      0xfe2b
+#define XKB_KEY_ISO_Fast_Cursor_Left          0xfe2c
+#define XKB_KEY_ISO_Fast_Cursor_Right         0xfe2d
+#define XKB_KEY_ISO_Fast_Cursor_Up            0xfe2e
+#define XKB_KEY_ISO_Fast_Cursor_Down          0xfe2f
+#define XKB_KEY_ISO_Continuous_Underline      0xfe30
+#define XKB_KEY_ISO_Discontinuous_Underline   0xfe31
+#define XKB_KEY_ISO_Emphasize                 0xfe32
+#define XKB_KEY_ISO_Center_Object             0xfe33
+#define XKB_KEY_ISO_Enter                     0xfe34
+
+#define XKB_KEY_dead_grave                    0xfe50
+#define XKB_KEY_dead_acute                    0xfe51
+#define XKB_KEY_dead_circumflex               0xfe52
+#define XKB_KEY_dead_tilde                    0xfe53
+#define XKB_KEY_dead_perispomeni              0xfe53  /* alias for dead_tilde */
+#define XKB_KEY_dead_macron                   0xfe54
+#define XKB_KEY_dead_breve                    0xfe55
+#define XKB_KEY_dead_abovedot                 0xfe56
+#define XKB_KEY_dead_diaeresis                0xfe57
+#define XKB_KEY_dead_abovering                0xfe58
+#define XKB_KEY_dead_doubleacute              0xfe59
+#define XKB_KEY_dead_caron                    0xfe5a
+#define XKB_KEY_dead_cedilla                  0xfe5b
+#define XKB_KEY_dead_ogonek                   0xfe5c
+#define XKB_KEY_dead_iota                     0xfe5d
+#define XKB_KEY_dead_voiced_sound             0xfe5e
+#define XKB_KEY_dead_semivoiced_sound         0xfe5f
+#define XKB_KEY_dead_belowdot                 0xfe60
+#define XKB_KEY_dead_hook                     0xfe61
+#define XKB_KEY_dead_horn                     0xfe62
+#define XKB_KEY_dead_stroke                   0xfe63
+#define XKB_KEY_dead_abovecomma               0xfe64
+#define XKB_KEY_dead_psili                    0xfe64  /* alias for dead_abovecomma */
+#define XKB_KEY_dead_abovereversedcomma       0xfe65
+#define XKB_KEY_dead_dasia                    0xfe65  /* alias for dead_abovereversedcomma */
+#define XKB_KEY_dead_doublegrave              0xfe66
+#define XKB_KEY_dead_belowring                0xfe67
+#define XKB_KEY_dead_belowmacron              0xfe68
+#define XKB_KEY_dead_belowcircumflex          0xfe69
+#define XKB_KEY_dead_belowtilde               0xfe6a
+#define XKB_KEY_dead_belowbreve               0xfe6b
+#define XKB_KEY_dead_belowdiaeresis           0xfe6c
+#define XKB_KEY_dead_invertedbreve            0xfe6d
+#define XKB_KEY_dead_belowcomma               0xfe6e
+#define XKB_KEY_dead_currency                 0xfe6f
+
+/* extra dead elements for German T3 layout */
+#define XKB_KEY_dead_lowline                  0xfe90
+#define XKB_KEY_dead_aboveverticalline        0xfe91
+#define XKB_KEY_dead_belowverticalline        0xfe92
+#define XKB_KEY_dead_longsolidusoverlay       0xfe93
+
+/* dead vowels for universal syllable entry */
+#define XKB_KEY_dead_a                        0xfe80
+#define XKB_KEY_dead_A                        0xfe81
+#define XKB_KEY_dead_e                        0xfe82
+#define XKB_KEY_dead_E                        0xfe83
+#define XKB_KEY_dead_i                        0xfe84
+#define XKB_KEY_dead_I                        0xfe85
+#define XKB_KEY_dead_o                        0xfe86
+#define XKB_KEY_dead_O                        0xfe87
+#define XKB_KEY_dead_u                        0xfe88
+#define XKB_KEY_dead_U                        0xfe89
+#define XKB_KEY_dead_small_schwa              0xfe8a
+#define XKB_KEY_dead_capital_schwa            0xfe8b
+
+#define XKB_KEY_dead_greek                    0xfe8c
+
+#define XKB_KEY_First_Virtual_Screen          0xfed0
+#define XKB_KEY_Prev_Virtual_Screen           0xfed1
+#define XKB_KEY_Next_Virtual_Screen           0xfed2
+#define XKB_KEY_Last_Virtual_Screen           0xfed4
+#define XKB_KEY_Terminate_Server              0xfed5
+
+#define XKB_KEY_AccessX_Enable                0xfe70
+#define XKB_KEY_AccessX_Feedback_Enable       0xfe71
+#define XKB_KEY_RepeatKeys_Enable             0xfe72
+#define XKB_KEY_SlowKeys_Enable               0xfe73
+#define XKB_KEY_BounceKeys_Enable             0xfe74
+#define XKB_KEY_StickyKeys_Enable             0xfe75
+#define XKB_KEY_MouseKeys_Enable              0xfe76
+#define XKB_KEY_MouseKeys_Accel_Enable        0xfe77
+#define XKB_KEY_Overlay1_Enable               0xfe78
+#define XKB_KEY_Overlay2_Enable               0xfe79
+#define XKB_KEY_AudibleBell_Enable            0xfe7a
+
+#define XKB_KEY_Pointer_Left                  0xfee0
+#define XKB_KEY_Pointer_Right                 0xfee1
+#define XKB_KEY_Pointer_Up                    0xfee2
+#define XKB_KEY_Pointer_Down                  0xfee3
+#define XKB_KEY_Pointer_UpLeft                0xfee4
+#define XKB_KEY_Pointer_UpRight               0xfee5
+#define XKB_KEY_Pointer_DownLeft              0xfee6
+#define XKB_KEY_Pointer_DownRight             0xfee7
+#define XKB_KEY_Pointer_Button_Dflt           0xfee8
+#define XKB_KEY_Pointer_Button1               0xfee9
+#define XKB_KEY_Pointer_Button2               0xfeea
+#define XKB_KEY_Pointer_Button3               0xfeeb
+#define XKB_KEY_Pointer_Button4               0xfeec
+#define XKB_KEY_Pointer_Button5               0xfeed
+#define XKB_KEY_Pointer_DblClick_Dflt         0xfeee
+#define XKB_KEY_Pointer_DblClick1             0xfeef
+#define XKB_KEY_Pointer_DblClick2             0xfef0
+#define XKB_KEY_Pointer_DblClick3             0xfef1
+#define XKB_KEY_Pointer_DblClick4             0xfef2
+#define XKB_KEY_Pointer_DblClick5             0xfef3
+#define XKB_KEY_Pointer_Drag_Dflt             0xfef4
+#define XKB_KEY_Pointer_Drag1                 0xfef5
+#define XKB_KEY_Pointer_Drag2                 0xfef6
+#define XKB_KEY_Pointer_Drag3                 0xfef7
+#define XKB_KEY_Pointer_Drag4                 0xfef8
+#define XKB_KEY_Pointer_Drag5                 0xfefd
+
+#define XKB_KEY_Pointer_EnableKeys            0xfef9
+#define XKB_KEY_Pointer_Accelerate            0xfefa
+#define XKB_KEY_Pointer_DfltBtnNext           0xfefb
+#define XKB_KEY_Pointer_DfltBtnPrev           0xfefc
+
+/* Single-Stroke Multiple-Character N-Graph Keysyms For The X Input Method */
+
+#define XKB_KEY_ch                            0xfea0
+#define XKB_KEY_Ch                            0xfea1
+#define XKB_KEY_CH                            0xfea2
+#define XKB_KEY_c_h                           0xfea3
+#define XKB_KEY_C_h                           0xfea4
+#define XKB_KEY_C_H                           0xfea5
+
+
+/*
+ * 3270 Terminal Keys
+ * Byte 3 = 0xfd
+ */
+
+#define XKB_KEY_3270_Duplicate                0xfd01
+#define XKB_KEY_3270_FieldMark                0xfd02
+#define XKB_KEY_3270_Right2                   0xfd03
+#define XKB_KEY_3270_Left2                    0xfd04
+#define XKB_KEY_3270_BackTab                  0xfd05
+#define XKB_KEY_3270_EraseEOF                 0xfd06
+#define XKB_KEY_3270_EraseInput               0xfd07
+#define XKB_KEY_3270_Reset                    0xfd08
+#define XKB_KEY_3270_Quit                     0xfd09
+#define XKB_KEY_3270_PA1                      0xfd0a
+#define XKB_KEY_3270_PA2                      0xfd0b
+#define XKB_KEY_3270_PA3                      0xfd0c
+#define XKB_KEY_3270_Test                     0xfd0d
+#define XKB_KEY_3270_Attn                     0xfd0e
+#define XKB_KEY_3270_CursorBlink              0xfd0f
+#define XKB_KEY_3270_AltCursor                0xfd10
+#define XKB_KEY_3270_KeyClick                 0xfd11
+#define XKB_KEY_3270_Jump                     0xfd12
+#define XKB_KEY_3270_Ident                    0xfd13
+#define XKB_KEY_3270_Rule                     0xfd14
+#define XKB_KEY_3270_Copy                     0xfd15
+#define XKB_KEY_3270_Play                     0xfd16
+#define XKB_KEY_3270_Setup                    0xfd17
+#define XKB_KEY_3270_Record                   0xfd18
+#define XKB_KEY_3270_ChangeScreen             0xfd19
+#define XKB_KEY_3270_DeleteWord               0xfd1a
+#define XKB_KEY_3270_ExSelect                 0xfd1b
+#define XKB_KEY_3270_CursorSelect             0xfd1c
+#define XKB_KEY_3270_PrintScreen              0xfd1d
+#define XKB_KEY_3270_Enter                    0xfd1e
+
+/*
+ * Latin 1
+ * (ISO/IEC 8859-1 = Unicode U+0020..U+00FF)
+ * Byte 3 = 0
+ */
+#define XKB_KEY_space                         0x0020  /* U+0020 SPACE */
+#define XKB_KEY_exclam                        0x0021  /* U+0021 EXCLAMATION MARK */
+#define XKB_KEY_quotedbl                      0x0022  /* U+0022 QUOTATION MARK */
+#define XKB_KEY_numbersign                    0x0023  /* U+0023 NUMBER SIGN */
+#define XKB_KEY_dollar                        0x0024  /* U+0024 DOLLAR SIGN */
+#define XKB_KEY_percent                       0x0025  /* U+0025 PERCENT SIGN */
+#define XKB_KEY_ampersand                     0x0026  /* U+0026 AMPERSAND */
+#define XKB_KEY_apostrophe                    0x0027  /* U+0027 APOSTROPHE */
+#define XKB_KEY_quoteright                    0x0027  /* deprecated */
+#define XKB_KEY_parenleft                     0x0028  /* U+0028 LEFT PARENTHESIS */
+#define XKB_KEY_parenright                    0x0029  /* U+0029 RIGHT PARENTHESIS */
+#define XKB_KEY_asterisk                      0x002a  /* U+002A ASTERISK */
+#define XKB_KEY_plus                          0x002b  /* U+002B PLUS SIGN */
+#define XKB_KEY_comma                         0x002c  /* U+002C COMMA */
+#define XKB_KEY_minus                         0x002d  /* U+002D HYPHEN-MINUS */
+#define XKB_KEY_period                        0x002e  /* U+002E FULL STOP */
+#define XKB_KEY_slash                         0x002f  /* U+002F SOLIDUS */
+#define XKB_KEY_0                             0x0030  /* U+0030 DIGIT ZERO */
+#define XKB_KEY_1                             0x0031  /* U+0031 DIGIT ONE */
+#define XKB_KEY_2                             0x0032  /* U+0032 DIGIT TWO */
+#define XKB_KEY_3                             0x0033  /* U+0033 DIGIT THREE */
+#define XKB_KEY_4                             0x0034  /* U+0034 DIGIT FOUR */
+#define XKB_KEY_5                             0x0035  /* U+0035 DIGIT FIVE */
+#define XKB_KEY_6                             0x0036  /* U+0036 DIGIT SIX */
+#define XKB_KEY_7                             0x0037  /* U+0037 DIGIT SEVEN */
+#define XKB_KEY_8                             0x0038  /* U+0038 DIGIT EIGHT */
+#define XKB_KEY_9                             0x0039  /* U+0039 DIGIT NINE */
+#define XKB_KEY_colon                         0x003a  /* U+003A COLON */
+#define XKB_KEY_semicolon                     0x003b  /* U+003B SEMICOLON */
+#define XKB_KEY_less                          0x003c  /* U+003C LESS-THAN SIGN */
+#define XKB_KEY_equal                         0x003d  /* U+003D EQUALS SIGN */
+#define XKB_KEY_greater                       0x003e  /* U+003E GREATER-THAN SIGN */
+#define XKB_KEY_question                      0x003f  /* U+003F QUESTION MARK */
+#define XKB_KEY_at                            0x0040  /* U+0040 COMMERCIAL AT */
+#define XKB_KEY_A                             0x0041  /* U+0041 LATIN CAPITAL LETTER A */
+#define XKB_KEY_B                             0x0042  /* U+0042 LATIN CAPITAL LETTER B */
+#define XKB_KEY_C                             0x0043  /* U+0043 LATIN CAPITAL LETTER C */
+#define XKB_KEY_D                             0x0044  /* U+0044 LATIN CAPITAL LETTER D */
+#define XKB_KEY_E                             0x0045  /* U+0045 LATIN CAPITAL LETTER E */
+#define XKB_KEY_F                             0x0046  /* U+0046 LATIN CAPITAL LETTER F */
+#define XKB_KEY_G                             0x0047  /* U+0047 LATIN CAPITAL LETTER G */
+#define XKB_KEY_H                             0x0048  /* U+0048 LATIN CAPITAL LETTER H */
+#define XKB_KEY_I                             0x0049  /* U+0049 LATIN CAPITAL LETTER I */
+#define XKB_KEY_J                             0x004a  /* U+004A LATIN CAPITAL LETTER J */
+#define XKB_KEY_K                             0x004b  /* U+004B LATIN CAPITAL LETTER K */
+#define XKB_KEY_L                             0x004c  /* U+004C LATIN CAPITAL LETTER L */
+#define XKB_KEY_M                             0x004d  /* U+004D LATIN CAPITAL LETTER M */
+#define XKB_KEY_N                             0x004e  /* U+004E LATIN CAPITAL LETTER N */
+#define XKB_KEY_O                             0x004f  /* U+004F LATIN CAPITAL LETTER O */
+#define XKB_KEY_P                             0x0050  /* U+0050 LATIN CAPITAL LETTER P */
+#define XKB_KEY_Q                             0x0051  /* U+0051 LATIN CAPITAL LETTER Q */
+#define XKB_KEY_R                             0x0052  /* U+0052 LATIN CAPITAL LETTER R */
+#define XKB_KEY_S                             0x0053  /* U+0053 LATIN CAPITAL LETTER S */
+#define XKB_KEY_T                             0x0054  /* U+0054 LATIN CAPITAL LETTER T */
+#define XKB_KEY_U                             0x0055  /* U+0055 LATIN CAPITAL LETTER U */
+#define XKB_KEY_V                             0x0056  /* U+0056 LATIN CAPITAL LETTER V */
+#define XKB_KEY_W                             0x0057  /* U+0057 LATIN CAPITAL LETTER W */
+#define XKB_KEY_X                             0x0058  /* U+0058 LATIN CAPITAL LETTER X */
+#define XKB_KEY_Y                             0x0059  /* U+0059 LATIN CAPITAL LETTER Y */
+#define XKB_KEY_Z                             0x005a  /* U+005A LATIN CAPITAL LETTER Z */
+#define XKB_KEY_bracketleft                   0x005b  /* U+005B LEFT SQUARE BRACKET */
+#define XKB_KEY_backslash                     0x005c  /* U+005C REVERSE SOLIDUS */
+#define XKB_KEY_bracketright                  0x005d  /* U+005D RIGHT SQUARE BRACKET */
+#define XKB_KEY_asciicircum                   0x005e  /* U+005E CIRCUMFLEX ACCENT */
+#define XKB_KEY_underscore                    0x005f  /* U+005F LOW LINE */
+#define XKB_KEY_grave                         0x0060  /* U+0060 GRAVE ACCENT */
+#define XKB_KEY_quoteleft                     0x0060  /* deprecated */
+#define XKB_KEY_a                             0x0061  /* U+0061 LATIN SMALL LETTER A */
+#define XKB_KEY_b                             0x0062  /* U+0062 LATIN SMALL LETTER B */
+#define XKB_KEY_c                             0x0063  /* U+0063 LATIN SMALL LETTER C */
+#define XKB_KEY_d                             0x0064  /* U+0064 LATIN SMALL LETTER D */
+#define XKB_KEY_e                             0x0065  /* U+0065 LATIN SMALL LETTER E */
+#define XKB_KEY_f                             0x0066  /* U+0066 LATIN SMALL LETTER F */
+#define XKB_KEY_g                             0x0067  /* U+0067 LATIN SMALL LETTER G */
+#define XKB_KEY_h                             0x0068  /* U+0068 LATIN SMALL LETTER H */
+#define XKB_KEY_i                             0x0069  /* U+0069 LATIN SMALL LETTER I */
+#define XKB_KEY_j                             0x006a  /* U+006A LATIN SMALL LETTER J */
+#define XKB_KEY_k                             0x006b  /* U+006B LATIN SMALL LETTER K */
+#define XKB_KEY_l                             0x006c  /* U+006C LATIN SMALL LETTER L */
+#define XKB_KEY_m                             0x006d  /* U+006D LATIN SMALL LETTER M */
+#define XKB_KEY_n                             0x006e  /* U+006E LATIN SMALL LETTER N */
+#define XKB_KEY_o                             0x006f  /* U+006F LATIN SMALL LETTER O */
+#define XKB_KEY_p                             0x0070  /* U+0070 LATIN SMALL LETTER P */
+#define XKB_KEY_q                             0x0071  /* U+0071 LATIN SMALL LETTER Q */
+#define XKB_KEY_r                             0x0072  /* U+0072 LATIN SMALL LETTER R */
+#define XKB_KEY_s                             0x0073  /* U+0073 LATIN SMALL LETTER S */
+#define XKB_KEY_t                             0x0074  /* U+0074 LATIN SMALL LETTER T */
+#define XKB_KEY_u                             0x0075  /* U+0075 LATIN SMALL LETTER U */
+#define XKB_KEY_v                             0x0076  /* U+0076 LATIN SMALL LETTER V */
+#define XKB_KEY_w                             0x0077  /* U+0077 LATIN SMALL LETTER W */
+#define XKB_KEY_x                             0x0078  /* U+0078 LATIN SMALL LETTER X */
+#define XKB_KEY_y                             0x0079  /* U+0079 LATIN SMALL LETTER Y */
+#define XKB_KEY_z                             0x007a  /* U+007A LATIN SMALL LETTER Z */
+#define XKB_KEY_braceleft                     0x007b  /* U+007B LEFT CURLY BRACKET */
+#define XKB_KEY_bar                           0x007c  /* U+007C VERTICAL LINE */
+#define XKB_KEY_braceright                    0x007d  /* U+007D RIGHT CURLY BRACKET */
+#define XKB_KEY_asciitilde                    0x007e  /* U+007E TILDE */
+
+#define XKB_KEY_nobreakspace                  0x00a0  /* U+00A0 NO-BREAK SPACE */
+#define XKB_KEY_exclamdown                    0x00a1  /* U+00A1 INVERTED EXCLAMATION MARK */
+#define XKB_KEY_cent                          0x00a2  /* U+00A2 CENT SIGN */
+#define XKB_KEY_sterling                      0x00a3  /* U+00A3 POUND SIGN */
+#define XKB_KEY_currency                      0x00a4  /* U+00A4 CURRENCY SIGN */
+#define XKB_KEY_yen                           0x00a5  /* U+00A5 YEN SIGN */
+#define XKB_KEY_brokenbar                     0x00a6  /* U+00A6 BROKEN BAR */
+#define XKB_KEY_section                       0x00a7  /* U+00A7 SECTION SIGN */
+#define XKB_KEY_diaeresis                     0x00a8  /* U+00A8 DIAERESIS */
+#define XKB_KEY_copyright                     0x00a9  /* U+00A9 COPYRIGHT SIGN */
+#define XKB_KEY_ordfeminine                   0x00aa  /* U+00AA FEMININE ORDINAL INDICATOR */
+#define XKB_KEY_guillemotleft                 0x00ab  /* U+00AB LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */
+#define XKB_KEY_notsign                       0x00ac  /* U+00AC NOT SIGN */
+#define XKB_KEY_hyphen                        0x00ad  /* U+00AD SOFT HYPHEN */
+#define XKB_KEY_registered                    0x00ae  /* U+00AE REGISTERED SIGN */
+#define XKB_KEY_macron                        0x00af  /* U+00AF MACRON */
+#define XKB_KEY_degree                        0x00b0  /* U+00B0 DEGREE SIGN */
+#define XKB_KEY_plusminus                     0x00b1  /* U+00B1 PLUS-MINUS SIGN */
+#define XKB_KEY_twosuperior                   0x00b2  /* U+00B2 SUPERSCRIPT TWO */
+#define XKB_KEY_threesuperior                 0x00b3  /* U+00B3 SUPERSCRIPT THREE */
+#define XKB_KEY_acute                         0x00b4  /* U+00B4 ACUTE ACCENT */
+#define XKB_KEY_mu                            0x00b5  /* U+00B5 MICRO SIGN */
+#define XKB_KEY_paragraph                     0x00b6  /* U+00B6 PILCROW SIGN */
+#define XKB_KEY_periodcentered                0x00b7  /* U+00B7 MIDDLE DOT */
+#define XKB_KEY_cedilla                       0x00b8  /* U+00B8 CEDILLA */
+#define XKB_KEY_onesuperior                   0x00b9  /* U+00B9 SUPERSCRIPT ONE */
+#define XKB_KEY_masculine                     0x00ba  /* U+00BA MASCULINE ORDINAL INDICATOR */
+#define XKB_KEY_guillemotright                0x00bb  /* U+00BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */
+#define XKB_KEY_onequarter                    0x00bc  /* U+00BC VULGAR FRACTION ONE QUARTER */
+#define XKB_KEY_onehalf                       0x00bd  /* U+00BD VULGAR FRACTION ONE HALF */
+#define XKB_KEY_threequarters                 0x00be  /* U+00BE VULGAR FRACTION THREE QUARTERS */
+#define XKB_KEY_questiondown                  0x00bf  /* U+00BF INVERTED QUESTION MARK */
+#define XKB_KEY_Agrave                        0x00c0  /* U+00C0 LATIN CAPITAL LETTER A WITH GRAVE */
+#define XKB_KEY_Aacute                        0x00c1  /* U+00C1 LATIN CAPITAL LETTER A WITH ACUTE */
+#define XKB_KEY_Acircumflex                   0x00c2  /* U+00C2 LATIN CAPITAL LETTER A WITH CIRCUMFLEX */
+#define XKB_KEY_Atilde                        0x00c3  /* U+00C3 LATIN CAPITAL LETTER A WITH TILDE */
+#define XKB_KEY_Adiaeresis                    0x00c4  /* U+00C4 LATIN CAPITAL LETTER A WITH DIAERESIS */
+#define XKB_KEY_Aring                         0x00c5  /* U+00C5 LATIN CAPITAL LETTER A WITH RING ABOVE */
+#define XKB_KEY_AE                            0x00c6  /* U+00C6 LATIN CAPITAL LETTER AE */
+#define XKB_KEY_Ccedilla                      0x00c7  /* U+00C7 LATIN CAPITAL LETTER C WITH CEDILLA */
+#define XKB_KEY_Egrave                        0x00c8  /* U+00C8 LATIN CAPITAL LETTER E WITH GRAVE */
+#define XKB_KEY_Eacute                        0x00c9  /* U+00C9 LATIN CAPITAL LETTER E WITH ACUTE */
+#define XKB_KEY_Ecircumflex                   0x00ca  /* U+00CA LATIN CAPITAL LETTER E WITH CIRCUMFLEX */
+#define XKB_KEY_Ediaeresis                    0x00cb  /* U+00CB LATIN CAPITAL LETTER E WITH DIAERESIS */
+#define XKB_KEY_Igrave                        0x00cc  /* U+00CC LATIN CAPITAL LETTER I WITH GRAVE */
+#define XKB_KEY_Iacute                        0x00cd  /* U+00CD LATIN CAPITAL LETTER I WITH ACUTE */
+#define XKB_KEY_Icircumflex                   0x00ce  /* U+00CE LATIN CAPITAL LETTER I WITH CIRCUMFLEX */
+#define XKB_KEY_Idiaeresis                    0x00cf  /* U+00CF LATIN CAPITAL LETTER I WITH DIAERESIS */
+#define XKB_KEY_ETH                           0x00d0  /* U+00D0 LATIN CAPITAL LETTER ETH */
+#define XKB_KEY_Eth                           0x00d0  /* deprecated */
+#define XKB_KEY_Ntilde                        0x00d1  /* U+00D1 LATIN CAPITAL LETTER N WITH TILDE */
+#define XKB_KEY_Ograve                        0x00d2  /* U+00D2 LATIN CAPITAL LETTER O WITH GRAVE */
+#define XKB_KEY_Oacute                        0x00d3  /* U+00D3 LATIN CAPITAL LETTER O WITH ACUTE */
+#define XKB_KEY_Ocircumflex                   0x00d4  /* U+00D4 LATIN CAPITAL LETTER O WITH CIRCUMFLEX */
+#define XKB_KEY_Otilde                        0x00d5  /* U+00D5 LATIN CAPITAL LETTER O WITH TILDE */
+#define XKB_KEY_Odiaeresis                    0x00d6  /* U+00D6 LATIN CAPITAL LETTER O WITH DIAERESIS */
+#define XKB_KEY_multiply                      0x00d7  /* U+00D7 MULTIPLICATION SIGN */
+#define XKB_KEY_Oslash                        0x00d8  /* U+00D8 LATIN CAPITAL LETTER O WITH STROKE */
+#define XKB_KEY_Ooblique                      0x00d8  /* U+00D8 LATIN CAPITAL LETTER O WITH STROKE */
+#define XKB_KEY_Ugrave                        0x00d9  /* U+00D9 LATIN CAPITAL LETTER U WITH GRAVE */
+#define XKB_KEY_Uacute                        0x00da  /* U+00DA LATIN CAPITAL LETTER U WITH ACUTE */
+#define XKB_KEY_Ucircumflex                   0x00db  /* U+00DB LATIN CAPITAL LETTER U WITH CIRCUMFLEX */
+#define XKB_KEY_Udiaeresis                    0x00dc  /* U+00DC LATIN CAPITAL LETTER U WITH DIAERESIS */
+#define XKB_KEY_Yacute                        0x00dd  /* U+00DD LATIN CAPITAL LETTER Y WITH ACUTE */
+#define XKB_KEY_THORN                         0x00de  /* U+00DE LATIN CAPITAL LETTER THORN */
+#define XKB_KEY_Thorn                         0x00de  /* deprecated */
+#define XKB_KEY_ssharp                        0x00df  /* U+00DF LATIN SMALL LETTER SHARP S */
+#define XKB_KEY_agrave                        0x00e0  /* U+00E0 LATIN SMALL LETTER A WITH GRAVE */
+#define XKB_KEY_aacute                        0x00e1  /* U+00E1 LATIN SMALL LETTER A WITH ACUTE */
+#define XKB_KEY_acircumflex                   0x00e2  /* U+00E2 LATIN SMALL LETTER A WITH CIRCUMFLEX */
+#define XKB_KEY_atilde                        0x00e3  /* U+00E3 LATIN SMALL LETTER A WITH TILDE */
+#define XKB_KEY_adiaeresis                    0x00e4  /* U+00E4 LATIN SMALL LETTER A WITH DIAERESIS */
+#define XKB_KEY_aring                         0x00e5  /* U+00E5 LATIN SMALL LETTER A WITH RING ABOVE */
+#define XKB_KEY_ae                            0x00e6  /* U+00E6 LATIN SMALL LETTER AE */
+#define XKB_KEY_ccedilla                      0x00e7  /* U+00E7 LATIN SMALL LETTER C WITH CEDILLA */
+#define XKB_KEY_egrave                        0x00e8  /* U+00E8 LATIN SMALL LETTER E WITH GRAVE */
+#define XKB_KEY_eacute                        0x00e9  /* U+00E9 LATIN SMALL LETTER E WITH ACUTE */
+#define XKB_KEY_ecircumflex                   0x00ea  /* U+00EA LATIN SMALL LETTER E WITH CIRCUMFLEX */
+#define XKB_KEY_ediaeresis                    0x00eb  /* U+00EB LATIN SMALL LETTER E WITH DIAERESIS */
+#define XKB_KEY_igrave                        0x00ec  /* U+00EC LATIN SMALL LETTER I WITH GRAVE */
+#define XKB_KEY_iacute                        0x00ed  /* U+00ED LATIN SMALL LETTER I WITH ACUTE */
+#define XKB_KEY_icircumflex                   0x00ee  /* U+00EE LATIN SMALL LETTER I WITH CIRCUMFLEX */
+#define XKB_KEY_idiaeresis                    0x00ef  /* U+00EF LATIN SMALL LETTER I WITH DIAERESIS */
+#define XKB_KEY_eth                           0x00f0  /* U+00F0 LATIN SMALL LETTER ETH */
+#define XKB_KEY_ntilde                        0x00f1  /* U+00F1 LATIN SMALL LETTER N WITH TILDE */
+#define XKB_KEY_ograve                        0x00f2  /* U+00F2 LATIN SMALL LETTER O WITH GRAVE */
+#define XKB_KEY_oacute                        0x00f3  /* U+00F3 LATIN SMALL LETTER O WITH ACUTE */
+#define XKB_KEY_ocircumflex                   0x00f4  /* U+00F4 LATIN SMALL LETTER O WITH CIRCUMFLEX */
+#define XKB_KEY_otilde                        0x00f5  /* U+00F5 LATIN SMALL LETTER O WITH TILDE */
+#define XKB_KEY_odiaeresis                    0x00f6  /* U+00F6 LATIN SMALL LETTER O WITH DIAERESIS */
+#define XKB_KEY_division                      0x00f7  /* U+00F7 DIVISION SIGN */
+#define XKB_KEY_oslash                        0x00f8  /* U+00F8 LATIN SMALL LETTER O WITH STROKE */
+#define XKB_KEY_ooblique                      0x00f8  /* U+00F8 LATIN SMALL LETTER O WITH STROKE */
+#define XKB_KEY_ugrave                        0x00f9  /* U+00F9 LATIN SMALL LETTER U WITH GRAVE */
+#define XKB_KEY_uacute                        0x00fa  /* U+00FA LATIN SMALL LETTER U WITH ACUTE */
+#define XKB_KEY_ucircumflex                   0x00fb  /* U+00FB LATIN SMALL LETTER U WITH CIRCUMFLEX */
+#define XKB_KEY_udiaeresis                    0x00fc  /* U+00FC LATIN SMALL LETTER U WITH DIAERESIS */
+#define XKB_KEY_yacute                        0x00fd  /* U+00FD LATIN SMALL LETTER Y WITH ACUTE */
+#define XKB_KEY_thorn                         0x00fe  /* U+00FE LATIN SMALL LETTER THORN */
+#define XKB_KEY_ydiaeresis                    0x00ff  /* U+00FF LATIN SMALL LETTER Y WITH DIAERESIS */
+
+/*
+ * Latin 2
+ * Byte 3 = 1
+ */
+
+#define XKB_KEY_Aogonek                       0x01a1  /* U+0104 LATIN CAPITAL LETTER A WITH OGONEK */
+#define XKB_KEY_breve                         0x01a2  /* U+02D8 BREVE */
+#define XKB_KEY_Lstroke                       0x01a3  /* U+0141 LATIN CAPITAL LETTER L WITH STROKE */
+#define XKB_KEY_Lcaron                        0x01a5  /* U+013D LATIN CAPITAL LETTER L WITH CARON */
+#define XKB_KEY_Sacute                        0x01a6  /* U+015A LATIN CAPITAL LETTER S WITH ACUTE */
+#define XKB_KEY_Scaron                        0x01a9  /* U+0160 LATIN CAPITAL LETTER S WITH CARON */
+#define XKB_KEY_Scedilla                      0x01aa  /* U+015E LATIN CAPITAL LETTER S WITH CEDILLA */
+#define XKB_KEY_Tcaron                        0x01ab  /* U+0164 LATIN CAPITAL LETTER T WITH CARON */
+#define XKB_KEY_Zacute                        0x01ac  /* U+0179 LATIN CAPITAL LETTER Z WITH ACUTE */
+#define XKB_KEY_Zcaron                        0x01ae  /* U+017D LATIN CAPITAL LETTER Z WITH CARON */
+#define XKB_KEY_Zabovedot                     0x01af  /* U+017B LATIN CAPITAL LETTER Z WITH DOT ABOVE */
+#define XKB_KEY_aogonek                       0x01b1  /* U+0105 LATIN SMALL LETTER A WITH OGONEK */
+#define XKB_KEY_ogonek                        0x01b2  /* U+02DB OGONEK */
+#define XKB_KEY_lstroke                       0x01b3  /* U+0142 LATIN SMALL LETTER L WITH STROKE */
+#define XKB_KEY_lcaron                        0x01b5  /* U+013E LATIN SMALL LETTER L WITH CARON */
+#define XKB_KEY_sacute                        0x01b6  /* U+015B LATIN SMALL LETTER S WITH ACUTE */
+#define XKB_KEY_caron                         0x01b7  /* U+02C7 CARON */
+#define XKB_KEY_scaron                        0x01b9  /* U+0161 LATIN SMALL LETTER S WITH CARON */
+#define XKB_KEY_scedilla                      0x01ba  /* U+015F LATIN SMALL LETTER S WITH CEDILLA */
+#define XKB_KEY_tcaron                        0x01bb  /* U+0165 LATIN SMALL LETTER T WITH CARON */
+#define XKB_KEY_zacute                        0x01bc  /* U+017A LATIN SMALL LETTER Z WITH ACUTE */
+#define XKB_KEY_doubleacute                   0x01bd  /* U+02DD DOUBLE ACUTE ACCENT */
+#define XKB_KEY_zcaron                        0x01be  /* U+017E LATIN SMALL LETTER Z WITH CARON */
+#define XKB_KEY_zabovedot                     0x01bf  /* U+017C LATIN SMALL LETTER Z WITH DOT ABOVE */
+#define XKB_KEY_Racute                        0x01c0  /* U+0154 LATIN CAPITAL LETTER R WITH ACUTE */
+#define XKB_KEY_Abreve                        0x01c3  /* U+0102 LATIN CAPITAL LETTER A WITH BREVE */
+#define XKB_KEY_Lacute                        0x01c5  /* U+0139 LATIN CAPITAL LETTER L WITH ACUTE */
+#define XKB_KEY_Cacute                        0x01c6  /* U+0106 LATIN CAPITAL LETTER C WITH ACUTE */
+#define XKB_KEY_Ccaron                        0x01c8  /* U+010C LATIN CAPITAL LETTER C WITH CARON */
+#define XKB_KEY_Eogonek                       0x01ca  /* U+0118 LATIN CAPITAL LETTER E WITH OGONEK */
+#define XKB_KEY_Ecaron                        0x01cc  /* U+011A LATIN CAPITAL LETTER E WITH CARON */
+#define XKB_KEY_Dcaron                        0x01cf  /* U+010E LATIN CAPITAL LETTER D WITH CARON */
+#define XKB_KEY_Dstroke                       0x01d0  /* U+0110 LATIN CAPITAL LETTER D WITH STROKE */
+#define XKB_KEY_Nacute                        0x01d1  /* U+0143 LATIN CAPITAL LETTER N WITH ACUTE */
+#define XKB_KEY_Ncaron                        0x01d2  /* U+0147 LATIN CAPITAL LETTER N WITH CARON */
+#define XKB_KEY_Odoubleacute                  0x01d5  /* U+0150 LATIN CAPITAL LETTER O WITH DOUBLE ACUTE */
+#define XKB_KEY_Rcaron                        0x01d8  /* U+0158 LATIN CAPITAL LETTER R WITH CARON */
+#define XKB_KEY_Uring                         0x01d9  /* U+016E LATIN CAPITAL LETTER U WITH RING ABOVE */
+#define XKB_KEY_Udoubleacute                  0x01db  /* U+0170 LATIN CAPITAL LETTER U WITH DOUBLE ACUTE */
+#define XKB_KEY_Tcedilla                      0x01de  /* U+0162 LATIN CAPITAL LETTER T WITH CEDILLA */
+#define XKB_KEY_racute                        0x01e0  /* U+0155 LATIN SMALL LETTER R WITH ACUTE */
+#define XKB_KEY_abreve                        0x01e3  /* U+0103 LATIN SMALL LETTER A WITH BREVE */
+#define XKB_KEY_lacute                        0x01e5  /* U+013A LATIN SMALL LETTER L WITH ACUTE */
+#define XKB_KEY_cacute                        0x01e6  /* U+0107 LATIN SMALL LETTER C WITH ACUTE */
+#define XKB_KEY_ccaron                        0x01e8  /* U+010D LATIN SMALL LETTER C WITH CARON */
+#define XKB_KEY_eogonek                       0x01ea  /* U+0119 LATIN SMALL LETTER E WITH OGONEK */
+#define XKB_KEY_ecaron                        0x01ec  /* U+011B LATIN SMALL LETTER E WITH CARON */
+#define XKB_KEY_dcaron                        0x01ef  /* U+010F LATIN SMALL LETTER D WITH CARON */
+#define XKB_KEY_dstroke                       0x01f0  /* U+0111 LATIN SMALL LETTER D WITH STROKE */
+#define XKB_KEY_nacute                        0x01f1  /* U+0144 LATIN SMALL LETTER N WITH ACUTE */
+#define XKB_KEY_ncaron                        0x01f2  /* U+0148 LATIN SMALL LETTER N WITH CARON */
+#define XKB_KEY_odoubleacute                  0x01f5  /* U+0151 LATIN SMALL LETTER O WITH DOUBLE ACUTE */
+#define XKB_KEY_rcaron                        0x01f8  /* U+0159 LATIN SMALL LETTER R WITH CARON */
+#define XKB_KEY_uring                         0x01f9  /* U+016F LATIN SMALL LETTER U WITH RING ABOVE */
+#define XKB_KEY_udoubleacute                  0x01fb  /* U+0171 LATIN SMALL LETTER U WITH DOUBLE ACUTE */
+#define XKB_KEY_tcedilla                      0x01fe  /* U+0163 LATIN SMALL LETTER T WITH CEDILLA */
+#define XKB_KEY_abovedot                      0x01ff  /* U+02D9 DOT ABOVE */
+
+/*
+ * Latin 3
+ * Byte 3 = 2
+ */
+
+#define XKB_KEY_Hstroke                       0x02a1  /* U+0126 LATIN CAPITAL LETTER H WITH STROKE */
+#define XKB_KEY_Hcircumflex                   0x02a6  /* U+0124 LATIN CAPITAL LETTER H WITH CIRCUMFLEX */
+#define XKB_KEY_Iabovedot                     0x02a9  /* U+0130 LATIN CAPITAL LETTER I WITH DOT ABOVE */
+#define XKB_KEY_Gbreve                        0x02ab  /* U+011E LATIN CAPITAL LETTER G WITH BREVE */
+#define XKB_KEY_Jcircumflex                   0x02ac  /* U+0134 LATIN CAPITAL LETTER J WITH CIRCUMFLEX */
+#define XKB_KEY_hstroke                       0x02b1  /* U+0127 LATIN SMALL LETTER H WITH STROKE */
+#define XKB_KEY_hcircumflex                   0x02b6  /* U+0125 LATIN SMALL LETTER H WITH CIRCUMFLEX */
+#define XKB_KEY_idotless                      0x02b9  /* U+0131 LATIN SMALL LETTER DOTLESS I */
+#define XKB_KEY_gbreve                        0x02bb  /* U+011F LATIN SMALL LETTER G WITH BREVE */
+#define XKB_KEY_jcircumflex                   0x02bc  /* U+0135 LATIN SMALL LETTER J WITH CIRCUMFLEX */
+#define XKB_KEY_Cabovedot                     0x02c5  /* U+010A LATIN CAPITAL LETTER C WITH DOT ABOVE */
+#define XKB_KEY_Ccircumflex                   0x02c6  /* U+0108 LATIN CAPITAL LETTER C WITH CIRCUMFLEX */
+#define XKB_KEY_Gabovedot                     0x02d5  /* U+0120 LATIN CAPITAL LETTER G WITH DOT ABOVE */
+#define XKB_KEY_Gcircumflex                   0x02d8  /* U+011C LATIN CAPITAL LETTER G WITH CIRCUMFLEX */
+#define XKB_KEY_Ubreve                        0x02dd  /* U+016C LATIN CAPITAL LETTER U WITH BREVE */
+#define XKB_KEY_Scircumflex                   0x02de  /* U+015C LATIN CAPITAL LETTER S WITH CIRCUMFLEX */
+#define XKB_KEY_cabovedot                     0x02e5  /* U+010B LATIN SMALL LETTER C WITH DOT ABOVE */
+#define XKB_KEY_ccircumflex                   0x02e6  /* U+0109 LATIN SMALL LETTER C WITH CIRCUMFLEX */
+#define XKB_KEY_gabovedot                     0x02f5  /* U+0121 LATIN SMALL LETTER G WITH DOT ABOVE */
+#define XKB_KEY_gcircumflex                   0x02f8  /* U+011D LATIN SMALL LETTER G WITH CIRCUMFLEX */
+#define XKB_KEY_ubreve                        0x02fd  /* U+016D LATIN SMALL LETTER U WITH BREVE */
+#define XKB_KEY_scircumflex                   0x02fe  /* U+015D LATIN SMALL LETTER S WITH CIRCUMFLEX */
+
+
+/*
+ * Latin 4
+ * Byte 3 = 3
+ */
+
+#define XKB_KEY_kra                           0x03a2  /* U+0138 LATIN SMALL LETTER KRA */
+#define XKB_KEY_kappa                         0x03a2  /* deprecated */
+#define XKB_KEY_Rcedilla                      0x03a3  /* U+0156 LATIN CAPITAL LETTER R WITH CEDILLA */
+#define XKB_KEY_Itilde                        0x03a5  /* U+0128 LATIN CAPITAL LETTER I WITH TILDE */
+#define XKB_KEY_Lcedilla                      0x03a6  /* U+013B LATIN CAPITAL LETTER L WITH CEDILLA */
+#define XKB_KEY_Emacron                       0x03aa  /* U+0112 LATIN CAPITAL LETTER E WITH MACRON */
+#define XKB_KEY_Gcedilla                      0x03ab  /* U+0122 LATIN CAPITAL LETTER G WITH CEDILLA */
+#define XKB_KEY_Tslash                        0x03ac  /* U+0166 LATIN CAPITAL LETTER T WITH STROKE */
+#define XKB_KEY_rcedilla                      0x03b3  /* U+0157 LATIN SMALL LETTER R WITH CEDILLA */
+#define XKB_KEY_itilde                        0x03b5  /* U+0129 LATIN SMALL LETTER I WITH TILDE */
+#define XKB_KEY_lcedilla                      0x03b6  /* U+013C LATIN SMALL LETTER L WITH CEDILLA */
+#define XKB_KEY_emacron                       0x03ba  /* U+0113 LATIN SMALL LETTER E WITH MACRON */
+#define XKB_KEY_gcedilla                      0x03bb  /* U+0123 LATIN SMALL LETTER G WITH CEDILLA */
+#define XKB_KEY_tslash                        0x03bc  /* U+0167 LATIN SMALL LETTER T WITH STROKE */
+#define XKB_KEY_ENG                           0x03bd  /* U+014A LATIN CAPITAL LETTER ENG */
+#define XKB_KEY_eng                           0x03bf  /* U+014B LATIN SMALL LETTER ENG */
+#define XKB_KEY_Amacron                       0x03c0  /* U+0100 LATIN CAPITAL LETTER A WITH MACRON */
+#define XKB_KEY_Iogonek                       0x03c7  /* U+012E LATIN CAPITAL LETTER I WITH OGONEK */
+#define XKB_KEY_Eabovedot                     0x03cc  /* U+0116 LATIN CAPITAL LETTER E WITH DOT ABOVE */
+#define XKB_KEY_Imacron                       0x03cf  /* U+012A LATIN CAPITAL LETTER I WITH MACRON */
+#define XKB_KEY_Ncedilla                      0x03d1  /* U+0145 LATIN CAPITAL LETTER N WITH CEDILLA */
+#define XKB_KEY_Omacron                       0x03d2  /* U+014C LATIN CAPITAL LETTER O WITH MACRON */
+#define XKB_KEY_Kcedilla                      0x03d3  /* U+0136 LATIN CAPITAL LETTER K WITH CEDILLA */
+#define XKB_KEY_Uogonek                       0x03d9  /* U+0172 LATIN CAPITAL LETTER U WITH OGONEK */
+#define XKB_KEY_Utilde                        0x03dd  /* U+0168 LATIN CAPITAL LETTER U WITH TILDE */
+#define XKB_KEY_Umacron                       0x03de  /* U+016A LATIN CAPITAL LETTER U WITH MACRON */
+#define XKB_KEY_amacron                       0x03e0  /* U+0101 LATIN SMALL LETTER A WITH MACRON */
+#define XKB_KEY_iogonek                       0x03e7  /* U+012F LATIN SMALL LETTER I WITH OGONEK */
+#define XKB_KEY_eabovedot                     0x03ec  /* U+0117 LATIN SMALL LETTER E WITH DOT ABOVE */
+#define XKB_KEY_imacron                       0x03ef  /* U+012B LATIN SMALL LETTER I WITH MACRON */
+#define XKB_KEY_ncedilla                      0x03f1  /* U+0146 LATIN SMALL LETTER N WITH CEDILLA */
+#define XKB_KEY_omacron                       0x03f2  /* U+014D LATIN SMALL LETTER O WITH MACRON */
+#define XKB_KEY_kcedilla                      0x03f3  /* U+0137 LATIN SMALL LETTER K WITH CEDILLA */
+#define XKB_KEY_uogonek                       0x03f9  /* U+0173 LATIN SMALL LETTER U WITH OGONEK */
+#define XKB_KEY_utilde                        0x03fd  /* U+0169 LATIN SMALL LETTER U WITH TILDE */
+#define XKB_KEY_umacron                       0x03fe  /* U+016B LATIN SMALL LETTER U WITH MACRON */
+
+/*
+ * Latin 8
+ */
+#define XKB_KEY_Wcircumflex                0x1000174  /* U+0174 LATIN CAPITAL LETTER W WITH CIRCUMFLEX */
+#define XKB_KEY_wcircumflex                0x1000175  /* U+0175 LATIN SMALL LETTER W WITH CIRCUMFLEX */
+#define XKB_KEY_Ycircumflex                0x1000176  /* U+0176 LATIN CAPITAL LETTER Y WITH CIRCUMFLEX */
+#define XKB_KEY_ycircumflex                0x1000177  /* U+0177 LATIN SMALL LETTER Y WITH CIRCUMFLEX */
+#define XKB_KEY_Babovedot                  0x1001e02  /* U+1E02 LATIN CAPITAL LETTER B WITH DOT ABOVE */
+#define XKB_KEY_babovedot                  0x1001e03  /* U+1E03 LATIN SMALL LETTER B WITH DOT ABOVE */
+#define XKB_KEY_Dabovedot                  0x1001e0a  /* U+1E0A LATIN CAPITAL LETTER D WITH DOT ABOVE */
+#define XKB_KEY_dabovedot                  0x1001e0b  /* U+1E0B LATIN SMALL LETTER D WITH DOT ABOVE */
+#define XKB_KEY_Fabovedot                  0x1001e1e  /* U+1E1E LATIN CAPITAL LETTER F WITH DOT ABOVE */
+#define XKB_KEY_fabovedot                  0x1001e1f  /* U+1E1F LATIN SMALL LETTER F WITH DOT ABOVE */
+#define XKB_KEY_Mabovedot                  0x1001e40  /* U+1E40 LATIN CAPITAL LETTER M WITH DOT ABOVE */
+#define XKB_KEY_mabovedot                  0x1001e41  /* U+1E41 LATIN SMALL LETTER M WITH DOT ABOVE */
+#define XKB_KEY_Pabovedot                  0x1001e56  /* U+1E56 LATIN CAPITAL LETTER P WITH DOT ABOVE */
+#define XKB_KEY_pabovedot                  0x1001e57  /* U+1E57 LATIN SMALL LETTER P WITH DOT ABOVE */
+#define XKB_KEY_Sabovedot                  0x1001e60  /* U+1E60 LATIN CAPITAL LETTER S WITH DOT ABOVE */
+#define XKB_KEY_sabovedot                  0x1001e61  /* U+1E61 LATIN SMALL LETTER S WITH DOT ABOVE */
+#define XKB_KEY_Tabovedot                  0x1001e6a  /* U+1E6A LATIN CAPITAL LETTER T WITH DOT ABOVE */
+#define XKB_KEY_tabovedot                  0x1001e6b  /* U+1E6B LATIN SMALL LETTER T WITH DOT ABOVE */
+#define XKB_KEY_Wgrave                     0x1001e80  /* U+1E80 LATIN CAPITAL LETTER W WITH GRAVE */
+#define XKB_KEY_wgrave                     0x1001e81  /* U+1E81 LATIN SMALL LETTER W WITH GRAVE */
+#define XKB_KEY_Wacute                     0x1001e82  /* U+1E82 LATIN CAPITAL LETTER W WITH ACUTE */
+#define XKB_KEY_wacute                     0x1001e83  /* U+1E83 LATIN SMALL LETTER W WITH ACUTE */
+#define XKB_KEY_Wdiaeresis                 0x1001e84  /* U+1E84 LATIN CAPITAL LETTER W WITH DIAERESIS */
+#define XKB_KEY_wdiaeresis                 0x1001e85  /* U+1E85 LATIN SMALL LETTER W WITH DIAERESIS */
+#define XKB_KEY_Ygrave                     0x1001ef2  /* U+1EF2 LATIN CAPITAL LETTER Y WITH GRAVE */
+#define XKB_KEY_ygrave                     0x1001ef3  /* U+1EF3 LATIN SMALL LETTER Y WITH GRAVE */
+
+/*
+ * Latin 9
+ * Byte 3 = 0x13
+ */
+
+#define XKB_KEY_OE                            0x13bc  /* U+0152 LATIN CAPITAL LIGATURE OE */
+#define XKB_KEY_oe                            0x13bd  /* U+0153 LATIN SMALL LIGATURE OE */
+#define XKB_KEY_Ydiaeresis                    0x13be  /* U+0178 LATIN CAPITAL LETTER Y WITH DIAERESIS */
+
+/*
+ * Katakana
+ * Byte 3 = 4
+ */
+
+#define XKB_KEY_overline                      0x047e  /* U+203E OVERLINE */
+#define XKB_KEY_kana_fullstop                 0x04a1  /* U+3002 IDEOGRAPHIC FULL STOP */
+#define XKB_KEY_kana_openingbracket           0x04a2  /* U+300C LEFT CORNER BRACKET */
+#define XKB_KEY_kana_closingbracket           0x04a3  /* U+300D RIGHT CORNER BRACKET */
+#define XKB_KEY_kana_comma                    0x04a4  /* U+3001 IDEOGRAPHIC COMMA */
+#define XKB_KEY_kana_conjunctive              0x04a5  /* U+30FB KATAKANA MIDDLE DOT */
+#define XKB_KEY_kana_middledot                0x04a5  /* deprecated */
+#define XKB_KEY_kana_WO                       0x04a6  /* U+30F2 KATAKANA LETTER WO */
+#define XKB_KEY_kana_a                        0x04a7  /* U+30A1 KATAKANA LETTER SMALL A */
+#define XKB_KEY_kana_i                        0x04a8  /* U+30A3 KATAKANA LETTER SMALL I */
+#define XKB_KEY_kana_u                        0x04a9  /* U+30A5 KATAKANA LETTER SMALL U */
+#define XKB_KEY_kana_e                        0x04aa  /* U+30A7 KATAKANA LETTER SMALL E */
+#define XKB_KEY_kana_o                        0x04ab  /* U+30A9 KATAKANA LETTER SMALL O */
+#define XKB_KEY_kana_ya                       0x04ac  /* U+30E3 KATAKANA LETTER SMALL YA */
+#define XKB_KEY_kana_yu                       0x04ad  /* U+30E5 KATAKANA LETTER SMALL YU */
+#define XKB_KEY_kana_yo                       0x04ae  /* U+30E7 KATAKANA LETTER SMALL YO */
+#define XKB_KEY_kana_tsu                      0x04af  /* U+30C3 KATAKANA LETTER SMALL TU */
+#define XKB_KEY_kana_tu                       0x04af  /* deprecated */
+#define XKB_KEY_prolongedsound                0x04b0  /* U+30FC KATAKANA-HIRAGANA PROLONGED SOUND MARK */
+#define XKB_KEY_kana_A                        0x04b1  /* U+30A2 KATAKANA LETTER A */
+#define XKB_KEY_kana_I                        0x04b2  /* U+30A4 KATAKANA LETTER I */
+#define XKB_KEY_kana_U                        0x04b3  /* U+30A6 KATAKANA LETTER U */
+#define XKB_KEY_kana_E                        0x04b4  /* U+30A8 KATAKANA LETTER E */
+#define XKB_KEY_kana_O                        0x04b5  /* U+30AA KATAKANA LETTER O */
+#define XKB_KEY_kana_KA                       0x04b6  /* U+30AB KATAKANA LETTER KA */
+#define XKB_KEY_kana_KI                       0x04b7  /* U+30AD KATAKANA LETTER KI */
+#define XKB_KEY_kana_KU                       0x04b8  /* U+30AF KATAKANA LETTER KU */
+#define XKB_KEY_kana_KE                       0x04b9  /* U+30B1 KATAKANA LETTER KE */
+#define XKB_KEY_kana_KO                       0x04ba  /* U+30B3 KATAKANA LETTER KO */
+#define XKB_KEY_kana_SA                       0x04bb  /* U+30B5 KATAKANA LETTER SA */
+#define XKB_KEY_kana_SHI                      0x04bc  /* U+30B7 KATAKANA LETTER SI */
+#define XKB_KEY_kana_SU                       0x04bd  /* U+30B9 KATAKANA LETTER SU */
+#define XKB_KEY_kana_SE                       0x04be  /* U+30BB KATAKANA LETTER SE */
+#define XKB_KEY_kana_SO                       0x04bf  /* U+30BD KATAKANA LETTER SO */
+#define XKB_KEY_kana_TA                       0x04c0  /* U+30BF KATAKANA LETTER TA */
+#define XKB_KEY_kana_CHI                      0x04c1  /* U+30C1 KATAKANA LETTER TI */
+#define XKB_KEY_kana_TI                       0x04c1  /* deprecated */
+#define XKB_KEY_kana_TSU                      0x04c2  /* U+30C4 KATAKANA LETTER TU */
+#define XKB_KEY_kana_TU                       0x04c2  /* deprecated */
+#define XKB_KEY_kana_TE                       0x04c3  /* U+30C6 KATAKANA LETTER TE */
+#define XKB_KEY_kana_TO                       0x04c4  /* U+30C8 KATAKANA LETTER TO */
+#define XKB_KEY_kana_NA                       0x04c5  /* U+30CA KATAKANA LETTER NA */
+#define XKB_KEY_kana_NI                       0x04c6  /* U+30CB KATAKANA LETTER NI */
+#define XKB_KEY_kana_NU                       0x04c7  /* U+30CC KATAKANA LETTER NU */
+#define XKB_KEY_kana_NE                       0x04c8  /* U+30CD KATAKANA LETTER NE */
+#define XKB_KEY_kana_NO                       0x04c9  /* U+30CE KATAKANA LETTER NO */
+#define XKB_KEY_kana_HA                       0x04ca  /* U+30CF KATAKANA LETTER HA */
+#define XKB_KEY_kana_HI                       0x04cb  /* U+30D2 KATAKANA LETTER HI */
+#define XKB_KEY_kana_FU                       0x04cc  /* U+30D5 KATAKANA LETTER HU */
+#define XKB_KEY_kana_HU                       0x04cc  /* deprecated */
+#define XKB_KEY_kana_HE                       0x04cd  /* U+30D8 KATAKANA LETTER HE */
+#define XKB_KEY_kana_HO                       0x04ce  /* U+30DB KATAKANA LETTER HO */
+#define XKB_KEY_kana_MA                       0x04cf  /* U+30DE KATAKANA LETTER MA */
+#define XKB_KEY_kana_MI                       0x04d0  /* U+30DF KATAKANA LETTER MI */
+#define XKB_KEY_kana_MU                       0x04d1  /* U+30E0 KATAKANA LETTER MU */
+#define XKB_KEY_kana_ME                       0x04d2  /* U+30E1 KATAKANA LETTER ME */
+#define XKB_KEY_kana_MO                       0x04d3  /* U+30E2 KATAKANA LETTER MO */
+#define XKB_KEY_kana_YA                       0x04d4  /* U+30E4 KATAKANA LETTER YA */
+#define XKB_KEY_kana_YU                       0x04d5  /* U+30E6 KATAKANA LETTER YU */
+#define XKB_KEY_kana_YO                       0x04d6  /* U+30E8 KATAKANA LETTER YO */
+#define XKB_KEY_kana_RA                       0x04d7  /* U+30E9 KATAKANA LETTER RA */
+#define XKB_KEY_kana_RI                       0x04d8  /* U+30EA KATAKANA LETTER RI */
+#define XKB_KEY_kana_RU                       0x04d9  /* U+30EB KATAKANA LETTER RU */
+#define XKB_KEY_kana_RE                       0x04da  /* U+30EC KATAKANA LETTER RE */
+#define XKB_KEY_kana_RO                       0x04db  /* U+30ED KATAKANA LETTER RO */
+#define XKB_KEY_kana_WA                       0x04dc  /* U+30EF KATAKANA LETTER WA */
+#define XKB_KEY_kana_N                        0x04dd  /* U+30F3 KATAKANA LETTER N */
+#define XKB_KEY_voicedsound                   0x04de  /* U+309B KATAKANA-HIRAGANA VOICED SOUND MARK */
+#define XKB_KEY_semivoicedsound               0x04df  /* U+309C KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK */
+#define XKB_KEY_kana_switch                   0xff7e  /* Alias for mode_switch */
+
+/*
+ * Arabic
+ * Byte 3 = 5
+ */
+
+#define XKB_KEY_Farsi_0                    0x10006f0  /* U+06F0 EXTENDED ARABIC-INDIC DIGIT ZERO */
+#define XKB_KEY_Farsi_1                    0x10006f1  /* U+06F1 EXTENDED ARABIC-INDIC DIGIT ONE */
+#define XKB_KEY_Farsi_2                    0x10006f2  /* U+06F2 EXTENDED ARABIC-INDIC DIGIT TWO */
+#define XKB_KEY_Farsi_3                    0x10006f3  /* U+06F3 EXTENDED ARABIC-INDIC DIGIT THREE */
+#define XKB_KEY_Farsi_4                    0x10006f4  /* U+06F4 EXTENDED ARABIC-INDIC DIGIT FOUR */
+#define XKB_KEY_Farsi_5                    0x10006f5  /* U+06F5 EXTENDED ARABIC-INDIC DIGIT FIVE */
+#define XKB_KEY_Farsi_6                    0x10006f6  /* U+06F6 EXTENDED ARABIC-INDIC DIGIT SIX */
+#define XKB_KEY_Farsi_7                    0x10006f7  /* U+06F7 EXTENDED ARABIC-INDIC DIGIT SEVEN */
+#define XKB_KEY_Farsi_8                    0x10006f8  /* U+06F8 EXTENDED ARABIC-INDIC DIGIT EIGHT */
+#define XKB_KEY_Farsi_9                    0x10006f9  /* U+06F9 EXTENDED ARABIC-INDIC DIGIT NINE */
+#define XKB_KEY_Arabic_percent             0x100066a  /* U+066A ARABIC PERCENT SIGN */
+#define XKB_KEY_Arabic_superscript_alef    0x1000670  /* U+0670 ARABIC LETTER SUPERSCRIPT ALEF */
+#define XKB_KEY_Arabic_tteh                0x1000679  /* U+0679 ARABIC LETTER TTEH */
+#define XKB_KEY_Arabic_peh                 0x100067e  /* U+067E ARABIC LETTER PEH */
+#define XKB_KEY_Arabic_tcheh               0x1000686  /* U+0686 ARABIC LETTER TCHEH */
+#define XKB_KEY_Arabic_ddal                0x1000688  /* U+0688 ARABIC LETTER DDAL */
+#define XKB_KEY_Arabic_rreh                0x1000691  /* U+0691 ARABIC LETTER RREH */
+#define XKB_KEY_Arabic_comma                  0x05ac  /* U+060C ARABIC COMMA */
+#define XKB_KEY_Arabic_fullstop            0x10006d4  /* U+06D4 ARABIC FULL STOP */
+#define XKB_KEY_Arabic_0                   0x1000660  /* U+0660 ARABIC-INDIC DIGIT ZERO */
+#define XKB_KEY_Arabic_1                   0x1000661  /* U+0661 ARABIC-INDIC DIGIT ONE */
+#define XKB_KEY_Arabic_2                   0x1000662  /* U+0662 ARABIC-INDIC DIGIT TWO */
+#define XKB_KEY_Arabic_3                   0x1000663  /* U+0663 ARABIC-INDIC DIGIT THREE */
+#define XKB_KEY_Arabic_4                   0x1000664  /* U+0664 ARABIC-INDIC DIGIT FOUR */
+#define XKB_KEY_Arabic_5                   0x1000665  /* U+0665 ARABIC-INDIC DIGIT FIVE */
+#define XKB_KEY_Arabic_6                   0x1000666  /* U+0666 ARABIC-INDIC DIGIT SIX */
+#define XKB_KEY_Arabic_7                   0x1000667  /* U+0667 ARABIC-INDIC DIGIT SEVEN */
+#define XKB_KEY_Arabic_8                   0x1000668  /* U+0668 ARABIC-INDIC DIGIT EIGHT */
+#define XKB_KEY_Arabic_9                   0x1000669  /* U+0669 ARABIC-INDIC DIGIT NINE */
+#define XKB_KEY_Arabic_semicolon              0x05bb  /* U+061B ARABIC SEMICOLON */
+#define XKB_KEY_Arabic_question_mark          0x05bf  /* U+061F ARABIC QUESTION MARK */
+#define XKB_KEY_Arabic_hamza                  0x05c1  /* U+0621 ARABIC LETTER HAMZA */
+#define XKB_KEY_Arabic_maddaonalef            0x05c2  /* U+0622 ARABIC LETTER ALEF WITH MADDA ABOVE */
+#define XKB_KEY_Arabic_hamzaonalef            0x05c3  /* U+0623 ARABIC LETTER ALEF WITH HAMZA ABOVE */
+#define XKB_KEY_Arabic_hamzaonwaw             0x05c4  /* U+0624 ARABIC LETTER WAW WITH HAMZA ABOVE */
+#define XKB_KEY_Arabic_hamzaunderalef         0x05c5  /* U+0625 ARABIC LETTER ALEF WITH HAMZA BELOW */
+#define XKB_KEY_Arabic_hamzaonyeh             0x05c6  /* U+0626 ARABIC LETTER YEH WITH HAMZA ABOVE */
+#define XKB_KEY_Arabic_alef                   0x05c7  /* U+0627 ARABIC LETTER ALEF */
+#define XKB_KEY_Arabic_beh                    0x05c8  /* U+0628 ARABIC LETTER BEH */
+#define XKB_KEY_Arabic_tehmarbuta             0x05c9  /* U+0629 ARABIC LETTER TEH MARBUTA */
+#define XKB_KEY_Arabic_teh                    0x05ca  /* U+062A ARABIC LETTER TEH */
+#define XKB_KEY_Arabic_theh                   0x05cb  /* U+062B ARABIC LETTER THEH */
+#define XKB_KEY_Arabic_jeem                   0x05cc  /* U+062C ARABIC LETTER JEEM */
+#define XKB_KEY_Arabic_hah                    0x05cd  /* U+062D ARABIC LETTER HAH */
+#define XKB_KEY_Arabic_khah                   0x05ce  /* U+062E ARABIC LETTER KHAH */
+#define XKB_KEY_Arabic_dal                    0x05cf  /* U+062F ARABIC LETTER DAL */
+#define XKB_KEY_Arabic_thal                   0x05d0  /* U+0630 ARABIC LETTER THAL */
+#define XKB_KEY_Arabic_ra                     0x05d1  /* U+0631 ARABIC LETTER REH */
+#define XKB_KEY_Arabic_zain                   0x05d2  /* U+0632 ARABIC LETTER ZAIN */
+#define XKB_KEY_Arabic_seen                   0x05d3  /* U+0633 ARABIC LETTER SEEN */
+#define XKB_KEY_Arabic_sheen                  0x05d4  /* U+0634 ARABIC LETTER SHEEN */
+#define XKB_KEY_Arabic_sad                    0x05d5  /* U+0635 ARABIC LETTER SAD */
+#define XKB_KEY_Arabic_dad                    0x05d6  /* U+0636 ARABIC LETTER DAD */
+#define XKB_KEY_Arabic_tah                    0x05d7  /* U+0637 ARABIC LETTER TAH */
+#define XKB_KEY_Arabic_zah                    0x05d8  /* U+0638 ARABIC LETTER ZAH */
+#define XKB_KEY_Arabic_ain                    0x05d9  /* U+0639 ARABIC LETTER AIN */
+#define XKB_KEY_Arabic_ghain                  0x05da  /* U+063A ARABIC LETTER GHAIN */
+#define XKB_KEY_Arabic_tatweel                0x05e0  /* U+0640 ARABIC TATWEEL */
+#define XKB_KEY_Arabic_feh                    0x05e1  /* U+0641 ARABIC LETTER FEH */
+#define XKB_KEY_Arabic_qaf                    0x05e2  /* U+0642 ARABIC LETTER QAF */
+#define XKB_KEY_Arabic_kaf                    0x05e3  /* U+0643 ARABIC LETTER KAF */
+#define XKB_KEY_Arabic_lam                    0x05e4  /* U+0644 ARABIC LETTER LAM */
+#define XKB_KEY_Arabic_meem                   0x05e5  /* U+0645 ARABIC LETTER MEEM */
+#define XKB_KEY_Arabic_noon                   0x05e6  /* U+0646 ARABIC LETTER NOON */
+#define XKB_KEY_Arabic_ha                     0x05e7  /* U+0647 ARABIC LETTER HEH */
+#define XKB_KEY_Arabic_heh                    0x05e7  /* deprecated */
+#define XKB_KEY_Arabic_waw                    0x05e8  /* U+0648 ARABIC LETTER WAW */
+#define XKB_KEY_Arabic_alefmaksura            0x05e9  /* U+0649 ARABIC LETTER ALEF MAKSURA */
+#define XKB_KEY_Arabic_yeh                    0x05ea  /* U+064A ARABIC LETTER YEH */
+#define XKB_KEY_Arabic_fathatan               0x05eb  /* U+064B ARABIC FATHATAN */
+#define XKB_KEY_Arabic_dammatan               0x05ec  /* U+064C ARABIC DAMMATAN */
+#define XKB_KEY_Arabic_kasratan               0x05ed  /* U+064D ARABIC KASRATAN */
+#define XKB_KEY_Arabic_fatha                  0x05ee  /* U+064E ARABIC FATHA */
+#define XKB_KEY_Arabic_damma                  0x05ef  /* U+064F ARABIC DAMMA */
+#define XKB_KEY_Arabic_kasra                  0x05f0  /* U+0650 ARABIC KASRA */
+#define XKB_KEY_Arabic_shadda                 0x05f1  /* U+0651 ARABIC SHADDA */
+#define XKB_KEY_Arabic_sukun                  0x05f2  /* U+0652 ARABIC SUKUN */
+#define XKB_KEY_Arabic_madda_above         0x1000653  /* U+0653 ARABIC MADDAH ABOVE */
+#define XKB_KEY_Arabic_hamza_above         0x1000654  /* U+0654 ARABIC HAMZA ABOVE */
+#define XKB_KEY_Arabic_hamza_below         0x1000655  /* U+0655 ARABIC HAMZA BELOW */
+#define XKB_KEY_Arabic_jeh                 0x1000698  /* U+0698 ARABIC LETTER JEH */
+#define XKB_KEY_Arabic_veh                 0x10006a4  /* U+06A4 ARABIC LETTER VEH */
+#define XKB_KEY_Arabic_keheh               0x10006a9  /* U+06A9 ARABIC LETTER KEHEH */
+#define XKB_KEY_Arabic_gaf                 0x10006af  /* U+06AF ARABIC LETTER GAF */
+#define XKB_KEY_Arabic_noon_ghunna         0x10006ba  /* U+06BA ARABIC LETTER NOON GHUNNA */
+#define XKB_KEY_Arabic_heh_doachashmee     0x10006be  /* U+06BE ARABIC LETTER HEH DOACHASHMEE */
+#define XKB_KEY_Farsi_yeh                  0x10006cc  /* U+06CC ARABIC LETTER FARSI YEH */
+#define XKB_KEY_Arabic_farsi_yeh           0x10006cc  /* U+06CC ARABIC LETTER FARSI YEH */
+#define XKB_KEY_Arabic_yeh_baree           0x10006d2  /* U+06D2 ARABIC LETTER YEH BARREE */
+#define XKB_KEY_Arabic_heh_goal            0x10006c1  /* U+06C1 ARABIC LETTER HEH GOAL */
+#define XKB_KEY_Arabic_switch                 0xff7e  /* Alias for mode_switch */
+
+/*
+ * Cyrillic
+ * Byte 3 = 6
+ */
+#define XKB_KEY_Cyrillic_GHE_bar           0x1000492  /* U+0492 CYRILLIC CAPITAL LETTER GHE WITH STROKE */
+#define XKB_KEY_Cyrillic_ghe_bar           0x1000493  /* U+0493 CYRILLIC SMALL LETTER GHE WITH STROKE */
+#define XKB_KEY_Cyrillic_ZHE_descender     0x1000496  /* U+0496 CYRILLIC CAPITAL LETTER ZHE WITH DESCENDER */
+#define XKB_KEY_Cyrillic_zhe_descender     0x1000497  /* U+0497 CYRILLIC SMALL LETTER ZHE WITH DESCENDER */
+#define XKB_KEY_Cyrillic_KA_descender      0x100049a  /* U+049A CYRILLIC CAPITAL LETTER KA WITH DESCENDER */
+#define XKB_KEY_Cyrillic_ka_descender      0x100049b  /* U+049B CYRILLIC SMALL LETTER KA WITH DESCENDER */
+#define XKB_KEY_Cyrillic_KA_vertstroke     0x100049c  /* U+049C CYRILLIC CAPITAL LETTER KA WITH VERTICAL STROKE */
+#define XKB_KEY_Cyrillic_ka_vertstroke     0x100049d  /* U+049D CYRILLIC SMALL LETTER KA WITH VERTICAL STROKE */
+#define XKB_KEY_Cyrillic_EN_descender      0x10004a2  /* U+04A2 CYRILLIC CAPITAL LETTER EN WITH DESCENDER */
+#define XKB_KEY_Cyrillic_en_descender      0x10004a3  /* U+04A3 CYRILLIC SMALL LETTER EN WITH DESCENDER */
+#define XKB_KEY_Cyrillic_U_straight        0x10004ae  /* U+04AE CYRILLIC CAPITAL LETTER STRAIGHT U */
+#define XKB_KEY_Cyrillic_u_straight        0x10004af  /* U+04AF CYRILLIC SMALL LETTER STRAIGHT U */
+#define XKB_KEY_Cyrillic_U_straight_bar    0x10004b0  /* U+04B0 CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE */
+#define XKB_KEY_Cyrillic_u_straight_bar    0x10004b1  /* U+04B1 CYRILLIC SMALL LETTER STRAIGHT U WITH STROKE */
+#define XKB_KEY_Cyrillic_HA_descender      0x10004b2  /* U+04B2 CYRILLIC CAPITAL LETTER HA WITH DESCENDER */
+#define XKB_KEY_Cyrillic_ha_descender      0x10004b3  /* U+04B3 CYRILLIC SMALL LETTER HA WITH DESCENDER */
+#define XKB_KEY_Cyrillic_CHE_descender     0x10004b6  /* U+04B6 CYRILLIC CAPITAL LETTER CHE WITH DESCENDER */
+#define XKB_KEY_Cyrillic_che_descender     0x10004b7  /* U+04B7 CYRILLIC SMALL LETTER CHE WITH DESCENDER */
+#define XKB_KEY_Cyrillic_CHE_vertstroke    0x10004b8  /* U+04B8 CYRILLIC CAPITAL LETTER CHE WITH VERTICAL STROKE */
+#define XKB_KEY_Cyrillic_che_vertstroke    0x10004b9  /* U+04B9 CYRILLIC SMALL LETTER CHE WITH VERTICAL STROKE */
+#define XKB_KEY_Cyrillic_SHHA              0x10004ba  /* U+04BA CYRILLIC CAPITAL LETTER SHHA */
+#define XKB_KEY_Cyrillic_shha              0x10004bb  /* U+04BB CYRILLIC SMALL LETTER SHHA */
+
+#define XKB_KEY_Cyrillic_SCHWA             0x10004d8  /* U+04D8 CYRILLIC CAPITAL LETTER SCHWA */
+#define XKB_KEY_Cyrillic_schwa             0x10004d9  /* U+04D9 CYRILLIC SMALL LETTER SCHWA */
+#define XKB_KEY_Cyrillic_I_macron          0x10004e2  /* U+04E2 CYRILLIC CAPITAL LETTER I WITH MACRON */
+#define XKB_KEY_Cyrillic_i_macron          0x10004e3  /* U+04E3 CYRILLIC SMALL LETTER I WITH MACRON */
+#define XKB_KEY_Cyrillic_O_bar             0x10004e8  /* U+04E8 CYRILLIC CAPITAL LETTER BARRED O */
+#define XKB_KEY_Cyrillic_o_bar             0x10004e9  /* U+04E9 CYRILLIC SMALL LETTER BARRED O */
+#define XKB_KEY_Cyrillic_U_macron          0x10004ee  /* U+04EE CYRILLIC CAPITAL LETTER U WITH MACRON */
+#define XKB_KEY_Cyrillic_u_macron          0x10004ef  /* U+04EF CYRILLIC SMALL LETTER U WITH MACRON */
+
+#define XKB_KEY_Serbian_dje                   0x06a1  /* U+0452 CYRILLIC SMALL LETTER DJE */
+#define XKB_KEY_Macedonia_gje                 0x06a2  /* U+0453 CYRILLIC SMALL LETTER GJE */
+#define XKB_KEY_Cyrillic_io                   0x06a3  /* U+0451 CYRILLIC SMALL LETTER IO */
+#define XKB_KEY_Ukrainian_ie                  0x06a4  /* U+0454 CYRILLIC SMALL LETTER UKRAINIAN IE */
+#define XKB_KEY_Ukranian_je                   0x06a4  /* deprecated */
+#define XKB_KEY_Macedonia_dse                 0x06a5  /* U+0455 CYRILLIC SMALL LETTER DZE */
+#define XKB_KEY_Ukrainian_i                   0x06a6  /* U+0456 CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I */
+#define XKB_KEY_Ukranian_i                    0x06a6  /* deprecated */
+#define XKB_KEY_Ukrainian_yi                  0x06a7  /* U+0457 CYRILLIC SMALL LETTER YI */
+#define XKB_KEY_Ukranian_yi                   0x06a7  /* deprecated */
+#define XKB_KEY_Cyrillic_je                   0x06a8  /* U+0458 CYRILLIC SMALL LETTER JE */
+#define XKB_KEY_Serbian_je                    0x06a8  /* deprecated */
+#define XKB_KEY_Cyrillic_lje                  0x06a9  /* U+0459 CYRILLIC SMALL LETTER LJE */
+#define XKB_KEY_Serbian_lje                   0x06a9  /* deprecated */
+#define XKB_KEY_Cyrillic_nje                  0x06aa  /* U+045A CYRILLIC SMALL LETTER NJE */
+#define XKB_KEY_Serbian_nje                   0x06aa  /* deprecated */
+#define XKB_KEY_Serbian_tshe                  0x06ab  /* U+045B CYRILLIC SMALL LETTER TSHE */
+#define XKB_KEY_Macedonia_kje                 0x06ac  /* U+045C CYRILLIC SMALL LETTER KJE */
+#define XKB_KEY_Ukrainian_ghe_with_upturn     0x06ad  /* U+0491 CYRILLIC SMALL LETTER GHE WITH UPTURN */
+#define XKB_KEY_Byelorussian_shortu           0x06ae  /* U+045E CYRILLIC SMALL LETTER SHORT U */
+#define XKB_KEY_Cyrillic_dzhe                 0x06af  /* U+045F CYRILLIC SMALL LETTER DZHE */
+#define XKB_KEY_Serbian_dze                   0x06af  /* deprecated */
+#define XKB_KEY_numerosign                    0x06b0  /* U+2116 NUMERO SIGN */
+#define XKB_KEY_Serbian_DJE                   0x06b1  /* U+0402 CYRILLIC CAPITAL LETTER DJE */
+#define XKB_KEY_Macedonia_GJE                 0x06b2  /* U+0403 CYRILLIC CAPITAL LETTER GJE */
+#define XKB_KEY_Cyrillic_IO                   0x06b3  /* U+0401 CYRILLIC CAPITAL LETTER IO */
+#define XKB_KEY_Ukrainian_IE                  0x06b4  /* U+0404 CYRILLIC CAPITAL LETTER UKRAINIAN IE */
+#define XKB_KEY_Ukranian_JE                   0x06b4  /* deprecated */
+#define XKB_KEY_Macedonia_DSE                 0x06b5  /* U+0405 CYRILLIC CAPITAL LETTER DZE */
+#define XKB_KEY_Ukrainian_I                   0x06b6  /* U+0406 CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I */
+#define XKB_KEY_Ukranian_I                    0x06b6  /* deprecated */
+#define XKB_KEY_Ukrainian_YI                  0x06b7  /* U+0407 CYRILLIC CAPITAL LETTER YI */
+#define XKB_KEY_Ukranian_YI                   0x06b7  /* deprecated */
+#define XKB_KEY_Cyrillic_JE                   0x06b8  /* U+0408 CYRILLIC CAPITAL LETTER JE */
+#define XKB_KEY_Serbian_JE                    0x06b8  /* deprecated */
+#define XKB_KEY_Cyrillic_LJE                  0x06b9  /* U+0409 CYRILLIC CAPITAL LETTER LJE */
+#define XKB_KEY_Serbian_LJE                   0x06b9  /* deprecated */
+#define XKB_KEY_Cyrillic_NJE                  0x06ba  /* U+040A CYRILLIC CAPITAL LETTER NJE */
+#define XKB_KEY_Serbian_NJE                   0x06ba  /* deprecated */
+#define XKB_KEY_Serbian_TSHE                  0x06bb  /* U+040B CYRILLIC CAPITAL LETTER TSHE */
+#define XKB_KEY_Macedonia_KJE                 0x06bc  /* U+040C CYRILLIC CAPITAL LETTER KJE */
+#define XKB_KEY_Ukrainian_GHE_WITH_UPTURN     0x06bd  /* U+0490 CYRILLIC CAPITAL LETTER GHE WITH UPTURN */
+#define XKB_KEY_Byelorussian_SHORTU           0x06be  /* U+040E CYRILLIC CAPITAL LETTER SHORT U */
+#define XKB_KEY_Cyrillic_DZHE                 0x06bf  /* U+040F CYRILLIC CAPITAL LETTER DZHE */
+#define XKB_KEY_Serbian_DZE                   0x06bf  /* deprecated */
+#define XKB_KEY_Cyrillic_yu                   0x06c0  /* U+044E CYRILLIC SMALL LETTER YU */
+#define XKB_KEY_Cyrillic_a                    0x06c1  /* U+0430 CYRILLIC SMALL LETTER A */
+#define XKB_KEY_Cyrillic_be                   0x06c2  /* U+0431 CYRILLIC SMALL LETTER BE */
+#define XKB_KEY_Cyrillic_tse                  0x06c3  /* U+0446 CYRILLIC SMALL LETTER TSE */
+#define XKB_KEY_Cyrillic_de                   0x06c4  /* U+0434 CYRILLIC SMALL LETTER DE */
+#define XKB_KEY_Cyrillic_ie                   0x06c5  /* U+0435 CYRILLIC SMALL LETTER IE */
+#define XKB_KEY_Cyrillic_ef                   0x06c6  /* U+0444 CYRILLIC SMALL LETTER EF */
+#define XKB_KEY_Cyrillic_ghe                  0x06c7  /* U+0433 CYRILLIC SMALL LETTER GHE */
+#define XKB_KEY_Cyrillic_ha                   0x06c8  /* U+0445 CYRILLIC SMALL LETTER HA */
+#define XKB_KEY_Cyrillic_i                    0x06c9  /* U+0438 CYRILLIC SMALL LETTER I */
+#define XKB_KEY_Cyrillic_shorti               0x06ca  /* U+0439 CYRILLIC SMALL LETTER SHORT I */
+#define XKB_KEY_Cyrillic_ka                   0x06cb  /* U+043A CYRILLIC SMALL LETTER KA */
+#define XKB_KEY_Cyrillic_el                   0x06cc  /* U+043B CYRILLIC SMALL LETTER EL */
+#define XKB_KEY_Cyrillic_em                   0x06cd  /* U+043C CYRILLIC SMALL LETTER EM */
+#define XKB_KEY_Cyrillic_en                   0x06ce  /* U+043D CYRILLIC SMALL LETTER EN */
+#define XKB_KEY_Cyrillic_o                    0x06cf  /* U+043E CYRILLIC SMALL LETTER O */
+#define XKB_KEY_Cyrillic_pe                   0x06d0  /* U+043F CYRILLIC SMALL LETTER PE */
+#define XKB_KEY_Cyrillic_ya                   0x06d1  /* U+044F CYRILLIC SMALL LETTER YA */
+#define XKB_KEY_Cyrillic_er                   0x06d2  /* U+0440 CYRILLIC SMALL LETTER ER */
+#define XKB_KEY_Cyrillic_es                   0x06d3  /* U+0441 CYRILLIC SMALL LETTER ES */
+#define XKB_KEY_Cyrillic_te                   0x06d4  /* U+0442 CYRILLIC SMALL LETTER TE */
+#define XKB_KEY_Cyrillic_u                    0x06d5  /* U+0443 CYRILLIC SMALL LETTER U */
+#define XKB_KEY_Cyrillic_zhe                  0x06d6  /* U+0436 CYRILLIC SMALL LETTER ZHE */
+#define XKB_KEY_Cyrillic_ve                   0x06d7  /* U+0432 CYRILLIC SMALL LETTER VE */
+#define XKB_KEY_Cyrillic_softsign             0x06d8  /* U+044C CYRILLIC SMALL LETTER SOFT SIGN */
+#define XKB_KEY_Cyrillic_yeru                 0x06d9  /* U+044B CYRILLIC SMALL LETTER YERU */
+#define XKB_KEY_Cyrillic_ze                   0x06da  /* U+0437 CYRILLIC SMALL LETTER ZE */
+#define XKB_KEY_Cyrillic_sha                  0x06db  /* U+0448 CYRILLIC SMALL LETTER SHA */
+#define XKB_KEY_Cyrillic_e                    0x06dc  /* U+044D CYRILLIC SMALL LETTER E */
+#define XKB_KEY_Cyrillic_shcha                0x06dd  /* U+0449 CYRILLIC SMALL LETTER SHCHA */
+#define XKB_KEY_Cyrillic_che                  0x06de  /* U+0447 CYRILLIC SMALL LETTER CHE */
+#define XKB_KEY_Cyrillic_hardsign             0x06df  /* U+044A CYRILLIC SMALL LETTER HARD SIGN */
+#define XKB_KEY_Cyrillic_YU                   0x06e0  /* U+042E CYRILLIC CAPITAL LETTER YU */
+#define XKB_KEY_Cyrillic_A                    0x06e1  /* U+0410 CYRILLIC CAPITAL LETTER A */
+#define XKB_KEY_Cyrillic_BE                   0x06e2  /* U+0411 CYRILLIC CAPITAL LETTER BE */
+#define XKB_KEY_Cyrillic_TSE                  0x06e3  /* U+0426 CYRILLIC CAPITAL LETTER TSE */
+#define XKB_KEY_Cyrillic_DE                   0x06e4  /* U+0414 CYRILLIC CAPITAL LETTER DE */
+#define XKB_KEY_Cyrillic_IE                   0x06e5  /* U+0415 CYRILLIC CAPITAL LETTER IE */
+#define XKB_KEY_Cyrillic_EF                   0x06e6  /* U+0424 CYRILLIC CAPITAL LETTER EF */
+#define XKB_KEY_Cyrillic_GHE                  0x06e7  /* U+0413 CYRILLIC CAPITAL LETTER GHE */
+#define XKB_KEY_Cyrillic_HA                   0x06e8  /* U+0425 CYRILLIC CAPITAL LETTER HA */
+#define XKB_KEY_Cyrillic_I                    0x06e9  /* U+0418 CYRILLIC CAPITAL LETTER I */
+#define XKB_KEY_Cyrillic_SHORTI               0x06ea  /* U+0419 CYRILLIC CAPITAL LETTER SHORT I */
+#define XKB_KEY_Cyrillic_KA                   0x06eb  /* U+041A CYRILLIC CAPITAL LETTER KA */
+#define XKB_KEY_Cyrillic_EL                   0x06ec  /* U+041B CYRILLIC CAPITAL LETTER EL */
+#define XKB_KEY_Cyrillic_EM                   0x06ed  /* U+041C CYRILLIC CAPITAL LETTER EM */
+#define XKB_KEY_Cyrillic_EN                   0x06ee  /* U+041D CYRILLIC CAPITAL LETTER EN */
+#define XKB_KEY_Cyrillic_O                    0x06ef  /* U+041E CYRILLIC CAPITAL LETTER O */
+#define XKB_KEY_Cyrillic_PE                   0x06f0  /* U+041F CYRILLIC CAPITAL LETTER PE */
+#define XKB_KEY_Cyrillic_YA                   0x06f1  /* U+042F CYRILLIC CAPITAL LETTER YA */
+#define XKB_KEY_Cyrillic_ER                   0x06f2  /* U+0420 CYRILLIC CAPITAL LETTER ER */
+#define XKB_KEY_Cyrillic_ES                   0x06f3  /* U+0421 CYRILLIC CAPITAL LETTER ES */
+#define XKB_KEY_Cyrillic_TE                   0x06f4  /* U+0422 CYRILLIC CAPITAL LETTER TE */
+#define XKB_KEY_Cyrillic_U                    0x06f5  /* U+0423 CYRILLIC CAPITAL LETTER U */
+#define XKB_KEY_Cyrillic_ZHE                  0x06f6  /* U+0416 CYRILLIC CAPITAL LETTER ZHE */
+#define XKB_KEY_Cyrillic_VE                   0x06f7  /* U+0412 CYRILLIC CAPITAL LETTER VE */
+#define XKB_KEY_Cyrillic_SOFTSIGN             0x06f8  /* U+042C CYRILLIC CAPITAL LETTER SOFT SIGN */
+#define XKB_KEY_Cyrillic_YERU                 0x06f9  /* U+042B CYRILLIC CAPITAL LETTER YERU */
+#define XKB_KEY_Cyrillic_ZE                   0x06fa  /* U+0417 CYRILLIC CAPITAL LETTER ZE */
+#define XKB_KEY_Cyrillic_SHA                  0x06fb  /* U+0428 CYRILLIC CAPITAL LETTER SHA */
+#define XKB_KEY_Cyrillic_E                    0x06fc  /* U+042D CYRILLIC CAPITAL LETTER E */
+#define XKB_KEY_Cyrillic_SHCHA                0x06fd  /* U+0429 CYRILLIC CAPITAL LETTER SHCHA */
+#define XKB_KEY_Cyrillic_CHE                  0x06fe  /* U+0427 CYRILLIC CAPITAL LETTER CHE */
+#define XKB_KEY_Cyrillic_HARDSIGN             0x06ff  /* U+042A CYRILLIC CAPITAL LETTER HARD SIGN */
+
+/*
+ * Greek
+ * (based on an early draft of, and not quite identical to, ISO/IEC 8859-7)
+ * Byte 3 = 7
+ */
+
+#define XKB_KEY_Greek_ALPHAaccent             0x07a1  /* U+0386 GREEK CAPITAL LETTER ALPHA WITH TONOS */
+#define XKB_KEY_Greek_EPSILONaccent           0x07a2  /* U+0388 GREEK CAPITAL LETTER EPSILON WITH TONOS */
+#define XKB_KEY_Greek_ETAaccent               0x07a3  /* U+0389 GREEK CAPITAL LETTER ETA WITH TONOS */
+#define XKB_KEY_Greek_IOTAaccent              0x07a4  /* U+038A GREEK CAPITAL LETTER IOTA WITH TONOS */
+#define XKB_KEY_Greek_IOTAdieresis            0x07a5  /* U+03AA GREEK CAPITAL LETTER IOTA WITH DIALYTIKA */
+#define XKB_KEY_Greek_IOTAdiaeresis           0x07a5  /* old typo */
+#define XKB_KEY_Greek_OMICRONaccent           0x07a7  /* U+038C GREEK CAPITAL LETTER OMICRON WITH TONOS */
+#define XKB_KEY_Greek_UPSILONaccent           0x07a8  /* U+038E GREEK CAPITAL LETTER UPSILON WITH TONOS */
+#define XKB_KEY_Greek_UPSILONdieresis         0x07a9  /* U+03AB GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA */
+#define XKB_KEY_Greek_OMEGAaccent             0x07ab  /* U+038F GREEK CAPITAL LETTER OMEGA WITH TONOS */
+#define XKB_KEY_Greek_accentdieresis          0x07ae  /* U+0385 GREEK DIALYTIKA TONOS */
+#define XKB_KEY_Greek_horizbar                0x07af  /* U+2015 HORIZONTAL BAR */
+#define XKB_KEY_Greek_alphaaccent             0x07b1  /* U+03AC GREEK SMALL LETTER ALPHA WITH TONOS */
+#define XKB_KEY_Greek_epsilonaccent           0x07b2  /* U+03AD GREEK SMALL LETTER EPSILON WITH TONOS */
+#define XKB_KEY_Greek_etaaccent               0x07b3  /* U+03AE GREEK SMALL LETTER ETA WITH TONOS */
+#define XKB_KEY_Greek_iotaaccent              0x07b4  /* U+03AF GREEK SMALL LETTER IOTA WITH TONOS */
+#define XKB_KEY_Greek_iotadieresis            0x07b5  /* U+03CA GREEK SMALL LETTER IOTA WITH DIALYTIKA */
+#define XKB_KEY_Greek_iotaaccentdieresis      0x07b6  /* U+0390 GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */
+#define XKB_KEY_Greek_omicronaccent           0x07b7  /* U+03CC GREEK SMALL LETTER OMICRON WITH TONOS */
+#define XKB_KEY_Greek_upsilonaccent           0x07b8  /* U+03CD GREEK SMALL LETTER UPSILON WITH TONOS */
+#define XKB_KEY_Greek_upsilondieresis         0x07b9  /* U+03CB GREEK SMALL LETTER UPSILON WITH DIALYTIKA */
+#define XKB_KEY_Greek_upsilonaccentdieresis   0x07ba  /* U+03B0 GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS */
+#define XKB_KEY_Greek_omegaaccent             0x07bb  /* U+03CE GREEK SMALL LETTER OMEGA WITH TONOS */
+#define XKB_KEY_Greek_ALPHA                   0x07c1  /* U+0391 GREEK CAPITAL LETTER ALPHA */
+#define XKB_KEY_Greek_BETA                    0x07c2  /* U+0392 GREEK CAPITAL LETTER BETA */
+#define XKB_KEY_Greek_GAMMA                   0x07c3  /* U+0393 GREEK CAPITAL LETTER GAMMA */
+#define XKB_KEY_Greek_DELTA                   0x07c4  /* U+0394 GREEK CAPITAL LETTER DELTA */
+#define XKB_KEY_Greek_EPSILON                 0x07c5  /* U+0395 GREEK CAPITAL LETTER EPSILON */
+#define XKB_KEY_Greek_ZETA                    0x07c6  /* U+0396 GREEK CAPITAL LETTER ZETA */
+#define XKB_KEY_Greek_ETA                     0x07c7  /* U+0397 GREEK CAPITAL LETTER ETA */
+#define XKB_KEY_Greek_THETA                   0x07c8  /* U+0398 GREEK CAPITAL LETTER THETA */
+#define XKB_KEY_Greek_IOTA                    0x07c9  /* U+0399 GREEK CAPITAL LETTER IOTA */
+#define XKB_KEY_Greek_KAPPA                   0x07ca  /* U+039A GREEK CAPITAL LETTER KAPPA */
+#define XKB_KEY_Greek_LAMDA                   0x07cb  /* U+039B GREEK CAPITAL LETTER LAMDA */
+#define XKB_KEY_Greek_LAMBDA                  0x07cb  /* U+039B GREEK CAPITAL LETTER LAMDA */
+#define XKB_KEY_Greek_MU                      0x07cc  /* U+039C GREEK CAPITAL LETTER MU */
+#define XKB_KEY_Greek_NU                      0x07cd  /* U+039D GREEK CAPITAL LETTER NU */
+#define XKB_KEY_Greek_XI                      0x07ce  /* U+039E GREEK CAPITAL LETTER XI */
+#define XKB_KEY_Greek_OMICRON                 0x07cf  /* U+039F GREEK CAPITAL LETTER OMICRON */
+#define XKB_KEY_Greek_PI                      0x07d0  /* U+03A0 GREEK CAPITAL LETTER PI */
+#define XKB_KEY_Greek_RHO                     0x07d1  /* U+03A1 GREEK CAPITAL LETTER RHO */
+#define XKB_KEY_Greek_SIGMA                   0x07d2  /* U+03A3 GREEK CAPITAL LETTER SIGMA */
+#define XKB_KEY_Greek_TAU                     0x07d4  /* U+03A4 GREEK CAPITAL LETTER TAU */
+#define XKB_KEY_Greek_UPSILON                 0x07d5  /* U+03A5 GREEK CAPITAL LETTER UPSILON */
+#define XKB_KEY_Greek_PHI                     0x07d6  /* U+03A6 GREEK CAPITAL LETTER PHI */
+#define XKB_KEY_Greek_CHI                     0x07d7  /* U+03A7 GREEK CAPITAL LETTER CHI */
+#define XKB_KEY_Greek_PSI                     0x07d8  /* U+03A8 GREEK CAPITAL LETTER PSI */
+#define XKB_KEY_Greek_OMEGA                   0x07d9  /* U+03A9 GREEK CAPITAL LETTER OMEGA */
+#define XKB_KEY_Greek_alpha                   0x07e1  /* U+03B1 GREEK SMALL LETTER ALPHA */
+#define XKB_KEY_Greek_beta                    0x07e2  /* U+03B2 GREEK SMALL LETTER BETA */
+#define XKB_KEY_Greek_gamma                   0x07e3  /* U+03B3 GREEK SMALL LETTER GAMMA */
+#define XKB_KEY_Greek_delta                   0x07e4  /* U+03B4 GREEK SMALL LETTER DELTA */
+#define XKB_KEY_Greek_epsilon                 0x07e5  /* U+03B5 GREEK SMALL LETTER EPSILON */
+#define XKB_KEY_Greek_zeta                    0x07e6  /* U+03B6 GREEK SMALL LETTER ZETA */
+#define XKB_KEY_Greek_eta                     0x07e7  /* U+03B7 GREEK SMALL LETTER ETA */
+#define XKB_KEY_Greek_theta                   0x07e8  /* U+03B8 GREEK SMALL LETTER THETA */
+#define XKB_KEY_Greek_iota                    0x07e9  /* U+03B9 GREEK SMALL LETTER IOTA */
+#define XKB_KEY_Greek_kappa                   0x07ea  /* U+03BA GREEK SMALL LETTER KAPPA */
+#define XKB_KEY_Greek_lamda                   0x07eb  /* U+03BB GREEK SMALL LETTER LAMDA */
+#define XKB_KEY_Greek_lambda                  0x07eb  /* U+03BB GREEK SMALL LETTER LAMDA */
+#define XKB_KEY_Greek_mu                      0x07ec  /* U+03BC GREEK SMALL LETTER MU */
+#define XKB_KEY_Greek_nu                      0x07ed  /* U+03BD GREEK SMALL LETTER NU */
+#define XKB_KEY_Greek_xi                      0x07ee  /* U+03BE GREEK SMALL LETTER XI */
+#define XKB_KEY_Greek_omicron                 0x07ef  /* U+03BF GREEK SMALL LETTER OMICRON */
+#define XKB_KEY_Greek_pi                      0x07f0  /* U+03C0 GREEK SMALL LETTER PI */
+#define XKB_KEY_Greek_rho                     0x07f1  /* U+03C1 GREEK SMALL LETTER RHO */
+#define XKB_KEY_Greek_sigma                   0x07f2  /* U+03C3 GREEK SMALL LETTER SIGMA */
+#define XKB_KEY_Greek_finalsmallsigma         0x07f3  /* U+03C2 GREEK SMALL LETTER FINAL SIGMA */
+#define XKB_KEY_Greek_tau                     0x07f4  /* U+03C4 GREEK SMALL LETTER TAU */
+#define XKB_KEY_Greek_upsilon                 0x07f5  /* U+03C5 GREEK SMALL LETTER UPSILON */
+#define XKB_KEY_Greek_phi                     0x07f6  /* U+03C6 GREEK SMALL LETTER PHI */
+#define XKB_KEY_Greek_chi                     0x07f7  /* U+03C7 GREEK SMALL LETTER CHI */
+#define XKB_KEY_Greek_psi                     0x07f8  /* U+03C8 GREEK SMALL LETTER PSI */
+#define XKB_KEY_Greek_omega                   0x07f9  /* U+03C9 GREEK SMALL LETTER OMEGA */
+#define XKB_KEY_Greek_switch                  0xff7e  /* Alias for mode_switch */
+
+/*
+ * Technical
+ * (from the DEC VT330/VT420 Technical Character Set, http://vt100.net/charsets/technical.html)
+ * Byte 3 = 8
+ */
+
+#define XKB_KEY_leftradical                   0x08a1  /* U+23B7 RADICAL SYMBOL BOTTOM */
+#define XKB_KEY_topleftradical                0x08a2  /*(U+250C BOX DRAWINGS LIGHT DOWN AND RIGHT)*/
+#define XKB_KEY_horizconnector                0x08a3  /*(U+2500 BOX DRAWINGS LIGHT HORIZONTAL)*/
+#define XKB_KEY_topintegral                   0x08a4  /* U+2320 TOP HALF INTEGRAL */
+#define XKB_KEY_botintegral                   0x08a5  /* U+2321 BOTTOM HALF INTEGRAL */
+#define XKB_KEY_vertconnector                 0x08a6  /*(U+2502 BOX DRAWINGS LIGHT VERTICAL)*/
+#define XKB_KEY_topleftsqbracket              0x08a7  /* U+23A1 LEFT SQUARE BRACKET UPPER CORNER */
+#define XKB_KEY_botleftsqbracket              0x08a8  /* U+23A3 LEFT SQUARE BRACKET LOWER CORNER */
+#define XKB_KEY_toprightsqbracket             0x08a9  /* U+23A4 RIGHT SQUARE BRACKET UPPER CORNER */
+#define XKB_KEY_botrightsqbracket             0x08aa  /* U+23A6 RIGHT SQUARE BRACKET LOWER CORNER */
+#define XKB_KEY_topleftparens                 0x08ab  /* U+239B LEFT PARENTHESIS UPPER HOOK */
+#define XKB_KEY_botleftparens                 0x08ac  /* U+239D LEFT PARENTHESIS LOWER HOOK */
+#define XKB_KEY_toprightparens                0x08ad  /* U+239E RIGHT PARENTHESIS UPPER HOOK */
+#define XKB_KEY_botrightparens                0x08ae  /* U+23A0 RIGHT PARENTHESIS LOWER HOOK */
+#define XKB_KEY_leftmiddlecurlybrace          0x08af  /* U+23A8 LEFT CURLY BRACKET MIDDLE PIECE */
+#define XKB_KEY_rightmiddlecurlybrace         0x08b0  /* U+23AC RIGHT CURLY BRACKET MIDDLE PIECE */
+#define XKB_KEY_topleftsummation              0x08b1
+#define XKB_KEY_botleftsummation              0x08b2
+#define XKB_KEY_topvertsummationconnector     0x08b3
+#define XKB_KEY_botvertsummationconnector     0x08b4
+#define XKB_KEY_toprightsummation             0x08b5
+#define XKB_KEY_botrightsummation             0x08b6
+#define XKB_KEY_rightmiddlesummation          0x08b7
+#define XKB_KEY_lessthanequal                 0x08bc  /* U+2264 LESS-THAN OR EQUAL TO */
+#define XKB_KEY_notequal                      0x08bd  /* U+2260 NOT EQUAL TO */
+#define XKB_KEY_greaterthanequal              0x08be  /* U+2265 GREATER-THAN OR EQUAL TO */
+#define XKB_KEY_integral                      0x08bf  /* U+222B INTEGRAL */
+#define XKB_KEY_therefore                     0x08c0  /* U+2234 THEREFORE */
+#define XKB_KEY_variation                     0x08c1  /* U+221D PROPORTIONAL TO */
+#define XKB_KEY_infinity                      0x08c2  /* U+221E INFINITY */
+#define XKB_KEY_nabla                         0x08c5  /* U+2207 NABLA */
+#define XKB_KEY_approximate                   0x08c8  /* U+223C TILDE OPERATOR */
+#define XKB_KEY_similarequal                  0x08c9  /* U+2243 ASYMPTOTICALLY EQUAL TO */
+#define XKB_KEY_ifonlyif                      0x08cd  /* U+21D4 LEFT RIGHT DOUBLE ARROW */
+#define XKB_KEY_implies                       0x08ce  /* U+21D2 RIGHTWARDS DOUBLE ARROW */
+#define XKB_KEY_identical                     0x08cf  /* U+2261 IDENTICAL TO */
+#define XKB_KEY_radical                       0x08d6  /* U+221A SQUARE ROOT */
+#define XKB_KEY_includedin                    0x08da  /* U+2282 SUBSET OF */
+#define XKB_KEY_includes                      0x08db  /* U+2283 SUPERSET OF */
+#define XKB_KEY_intersection                  0x08dc  /* U+2229 INTERSECTION */
+#define XKB_KEY_union                         0x08dd  /* U+222A UNION */
+#define XKB_KEY_logicaland                    0x08de  /* U+2227 LOGICAL AND */
+#define XKB_KEY_logicalor                     0x08df  /* U+2228 LOGICAL OR */
+#define XKB_KEY_partialderivative             0x08ef  /* U+2202 PARTIAL DIFFERENTIAL */
+#define XKB_KEY_function                      0x08f6  /* U+0192 LATIN SMALL LETTER F WITH HOOK */
+#define XKB_KEY_leftarrow                     0x08fb  /* U+2190 LEFTWARDS ARROW */
+#define XKB_KEY_uparrow                       0x08fc  /* U+2191 UPWARDS ARROW */
+#define XKB_KEY_rightarrow                    0x08fd  /* U+2192 RIGHTWARDS ARROW */
+#define XKB_KEY_downarrow                     0x08fe  /* U+2193 DOWNWARDS ARROW */
+
+/*
+ * Special
+ * (from the DEC VT100 Special Graphics Character Set)
+ * Byte 3 = 9
+ */
+
+#define XKB_KEY_blank                         0x09df
+#define XKB_KEY_soliddiamond                  0x09e0  /* U+25C6 BLACK DIAMOND */
+#define XKB_KEY_checkerboard                  0x09e1  /* U+2592 MEDIUM SHADE */
+#define XKB_KEY_ht                            0x09e2  /* U+2409 SYMBOL FOR HORIZONTAL TABULATION */
+#define XKB_KEY_ff                            0x09e3  /* U+240C SYMBOL FOR FORM FEED */
+#define XKB_KEY_cr                            0x09e4  /* U+240D SYMBOL FOR CARRIAGE RETURN */
+#define XKB_KEY_lf                            0x09e5  /* U+240A SYMBOL FOR LINE FEED */
+#define XKB_KEY_nl                            0x09e8  /* U+2424 SYMBOL FOR NEWLINE */
+#define XKB_KEY_vt                            0x09e9  /* U+240B SYMBOL FOR VERTICAL TABULATION */
+#define XKB_KEY_lowrightcorner                0x09ea  /* U+2518 BOX DRAWINGS LIGHT UP AND LEFT */
+#define XKB_KEY_uprightcorner                 0x09eb  /* U+2510 BOX DRAWINGS LIGHT DOWN AND LEFT */
+#define XKB_KEY_upleftcorner                  0x09ec  /* U+250C BOX DRAWINGS LIGHT DOWN AND RIGHT */
+#define XKB_KEY_lowleftcorner                 0x09ed  /* U+2514 BOX DRAWINGS LIGHT UP AND RIGHT */
+#define XKB_KEY_crossinglines                 0x09ee  /* U+253C BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL */
+#define XKB_KEY_horizlinescan1                0x09ef  /* U+23BA HORIZONTAL SCAN LINE-1 */
+#define XKB_KEY_horizlinescan3                0x09f0  /* U+23BB HORIZONTAL SCAN LINE-3 */
+#define XKB_KEY_horizlinescan5                0x09f1  /* U+2500 BOX DRAWINGS LIGHT HORIZONTAL */
+#define XKB_KEY_horizlinescan7                0x09f2  /* U+23BC HORIZONTAL SCAN LINE-7 */
+#define XKB_KEY_horizlinescan9                0x09f3  /* U+23BD HORIZONTAL SCAN LINE-9 */
+#define XKB_KEY_leftt                         0x09f4  /* U+251C BOX DRAWINGS LIGHT VERTICAL AND RIGHT */
+#define XKB_KEY_rightt                        0x09f5  /* U+2524 BOX DRAWINGS LIGHT VERTICAL AND LEFT */
+#define XKB_KEY_bott                          0x09f6  /* U+2534 BOX DRAWINGS LIGHT UP AND HORIZONTAL */
+#define XKB_KEY_topt                          0x09f7  /* U+252C BOX DRAWINGS LIGHT DOWN AND HORIZONTAL */
+#define XKB_KEY_vertbar                       0x09f8  /* U+2502 BOX DRAWINGS LIGHT VERTICAL */
+
+/*
+ * Publishing
+ * (these are probably from a long forgotten DEC Publishing
+ * font that once shipped with DECwrite)
+ * Byte 3 = 0x0a
+ */
+
+#define XKB_KEY_emspace                       0x0aa1  /* U+2003 EM SPACE */
+#define XKB_KEY_enspace                       0x0aa2  /* U+2002 EN SPACE */
+#define XKB_KEY_em3space                      0x0aa3  /* U+2004 THREE-PER-EM SPACE */
+#define XKB_KEY_em4space                      0x0aa4  /* U+2005 FOUR-PER-EM SPACE */
+#define XKB_KEY_digitspace                    0x0aa5  /* U+2007 FIGURE SPACE */
+#define XKB_KEY_punctspace                    0x0aa6  /* U+2008 PUNCTUATION SPACE */
+#define XKB_KEY_thinspace                     0x0aa7  /* U+2009 THIN SPACE */
+#define XKB_KEY_hairspace                     0x0aa8  /* U+200A HAIR SPACE */
+#define XKB_KEY_emdash                        0x0aa9  /* U+2014 EM DASH */
+#define XKB_KEY_endash                        0x0aaa  /* U+2013 EN DASH */
+#define XKB_KEY_signifblank                   0x0aac  /*(U+2423 OPEN BOX)*/
+#define XKB_KEY_ellipsis                      0x0aae  /* U+2026 HORIZONTAL ELLIPSIS */
+#define XKB_KEY_doubbaselinedot               0x0aaf  /* U+2025 TWO DOT LEADER */
+#define XKB_KEY_onethird                      0x0ab0  /* U+2153 VULGAR FRACTION ONE THIRD */
+#define XKB_KEY_twothirds                     0x0ab1  /* U+2154 VULGAR FRACTION TWO THIRDS */
+#define XKB_KEY_onefifth                      0x0ab2  /* U+2155 VULGAR FRACTION ONE FIFTH */
+#define XKB_KEY_twofifths                     0x0ab3  /* U+2156 VULGAR FRACTION TWO FIFTHS */
+#define XKB_KEY_threefifths                   0x0ab4  /* U+2157 VULGAR FRACTION THREE FIFTHS */
+#define XKB_KEY_fourfifths                    0x0ab5  /* U+2158 VULGAR FRACTION FOUR FIFTHS */
+#define XKB_KEY_onesixth                      0x0ab6  /* U+2159 VULGAR FRACTION ONE SIXTH */
+#define XKB_KEY_fivesixths                    0x0ab7  /* U+215A VULGAR FRACTION FIVE SIXTHS */
+#define XKB_KEY_careof                        0x0ab8  /* U+2105 CARE OF */
+#define XKB_KEY_figdash                       0x0abb  /* U+2012 FIGURE DASH */
+#define XKB_KEY_leftanglebracket              0x0abc  /*(U+27E8 MATHEMATICAL LEFT ANGLE BRACKET)*/
+#define XKB_KEY_decimalpoint                  0x0abd  /*(U+002E FULL STOP)*/
+#define XKB_KEY_rightanglebracket             0x0abe  /*(U+27E9 MATHEMATICAL RIGHT ANGLE BRACKET)*/
+#define XKB_KEY_marker                        0x0abf
+#define XKB_KEY_oneeighth                     0x0ac3  /* U+215B VULGAR FRACTION ONE EIGHTH */
+#define XKB_KEY_threeeighths                  0x0ac4  /* U+215C VULGAR FRACTION THREE EIGHTHS */
+#define XKB_KEY_fiveeighths                   0x0ac5  /* U+215D VULGAR FRACTION FIVE EIGHTHS */
+#define XKB_KEY_seveneighths                  0x0ac6  /* U+215E VULGAR FRACTION SEVEN EIGHTHS */
+#define XKB_KEY_trademark                     0x0ac9  /* U+2122 TRADE MARK SIGN */
+#define XKB_KEY_signaturemark                 0x0aca  /*(U+2613 SALTIRE)*/
+#define XKB_KEY_trademarkincircle             0x0acb
+#define XKB_KEY_leftopentriangle              0x0acc  /*(U+25C1 WHITE LEFT-POINTING TRIANGLE)*/
+#define XKB_KEY_rightopentriangle             0x0acd  /*(U+25B7 WHITE RIGHT-POINTING TRIANGLE)*/
+#define XKB_KEY_emopencircle                  0x0ace  /*(U+25CB WHITE CIRCLE)*/
+#define XKB_KEY_emopenrectangle               0x0acf  /*(U+25AF WHITE VERTICAL RECTANGLE)*/
+#define XKB_KEY_leftsinglequotemark           0x0ad0  /* U+2018 LEFT SINGLE QUOTATION MARK */
+#define XKB_KEY_rightsinglequotemark          0x0ad1  /* U+2019 RIGHT SINGLE QUOTATION MARK */
+#define XKB_KEY_leftdoublequotemark           0x0ad2  /* U+201C LEFT DOUBLE QUOTATION MARK */
+#define XKB_KEY_rightdoublequotemark          0x0ad3  /* U+201D RIGHT DOUBLE QUOTATION MARK */
+#define XKB_KEY_prescription                  0x0ad4  /* U+211E PRESCRIPTION TAKE */
+#define XKB_KEY_permille                      0x0ad5  /* U+2030 PER MILLE SIGN */
+#define XKB_KEY_minutes                       0x0ad6  /* U+2032 PRIME */
+#define XKB_KEY_seconds                       0x0ad7  /* U+2033 DOUBLE PRIME */
+#define XKB_KEY_latincross                    0x0ad9  /* U+271D LATIN CROSS */
+#define XKB_KEY_hexagram                      0x0ada
+#define XKB_KEY_filledrectbullet              0x0adb  /*(U+25AC BLACK RECTANGLE)*/
+#define XKB_KEY_filledlefttribullet           0x0adc  /*(U+25C0 BLACK LEFT-POINTING TRIANGLE)*/
+#define XKB_KEY_filledrighttribullet          0x0add  /*(U+25B6 BLACK RIGHT-POINTING TRIANGLE)*/
+#define XKB_KEY_emfilledcircle                0x0ade  /*(U+25CF BLACK CIRCLE)*/
+#define XKB_KEY_emfilledrect                  0x0adf  /*(U+25AE BLACK VERTICAL RECTANGLE)*/
+#define XKB_KEY_enopencircbullet              0x0ae0  /*(U+25E6 WHITE BULLET)*/
+#define XKB_KEY_enopensquarebullet            0x0ae1  /*(U+25AB WHITE SMALL SQUARE)*/
+#define XKB_KEY_openrectbullet                0x0ae2  /*(U+25AD WHITE RECTANGLE)*/
+#define XKB_KEY_opentribulletup               0x0ae3  /*(U+25B3 WHITE UP-POINTING TRIANGLE)*/
+#define XKB_KEY_opentribulletdown             0x0ae4  /*(U+25BD WHITE DOWN-POINTING TRIANGLE)*/
+#define XKB_KEY_openstar                      0x0ae5  /*(U+2606 WHITE STAR)*/
+#define XKB_KEY_enfilledcircbullet            0x0ae6  /*(U+2022 BULLET)*/
+#define XKB_KEY_enfilledsqbullet              0x0ae7  /*(U+25AA BLACK SMALL SQUARE)*/
+#define XKB_KEY_filledtribulletup             0x0ae8  /*(U+25B2 BLACK UP-POINTING TRIANGLE)*/
+#define XKB_KEY_filledtribulletdown           0x0ae9  /*(U+25BC BLACK DOWN-POINTING TRIANGLE)*/
+#define XKB_KEY_leftpointer                   0x0aea  /*(U+261C WHITE LEFT POINTING INDEX)*/
+#define XKB_KEY_rightpointer                  0x0aeb  /*(U+261E WHITE RIGHT POINTING INDEX)*/
+#define XKB_KEY_club                          0x0aec  /* U+2663 BLACK CLUB SUIT */
+#define XKB_KEY_diamond                       0x0aed  /* U+2666 BLACK DIAMOND SUIT */
+#define XKB_KEY_heart                         0x0aee  /* U+2665 BLACK HEART SUIT */
+#define XKB_KEY_maltesecross                  0x0af0  /* U+2720 MALTESE CROSS */
+#define XKB_KEY_dagger                        0x0af1  /* U+2020 DAGGER */
+#define XKB_KEY_doubledagger                  0x0af2  /* U+2021 DOUBLE DAGGER */
+#define XKB_KEY_checkmark                     0x0af3  /* U+2713 CHECK MARK */
+#define XKB_KEY_ballotcross                   0x0af4  /* U+2717 BALLOT X */
+#define XKB_KEY_musicalsharp                  0x0af5  /* U+266F MUSIC SHARP SIGN */
+#define XKB_KEY_musicalflat                   0x0af6  /* U+266D MUSIC FLAT SIGN */
+#define XKB_KEY_malesymbol                    0x0af7  /* U+2642 MALE SIGN */
+#define XKB_KEY_femalesymbol                  0x0af8  /* U+2640 FEMALE SIGN */
+#define XKB_KEY_telephone                     0x0af9  /* U+260E BLACK TELEPHONE */
+#define XKB_KEY_telephonerecorder             0x0afa  /* U+2315 TELEPHONE RECORDER */
+#define XKB_KEY_phonographcopyright           0x0afb  /* U+2117 SOUND RECORDING COPYRIGHT */
+#define XKB_KEY_caret                         0x0afc  /* U+2038 CARET */
+#define XKB_KEY_singlelowquotemark            0x0afd  /* U+201A SINGLE LOW-9 QUOTATION MARK */
+#define XKB_KEY_doublelowquotemark            0x0afe  /* U+201E DOUBLE LOW-9 QUOTATION MARK */
+#define XKB_KEY_cursor                        0x0aff
+
+/*
+ * APL
+ * Byte 3 = 0x0b
+ */
+
+#define XKB_KEY_leftcaret                     0x0ba3  /*(U+003C LESS-THAN SIGN)*/
+#define XKB_KEY_rightcaret                    0x0ba6  /*(U+003E GREATER-THAN SIGN)*/
+#define XKB_KEY_downcaret                     0x0ba8  /*(U+2228 LOGICAL OR)*/
+#define XKB_KEY_upcaret                       0x0ba9  /*(U+2227 LOGICAL AND)*/
+#define XKB_KEY_overbar                       0x0bc0  /*(U+00AF MACRON)*/
+#define XKB_KEY_downtack                      0x0bc2  /* U+22A4 DOWN TACK */
+#define XKB_KEY_upshoe                        0x0bc3  /*(U+2229 INTERSECTION)*/
+#define XKB_KEY_downstile                     0x0bc4  /* U+230A LEFT FLOOR */
+#define XKB_KEY_underbar                      0x0bc6  /*(U+005F LOW LINE)*/
+#define XKB_KEY_jot                           0x0bca  /* U+2218 RING OPERATOR */
+#define XKB_KEY_quad                          0x0bcc  /* U+2395 APL FUNCTIONAL SYMBOL QUAD */
+#define XKB_KEY_uptack                        0x0bce  /* U+22A5 UP TACK */
+#define XKB_KEY_circle                        0x0bcf  /* U+25CB WHITE CIRCLE */
+#define XKB_KEY_upstile                       0x0bd3  /* U+2308 LEFT CEILING */
+#define XKB_KEY_downshoe                      0x0bd6  /*(U+222A UNION)*/
+#define XKB_KEY_rightshoe                     0x0bd8  /*(U+2283 SUPERSET OF)*/
+#define XKB_KEY_leftshoe                      0x0bda  /*(U+2282 SUBSET OF)*/
+#define XKB_KEY_lefttack                      0x0bdc  /* U+22A3 LEFT TACK */
+#define XKB_KEY_righttack                     0x0bfc  /* U+22A2 RIGHT TACK */
+
+/*
+ * Hebrew
+ * Byte 3 = 0x0c
+ */
+
+#define XKB_KEY_hebrew_doublelowline          0x0cdf  /* U+2017 DOUBLE LOW LINE */
+#define XKB_KEY_hebrew_aleph                  0x0ce0  /* U+05D0 HEBREW LETTER ALEF */
+#define XKB_KEY_hebrew_bet                    0x0ce1  /* U+05D1 HEBREW LETTER BET */
+#define XKB_KEY_hebrew_beth                   0x0ce1  /* deprecated */
+#define XKB_KEY_hebrew_gimel                  0x0ce2  /* U+05D2 HEBREW LETTER GIMEL */
+#define XKB_KEY_hebrew_gimmel                 0x0ce2  /* deprecated */
+#define XKB_KEY_hebrew_dalet                  0x0ce3  /* U+05D3 HEBREW LETTER DALET */
+#define XKB_KEY_hebrew_daleth                 0x0ce3  /* deprecated */
+#define XKB_KEY_hebrew_he                     0x0ce4  /* U+05D4 HEBREW LETTER HE */
+#define XKB_KEY_hebrew_waw                    0x0ce5  /* U+05D5 HEBREW LETTER VAV */
+#define XKB_KEY_hebrew_zain                   0x0ce6  /* U+05D6 HEBREW LETTER ZAYIN */
+#define XKB_KEY_hebrew_zayin                  0x0ce6  /* deprecated */
+#define XKB_KEY_hebrew_chet                   0x0ce7  /* U+05D7 HEBREW LETTER HET */
+#define XKB_KEY_hebrew_het                    0x0ce7  /* deprecated */
+#define XKB_KEY_hebrew_tet                    0x0ce8  /* U+05D8 HEBREW LETTER TET */
+#define XKB_KEY_hebrew_teth                   0x0ce8  /* deprecated */
+#define XKB_KEY_hebrew_yod                    0x0ce9  /* U+05D9 HEBREW LETTER YOD */
+#define XKB_KEY_hebrew_finalkaph              0x0cea  /* U+05DA HEBREW LETTER FINAL KAF */
+#define XKB_KEY_hebrew_kaph                   0x0ceb  /* U+05DB HEBREW LETTER KAF */
+#define XKB_KEY_hebrew_lamed                  0x0cec  /* U+05DC HEBREW LETTER LAMED */
+#define XKB_KEY_hebrew_finalmem               0x0ced  /* U+05DD HEBREW LETTER FINAL MEM */
+#define XKB_KEY_hebrew_mem                    0x0cee  /* U+05DE HEBREW LETTER MEM */
+#define XKB_KEY_hebrew_finalnun               0x0cef  /* U+05DF HEBREW LETTER FINAL NUN */
+#define XKB_KEY_hebrew_nun                    0x0cf0  /* U+05E0 HEBREW LETTER NUN */
+#define XKB_KEY_hebrew_samech                 0x0cf1  /* U+05E1 HEBREW LETTER SAMEKH */
+#define XKB_KEY_hebrew_samekh                 0x0cf1  /* deprecated */
+#define XKB_KEY_hebrew_ayin                   0x0cf2  /* U+05E2 HEBREW LETTER AYIN */
+#define XKB_KEY_hebrew_finalpe                0x0cf3  /* U+05E3 HEBREW LETTER FINAL PE */
+#define XKB_KEY_hebrew_pe                     0x0cf4  /* U+05E4 HEBREW LETTER PE */
+#define XKB_KEY_hebrew_finalzade              0x0cf5  /* U+05E5 HEBREW LETTER FINAL TSADI */
+#define XKB_KEY_hebrew_finalzadi              0x0cf5  /* deprecated */
+#define XKB_KEY_hebrew_zade                   0x0cf6  /* U+05E6 HEBREW LETTER TSADI */
+#define XKB_KEY_hebrew_zadi                   0x0cf6  /* deprecated */
+#define XKB_KEY_hebrew_qoph                   0x0cf7  /* U+05E7 HEBREW LETTER QOF */
+#define XKB_KEY_hebrew_kuf                    0x0cf7  /* deprecated */
+#define XKB_KEY_hebrew_resh                   0x0cf8  /* U+05E8 HEBREW LETTER RESH */
+#define XKB_KEY_hebrew_shin                   0x0cf9  /* U+05E9 HEBREW LETTER SHIN */
+#define XKB_KEY_hebrew_taw                    0x0cfa  /* U+05EA HEBREW LETTER TAV */
+#define XKB_KEY_hebrew_taf                    0x0cfa  /* deprecated */
+#define XKB_KEY_Hebrew_switch                 0xff7e  /* Alias for mode_switch */
+
+/*
+ * Thai
+ * Byte 3 = 0x0d
+ */
+
+#define XKB_KEY_Thai_kokai                    0x0da1  /* U+0E01 THAI CHARACTER KO KAI */
+#define XKB_KEY_Thai_khokhai                  0x0da2  /* U+0E02 THAI CHARACTER KHO KHAI */
+#define XKB_KEY_Thai_khokhuat                 0x0da3  /* U+0E03 THAI CHARACTER KHO KHUAT */
+#define XKB_KEY_Thai_khokhwai                 0x0da4  /* U+0E04 THAI CHARACTER KHO KHWAI */
+#define XKB_KEY_Thai_khokhon                  0x0da5  /* U+0E05 THAI CHARACTER KHO KHON */
+#define XKB_KEY_Thai_khorakhang               0x0da6  /* U+0E06 THAI CHARACTER KHO RAKHANG */
+#define XKB_KEY_Thai_ngongu                   0x0da7  /* U+0E07 THAI CHARACTER NGO NGU */
+#define XKB_KEY_Thai_chochan                  0x0da8  /* U+0E08 THAI CHARACTER CHO CHAN */
+#define XKB_KEY_Thai_choching                 0x0da9  /* U+0E09 THAI CHARACTER CHO CHING */
+#define XKB_KEY_Thai_chochang                 0x0daa  /* U+0E0A THAI CHARACTER CHO CHANG */
+#define XKB_KEY_Thai_soso                     0x0dab  /* U+0E0B THAI CHARACTER SO SO */
+#define XKB_KEY_Thai_chochoe                  0x0dac  /* U+0E0C THAI CHARACTER CHO CHOE */
+#define XKB_KEY_Thai_yoying                   0x0dad  /* U+0E0D THAI CHARACTER YO YING */
+#define XKB_KEY_Thai_dochada                  0x0dae  /* U+0E0E THAI CHARACTER DO CHADA */
+#define XKB_KEY_Thai_topatak                  0x0daf  /* U+0E0F THAI CHARACTER TO PATAK */
+#define XKB_KEY_Thai_thothan                  0x0db0  /* U+0E10 THAI CHARACTER THO THAN */
+#define XKB_KEY_Thai_thonangmontho            0x0db1  /* U+0E11 THAI CHARACTER THO NANGMONTHO */
+#define XKB_KEY_Thai_thophuthao               0x0db2  /* U+0E12 THAI CHARACTER THO PHUTHAO */
+#define XKB_KEY_Thai_nonen                    0x0db3  /* U+0E13 THAI CHARACTER NO NEN */
+#define XKB_KEY_Thai_dodek                    0x0db4  /* U+0E14 THAI CHARACTER DO DEK */
+#define XKB_KEY_Thai_totao                    0x0db5  /* U+0E15 THAI CHARACTER TO TAO */
+#define XKB_KEY_Thai_thothung                 0x0db6  /* U+0E16 THAI CHARACTER THO THUNG */
+#define XKB_KEY_Thai_thothahan                0x0db7  /* U+0E17 THAI CHARACTER THO THAHAN */
+#define XKB_KEY_Thai_thothong                 0x0db8  /* U+0E18 THAI CHARACTER THO THONG */
+#define XKB_KEY_Thai_nonu                     0x0db9  /* U+0E19 THAI CHARACTER NO NU */
+#define XKB_KEY_Thai_bobaimai                 0x0dba  /* U+0E1A THAI CHARACTER BO BAIMAI */
+#define XKB_KEY_Thai_popla                    0x0dbb  /* U+0E1B THAI CHARACTER PO PLA */
+#define XKB_KEY_Thai_phophung                 0x0dbc  /* U+0E1C THAI CHARACTER PHO PHUNG */
+#define XKB_KEY_Thai_fofa                     0x0dbd  /* U+0E1D THAI CHARACTER FO FA */
+#define XKB_KEY_Thai_phophan                  0x0dbe  /* U+0E1E THAI CHARACTER PHO PHAN */
+#define XKB_KEY_Thai_fofan                    0x0dbf  /* U+0E1F THAI CHARACTER FO FAN */
+#define XKB_KEY_Thai_phosamphao               0x0dc0  /* U+0E20 THAI CHARACTER PHO SAMPHAO */
+#define XKB_KEY_Thai_moma                     0x0dc1  /* U+0E21 THAI CHARACTER MO MA */
+#define XKB_KEY_Thai_yoyak                    0x0dc2  /* U+0E22 THAI CHARACTER YO YAK */
+#define XKB_KEY_Thai_rorua                    0x0dc3  /* U+0E23 THAI CHARACTER RO RUA */
+#define XKB_KEY_Thai_ru                       0x0dc4  /* U+0E24 THAI CHARACTER RU */
+#define XKB_KEY_Thai_loling                   0x0dc5  /* U+0E25 THAI CHARACTER LO LING */
+#define XKB_KEY_Thai_lu                       0x0dc6  /* U+0E26 THAI CHARACTER LU */
+#define XKB_KEY_Thai_wowaen                   0x0dc7  /* U+0E27 THAI CHARACTER WO WAEN */
+#define XKB_KEY_Thai_sosala                   0x0dc8  /* U+0E28 THAI CHARACTER SO SALA */
+#define XKB_KEY_Thai_sorusi                   0x0dc9  /* U+0E29 THAI CHARACTER SO RUSI */
+#define XKB_KEY_Thai_sosua                    0x0dca  /* U+0E2A THAI CHARACTER SO SUA */
+#define XKB_KEY_Thai_hohip                    0x0dcb  /* U+0E2B THAI CHARACTER HO HIP */
+#define XKB_KEY_Thai_lochula                  0x0dcc  /* U+0E2C THAI CHARACTER LO CHULA */
+#define XKB_KEY_Thai_oang                     0x0dcd  /* U+0E2D THAI CHARACTER O ANG */
+#define XKB_KEY_Thai_honokhuk                 0x0dce  /* U+0E2E THAI CHARACTER HO NOKHUK */
+#define XKB_KEY_Thai_paiyannoi                0x0dcf  /* U+0E2F THAI CHARACTER PAIYANNOI */
+#define XKB_KEY_Thai_saraa                    0x0dd0  /* U+0E30 THAI CHARACTER SARA A */
+#define XKB_KEY_Thai_maihanakat               0x0dd1  /* U+0E31 THAI CHARACTER MAI HAN-AKAT */
+#define XKB_KEY_Thai_saraaa                   0x0dd2  /* U+0E32 THAI CHARACTER SARA AA */
+#define XKB_KEY_Thai_saraam                   0x0dd3  /* U+0E33 THAI CHARACTER SARA AM */
+#define XKB_KEY_Thai_sarai                    0x0dd4  /* U+0E34 THAI CHARACTER SARA I */
+#define XKB_KEY_Thai_saraii                   0x0dd5  /* U+0E35 THAI CHARACTER SARA II */
+#define XKB_KEY_Thai_saraue                   0x0dd6  /* U+0E36 THAI CHARACTER SARA UE */
+#define XKB_KEY_Thai_sarauee                  0x0dd7  /* U+0E37 THAI CHARACTER SARA UEE */
+#define XKB_KEY_Thai_sarau                    0x0dd8  /* U+0E38 THAI CHARACTER SARA U */
+#define XKB_KEY_Thai_sarauu                   0x0dd9  /* U+0E39 THAI CHARACTER SARA UU */
+#define XKB_KEY_Thai_phinthu                  0x0dda  /* U+0E3A THAI CHARACTER PHINTHU */
+#define XKB_KEY_Thai_maihanakat_maitho        0x0dde
+#define XKB_KEY_Thai_baht                     0x0ddf  /* U+0E3F THAI CURRENCY SYMBOL BAHT */
+#define XKB_KEY_Thai_sarae                    0x0de0  /* U+0E40 THAI CHARACTER SARA E */
+#define XKB_KEY_Thai_saraae                   0x0de1  /* U+0E41 THAI CHARACTER SARA AE */
+#define XKB_KEY_Thai_sarao                    0x0de2  /* U+0E42 THAI CHARACTER SARA O */
+#define XKB_KEY_Thai_saraaimaimuan            0x0de3  /* U+0E43 THAI CHARACTER SARA AI MAIMUAN */
+#define XKB_KEY_Thai_saraaimaimalai           0x0de4  /* U+0E44 THAI CHARACTER SARA AI MAIMALAI */
+#define XKB_KEY_Thai_lakkhangyao              0x0de5  /* U+0E45 THAI CHARACTER LAKKHANGYAO */
+#define XKB_KEY_Thai_maiyamok                 0x0de6  /* U+0E46 THAI CHARACTER MAIYAMOK */
+#define XKB_KEY_Thai_maitaikhu                0x0de7  /* U+0E47 THAI CHARACTER MAITAIKHU */
+#define XKB_KEY_Thai_maiek                    0x0de8  /* U+0E48 THAI CHARACTER MAI EK */
+#define XKB_KEY_Thai_maitho                   0x0de9  /* U+0E49 THAI CHARACTER MAI THO */
+#define XKB_KEY_Thai_maitri                   0x0dea  /* U+0E4A THAI CHARACTER MAI TRI */
+#define XKB_KEY_Thai_maichattawa              0x0deb  /* U+0E4B THAI CHARACTER MAI CHATTAWA */
+#define XKB_KEY_Thai_thanthakhat              0x0dec  /* U+0E4C THAI CHARACTER THANTHAKHAT */
+#define XKB_KEY_Thai_nikhahit                 0x0ded  /* U+0E4D THAI CHARACTER NIKHAHIT */
+#define XKB_KEY_Thai_leksun                   0x0df0  /* U+0E50 THAI DIGIT ZERO */
+#define XKB_KEY_Thai_leknung                  0x0df1  /* U+0E51 THAI DIGIT ONE */
+#define XKB_KEY_Thai_leksong                  0x0df2  /* U+0E52 THAI DIGIT TWO */
+#define XKB_KEY_Thai_leksam                   0x0df3  /* U+0E53 THAI DIGIT THREE */
+#define XKB_KEY_Thai_leksi                    0x0df4  /* U+0E54 THAI DIGIT FOUR */
+#define XKB_KEY_Thai_lekha                    0x0df5  /* U+0E55 THAI DIGIT FIVE */
+#define XKB_KEY_Thai_lekhok                   0x0df6  /* U+0E56 THAI DIGIT SIX */
+#define XKB_KEY_Thai_lekchet                  0x0df7  /* U+0E57 THAI DIGIT SEVEN */
+#define XKB_KEY_Thai_lekpaet                  0x0df8  /* U+0E58 THAI DIGIT EIGHT */
+#define XKB_KEY_Thai_lekkao                   0x0df9  /* U+0E59 THAI DIGIT NINE */
+
+/*
+ * Korean
+ * Byte 3 = 0x0e
+ */
+
+
+#define XKB_KEY_Hangul                        0xff31  /* Hangul start/stop(toggle) */
+#define XKB_KEY_Hangul_Start                  0xff32  /* Hangul start */
+#define XKB_KEY_Hangul_End                    0xff33  /* Hangul end, English start */
+#define XKB_KEY_Hangul_Hanja                  0xff34  /* Start Hangul->Hanja Conversion */
+#define XKB_KEY_Hangul_Jamo                   0xff35  /* Hangul Jamo mode */
+#define XKB_KEY_Hangul_Romaja                 0xff36  /* Hangul Romaja mode */
+#define XKB_KEY_Hangul_Codeinput              0xff37  /* Hangul code input mode */
+#define XKB_KEY_Hangul_Jeonja                 0xff38  /* Jeonja mode */
+#define XKB_KEY_Hangul_Banja                  0xff39  /* Banja mode */
+#define XKB_KEY_Hangul_PreHanja               0xff3a  /* Pre Hanja conversion */
+#define XKB_KEY_Hangul_PostHanja              0xff3b  /* Post Hanja conversion */
+#define XKB_KEY_Hangul_SingleCandidate        0xff3c  /* Single candidate */
+#define XKB_KEY_Hangul_MultipleCandidate      0xff3d  /* Multiple candidate */
+#define XKB_KEY_Hangul_PreviousCandidate      0xff3e  /* Previous candidate */
+#define XKB_KEY_Hangul_Special                0xff3f  /* Special symbols */
+#define XKB_KEY_Hangul_switch                 0xff7e  /* Alias for mode_switch */
+
+/* Hangul Consonant Characters */
+#define XKB_KEY_Hangul_Kiyeog                 0x0ea1
+#define XKB_KEY_Hangul_SsangKiyeog            0x0ea2
+#define XKB_KEY_Hangul_KiyeogSios             0x0ea3
+#define XKB_KEY_Hangul_Nieun                  0x0ea4
+#define XKB_KEY_Hangul_NieunJieuj             0x0ea5
+#define XKB_KEY_Hangul_NieunHieuh             0x0ea6
+#define XKB_KEY_Hangul_Dikeud                 0x0ea7
+#define XKB_KEY_Hangul_SsangDikeud            0x0ea8
+#define XKB_KEY_Hangul_Rieul                  0x0ea9
+#define XKB_KEY_Hangul_RieulKiyeog            0x0eaa
+#define XKB_KEY_Hangul_RieulMieum             0x0eab
+#define XKB_KEY_Hangul_RieulPieub             0x0eac
+#define XKB_KEY_Hangul_RieulSios              0x0ead
+#define XKB_KEY_Hangul_RieulTieut             0x0eae
+#define XKB_KEY_Hangul_RieulPhieuf            0x0eaf
+#define XKB_KEY_Hangul_RieulHieuh             0x0eb0
+#define XKB_KEY_Hangul_Mieum                  0x0eb1
+#define XKB_KEY_Hangul_Pieub                  0x0eb2
+#define XKB_KEY_Hangul_SsangPieub             0x0eb3
+#define XKB_KEY_Hangul_PieubSios              0x0eb4
+#define XKB_KEY_Hangul_Sios                   0x0eb5
+#define XKB_KEY_Hangul_SsangSios              0x0eb6
+#define XKB_KEY_Hangul_Ieung                  0x0eb7
+#define XKB_KEY_Hangul_Jieuj                  0x0eb8
+#define XKB_KEY_Hangul_SsangJieuj             0x0eb9
+#define XKB_KEY_Hangul_Cieuc                  0x0eba
+#define XKB_KEY_Hangul_Khieuq                 0x0ebb
+#define XKB_KEY_Hangul_Tieut                  0x0ebc
+#define XKB_KEY_Hangul_Phieuf                 0x0ebd
+#define XKB_KEY_Hangul_Hieuh                  0x0ebe
+
+/* Hangul Vowel Characters */
+#define XKB_KEY_Hangul_A                      0x0ebf
+#define XKB_KEY_Hangul_AE                     0x0ec0
+#define XKB_KEY_Hangul_YA                     0x0ec1
+#define XKB_KEY_Hangul_YAE                    0x0ec2
+#define XKB_KEY_Hangul_EO                     0x0ec3
+#define XKB_KEY_Hangul_E                      0x0ec4
+#define XKB_KEY_Hangul_YEO                    0x0ec5
+#define XKB_KEY_Hangul_YE                     0x0ec6
+#define XKB_KEY_Hangul_O                      0x0ec7
+#define XKB_KEY_Hangul_WA                     0x0ec8
+#define XKB_KEY_Hangul_WAE                    0x0ec9
+#define XKB_KEY_Hangul_OE                     0x0eca
+#define XKB_KEY_Hangul_YO                     0x0ecb
+#define XKB_KEY_Hangul_U                      0x0ecc
+#define XKB_KEY_Hangul_WEO                    0x0ecd
+#define XKB_KEY_Hangul_WE                     0x0ece
+#define XKB_KEY_Hangul_WI                     0x0ecf
+#define XKB_KEY_Hangul_YU                     0x0ed0
+#define XKB_KEY_Hangul_EU                     0x0ed1
+#define XKB_KEY_Hangul_YI                     0x0ed2
+#define XKB_KEY_Hangul_I                      0x0ed3
+
+/* Hangul syllable-final (JongSeong) Characters */
+#define XKB_KEY_Hangul_J_Kiyeog               0x0ed4
+#define XKB_KEY_Hangul_J_SsangKiyeog          0x0ed5
+#define XKB_KEY_Hangul_J_KiyeogSios           0x0ed6
+#define XKB_KEY_Hangul_J_Nieun                0x0ed7
+#define XKB_KEY_Hangul_J_NieunJieuj           0x0ed8
+#define XKB_KEY_Hangul_J_NieunHieuh           0x0ed9
+#define XKB_KEY_Hangul_J_Dikeud               0x0eda
+#define XKB_KEY_Hangul_J_Rieul                0x0edb
+#define XKB_KEY_Hangul_J_RieulKiyeog          0x0edc
+#define XKB_KEY_Hangul_J_RieulMieum           0x0edd
+#define XKB_KEY_Hangul_J_RieulPieub           0x0ede
+#define XKB_KEY_Hangul_J_RieulSios            0x0edf
+#define XKB_KEY_Hangul_J_RieulTieut           0x0ee0
+#define XKB_KEY_Hangul_J_RieulPhieuf          0x0ee1
+#define XKB_KEY_Hangul_J_RieulHieuh           0x0ee2
+#define XKB_KEY_Hangul_J_Mieum                0x0ee3
+#define XKB_KEY_Hangul_J_Pieub                0x0ee4
+#define XKB_KEY_Hangul_J_PieubSios            0x0ee5
+#define XKB_KEY_Hangul_J_Sios                 0x0ee6
+#define XKB_KEY_Hangul_J_SsangSios            0x0ee7
+#define XKB_KEY_Hangul_J_Ieung                0x0ee8
+#define XKB_KEY_Hangul_J_Jieuj                0x0ee9
+#define XKB_KEY_Hangul_J_Cieuc                0x0eea
+#define XKB_KEY_Hangul_J_Khieuq               0x0eeb
+#define XKB_KEY_Hangul_J_Tieut                0x0eec
+#define XKB_KEY_Hangul_J_Phieuf               0x0eed
+#define XKB_KEY_Hangul_J_Hieuh                0x0eee
+
+/* Ancient Hangul Consonant Characters */
+#define XKB_KEY_Hangul_RieulYeorinHieuh       0x0eef
+#define XKB_KEY_Hangul_SunkyeongeumMieum      0x0ef0
+#define XKB_KEY_Hangul_SunkyeongeumPieub      0x0ef1
+#define XKB_KEY_Hangul_PanSios                0x0ef2
+#define XKB_KEY_Hangul_KkogjiDalrinIeung      0x0ef3
+#define XKB_KEY_Hangul_SunkyeongeumPhieuf     0x0ef4
+#define XKB_KEY_Hangul_YeorinHieuh            0x0ef5
+
+/* Ancient Hangul Vowel Characters */
+#define XKB_KEY_Hangul_AraeA                  0x0ef6
+#define XKB_KEY_Hangul_AraeAE                 0x0ef7
+
+/* Ancient Hangul syllable-final (JongSeong) Characters */
+#define XKB_KEY_Hangul_J_PanSios              0x0ef8
+#define XKB_KEY_Hangul_J_KkogjiDalrinIeung    0x0ef9
+#define XKB_KEY_Hangul_J_YeorinHieuh          0x0efa
+
+/* Korean currency symbol */
+#define XKB_KEY_Korean_Won                    0x0eff  /*(U+20A9 WON SIGN)*/
+
+
+/*
+ * Armenian
+ */
+
+#define XKB_KEY_Armenian_ligature_ew       0x1000587  /* U+0587 ARMENIAN SMALL LIGATURE ECH YIWN */
+#define XKB_KEY_Armenian_full_stop         0x1000589  /* U+0589 ARMENIAN FULL STOP */
+#define XKB_KEY_Armenian_verjaket          0x1000589  /* U+0589 ARMENIAN FULL STOP */
+#define XKB_KEY_Armenian_separation_mark   0x100055d  /* U+055D ARMENIAN COMMA */
+#define XKB_KEY_Armenian_but               0x100055d  /* U+055D ARMENIAN COMMA */
+#define XKB_KEY_Armenian_hyphen            0x100058a  /* U+058A ARMENIAN HYPHEN */
+#define XKB_KEY_Armenian_yentamna          0x100058a  /* U+058A ARMENIAN HYPHEN */
+#define XKB_KEY_Armenian_exclam            0x100055c  /* U+055C ARMENIAN EXCLAMATION MARK */
+#define XKB_KEY_Armenian_amanak            0x100055c  /* U+055C ARMENIAN EXCLAMATION MARK */
+#define XKB_KEY_Armenian_accent            0x100055b  /* U+055B ARMENIAN EMPHASIS MARK */
+#define XKB_KEY_Armenian_shesht            0x100055b  /* U+055B ARMENIAN EMPHASIS MARK */
+#define XKB_KEY_Armenian_question          0x100055e  /* U+055E ARMENIAN QUESTION MARK */
+#define XKB_KEY_Armenian_paruyk            0x100055e  /* U+055E ARMENIAN QUESTION MARK */
+#define XKB_KEY_Armenian_AYB               0x1000531  /* U+0531 ARMENIAN CAPITAL LETTER AYB */
+#define XKB_KEY_Armenian_ayb               0x1000561  /* U+0561 ARMENIAN SMALL LETTER AYB */
+#define XKB_KEY_Armenian_BEN               0x1000532  /* U+0532 ARMENIAN CAPITAL LETTER BEN */
+#define XKB_KEY_Armenian_ben               0x1000562  /* U+0562 ARMENIAN SMALL LETTER BEN */
+#define XKB_KEY_Armenian_GIM               0x1000533  /* U+0533 ARMENIAN CAPITAL LETTER GIM */
+#define XKB_KEY_Armenian_gim               0x1000563  /* U+0563 ARMENIAN SMALL LETTER GIM */
+#define XKB_KEY_Armenian_DA                0x1000534  /* U+0534 ARMENIAN CAPITAL LETTER DA */
+#define XKB_KEY_Armenian_da                0x1000564  /* U+0564 ARMENIAN SMALL LETTER DA */
+#define XKB_KEY_Armenian_YECH              0x1000535  /* U+0535 ARMENIAN CAPITAL LETTER ECH */
+#define XKB_KEY_Armenian_yech              0x1000565  /* U+0565 ARMENIAN SMALL LETTER ECH */
+#define XKB_KEY_Armenian_ZA                0x1000536  /* U+0536 ARMENIAN CAPITAL LETTER ZA */
+#define XKB_KEY_Armenian_za                0x1000566  /* U+0566 ARMENIAN SMALL LETTER ZA */
+#define XKB_KEY_Armenian_E                 0x1000537  /* U+0537 ARMENIAN CAPITAL LETTER EH */
+#define XKB_KEY_Armenian_e                 0x1000567  /* U+0567 ARMENIAN SMALL LETTER EH */
+#define XKB_KEY_Armenian_AT                0x1000538  /* U+0538 ARMENIAN CAPITAL LETTER ET */
+#define XKB_KEY_Armenian_at                0x1000568  /* U+0568 ARMENIAN SMALL LETTER ET */
+#define XKB_KEY_Armenian_TO                0x1000539  /* U+0539 ARMENIAN CAPITAL LETTER TO */
+#define XKB_KEY_Armenian_to                0x1000569  /* U+0569 ARMENIAN SMALL LETTER TO */
+#define XKB_KEY_Armenian_ZHE               0x100053a  /* U+053A ARMENIAN CAPITAL LETTER ZHE */
+#define XKB_KEY_Armenian_zhe               0x100056a  /* U+056A ARMENIAN SMALL LETTER ZHE */
+#define XKB_KEY_Armenian_INI               0x100053b  /* U+053B ARMENIAN CAPITAL LETTER INI */
+#define XKB_KEY_Armenian_ini               0x100056b  /* U+056B ARMENIAN SMALL LETTER INI */
+#define XKB_KEY_Armenian_LYUN              0x100053c  /* U+053C ARMENIAN CAPITAL LETTER LIWN */
+#define XKB_KEY_Armenian_lyun              0x100056c  /* U+056C ARMENIAN SMALL LETTER LIWN */
+#define XKB_KEY_Armenian_KHE               0x100053d  /* U+053D ARMENIAN CAPITAL LETTER XEH */
+#define XKB_KEY_Armenian_khe               0x100056d  /* U+056D ARMENIAN SMALL LETTER XEH */
+#define XKB_KEY_Armenian_TSA               0x100053e  /* U+053E ARMENIAN CAPITAL LETTER CA */
+#define XKB_KEY_Armenian_tsa               0x100056e  /* U+056E ARMENIAN SMALL LETTER CA */
+#define XKB_KEY_Armenian_KEN               0x100053f  /* U+053F ARMENIAN CAPITAL LETTER KEN */
+#define XKB_KEY_Armenian_ken               0x100056f  /* U+056F ARMENIAN SMALL LETTER KEN */
+#define XKB_KEY_Armenian_HO                0x1000540  /* U+0540 ARMENIAN CAPITAL LETTER HO */
+#define XKB_KEY_Armenian_ho                0x1000570  /* U+0570 ARMENIAN SMALL LETTER HO */
+#define XKB_KEY_Armenian_DZA               0x1000541  /* U+0541 ARMENIAN CAPITAL LETTER JA */
+#define XKB_KEY_Armenian_dza               0x1000571  /* U+0571 ARMENIAN SMALL LETTER JA */
+#define XKB_KEY_Armenian_GHAT              0x1000542  /* U+0542 ARMENIAN CAPITAL LETTER GHAD */
+#define XKB_KEY_Armenian_ghat              0x1000572  /* U+0572 ARMENIAN SMALL LETTER GHAD */
+#define XKB_KEY_Armenian_TCHE              0x1000543  /* U+0543 ARMENIAN CAPITAL LETTER CHEH */
+#define XKB_KEY_Armenian_tche              0x1000573  /* U+0573 ARMENIAN SMALL LETTER CHEH */
+#define XKB_KEY_Armenian_MEN               0x1000544  /* U+0544 ARMENIAN CAPITAL LETTER MEN */
+#define XKB_KEY_Armenian_men               0x1000574  /* U+0574 ARMENIAN SMALL LETTER MEN */
+#define XKB_KEY_Armenian_HI                0x1000545  /* U+0545 ARMENIAN CAPITAL LETTER YI */
+#define XKB_KEY_Armenian_hi                0x1000575  /* U+0575 ARMENIAN SMALL LETTER YI */
+#define XKB_KEY_Armenian_NU                0x1000546  /* U+0546 ARMENIAN CAPITAL LETTER NOW */
+#define XKB_KEY_Armenian_nu                0x1000576  /* U+0576 ARMENIAN SMALL LETTER NOW */
+#define XKB_KEY_Armenian_SHA               0x1000547  /* U+0547 ARMENIAN CAPITAL LETTER SHA */
+#define XKB_KEY_Armenian_sha               0x1000577  /* U+0577 ARMENIAN SMALL LETTER SHA */
+#define XKB_KEY_Armenian_VO                0x1000548  /* U+0548 ARMENIAN CAPITAL LETTER VO */
+#define XKB_KEY_Armenian_vo                0x1000578  /* U+0578 ARMENIAN SMALL LETTER VO */
+#define XKB_KEY_Armenian_CHA               0x1000549  /* U+0549 ARMENIAN CAPITAL LETTER CHA */
+#define XKB_KEY_Armenian_cha               0x1000579  /* U+0579 ARMENIAN SMALL LETTER CHA */
+#define XKB_KEY_Armenian_PE                0x100054a  /* U+054A ARMENIAN CAPITAL LETTER PEH */
+#define XKB_KEY_Armenian_pe                0x100057a  /* U+057A ARMENIAN SMALL LETTER PEH */
+#define XKB_KEY_Armenian_JE                0x100054b  /* U+054B ARMENIAN CAPITAL LETTER JHEH */
+#define XKB_KEY_Armenian_je                0x100057b  /* U+057B ARMENIAN SMALL LETTER JHEH */
+#define XKB_KEY_Armenian_RA                0x100054c  /* U+054C ARMENIAN CAPITAL LETTER RA */
+#define XKB_KEY_Armenian_ra                0x100057c  /* U+057C ARMENIAN SMALL LETTER RA */
+#define XKB_KEY_Armenian_SE                0x100054d  /* U+054D ARMENIAN CAPITAL LETTER SEH */
+#define XKB_KEY_Armenian_se                0x100057d  /* U+057D ARMENIAN SMALL LETTER SEH */
+#define XKB_KEY_Armenian_VEV               0x100054e  /* U+054E ARMENIAN CAPITAL LETTER VEW */
+#define XKB_KEY_Armenian_vev               0x100057e  /* U+057E ARMENIAN SMALL LETTER VEW */
+#define XKB_KEY_Armenian_TYUN              0x100054f  /* U+054F ARMENIAN CAPITAL LETTER TIWN */
+#define XKB_KEY_Armenian_tyun              0x100057f  /* U+057F ARMENIAN SMALL LETTER TIWN */
+#define XKB_KEY_Armenian_RE                0x1000550  /* U+0550 ARMENIAN CAPITAL LETTER REH */
+#define XKB_KEY_Armenian_re                0x1000580  /* U+0580 ARMENIAN SMALL LETTER REH */
+#define XKB_KEY_Armenian_TSO               0x1000551  /* U+0551 ARMENIAN CAPITAL LETTER CO */
+#define XKB_KEY_Armenian_tso               0x1000581  /* U+0581 ARMENIAN SMALL LETTER CO */
+#define XKB_KEY_Armenian_VYUN              0x1000552  /* U+0552 ARMENIAN CAPITAL LETTER YIWN */
+#define XKB_KEY_Armenian_vyun              0x1000582  /* U+0582 ARMENIAN SMALL LETTER YIWN */
+#define XKB_KEY_Armenian_PYUR              0x1000553  /* U+0553 ARMENIAN CAPITAL LETTER PIWR */
+#define XKB_KEY_Armenian_pyur              0x1000583  /* U+0583 ARMENIAN SMALL LETTER PIWR */
+#define XKB_KEY_Armenian_KE                0x1000554  /* U+0554 ARMENIAN CAPITAL LETTER KEH */
+#define XKB_KEY_Armenian_ke                0x1000584  /* U+0584 ARMENIAN SMALL LETTER KEH */
+#define XKB_KEY_Armenian_O                 0x1000555  /* U+0555 ARMENIAN CAPITAL LETTER OH */
+#define XKB_KEY_Armenian_o                 0x1000585  /* U+0585 ARMENIAN SMALL LETTER OH */
+#define XKB_KEY_Armenian_FE                0x1000556  /* U+0556 ARMENIAN CAPITAL LETTER FEH */
+#define XKB_KEY_Armenian_fe                0x1000586  /* U+0586 ARMENIAN SMALL LETTER FEH */
+#define XKB_KEY_Armenian_apostrophe        0x100055a  /* U+055A ARMENIAN APOSTROPHE */
+
+/*
+ * Georgian
+ */
+
+#define XKB_KEY_Georgian_an                0x10010d0  /* U+10D0 GEORGIAN LETTER AN */
+#define XKB_KEY_Georgian_ban               0x10010d1  /* U+10D1 GEORGIAN LETTER BAN */
+#define XKB_KEY_Georgian_gan               0x10010d2  /* U+10D2 GEORGIAN LETTER GAN */
+#define XKB_KEY_Georgian_don               0x10010d3  /* U+10D3 GEORGIAN LETTER DON */
+#define XKB_KEY_Georgian_en                0x10010d4  /* U+10D4 GEORGIAN LETTER EN */
+#define XKB_KEY_Georgian_vin               0x10010d5  /* U+10D5 GEORGIAN LETTER VIN */
+#define XKB_KEY_Georgian_zen               0x10010d6  /* U+10D6 GEORGIAN LETTER ZEN */
+#define XKB_KEY_Georgian_tan               0x10010d7  /* U+10D7 GEORGIAN LETTER TAN */
+#define XKB_KEY_Georgian_in                0x10010d8  /* U+10D8 GEORGIAN LETTER IN */
+#define XKB_KEY_Georgian_kan               0x10010d9  /* U+10D9 GEORGIAN LETTER KAN */
+#define XKB_KEY_Georgian_las               0x10010da  /* U+10DA GEORGIAN LETTER LAS */
+#define XKB_KEY_Georgian_man               0x10010db  /* U+10DB GEORGIAN LETTER MAN */
+#define XKB_KEY_Georgian_nar               0x10010dc  /* U+10DC GEORGIAN LETTER NAR */
+#define XKB_KEY_Georgian_on                0x10010dd  /* U+10DD GEORGIAN LETTER ON */
+#define XKB_KEY_Georgian_par               0x10010de  /* U+10DE GEORGIAN LETTER PAR */
+#define XKB_KEY_Georgian_zhar              0x10010df  /* U+10DF GEORGIAN LETTER ZHAR */
+#define XKB_KEY_Georgian_rae               0x10010e0  /* U+10E0 GEORGIAN LETTER RAE */
+#define XKB_KEY_Georgian_san               0x10010e1  /* U+10E1 GEORGIAN LETTER SAN */
+#define XKB_KEY_Georgian_tar               0x10010e2  /* U+10E2 GEORGIAN LETTER TAR */
+#define XKB_KEY_Georgian_un                0x10010e3  /* U+10E3 GEORGIAN LETTER UN */
+#define XKB_KEY_Georgian_phar              0x10010e4  /* U+10E4 GEORGIAN LETTER PHAR */
+#define XKB_KEY_Georgian_khar              0x10010e5  /* U+10E5 GEORGIAN LETTER KHAR */
+#define XKB_KEY_Georgian_ghan              0x10010e6  /* U+10E6 GEORGIAN LETTER GHAN */
+#define XKB_KEY_Georgian_qar               0x10010e7  /* U+10E7 GEORGIAN LETTER QAR */
+#define XKB_KEY_Georgian_shin              0x10010e8  /* U+10E8 GEORGIAN LETTER SHIN */
+#define XKB_KEY_Georgian_chin              0x10010e9  /* U+10E9 GEORGIAN LETTER CHIN */
+#define XKB_KEY_Georgian_can               0x10010ea  /* U+10EA GEORGIAN LETTER CAN */
+#define XKB_KEY_Georgian_jil               0x10010eb  /* U+10EB GEORGIAN LETTER JIL */
+#define XKB_KEY_Georgian_cil               0x10010ec  /* U+10EC GEORGIAN LETTER CIL */
+#define XKB_KEY_Georgian_char              0x10010ed  /* U+10ED GEORGIAN LETTER CHAR */
+#define XKB_KEY_Georgian_xan               0x10010ee  /* U+10EE GEORGIAN LETTER XAN */
+#define XKB_KEY_Georgian_jhan              0x10010ef  /* U+10EF GEORGIAN LETTER JHAN */
+#define XKB_KEY_Georgian_hae               0x10010f0  /* U+10F0 GEORGIAN LETTER HAE */
+#define XKB_KEY_Georgian_he                0x10010f1  /* U+10F1 GEORGIAN LETTER HE */
+#define XKB_KEY_Georgian_hie               0x10010f2  /* U+10F2 GEORGIAN LETTER HIE */
+#define XKB_KEY_Georgian_we                0x10010f3  /* U+10F3 GEORGIAN LETTER WE */
+#define XKB_KEY_Georgian_har               0x10010f4  /* U+10F4 GEORGIAN LETTER HAR */
+#define XKB_KEY_Georgian_hoe               0x10010f5  /* U+10F5 GEORGIAN LETTER HOE */
+#define XKB_KEY_Georgian_fi                0x10010f6  /* U+10F6 GEORGIAN LETTER FI */
+
+/*
+ * Azeri (and other Turkic or Caucasian languages)
+ */
+
+/* latin */
+#define XKB_KEY_Xabovedot                  0x1001e8a  /* U+1E8A LATIN CAPITAL LETTER X WITH DOT ABOVE */
+#define XKB_KEY_Ibreve                     0x100012c  /* U+012C LATIN CAPITAL LETTER I WITH BREVE */
+#define XKB_KEY_Zstroke                    0x10001b5  /* U+01B5 LATIN CAPITAL LETTER Z WITH STROKE */
+#define XKB_KEY_Gcaron                     0x10001e6  /* U+01E6 LATIN CAPITAL LETTER G WITH CARON */
+#define XKB_KEY_Ocaron                     0x10001d1  /* U+01D2 LATIN CAPITAL LETTER O WITH CARON */
+#define XKB_KEY_Obarred                    0x100019f  /* U+019F LATIN CAPITAL LETTER O WITH MIDDLE TILDE */
+#define XKB_KEY_xabovedot                  0x1001e8b  /* U+1E8B LATIN SMALL LETTER X WITH DOT ABOVE */
+#define XKB_KEY_ibreve                     0x100012d  /* U+012D LATIN SMALL LETTER I WITH BREVE */
+#define XKB_KEY_zstroke                    0x10001b6  /* U+01B6 LATIN SMALL LETTER Z WITH STROKE */
+#define XKB_KEY_gcaron                     0x10001e7  /* U+01E7 LATIN SMALL LETTER G WITH CARON */
+#define XKB_KEY_ocaron                     0x10001d2  /* U+01D2 LATIN SMALL LETTER O WITH CARON */
+#define XKB_KEY_obarred                    0x1000275  /* U+0275 LATIN SMALL LETTER BARRED O */
+#define XKB_KEY_SCHWA                      0x100018f  /* U+018F LATIN CAPITAL LETTER SCHWA */
+#define XKB_KEY_schwa                      0x1000259  /* U+0259 LATIN SMALL LETTER SCHWA */
+#define XKB_KEY_EZH                        0x10001b7  /* U+01B7 LATIN CAPITAL LETTER EZH */
+#define XKB_KEY_ezh                        0x1000292  /* U+0292 LATIN SMALL LETTER EZH */
+/* those are not really Caucasus */
+/* For Inupiak */
+#define XKB_KEY_Lbelowdot                  0x1001e36  /* U+1E36 LATIN CAPITAL LETTER L WITH DOT BELOW */
+#define XKB_KEY_lbelowdot                  0x1001e37  /* U+1E37 LATIN SMALL LETTER L WITH DOT BELOW */
+
+/*
+ * Vietnamese
+ */
+
+#define XKB_KEY_Abelowdot                  0x1001ea0  /* U+1EA0 LATIN CAPITAL LETTER A WITH DOT BELOW */
+#define XKB_KEY_abelowdot                  0x1001ea1  /* U+1EA1 LATIN SMALL LETTER A WITH DOT BELOW */
+#define XKB_KEY_Ahook                      0x1001ea2  /* U+1EA2 LATIN CAPITAL LETTER A WITH HOOK ABOVE */
+#define XKB_KEY_ahook                      0x1001ea3  /* U+1EA3 LATIN SMALL LETTER A WITH HOOK ABOVE */
+#define XKB_KEY_Acircumflexacute           0x1001ea4  /* U+1EA4 LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE */
+#define XKB_KEY_acircumflexacute           0x1001ea5  /* U+1EA5 LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE */
+#define XKB_KEY_Acircumflexgrave           0x1001ea6  /* U+1EA6 LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE */
+#define XKB_KEY_acircumflexgrave           0x1001ea7  /* U+1EA7 LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE */
+#define XKB_KEY_Acircumflexhook            0x1001ea8  /* U+1EA8 LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE */
+#define XKB_KEY_acircumflexhook            0x1001ea9  /* U+1EA9 LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE */
+#define XKB_KEY_Acircumflextilde           0x1001eaa  /* U+1EAA LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE */
+#define XKB_KEY_acircumflextilde           0x1001eab  /* U+1EAB LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE */
+#define XKB_KEY_Acircumflexbelowdot        0x1001eac  /* U+1EAC LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW */
+#define XKB_KEY_acircumflexbelowdot        0x1001ead  /* U+1EAD LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW */
+#define XKB_KEY_Abreveacute                0x1001eae  /* U+1EAE LATIN CAPITAL LETTER A WITH BREVE AND ACUTE */
+#define XKB_KEY_abreveacute                0x1001eaf  /* U+1EAF LATIN SMALL LETTER A WITH BREVE AND ACUTE */
+#define XKB_KEY_Abrevegrave                0x1001eb0  /* U+1EB0 LATIN CAPITAL LETTER A WITH BREVE AND GRAVE */
+#define XKB_KEY_abrevegrave                0x1001eb1  /* U+1EB1 LATIN SMALL LETTER A WITH BREVE AND GRAVE */
+#define XKB_KEY_Abrevehook                 0x1001eb2  /* U+1EB2 LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE */
+#define XKB_KEY_abrevehook                 0x1001eb3  /* U+1EB3 LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE */
+#define XKB_KEY_Abrevetilde                0x1001eb4  /* U+1EB4 LATIN CAPITAL LETTER A WITH BREVE AND TILDE */
+#define XKB_KEY_abrevetilde                0x1001eb5  /* U+1EB5 LATIN SMALL LETTER A WITH BREVE AND TILDE */
+#define XKB_KEY_Abrevebelowdot             0x1001eb6  /* U+1EB6 LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW */
+#define XKB_KEY_abrevebelowdot             0x1001eb7  /* U+1EB7 LATIN SMALL LETTER A WITH BREVE AND DOT BELOW */
+#define XKB_KEY_Ebelowdot                  0x1001eb8  /* U+1EB8 LATIN CAPITAL LETTER E WITH DOT BELOW */
+#define XKB_KEY_ebelowdot                  0x1001eb9  /* U+1EB9 LATIN SMALL LETTER E WITH DOT BELOW */
+#define XKB_KEY_Ehook                      0x1001eba  /* U+1EBA LATIN CAPITAL LETTER E WITH HOOK ABOVE */
+#define XKB_KEY_ehook                      0x1001ebb  /* U+1EBB LATIN SMALL LETTER E WITH HOOK ABOVE */
+#define XKB_KEY_Etilde                     0x1001ebc  /* U+1EBC LATIN CAPITAL LETTER E WITH TILDE */
+#define XKB_KEY_etilde                     0x1001ebd  /* U+1EBD LATIN SMALL LETTER E WITH TILDE */
+#define XKB_KEY_Ecircumflexacute           0x1001ebe  /* U+1EBE LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE */
+#define XKB_KEY_ecircumflexacute           0x1001ebf  /* U+1EBF LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE */
+#define XKB_KEY_Ecircumflexgrave           0x1001ec0  /* U+1EC0 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE */
+#define XKB_KEY_ecircumflexgrave           0x1001ec1  /* U+1EC1 LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE */
+#define XKB_KEY_Ecircumflexhook            0x1001ec2  /* U+1EC2 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE */
+#define XKB_KEY_ecircumflexhook            0x1001ec3  /* U+1EC3 LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE */
+#define XKB_KEY_Ecircumflextilde           0x1001ec4  /* U+1EC4 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE */
+#define XKB_KEY_ecircumflextilde           0x1001ec5  /* U+1EC5 LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE */
+#define XKB_KEY_Ecircumflexbelowdot        0x1001ec6  /* U+1EC6 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW */
+#define XKB_KEY_ecircumflexbelowdot        0x1001ec7  /* U+1EC7 LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW */
+#define XKB_KEY_Ihook                      0x1001ec8  /* U+1EC8 LATIN CAPITAL LETTER I WITH HOOK ABOVE */
+#define XKB_KEY_ihook                      0x1001ec9  /* U+1EC9 LATIN SMALL LETTER I WITH HOOK ABOVE */
+#define XKB_KEY_Ibelowdot                  0x1001eca  /* U+1ECA LATIN CAPITAL LETTER I WITH DOT BELOW */
+#define XKB_KEY_ibelowdot                  0x1001ecb  /* U+1ECB LATIN SMALL LETTER I WITH DOT BELOW */
+#define XKB_KEY_Obelowdot                  0x1001ecc  /* U+1ECC LATIN CAPITAL LETTER O WITH DOT BELOW */
+#define XKB_KEY_obelowdot                  0x1001ecd  /* U+1ECD LATIN SMALL LETTER O WITH DOT BELOW */
+#define XKB_KEY_Ohook                      0x1001ece  /* U+1ECE LATIN CAPITAL LETTER O WITH HOOK ABOVE */
+#define XKB_KEY_ohook                      0x1001ecf  /* U+1ECF LATIN SMALL LETTER O WITH HOOK ABOVE */
+#define XKB_KEY_Ocircumflexacute           0x1001ed0  /* U+1ED0 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE */
+#define XKB_KEY_ocircumflexacute           0x1001ed1  /* U+1ED1 LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE */
+#define XKB_KEY_Ocircumflexgrave           0x1001ed2  /* U+1ED2 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE */
+#define XKB_KEY_ocircumflexgrave           0x1001ed3  /* U+1ED3 LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE */
+#define XKB_KEY_Ocircumflexhook            0x1001ed4  /* U+1ED4 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE */
+#define XKB_KEY_ocircumflexhook            0x1001ed5  /* U+1ED5 LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE */
+#define XKB_KEY_Ocircumflextilde           0x1001ed6  /* U+1ED6 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE */
+#define XKB_KEY_ocircumflextilde           0x1001ed7  /* U+1ED7 LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE */
+#define XKB_KEY_Ocircumflexbelowdot        0x1001ed8  /* U+1ED8 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW */
+#define XKB_KEY_ocircumflexbelowdot        0x1001ed9  /* U+1ED9 LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW */
+#define XKB_KEY_Ohornacute                 0x1001eda  /* U+1EDA LATIN CAPITAL LETTER O WITH HORN AND ACUTE */
+#define XKB_KEY_ohornacute                 0x1001edb  /* U+1EDB LATIN SMALL LETTER O WITH HORN AND ACUTE */
+#define XKB_KEY_Ohorngrave                 0x1001edc  /* U+1EDC LATIN CAPITAL LETTER O WITH HORN AND GRAVE */
+#define XKB_KEY_ohorngrave                 0x1001edd  /* U+1EDD LATIN SMALL LETTER O WITH HORN AND GRAVE */
+#define XKB_KEY_Ohornhook                  0x1001ede  /* U+1EDE LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE */
+#define XKB_KEY_ohornhook                  0x1001edf  /* U+1EDF LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE */
+#define XKB_KEY_Ohorntilde                 0x1001ee0  /* U+1EE0 LATIN CAPITAL LETTER O WITH HORN AND TILDE */
+#define XKB_KEY_ohorntilde                 0x1001ee1  /* U+1EE1 LATIN SMALL LETTER O WITH HORN AND TILDE */
+#define XKB_KEY_Ohornbelowdot              0x1001ee2  /* U+1EE2 LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW */
+#define XKB_KEY_ohornbelowdot              0x1001ee3  /* U+1EE3 LATIN SMALL LETTER O WITH HORN AND DOT BELOW */
+#define XKB_KEY_Ubelowdot                  0x1001ee4  /* U+1EE4 LATIN CAPITAL LETTER U WITH DOT BELOW */
+#define XKB_KEY_ubelowdot                  0x1001ee5  /* U+1EE5 LATIN SMALL LETTER U WITH DOT BELOW */
+#define XKB_KEY_Uhook                      0x1001ee6  /* U+1EE6 LATIN CAPITAL LETTER U WITH HOOK ABOVE */
+#define XKB_KEY_uhook                      0x1001ee7  /* U+1EE7 LATIN SMALL LETTER U WITH HOOK ABOVE */
+#define XKB_KEY_Uhornacute                 0x1001ee8  /* U+1EE8 LATIN CAPITAL LETTER U WITH HORN AND ACUTE */
+#define XKB_KEY_uhornacute                 0x1001ee9  /* U+1EE9 LATIN SMALL LETTER U WITH HORN AND ACUTE */
+#define XKB_KEY_Uhorngrave                 0x1001eea  /* U+1EEA LATIN CAPITAL LETTER U WITH HORN AND GRAVE */
+#define XKB_KEY_uhorngrave                 0x1001eeb  /* U+1EEB LATIN SMALL LETTER U WITH HORN AND GRAVE */
+#define XKB_KEY_Uhornhook                  0x1001eec  /* U+1EEC LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE */
+#define XKB_KEY_uhornhook                  0x1001eed  /* U+1EED LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE */
+#define XKB_KEY_Uhorntilde                 0x1001eee  /* U+1EEE LATIN CAPITAL LETTER U WITH HORN AND TILDE */
+#define XKB_KEY_uhorntilde                 0x1001eef  /* U+1EEF LATIN SMALL LETTER U WITH HORN AND TILDE */
+#define XKB_KEY_Uhornbelowdot              0x1001ef0  /* U+1EF0 LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW */
+#define XKB_KEY_uhornbelowdot              0x1001ef1  /* U+1EF1 LATIN SMALL LETTER U WITH HORN AND DOT BELOW */
+#define XKB_KEY_Ybelowdot                  0x1001ef4  /* U+1EF4 LATIN CAPITAL LETTER Y WITH DOT BELOW */
+#define XKB_KEY_ybelowdot                  0x1001ef5  /* U+1EF5 LATIN SMALL LETTER Y WITH DOT BELOW */
+#define XKB_KEY_Yhook                      0x1001ef6  /* U+1EF6 LATIN CAPITAL LETTER Y WITH HOOK ABOVE */
+#define XKB_KEY_yhook                      0x1001ef7  /* U+1EF7 LATIN SMALL LETTER Y WITH HOOK ABOVE */
+#define XKB_KEY_Ytilde                     0x1001ef8  /* U+1EF8 LATIN CAPITAL LETTER Y WITH TILDE */
+#define XKB_KEY_ytilde                     0x1001ef9  /* U+1EF9 LATIN SMALL LETTER Y WITH TILDE */
+#define XKB_KEY_Ohorn                      0x10001a0  /* U+01A0 LATIN CAPITAL LETTER O WITH HORN */
+#define XKB_KEY_ohorn                      0x10001a1  /* U+01A1 LATIN SMALL LETTER O WITH HORN */
+#define XKB_KEY_Uhorn                      0x10001af  /* U+01AF LATIN CAPITAL LETTER U WITH HORN */
+#define XKB_KEY_uhorn                      0x10001b0  /* U+01B0 LATIN SMALL LETTER U WITH HORN */
+
+
+#define XKB_KEY_EcuSign                    0x10020a0  /* U+20A0 EURO-CURRENCY SIGN */
+#define XKB_KEY_ColonSign                  0x10020a1  /* U+20A1 COLON SIGN */
+#define XKB_KEY_CruzeiroSign               0x10020a2  /* U+20A2 CRUZEIRO SIGN */
+#define XKB_KEY_FFrancSign                 0x10020a3  /* U+20A3 FRENCH FRANC SIGN */
+#define XKB_KEY_LiraSign                   0x10020a4  /* U+20A4 LIRA SIGN */
+#define XKB_KEY_MillSign                   0x10020a5  /* U+20A5 MILL SIGN */
+#define XKB_KEY_NairaSign                  0x10020a6  /* U+20A6 NAIRA SIGN */
+#define XKB_KEY_PesetaSign                 0x10020a7  /* U+20A7 PESETA SIGN */
+#define XKB_KEY_RupeeSign                  0x10020a8  /* U+20A8 RUPEE SIGN */
+#define XKB_KEY_WonSign                    0x10020a9  /* U+20A9 WON SIGN */
+#define XKB_KEY_NewSheqelSign              0x10020aa  /* U+20AA NEW SHEQEL SIGN */
+#define XKB_KEY_DongSign                   0x10020ab  /* U+20AB DONG SIGN */
+#define XKB_KEY_EuroSign                      0x20ac  /* U+20AC EURO SIGN */
+
+/* one, two and three are defined above. */
+#define XKB_KEY_zerosuperior               0x1002070  /* U+2070 SUPERSCRIPT ZERO */
+#define XKB_KEY_foursuperior               0x1002074  /* U+2074 SUPERSCRIPT FOUR */
+#define XKB_KEY_fivesuperior               0x1002075  /* U+2075 SUPERSCRIPT FIVE */
+#define XKB_KEY_sixsuperior                0x1002076  /* U+2076 SUPERSCRIPT SIX */
+#define XKB_KEY_sevensuperior              0x1002077  /* U+2077 SUPERSCRIPT SEVEN */
+#define XKB_KEY_eightsuperior              0x1002078  /* U+2078 SUPERSCRIPT EIGHT */
+#define XKB_KEY_ninesuperior               0x1002079  /* U+2079 SUPERSCRIPT NINE */
+#define XKB_KEY_zerosubscript              0x1002080  /* U+2080 SUBSCRIPT ZERO */
+#define XKB_KEY_onesubscript               0x1002081  /* U+2081 SUBSCRIPT ONE */
+#define XKB_KEY_twosubscript               0x1002082  /* U+2082 SUBSCRIPT TWO */
+#define XKB_KEY_threesubscript             0x1002083  /* U+2083 SUBSCRIPT THREE */
+#define XKB_KEY_foursubscript              0x1002084  /* U+2084 SUBSCRIPT FOUR */
+#define XKB_KEY_fivesubscript              0x1002085  /* U+2085 SUBSCRIPT FIVE */
+#define XKB_KEY_sixsubscript               0x1002086  /* U+2086 SUBSCRIPT SIX */
+#define XKB_KEY_sevensubscript             0x1002087  /* U+2087 SUBSCRIPT SEVEN */
+#define XKB_KEY_eightsubscript             0x1002088  /* U+2088 SUBSCRIPT EIGHT */
+#define XKB_KEY_ninesubscript              0x1002089  /* U+2089 SUBSCRIPT NINE */
+#define XKB_KEY_partdifferential           0x1002202  /* U+2202 PARTIAL DIFFERENTIAL */
+#define XKB_KEY_emptyset                   0x1002205  /* U+2205 NULL SET */
+#define XKB_KEY_elementof                  0x1002208  /* U+2208 ELEMENT OF */
+#define XKB_KEY_notelementof               0x1002209  /* U+2209 NOT AN ELEMENT OF */
+#define XKB_KEY_containsas                 0x100220B  /* U+220B CONTAINS AS MEMBER */
+#define XKB_KEY_squareroot                 0x100221A  /* U+221A SQUARE ROOT */
+#define XKB_KEY_cuberoot                   0x100221B  /* U+221B CUBE ROOT */
+#define XKB_KEY_fourthroot                 0x100221C  /* U+221C FOURTH ROOT */
+#define XKB_KEY_dintegral                  0x100222C  /* U+222C DOUBLE INTEGRAL */
+#define XKB_KEY_tintegral                  0x100222D  /* U+222D TRIPLE INTEGRAL */
+#define XKB_KEY_because                    0x1002235  /* U+2235 BECAUSE */
+#define XKB_KEY_approxeq                   0x1002248  /* U+2245 ALMOST EQUAL TO */
+#define XKB_KEY_notapproxeq                0x1002247  /* U+2247 NOT ALMOST EQUAL TO */
+#define XKB_KEY_notidentical               0x1002262  /* U+2262 NOT IDENTICAL TO */
+#define XKB_KEY_stricteq                   0x1002263  /* U+2263 STRICTLY EQUIVALENT TO */
+
+#define XKB_KEY_braille_dot_1                 0xfff1
+#define XKB_KEY_braille_dot_2                 0xfff2
+#define XKB_KEY_braille_dot_3                 0xfff3
+#define XKB_KEY_braille_dot_4                 0xfff4
+#define XKB_KEY_braille_dot_5                 0xfff5
+#define XKB_KEY_braille_dot_6                 0xfff6
+#define XKB_KEY_braille_dot_7                 0xfff7
+#define XKB_KEY_braille_dot_8                 0xfff8
+#define XKB_KEY_braille_dot_9                 0xfff9
+#define XKB_KEY_braille_dot_10                0xfffa
+#define XKB_KEY_braille_blank              0x1002800  /* U+2800 BRAILLE PATTERN BLANK */
+#define XKB_KEY_braille_dots_1             0x1002801  /* U+2801 BRAILLE PATTERN DOTS-1 */
+#define XKB_KEY_braille_dots_2             0x1002802  /* U+2802 BRAILLE PATTERN DOTS-2 */
+#define XKB_KEY_braille_dots_12            0x1002803  /* U+2803 BRAILLE PATTERN DOTS-12 */
+#define XKB_KEY_braille_dots_3             0x1002804  /* U+2804 BRAILLE PATTERN DOTS-3 */
+#define XKB_KEY_braille_dots_13            0x1002805  /* U+2805 BRAILLE PATTERN DOTS-13 */
+#define XKB_KEY_braille_dots_23            0x1002806  /* U+2806 BRAILLE PATTERN DOTS-23 */
+#define XKB_KEY_braille_dots_123           0x1002807  /* U+2807 BRAILLE PATTERN DOTS-123 */
+#define XKB_KEY_braille_dots_4             0x1002808  /* U+2808 BRAILLE PATTERN DOTS-4 */
+#define XKB_KEY_braille_dots_14            0x1002809  /* U+2809 BRAILLE PATTERN DOTS-14 */
+#define XKB_KEY_braille_dots_24            0x100280a  /* U+280a BRAILLE PATTERN DOTS-24 */
+#define XKB_KEY_braille_dots_124           0x100280b  /* U+280b BRAILLE PATTERN DOTS-124 */
+#define XKB_KEY_braille_dots_34            0x100280c  /* U+280c BRAILLE PATTERN DOTS-34 */
+#define XKB_KEY_braille_dots_134           0x100280d  /* U+280d BRAILLE PATTERN DOTS-134 */
+#define XKB_KEY_braille_dots_234           0x100280e  /* U+280e BRAILLE PATTERN DOTS-234 */
+#define XKB_KEY_braille_dots_1234          0x100280f  /* U+280f BRAILLE PATTERN DOTS-1234 */
+#define XKB_KEY_braille_dots_5             0x1002810  /* U+2810 BRAILLE PATTERN DOTS-5 */
+#define XKB_KEY_braille_dots_15            0x1002811  /* U+2811 BRAILLE PATTERN DOTS-15 */
+#define XKB_KEY_braille_dots_25            0x1002812  /* U+2812 BRAILLE PATTERN DOTS-25 */
+#define XKB_KEY_braille_dots_125           0x1002813  /* U+2813 BRAILLE PATTERN DOTS-125 */
+#define XKB_KEY_braille_dots_35            0x1002814  /* U+2814 BRAILLE PATTERN DOTS-35 */
+#define XKB_KEY_braille_dots_135           0x1002815  /* U+2815 BRAILLE PATTERN DOTS-135 */
+#define XKB_KEY_braille_dots_235           0x1002816  /* U+2816 BRAILLE PATTERN DOTS-235 */
+#define XKB_KEY_braille_dots_1235          0x1002817  /* U+2817 BRAILLE PATTERN DOTS-1235 */
+#define XKB_KEY_braille_dots_45            0x1002818  /* U+2818 BRAILLE PATTERN DOTS-45 */
+#define XKB_KEY_braille_dots_145           0x1002819  /* U+2819 BRAILLE PATTERN DOTS-145 */
+#define XKB_KEY_braille_dots_245           0x100281a  /* U+281a BRAILLE PATTERN DOTS-245 */
+#define XKB_KEY_braille_dots_1245          0x100281b  /* U+281b BRAILLE PATTERN DOTS-1245 */
+#define XKB_KEY_braille_dots_345           0x100281c  /* U+281c BRAILLE PATTERN DOTS-345 */
+#define XKB_KEY_braille_dots_1345          0x100281d  /* U+281d BRAILLE PATTERN DOTS-1345 */
+#define XKB_KEY_braille_dots_2345          0x100281e  /* U+281e BRAILLE PATTERN DOTS-2345 */
+#define XKB_KEY_braille_dots_12345         0x100281f  /* U+281f BRAILLE PATTERN DOTS-12345 */
+#define XKB_KEY_braille_dots_6             0x1002820  /* U+2820 BRAILLE PATTERN DOTS-6 */
+#define XKB_KEY_braille_dots_16            0x1002821  /* U+2821 BRAILLE PATTERN DOTS-16 */
+#define XKB_KEY_braille_dots_26            0x1002822  /* U+2822 BRAILLE PATTERN DOTS-26 */
+#define XKB_KEY_braille_dots_126           0x1002823  /* U+2823 BRAILLE PATTERN DOTS-126 */
+#define XKB_KEY_braille_dots_36            0x1002824  /* U+2824 BRAILLE PATTERN DOTS-36 */
+#define XKB_KEY_braille_dots_136           0x1002825  /* U+2825 BRAILLE PATTERN DOTS-136 */
+#define XKB_KEY_braille_dots_236           0x1002826  /* U+2826 BRAILLE PATTERN DOTS-236 */
+#define XKB_KEY_braille_dots_1236          0x1002827  /* U+2827 BRAILLE PATTERN DOTS-1236 */
+#define XKB_KEY_braille_dots_46            0x1002828  /* U+2828 BRAILLE PATTERN DOTS-46 */
+#define XKB_KEY_braille_dots_146           0x1002829  /* U+2829 BRAILLE PATTERN DOTS-146 */
+#define XKB_KEY_braille_dots_246           0x100282a  /* U+282a BRAILLE PATTERN DOTS-246 */
+#define XKB_KEY_braille_dots_1246          0x100282b  /* U+282b BRAILLE PATTERN DOTS-1246 */
+#define XKB_KEY_braille_dots_346           0x100282c  /* U+282c BRAILLE PATTERN DOTS-346 */
+#define XKB_KEY_braille_dots_1346          0x100282d  /* U+282d BRAILLE PATTERN DOTS-1346 */
+#define XKB_KEY_braille_dots_2346          0x100282e  /* U+282e BRAILLE PATTERN DOTS-2346 */
+#define XKB_KEY_braille_dots_12346         0x100282f  /* U+282f BRAILLE PATTERN DOTS-12346 */
+#define XKB_KEY_braille_dots_56            0x1002830  /* U+2830 BRAILLE PATTERN DOTS-56 */
+#define XKB_KEY_braille_dots_156           0x1002831  /* U+2831 BRAILLE PATTERN DOTS-156 */
+#define XKB_KEY_braille_dots_256           0x1002832  /* U+2832 BRAILLE PATTERN DOTS-256 */
+#define XKB_KEY_braille_dots_1256          0x1002833  /* U+2833 BRAILLE PATTERN DOTS-1256 */
+#define XKB_KEY_braille_dots_356           0x1002834  /* U+2834 BRAILLE PATTERN DOTS-356 */
+#define XKB_KEY_braille_dots_1356          0x1002835  /* U+2835 BRAILLE PATTERN DOTS-1356 */
+#define XKB_KEY_braille_dots_2356          0x1002836  /* U+2836 BRAILLE PATTERN DOTS-2356 */
+#define XKB_KEY_braille_dots_12356         0x1002837  /* U+2837 BRAILLE PATTERN DOTS-12356 */
+#define XKB_KEY_braille_dots_456           0x1002838  /* U+2838 BRAILLE PATTERN DOTS-456 */
+#define XKB_KEY_braille_dots_1456          0x1002839  /* U+2839 BRAILLE PATTERN DOTS-1456 */
+#define XKB_KEY_braille_dots_2456          0x100283a  /* U+283a BRAILLE PATTERN DOTS-2456 */
+#define XKB_KEY_braille_dots_12456         0x100283b  /* U+283b BRAILLE PATTERN DOTS-12456 */
+#define XKB_KEY_braille_dots_3456          0x100283c  /* U+283c BRAILLE PATTERN DOTS-3456 */
+#define XKB_KEY_braille_dots_13456         0x100283d  /* U+283d BRAILLE PATTERN DOTS-13456 */
+#define XKB_KEY_braille_dots_23456         0x100283e  /* U+283e BRAILLE PATTERN DOTS-23456 */
+#define XKB_KEY_braille_dots_123456        0x100283f  /* U+283f BRAILLE PATTERN DOTS-123456 */
+#define XKB_KEY_braille_dots_7             0x1002840  /* U+2840 BRAILLE PATTERN DOTS-7 */
+#define XKB_KEY_braille_dots_17            0x1002841  /* U+2841 BRAILLE PATTERN DOTS-17 */
+#define XKB_KEY_braille_dots_27            0x1002842  /* U+2842 BRAILLE PATTERN DOTS-27 */
+#define XKB_KEY_braille_dots_127           0x1002843  /* U+2843 BRAILLE PATTERN DOTS-127 */
+#define XKB_KEY_braille_dots_37            0x1002844  /* U+2844 BRAILLE PATTERN DOTS-37 */
+#define XKB_KEY_braille_dots_137           0x1002845  /* U+2845 BRAILLE PATTERN DOTS-137 */
+#define XKB_KEY_braille_dots_237           0x1002846  /* U+2846 BRAILLE PATTERN DOTS-237 */
+#define XKB_KEY_braille_dots_1237          0x1002847  /* U+2847 BRAILLE PATTERN DOTS-1237 */
+#define XKB_KEY_braille_dots_47            0x1002848  /* U+2848 BRAILLE PATTERN DOTS-47 */
+#define XKB_KEY_braille_dots_147           0x1002849  /* U+2849 BRAILLE PATTERN DOTS-147 */
+#define XKB_KEY_braille_dots_247           0x100284a  /* U+284a BRAILLE PATTERN DOTS-247 */
+#define XKB_KEY_braille_dots_1247          0x100284b  /* U+284b BRAILLE PATTERN DOTS-1247 */
+#define XKB_KEY_braille_dots_347           0x100284c  /* U+284c BRAILLE PATTERN DOTS-347 */
+#define XKB_KEY_braille_dots_1347          0x100284d  /* U+284d BRAILLE PATTERN DOTS-1347 */
+#define XKB_KEY_braille_dots_2347          0x100284e  /* U+284e BRAILLE PATTERN DOTS-2347 */
+#define XKB_KEY_braille_dots_12347         0x100284f  /* U+284f BRAILLE PATTERN DOTS-12347 */
+#define XKB_KEY_braille_dots_57            0x1002850  /* U+2850 BRAILLE PATTERN DOTS-57 */
+#define XKB_KEY_braille_dots_157           0x1002851  /* U+2851 BRAILLE PATTERN DOTS-157 */
+#define XKB_KEY_braille_dots_257           0x1002852  /* U+2852 BRAILLE PATTERN DOTS-257 */
+#define XKB_KEY_braille_dots_1257          0x1002853  /* U+2853 BRAILLE PATTERN DOTS-1257 */
+#define XKB_KEY_braille_dots_357           0x1002854  /* U+2854 BRAILLE PATTERN DOTS-357 */
+#define XKB_KEY_braille_dots_1357          0x1002855  /* U+2855 BRAILLE PATTERN DOTS-1357 */
+#define XKB_KEY_braille_dots_2357          0x1002856  /* U+2856 BRAILLE PATTERN DOTS-2357 */
+#define XKB_KEY_braille_dots_12357         0x1002857  /* U+2857 BRAILLE PATTERN DOTS-12357 */
+#define XKB_KEY_braille_dots_457           0x1002858  /* U+2858 BRAILLE PATTERN DOTS-457 */
+#define XKB_KEY_braille_dots_1457          0x1002859  /* U+2859 BRAILLE PATTERN DOTS-1457 */
+#define XKB_KEY_braille_dots_2457          0x100285a  /* U+285a BRAILLE PATTERN DOTS-2457 */
+#define XKB_KEY_braille_dots_12457         0x100285b  /* U+285b BRAILLE PATTERN DOTS-12457 */
+#define XKB_KEY_braille_dots_3457          0x100285c  /* U+285c BRAILLE PATTERN DOTS-3457 */
+#define XKB_KEY_braille_dots_13457         0x100285d  /* U+285d BRAILLE PATTERN DOTS-13457 */
+#define XKB_KEY_braille_dots_23457         0x100285e  /* U+285e BRAILLE PATTERN DOTS-23457 */
+#define XKB_KEY_braille_dots_123457        0x100285f  /* U+285f BRAILLE PATTERN DOTS-123457 */
+#define XKB_KEY_braille_dots_67            0x1002860  /* U+2860 BRAILLE PATTERN DOTS-67 */
+#define XKB_KEY_braille_dots_167           0x1002861  /* U+2861 BRAILLE PATTERN DOTS-167 */
+#define XKB_KEY_braille_dots_267           0x1002862  /* U+2862 BRAILLE PATTERN DOTS-267 */
+#define XKB_KEY_braille_dots_1267          0x1002863  /* U+2863 BRAILLE PATTERN DOTS-1267 */
+#define XKB_KEY_braille_dots_367           0x1002864  /* U+2864 BRAILLE PATTERN DOTS-367 */
+#define XKB_KEY_braille_dots_1367          0x1002865  /* U+2865 BRAILLE PATTERN DOTS-1367 */
+#define XKB_KEY_braille_dots_2367          0x1002866  /* U+2866 BRAILLE PATTERN DOTS-2367 */
+#define XKB_KEY_braille_dots_12367         0x1002867  /* U+2867 BRAILLE PATTERN DOTS-12367 */
+#define XKB_KEY_braille_dots_467           0x1002868  /* U+2868 BRAILLE PATTERN DOTS-467 */
+#define XKB_KEY_braille_dots_1467          0x1002869  /* U+2869 BRAILLE PATTERN DOTS-1467 */
+#define XKB_KEY_braille_dots_2467          0x100286a  /* U+286a BRAILLE PATTERN DOTS-2467 */
+#define XKB_KEY_braille_dots_12467         0x100286b  /* U+286b BRAILLE PATTERN DOTS-12467 */
+#define XKB_KEY_braille_dots_3467          0x100286c  /* U+286c BRAILLE PATTERN DOTS-3467 */
+#define XKB_KEY_braille_dots_13467         0x100286d  /* U+286d BRAILLE PATTERN DOTS-13467 */
+#define XKB_KEY_braille_dots_23467         0x100286e  /* U+286e BRAILLE PATTERN DOTS-23467 */
+#define XKB_KEY_braille_dots_123467        0x100286f  /* U+286f BRAILLE PATTERN DOTS-123467 */
+#define XKB_KEY_braille_dots_567           0x1002870  /* U+2870 BRAILLE PATTERN DOTS-567 */
+#define XKB_KEY_braille_dots_1567          0x1002871  /* U+2871 BRAILLE PATTERN DOTS-1567 */
+#define XKB_KEY_braille_dots_2567          0x1002872  /* U+2872 BRAILLE PATTERN DOTS-2567 */
+#define XKB_KEY_braille_dots_12567         0x1002873  /* U+2873 BRAILLE PATTERN DOTS-12567 */
+#define XKB_KEY_braille_dots_3567          0x1002874  /* U+2874 BRAILLE PATTERN DOTS-3567 */
+#define XKB_KEY_braille_dots_13567         0x1002875  /* U+2875 BRAILLE PATTERN DOTS-13567 */
+#define XKB_KEY_braille_dots_23567         0x1002876  /* U+2876 BRAILLE PATTERN DOTS-23567 */
+#define XKB_KEY_braille_dots_123567        0x1002877  /* U+2877 BRAILLE PATTERN DOTS-123567 */
+#define XKB_KEY_braille_dots_4567          0x1002878  /* U+2878 BRAILLE PATTERN DOTS-4567 */
+#define XKB_KEY_braille_dots_14567         0x1002879  /* U+2879 BRAILLE PATTERN DOTS-14567 */
+#define XKB_KEY_braille_dots_24567         0x100287a  /* U+287a BRAILLE PATTERN DOTS-24567 */
+#define XKB_KEY_braille_dots_124567        0x100287b  /* U+287b BRAILLE PATTERN DOTS-124567 */
+#define XKB_KEY_braille_dots_34567         0x100287c  /* U+287c BRAILLE PATTERN DOTS-34567 */
+#define XKB_KEY_braille_dots_134567        0x100287d  /* U+287d BRAILLE PATTERN DOTS-134567 */
+#define XKB_KEY_braille_dots_234567        0x100287e  /* U+287e BRAILLE PATTERN DOTS-234567 */
+#define XKB_KEY_braille_dots_1234567       0x100287f  /* U+287f BRAILLE PATTERN DOTS-1234567 */
+#define XKB_KEY_braille_dots_8             0x1002880  /* U+2880 BRAILLE PATTERN DOTS-8 */
+#define XKB_KEY_braille_dots_18            0x1002881  /* U+2881 BRAILLE PATTERN DOTS-18 */
+#define XKB_KEY_braille_dots_28            0x1002882  /* U+2882 BRAILLE PATTERN DOTS-28 */
+#define XKB_KEY_braille_dots_128           0x1002883  /* U+2883 BRAILLE PATTERN DOTS-128 */
+#define XKB_KEY_braille_dots_38            0x1002884  /* U+2884 BRAILLE PATTERN DOTS-38 */
+#define XKB_KEY_braille_dots_138           0x1002885  /* U+2885 BRAILLE PATTERN DOTS-138 */
+#define XKB_KEY_braille_dots_238           0x1002886  /* U+2886 BRAILLE PATTERN DOTS-238 */
+#define XKB_KEY_braille_dots_1238          0x1002887  /* U+2887 BRAILLE PATTERN DOTS-1238 */
+#define XKB_KEY_braille_dots_48            0x1002888  /* U+2888 BRAILLE PATTERN DOTS-48 */
+#define XKB_KEY_braille_dots_148           0x1002889  /* U+2889 BRAILLE PATTERN DOTS-148 */
+#define XKB_KEY_braille_dots_248           0x100288a  /* U+288a BRAILLE PATTERN DOTS-248 */
+#define XKB_KEY_braille_dots_1248          0x100288b  /* U+288b BRAILLE PATTERN DOTS-1248 */
+#define XKB_KEY_braille_dots_348           0x100288c  /* U+288c BRAILLE PATTERN DOTS-348 */
+#define XKB_KEY_braille_dots_1348          0x100288d  /* U+288d BRAILLE PATTERN DOTS-1348 */
+#define XKB_KEY_braille_dots_2348          0x100288e  /* U+288e BRAILLE PATTERN DOTS-2348 */
+#define XKB_KEY_braille_dots_12348         0x100288f  /* U+288f BRAILLE PATTERN DOTS-12348 */
+#define XKB_KEY_braille_dots_58            0x1002890  /* U+2890 BRAILLE PATTERN DOTS-58 */
+#define XKB_KEY_braille_dots_158           0x1002891  /* U+2891 BRAILLE PATTERN DOTS-158 */
+#define XKB_KEY_braille_dots_258           0x1002892  /* U+2892 BRAILLE PATTERN DOTS-258 */
+#define XKB_KEY_braille_dots_1258          0x1002893  /* U+2893 BRAILLE PATTERN DOTS-1258 */
+#define XKB_KEY_braille_dots_358           0x1002894  /* U+2894 BRAILLE PATTERN DOTS-358 */
+#define XKB_KEY_braille_dots_1358          0x1002895  /* U+2895 BRAILLE PATTERN DOTS-1358 */
+#define XKB_KEY_braille_dots_2358          0x1002896  /* U+2896 BRAILLE PATTERN DOTS-2358 */
+#define XKB_KEY_braille_dots_12358         0x1002897  /* U+2897 BRAILLE PATTERN DOTS-12358 */
+#define XKB_KEY_braille_dots_458           0x1002898  /* U+2898 BRAILLE PATTERN DOTS-458 */
+#define XKB_KEY_braille_dots_1458          0x1002899  /* U+2899 BRAILLE PATTERN DOTS-1458 */
+#define XKB_KEY_braille_dots_2458          0x100289a  /* U+289a BRAILLE PATTERN DOTS-2458 */
+#define XKB_KEY_braille_dots_12458         0x100289b  /* U+289b BRAILLE PATTERN DOTS-12458 */
+#define XKB_KEY_braille_dots_3458          0x100289c  /* U+289c BRAILLE PATTERN DOTS-3458 */
+#define XKB_KEY_braille_dots_13458         0x100289d  /* U+289d BRAILLE PATTERN DOTS-13458 */
+#define XKB_KEY_braille_dots_23458         0x100289e  /* U+289e BRAILLE PATTERN DOTS-23458 */
+#define XKB_KEY_braille_dots_123458        0x100289f  /* U+289f BRAILLE PATTERN DOTS-123458 */
+#define XKB_KEY_braille_dots_68            0x10028a0  /* U+28a0 BRAILLE PATTERN DOTS-68 */
+#define XKB_KEY_braille_dots_168           0x10028a1  /* U+28a1 BRAILLE PATTERN DOTS-168 */
+#define XKB_KEY_braille_dots_268           0x10028a2  /* U+28a2 BRAILLE PATTERN DOTS-268 */
+#define XKB_KEY_braille_dots_1268          0x10028a3  /* U+28a3 BRAILLE PATTERN DOTS-1268 */
+#define XKB_KEY_braille_dots_368           0x10028a4  /* U+28a4 BRAILLE PATTERN DOTS-368 */
+#define XKB_KEY_braille_dots_1368          0x10028a5  /* U+28a5 BRAILLE PATTERN DOTS-1368 */
+#define XKB_KEY_braille_dots_2368          0x10028a6  /* U+28a6 BRAILLE PATTERN DOTS-2368 */
+#define XKB_KEY_braille_dots_12368         0x10028a7  /* U+28a7 BRAILLE PATTERN DOTS-12368 */
+#define XKB_KEY_braille_dots_468           0x10028a8  /* U+28a8 BRAILLE PATTERN DOTS-468 */
+#define XKB_KEY_braille_dots_1468          0x10028a9  /* U+28a9 BRAILLE PATTERN DOTS-1468 */
+#define XKB_KEY_braille_dots_2468          0x10028aa  /* U+28aa BRAILLE PATTERN DOTS-2468 */
+#define XKB_KEY_braille_dots_12468         0x10028ab  /* U+28ab BRAILLE PATTERN DOTS-12468 */
+#define XKB_KEY_braille_dots_3468          0x10028ac  /* U+28ac BRAILLE PATTERN DOTS-3468 */
+#define XKB_KEY_braille_dots_13468         0x10028ad  /* U+28ad BRAILLE PATTERN DOTS-13468 */
+#define XKB_KEY_braille_dots_23468         0x10028ae  /* U+28ae BRAILLE PATTERN DOTS-23468 */
+#define XKB_KEY_braille_dots_123468        0x10028af  /* U+28af BRAILLE PATTERN DOTS-123468 */
+#define XKB_KEY_braille_dots_568           0x10028b0  /* U+28b0 BRAILLE PATTERN DOTS-568 */
+#define XKB_KEY_braille_dots_1568          0x10028b1  /* U+28b1 BRAILLE PATTERN DOTS-1568 */
+#define XKB_KEY_braille_dots_2568          0x10028b2  /* U+28b2 BRAILLE PATTERN DOTS-2568 */
+#define XKB_KEY_braille_dots_12568         0x10028b3  /* U+28b3 BRAILLE PATTERN DOTS-12568 */
+#define XKB_KEY_braille_dots_3568          0x10028b4  /* U+28b4 BRAILLE PATTERN DOTS-3568 */
+#define XKB_KEY_braille_dots_13568         0x10028b5  /* U+28b5 BRAILLE PATTERN DOTS-13568 */
+#define XKB_KEY_braille_dots_23568         0x10028b6  /* U+28b6 BRAILLE PATTERN DOTS-23568 */
+#define XKB_KEY_braille_dots_123568        0x10028b7  /* U+28b7 BRAILLE PATTERN DOTS-123568 */
+#define XKB_KEY_braille_dots_4568          0x10028b8  /* U+28b8 BRAILLE PATTERN DOTS-4568 */
+#define XKB_KEY_braille_dots_14568         0x10028b9  /* U+28b9 BRAILLE PATTERN DOTS-14568 */
+#define XKB_KEY_braille_dots_24568         0x10028ba  /* U+28ba BRAILLE PATTERN DOTS-24568 */
+#define XKB_KEY_braille_dots_124568        0x10028bb  /* U+28bb BRAILLE PATTERN DOTS-124568 */
+#define XKB_KEY_braille_dots_34568         0x10028bc  /* U+28bc BRAILLE PATTERN DOTS-34568 */
+#define XKB_KEY_braille_dots_134568        0x10028bd  /* U+28bd BRAILLE PATTERN DOTS-134568 */
+#define XKB_KEY_braille_dots_234568        0x10028be  /* U+28be BRAILLE PATTERN DOTS-234568 */
+#define XKB_KEY_braille_dots_1234568       0x10028bf  /* U+28bf BRAILLE PATTERN DOTS-1234568 */
+#define XKB_KEY_braille_dots_78            0x10028c0  /* U+28c0 BRAILLE PATTERN DOTS-78 */
+#define XKB_KEY_braille_dots_178           0x10028c1  /* U+28c1 BRAILLE PATTERN DOTS-178 */
+#define XKB_KEY_braille_dots_278           0x10028c2  /* U+28c2 BRAILLE PATTERN DOTS-278 */
+#define XKB_KEY_braille_dots_1278          0x10028c3  /* U+28c3 BRAILLE PATTERN DOTS-1278 */
+#define XKB_KEY_braille_dots_378           0x10028c4  /* U+28c4 BRAILLE PATTERN DOTS-378 */
+#define XKB_KEY_braille_dots_1378          0x10028c5  /* U+28c5 BRAILLE PATTERN DOTS-1378 */
+#define XKB_KEY_braille_dots_2378          0x10028c6  /* U+28c6 BRAILLE PATTERN DOTS-2378 */
+#define XKB_KEY_braille_dots_12378         0x10028c7  /* U+28c7 BRAILLE PATTERN DOTS-12378 */
+#define XKB_KEY_braille_dots_478           0x10028c8  /* U+28c8 BRAILLE PATTERN DOTS-478 */
+#define XKB_KEY_braille_dots_1478          0x10028c9  /* U+28c9 BRAILLE PATTERN DOTS-1478 */
+#define XKB_KEY_braille_dots_2478          0x10028ca  /* U+28ca BRAILLE PATTERN DOTS-2478 */
+#define XKB_KEY_braille_dots_12478         0x10028cb  /* U+28cb BRAILLE PATTERN DOTS-12478 */
+#define XKB_KEY_braille_dots_3478          0x10028cc  /* U+28cc BRAILLE PATTERN DOTS-3478 */
+#define XKB_KEY_braille_dots_13478         0x10028cd  /* U+28cd BRAILLE PATTERN DOTS-13478 */
+#define XKB_KEY_braille_dots_23478         0x10028ce  /* U+28ce BRAILLE PATTERN DOTS-23478 */
+#define XKB_KEY_braille_dots_123478        0x10028cf  /* U+28cf BRAILLE PATTERN DOTS-123478 */
+#define XKB_KEY_braille_dots_578           0x10028d0  /* U+28d0 BRAILLE PATTERN DOTS-578 */
+#define XKB_KEY_braille_dots_1578          0x10028d1  /* U+28d1 BRAILLE PATTERN DOTS-1578 */
+#define XKB_KEY_braille_dots_2578          0x10028d2  /* U+28d2 BRAILLE PATTERN DOTS-2578 */
+#define XKB_KEY_braille_dots_12578         0x10028d3  /* U+28d3 BRAILLE PATTERN DOTS-12578 */
+#define XKB_KEY_braille_dots_3578          0x10028d4  /* U+28d4 BRAILLE PATTERN DOTS-3578 */
+#define XKB_KEY_braille_dots_13578         0x10028d5  /* U+28d5 BRAILLE PATTERN DOTS-13578 */
+#define XKB_KEY_braille_dots_23578         0x10028d6  /* U+28d6 BRAILLE PATTERN DOTS-23578 */
+#define XKB_KEY_braille_dots_123578        0x10028d7  /* U+28d7 BRAILLE PATTERN DOTS-123578 */
+#define XKB_KEY_braille_dots_4578          0x10028d8  /* U+28d8 BRAILLE PATTERN DOTS-4578 */
+#define XKB_KEY_braille_dots_14578         0x10028d9  /* U+28d9 BRAILLE PATTERN DOTS-14578 */
+#define XKB_KEY_braille_dots_24578         0x10028da  /* U+28da BRAILLE PATTERN DOTS-24578 */
+#define XKB_KEY_braille_dots_124578        0x10028db  /* U+28db BRAILLE PATTERN DOTS-124578 */
+#define XKB_KEY_braille_dots_34578         0x10028dc  /* U+28dc BRAILLE PATTERN DOTS-34578 */
+#define XKB_KEY_braille_dots_134578        0x10028dd  /* U+28dd BRAILLE PATTERN DOTS-134578 */
+#define XKB_KEY_braille_dots_234578        0x10028de  /* U+28de BRAILLE PATTERN DOTS-234578 */
+#define XKB_KEY_braille_dots_1234578       0x10028df  /* U+28df BRAILLE PATTERN DOTS-1234578 */
+#define XKB_KEY_braille_dots_678           0x10028e0  /* U+28e0 BRAILLE PATTERN DOTS-678 */
+#define XKB_KEY_braille_dots_1678          0x10028e1  /* U+28e1 BRAILLE PATTERN DOTS-1678 */
+#define XKB_KEY_braille_dots_2678          0x10028e2  /* U+28e2 BRAILLE PATTERN DOTS-2678 */
+#define XKB_KEY_braille_dots_12678         0x10028e3  /* U+28e3 BRAILLE PATTERN DOTS-12678 */
+#define XKB_KEY_braille_dots_3678          0x10028e4  /* U+28e4 BRAILLE PATTERN DOTS-3678 */
+#define XKB_KEY_braille_dots_13678         0x10028e5  /* U+28e5 BRAILLE PATTERN DOTS-13678 */
+#define XKB_KEY_braille_dots_23678         0x10028e6  /* U+28e6 BRAILLE PATTERN DOTS-23678 */
+#define XKB_KEY_braille_dots_123678        0x10028e7  /* U+28e7 BRAILLE PATTERN DOTS-123678 */
+#define XKB_KEY_braille_dots_4678          0x10028e8  /* U+28e8 BRAILLE PATTERN DOTS-4678 */
+#define XKB_KEY_braille_dots_14678         0x10028e9  /* U+28e9 BRAILLE PATTERN DOTS-14678 */
+#define XKB_KEY_braille_dots_24678         0x10028ea  /* U+28ea BRAILLE PATTERN DOTS-24678 */
+#define XKB_KEY_braille_dots_124678        0x10028eb  /* U+28eb BRAILLE PATTERN DOTS-124678 */
+#define XKB_KEY_braille_dots_34678         0x10028ec  /* U+28ec BRAILLE PATTERN DOTS-34678 */
+#define XKB_KEY_braille_dots_134678        0x10028ed  /* U+28ed BRAILLE PATTERN DOTS-134678 */
+#define XKB_KEY_braille_dots_234678        0x10028ee  /* U+28ee BRAILLE PATTERN DOTS-234678 */
+#define XKB_KEY_braille_dots_1234678       0x10028ef  /* U+28ef BRAILLE PATTERN DOTS-1234678 */
+#define XKB_KEY_braille_dots_5678          0x10028f0  /* U+28f0 BRAILLE PATTERN DOTS-5678 */
+#define XKB_KEY_braille_dots_15678         0x10028f1  /* U+28f1 BRAILLE PATTERN DOTS-15678 */
+#define XKB_KEY_braille_dots_25678         0x10028f2  /* U+28f2 BRAILLE PATTERN DOTS-25678 */
+#define XKB_KEY_braille_dots_125678        0x10028f3  /* U+28f3 BRAILLE PATTERN DOTS-125678 */
+#define XKB_KEY_braille_dots_35678         0x10028f4  /* U+28f4 BRAILLE PATTERN DOTS-35678 */
+#define XKB_KEY_braille_dots_135678        0x10028f5  /* U+28f5 BRAILLE PATTERN DOTS-135678 */
+#define XKB_KEY_braille_dots_235678        0x10028f6  /* U+28f6 BRAILLE PATTERN DOTS-235678 */
+#define XKB_KEY_braille_dots_1235678       0x10028f7  /* U+28f7 BRAILLE PATTERN DOTS-1235678 */
+#define XKB_KEY_braille_dots_45678         0x10028f8  /* U+28f8 BRAILLE PATTERN DOTS-45678 */
+#define XKB_KEY_braille_dots_145678        0x10028f9  /* U+28f9 BRAILLE PATTERN DOTS-145678 */
+#define XKB_KEY_braille_dots_245678        0x10028fa  /* U+28fa BRAILLE PATTERN DOTS-245678 */
+#define XKB_KEY_braille_dots_1245678       0x10028fb  /* U+28fb BRAILLE PATTERN DOTS-1245678 */
+#define XKB_KEY_braille_dots_345678        0x10028fc  /* U+28fc BRAILLE PATTERN DOTS-345678 */
+#define XKB_KEY_braille_dots_1345678       0x10028fd  /* U+28fd BRAILLE PATTERN DOTS-1345678 */
+#define XKB_KEY_braille_dots_2345678       0x10028fe  /* U+28fe BRAILLE PATTERN DOTS-2345678 */
+#define XKB_KEY_braille_dots_12345678      0x10028ff  /* U+28ff BRAILLE PATTERN DOTS-12345678 */
+
+/*
+ * Sinhala (http://unicode.org/charts/PDF/U0D80.pdf)
+ * http://www.nongnu.org/sinhala/doc/transliteration/sinhala-transliteration_6.html
+ */
+
+#define XKB_KEY_Sinh_ng            0x1000d82  /* U+0D82 SINHALA ANUSVARAYA */
+#define XKB_KEY_Sinh_h2            0x1000d83  /* U+0D83 SINHALA VISARGAYA */
+#define XKB_KEY_Sinh_a             0x1000d85  /* U+0D85 SINHALA AYANNA */
+#define XKB_KEY_Sinh_aa            0x1000d86  /* U+0D86 SINHALA AAYANNA */
+#define XKB_KEY_Sinh_ae            0x1000d87  /* U+0D87 SINHALA AEYANNA */
+#define XKB_KEY_Sinh_aee           0x1000d88  /* U+0D88 SINHALA AEEYANNA */
+#define XKB_KEY_Sinh_i             0x1000d89  /* U+0D89 SINHALA IYANNA */
+#define XKB_KEY_Sinh_ii            0x1000d8a  /* U+0D8A SINHALA IIYANNA */
+#define XKB_KEY_Sinh_u             0x1000d8b  /* U+0D8B SINHALA UYANNA */
+#define XKB_KEY_Sinh_uu            0x1000d8c  /* U+0D8C SINHALA UUYANNA */
+#define XKB_KEY_Sinh_ri            0x1000d8d  /* U+0D8D SINHALA IRUYANNA */
+#define XKB_KEY_Sinh_rii           0x1000d8e  /* U+0D8E SINHALA IRUUYANNA */
+#define XKB_KEY_Sinh_lu            0x1000d8f  /* U+0D8F SINHALA ILUYANNA */
+#define XKB_KEY_Sinh_luu           0x1000d90  /* U+0D90 SINHALA ILUUYANNA */
+#define XKB_KEY_Sinh_e             0x1000d91  /* U+0D91 SINHALA EYANNA */
+#define XKB_KEY_Sinh_ee            0x1000d92  /* U+0D92 SINHALA EEYANNA */
+#define XKB_KEY_Sinh_ai            0x1000d93  /* U+0D93 SINHALA AIYANNA */
+#define XKB_KEY_Sinh_o             0x1000d94  /* U+0D94 SINHALA OYANNA */
+#define XKB_KEY_Sinh_oo            0x1000d95  /* U+0D95 SINHALA OOYANNA */
+#define XKB_KEY_Sinh_au            0x1000d96  /* U+0D96 SINHALA AUYANNA */
+#define XKB_KEY_Sinh_ka            0x1000d9a  /* U+0D9A SINHALA KAYANNA */
+#define XKB_KEY_Sinh_kha           0x1000d9b  /* U+0D9B SINHALA MAHA. KAYANNA */
+#define XKB_KEY_Sinh_ga            0x1000d9c  /* U+0D9C SINHALA GAYANNA */
+#define XKB_KEY_Sinh_gha           0x1000d9d  /* U+0D9D SINHALA MAHA. GAYANNA */
+#define XKB_KEY_Sinh_ng2           0x1000d9e  /* U+0D9E SINHALA KANTAJA NAASIKYAYA */
+#define XKB_KEY_Sinh_nga           0x1000d9f  /* U+0D9F SINHALA SANYAKA GAYANNA */
+#define XKB_KEY_Sinh_ca            0x1000da0  /* U+0DA0 SINHALA CAYANNA */
+#define XKB_KEY_Sinh_cha           0x1000da1  /* U+0DA1 SINHALA MAHA. CAYANNA */
+#define XKB_KEY_Sinh_ja            0x1000da2  /* U+0DA2 SINHALA JAYANNA */
+#define XKB_KEY_Sinh_jha           0x1000da3  /* U+0DA3 SINHALA MAHA. JAYANNA */
+#define XKB_KEY_Sinh_nya           0x1000da4  /* U+0DA4 SINHALA TAALUJA NAASIKYAYA */
+#define XKB_KEY_Sinh_jnya          0x1000da5  /* U+0DA5 SINHALA TAALUJA SANYOOGA NAASIKYAYA */
+#define XKB_KEY_Sinh_nja           0x1000da6  /* U+0DA6 SINHALA SANYAKA JAYANNA */
+#define XKB_KEY_Sinh_tta           0x1000da7  /* U+0DA7 SINHALA TTAYANNA */
+#define XKB_KEY_Sinh_ttha          0x1000da8  /* U+0DA8 SINHALA MAHA. TTAYANNA */
+#define XKB_KEY_Sinh_dda           0x1000da9  /* U+0DA9 SINHALA DDAYANNA */
+#define XKB_KEY_Sinh_ddha          0x1000daa  /* U+0DAA SINHALA MAHA. DDAYANNA */
+#define XKB_KEY_Sinh_nna           0x1000dab  /* U+0DAB SINHALA MUURDHAJA NAYANNA */
+#define XKB_KEY_Sinh_ndda          0x1000dac  /* U+0DAC SINHALA SANYAKA DDAYANNA */
+#define XKB_KEY_Sinh_tha           0x1000dad  /* U+0DAD SINHALA TAYANNA */
+#define XKB_KEY_Sinh_thha          0x1000dae  /* U+0DAE SINHALA MAHA. TAYANNA */
+#define XKB_KEY_Sinh_dha           0x1000daf  /* U+0DAF SINHALA DAYANNA */
+#define XKB_KEY_Sinh_dhha          0x1000db0  /* U+0DB0 SINHALA MAHA. DAYANNA */
+#define XKB_KEY_Sinh_na            0x1000db1  /* U+0DB1 SINHALA DANTAJA NAYANNA */
+#define XKB_KEY_Sinh_ndha          0x1000db3  /* U+0DB3 SINHALA SANYAKA DAYANNA */
+#define XKB_KEY_Sinh_pa            0x1000db4  /* U+0DB4 SINHALA PAYANNA */
+#define XKB_KEY_Sinh_pha           0x1000db5  /* U+0DB5 SINHALA MAHA. PAYANNA */
+#define XKB_KEY_Sinh_ba            0x1000db6  /* U+0DB6 SINHALA BAYANNA */
+#define XKB_KEY_Sinh_bha           0x1000db7  /* U+0DB7 SINHALA MAHA. BAYANNA */
+#define XKB_KEY_Sinh_ma            0x1000db8  /* U+0DB8 SINHALA MAYANNA */
+#define XKB_KEY_Sinh_mba           0x1000db9  /* U+0DB9 SINHALA AMBA BAYANNA */
+#define XKB_KEY_Sinh_ya            0x1000dba  /* U+0DBA SINHALA YAYANNA */
+#define XKB_KEY_Sinh_ra            0x1000dbb  /* U+0DBB SINHALA RAYANNA */
+#define XKB_KEY_Sinh_la            0x1000dbd  /* U+0DBD SINHALA DANTAJA LAYANNA */
+#define XKB_KEY_Sinh_va            0x1000dc0  /* U+0DC0 SINHALA VAYANNA */
+#define XKB_KEY_Sinh_sha           0x1000dc1  /* U+0DC1 SINHALA TAALUJA SAYANNA */
+#define XKB_KEY_Sinh_ssha          0x1000dc2  /* U+0DC2 SINHALA MUURDHAJA SAYANNA */
+#define XKB_KEY_Sinh_sa            0x1000dc3  /* U+0DC3 SINHALA DANTAJA SAYANNA */
+#define XKB_KEY_Sinh_ha            0x1000dc4  /* U+0DC4 SINHALA HAYANNA */
+#define XKB_KEY_Sinh_lla           0x1000dc5  /* U+0DC5 SINHALA MUURDHAJA LAYANNA */
+#define XKB_KEY_Sinh_fa            0x1000dc6  /* U+0DC6 SINHALA FAYANNA */
+#define XKB_KEY_Sinh_al            0x1000dca  /* U+0DCA SINHALA AL-LAKUNA */
+#define XKB_KEY_Sinh_aa2           0x1000dcf  /* U+0DCF SINHALA AELA-PILLA */
+#define XKB_KEY_Sinh_ae2           0x1000dd0  /* U+0DD0 SINHALA AEDA-PILLA */
+#define XKB_KEY_Sinh_aee2          0x1000dd1  /* U+0DD1 SINHALA DIGA AEDA-PILLA */
+#define XKB_KEY_Sinh_i2            0x1000dd2  /* U+0DD2 SINHALA IS-PILLA */
+#define XKB_KEY_Sinh_ii2           0x1000dd3  /* U+0DD3 SINHALA DIGA IS-PILLA */
+#define XKB_KEY_Sinh_u2            0x1000dd4  /* U+0DD4 SINHALA PAA-PILLA */
+#define XKB_KEY_Sinh_uu2           0x1000dd6  /* U+0DD6 SINHALA DIGA PAA-PILLA */
+#define XKB_KEY_Sinh_ru2           0x1000dd8  /* U+0DD8 SINHALA GAETTA-PILLA */
+#define XKB_KEY_Sinh_e2            0x1000dd9  /* U+0DD9 SINHALA KOMBUVA */
+#define XKB_KEY_Sinh_ee2           0x1000dda  /* U+0DDA SINHALA DIGA KOMBUVA */
+#define XKB_KEY_Sinh_ai2           0x1000ddb  /* U+0DDB SINHALA KOMBU DEKA */
+#define XKB_KEY_Sinh_o2            0x1000ddc  /* U+0DDC SINHALA KOMBUVA HAA AELA-PILLA*/
+#define XKB_KEY_Sinh_oo2           0x1000ddd  /* U+0DDD SINHALA KOMBUVA HAA DIGA AELA-PILLA*/
+#define XKB_KEY_Sinh_au2           0x1000dde  /* U+0DDE SINHALA KOMBUVA HAA GAYANUKITTA */
+#define XKB_KEY_Sinh_lu2           0x1000ddf  /* U+0DDF SINHALA GAYANUKITTA */
+#define XKB_KEY_Sinh_ruu2          0x1000df2  /* U+0DF2 SINHALA DIGA GAETTA-PILLA */
+#define XKB_KEY_Sinh_luu2          0x1000df3  /* U+0DF3 SINHALA DIGA GAYANUKITTA */
+#define XKB_KEY_Sinh_kunddaliya    0x1000df4  /* U+0DF4 SINHALA KUNDDALIYA */
+/*
+ * XFree86 vendor specific keysyms.
+ *
+ * The XFree86 keysym range is 0x10080001 - 0x1008FFFF.
+ *
+ * When adding new entries, the xc/lib/XKeysymDB file should also be
+ * updated to make the new entries visible to Xlib.
+ */
+
+/*
+ * ModeLock
+ *
+ * This one is old, and not really used any more since XKB offers this
+ * functionality.
+ */
+
+#define XKB_KEY_XF86ModeLock   0x1008FF01  /* Mode Switch Lock */
+
+/*
+ * Note, 0x1008FF07 - 0x1008FF0F are free and should be used for misc new
+ * keysyms that don't fit into any of the groups below.
+ *
+ * 0x1008FF64, 0x1008FF6F, 0x1008FF71, 0x1008FF83 are no longer used,
+ * and should be used first for new keysyms.
+ *
+ * Check in keysymdef.h for generic symbols before adding new XFree86-specific
+ * symbols here.
+ *
+ * X.Org will not be adding to the XF86 set of keysyms, though they have
+ * been adopted and are considered a "standard" part of X keysym definitions.
+ * XFree86 never properly commented these keysyms, so we have done our
+ * best to explain the semantic meaning of these keys.
+ *
+ * XFree86 has removed their mail archives of the period, that might have
+ * shed more light on some of these definitions. Until/unless we resurrect
+ * these archives, these are from memory and usage.
+ */
+
+
+/* Backlight controls. */
+#define XKB_KEY_XF86MonBrightnessUp   0x1008FF02  /* Monitor/panel brightness */
+#define XKB_KEY_XF86MonBrightnessDown 0x1008FF03  /* Monitor/panel brightness */
+#define XKB_KEY_XF86KbdLightOnOff     0x1008FF04  /* Keyboards may be lit     */
+#define XKB_KEY_XF86KbdBrightnessUp   0x1008FF05  /* Keyboards may be lit     */
+#define XKB_KEY_XF86KbdBrightnessDown 0x1008FF06  /* Keyboards may be lit     */
+
+/*
+ * Keys found on some "Internet" keyboards.
+ */
+#define XKB_KEY_XF86Standby    0x1008FF10   /* System into standby mode   */
+#define XKB_KEY_XF86AudioLowerVolume 0x1008FF11   /* Volume control down        */
+#define XKB_KEY_XF86AudioMute  0x1008FF12   /* Mute sound from the system */
+#define XKB_KEY_XF86AudioRaiseVolume 0x1008FF13   /* Volume control up          */
+#define XKB_KEY_XF86AudioPlay  0x1008FF14   /* Start playing of audio >   */
+#define XKB_KEY_XF86AudioStop  0x1008FF15   /* Stop playing audio         */
+#define XKB_KEY_XF86AudioPrev  0x1008FF16   /* Previous track             */
+#define XKB_KEY_XF86AudioNext  0x1008FF17   /* Next track                 */
+#define XKB_KEY_XF86HomePage   0x1008FF18   /* Display user's home page   */
+#define XKB_KEY_XF86Mail   0x1008FF19   /* Invoke user's mail program */
+#define XKB_KEY_XF86Start    0x1008FF1A   /* Start application          */
+#define XKB_KEY_XF86Search   0x1008FF1B   /* Search                     */
+#define XKB_KEY_XF86AudioRecord  0x1008FF1C   /* Record audio application   */
+
+/* These are sometimes found on PDA's (e.g. Palm, PocketPC or elsewhere)   */
+#define XKB_KEY_XF86Calculator 0x1008FF1D   /* Invoke calculator program  */
+#define XKB_KEY_XF86Memo   0x1008FF1E   /* Invoke Memo taking program */
+#define XKB_KEY_XF86ToDoList   0x1008FF1F   /* Invoke To Do List program  */
+#define XKB_KEY_XF86Calendar   0x1008FF20   /* Invoke Calendar program    */
+#define XKB_KEY_XF86PowerDown  0x1008FF21   /* Deep sleep the system      */
+#define XKB_KEY_XF86ContrastAdjust 0x1008FF22   /* Adjust screen contrast     */
+#define XKB_KEY_XF86RockerUp   0x1008FF23   /* Rocker switches exist up   */
+#define XKB_KEY_XF86RockerDown 0x1008FF24   /* and down                   */
+#define XKB_KEY_XF86RockerEnter  0x1008FF25   /* and let you press them     */
+
+/* Some more "Internet" keyboard symbols */
+#define XKB_KEY_XF86Back   0x1008FF26   /* Like back on a browser     */
+#define XKB_KEY_XF86Forward    0x1008FF27   /* Like forward on a browser  */
+#define XKB_KEY_XF86Stop   0x1008FF28   /* Stop current operation     */
+#define XKB_KEY_XF86Refresh    0x1008FF29   /* Refresh the page           */
+#define XKB_KEY_XF86PowerOff   0x1008FF2A   /* Power off system entirely  */
+#define XKB_KEY_XF86WakeUp   0x1008FF2B   /* Wake up system from sleep  */
+#define XKB_KEY_XF86Eject            0x1008FF2C   /* Eject device (e.g. DVD)    */
+#define XKB_KEY_XF86ScreenSaver      0x1008FF2D   /* Invoke screensaver         */
+#define XKB_KEY_XF86WWW              0x1008FF2E   /* Invoke web browser         */
+#define XKB_KEY_XF86Sleep            0x1008FF2F   /* Put system to sleep        */
+#define XKB_KEY_XF86Favorites  0x1008FF30   /* Show favorite locations    */
+#define XKB_KEY_XF86AudioPause 0x1008FF31   /* Pause audio playing        */
+#define XKB_KEY_XF86AudioMedia 0x1008FF32   /* Launch media collection app */
+#define XKB_KEY_XF86MyComputer 0x1008FF33   /* Display "My Computer" window */
+#define XKB_KEY_XF86VendorHome 0x1008FF34   /* Display vendor home web site */
+#define XKB_KEY_XF86LightBulb  0x1008FF35   /* Light bulb keys exist       */
+#define XKB_KEY_XF86Shop   0x1008FF36   /* Display shopping web site   */
+#define XKB_KEY_XF86History    0x1008FF37   /* Show history of web surfing */
+#define XKB_KEY_XF86OpenURL    0x1008FF38   /* Open selected URL           */
+#define XKB_KEY_XF86AddFavorite  0x1008FF39   /* Add URL to favorites list   */
+#define XKB_KEY_XF86HotLinks   0x1008FF3A   /* Show "hot" links            */
+#define XKB_KEY_XF86BrightnessAdjust 0x1008FF3B   /* Invoke brightness adj. UI   */
+#define XKB_KEY_XF86Finance    0x1008FF3C   /* Display financial site      */
+#define XKB_KEY_XF86Community  0x1008FF3D   /* Display user's community    */
+#define XKB_KEY_XF86AudioRewind  0x1008FF3E   /* "rewind" audio track        */
+#define XKB_KEY_XF86BackForward  0x1008FF3F   /* ??? */
+#define XKB_KEY_XF86Launch0    0x1008FF40   /* Launch Application          */
+#define XKB_KEY_XF86Launch1    0x1008FF41   /* Launch Application          */
+#define XKB_KEY_XF86Launch2    0x1008FF42   /* Launch Application          */
+#define XKB_KEY_XF86Launch3    0x1008FF43   /* Launch Application          */
+#define XKB_KEY_XF86Launch4    0x1008FF44   /* Launch Application          */
+#define XKB_KEY_XF86Launch5    0x1008FF45   /* Launch Application          */
+#define XKB_KEY_XF86Launch6    0x1008FF46   /* Launch Application          */
+#define XKB_KEY_XF86Launch7    0x1008FF47   /* Launch Application          */
+#define XKB_KEY_XF86Launch8    0x1008FF48   /* Launch Application          */
+#define XKB_KEY_XF86Launch9    0x1008FF49   /* Launch Application          */
+#define XKB_KEY_XF86LaunchA    0x1008FF4A   /* Launch Application          */
+#define XKB_KEY_XF86LaunchB    0x1008FF4B   /* Launch Application          */
+#define XKB_KEY_XF86LaunchC    0x1008FF4C   /* Launch Application          */
+#define XKB_KEY_XF86LaunchD    0x1008FF4D   /* Launch Application          */
+#define XKB_KEY_XF86LaunchE    0x1008FF4E   /* Launch Application          */
+#define XKB_KEY_XF86LaunchF    0x1008FF4F   /* Launch Application          */
+
+#define XKB_KEY_XF86ApplicationLeft  0x1008FF50   /* switch to application, left */
+#define XKB_KEY_XF86ApplicationRight 0x1008FF51   /* switch to application, right*/
+#define XKB_KEY_XF86Book   0x1008FF52   /* Launch bookreader           */
+#define XKB_KEY_XF86CD   0x1008FF53   /* Launch CD/DVD player        */
+#define XKB_KEY_XF86Calculater 0x1008FF54   /* Launch Calculater           */
+#define XKB_KEY_XF86Clear    0x1008FF55   /* Clear window, screen        */
+#define XKB_KEY_XF86Close    0x1008FF56   /* Close window                */
+#define XKB_KEY_XF86Copy   0x1008FF57   /* Copy selection              */
+#define XKB_KEY_XF86Cut    0x1008FF58   /* Cut selection               */
+#define XKB_KEY_XF86Display    0x1008FF59   /* Output switch key           */
+#define XKB_KEY_XF86DOS    0x1008FF5A   /* Launch DOS (emulation)      */
+#define XKB_KEY_XF86Documents  0x1008FF5B   /* Open documents window       */
+#define XKB_KEY_XF86Excel    0x1008FF5C   /* Launch spread sheet         */
+#define XKB_KEY_XF86Explorer   0x1008FF5D   /* Launch file explorer        */
+#define XKB_KEY_XF86Game   0x1008FF5E   /* Launch game                 */
+#define XKB_KEY_XF86Go   0x1008FF5F   /* Go to URL                   */
+#define XKB_KEY_XF86iTouch   0x1008FF60   /* Logitch iTouch- don't use   */
+#define XKB_KEY_XF86LogOff   0x1008FF61   /* Log off system              */
+#define XKB_KEY_XF86Market   0x1008FF62   /* ??                          */
+#define XKB_KEY_XF86Meeting    0x1008FF63   /* enter meeting in calendar   */
+#define XKB_KEY_XF86MenuKB   0x1008FF65   /* distingush keyboard from PB */
+#define XKB_KEY_XF86MenuPB   0x1008FF66   /* distinuish PB from keyboard */
+#define XKB_KEY_XF86MySites    0x1008FF67   /* Favourites                  */
+#define XKB_KEY_XF86New    0x1008FF68   /* New (folder, document...    */
+#define XKB_KEY_XF86News   0x1008FF69   /* News                        */
+#define XKB_KEY_XF86OfficeHome 0x1008FF6A   /* Office home (old Staroffice)*/
+#define XKB_KEY_XF86Open   0x1008FF6B   /* Open                        */
+#define XKB_KEY_XF86Option   0x1008FF6C   /* ?? */
+#define XKB_KEY_XF86Paste    0x1008FF6D   /* Paste                       */
+#define XKB_KEY_XF86Phone    0x1008FF6E   /* Launch phone; dial number   */
+#define XKB_KEY_XF86Q    0x1008FF70   /* Compaq's Q - don't use      */
+#define XKB_KEY_XF86Reply    0x1008FF72   /* Reply e.g., mail            */
+#define XKB_KEY_XF86Reload   0x1008FF73   /* Reload web page, file, etc. */
+#define XKB_KEY_XF86RotateWindows  0x1008FF74   /* Rotate windows e.g. xrandr  */
+#define XKB_KEY_XF86RotationPB 0x1008FF75   /* don't use                   */
+#define XKB_KEY_XF86RotationKB 0x1008FF76   /* don't use                   */
+#define XKB_KEY_XF86Save   0x1008FF77   /* Save (file, document, state */
+#define XKB_KEY_XF86ScrollUp   0x1008FF78   /* Scroll window/contents up   */
+#define XKB_KEY_XF86ScrollDown 0x1008FF79   /* Scrool window/contentd down */
+#define XKB_KEY_XF86ScrollClick  0x1008FF7A   /* Use XKB mousekeys instead   */
+#define XKB_KEY_XF86Send   0x1008FF7B   /* Send mail, file, object     */
+#define XKB_KEY_XF86Spell    0x1008FF7C   /* Spell checker               */
+#define XKB_KEY_XF86SplitScreen  0x1008FF7D   /* Split window or screen      */
+#define XKB_KEY_XF86Support    0x1008FF7E   /* Get support (??)            */
+#define XKB_KEY_XF86TaskPane   0x1008FF7F   /* Show tasks */
+#define XKB_KEY_XF86Terminal   0x1008FF80   /* Launch terminal emulator    */
+#define XKB_KEY_XF86Tools    0x1008FF81   /* toolbox of desktop/app.     */
+#define XKB_KEY_XF86Travel   0x1008FF82   /* ?? */
+#define XKB_KEY_XF86UserPB   0x1008FF84   /* ?? */
+#define XKB_KEY_XF86User1KB    0x1008FF85   /* ?? */
+#define XKB_KEY_XF86User2KB    0x1008FF86   /* ?? */
+#define XKB_KEY_XF86Video    0x1008FF87   /* Launch video player       */
+#define XKB_KEY_XF86WheelButton  0x1008FF88   /* button from a mouse wheel */
+#define XKB_KEY_XF86Word   0x1008FF89   /* Launch word processor     */
+#define XKB_KEY_XF86Xfer   0x1008FF8A
+#define XKB_KEY_XF86ZoomIn   0x1008FF8B   /* zoom in view, map, etc.   */
+#define XKB_KEY_XF86ZoomOut    0x1008FF8C   /* zoom out view, map, etc.  */
+
+#define XKB_KEY_XF86Away   0x1008FF8D   /* mark yourself as away     */
+#define XKB_KEY_XF86Messenger  0x1008FF8E   /* as in instant messaging   */
+#define XKB_KEY_XF86WebCam   0x1008FF8F   /* Launch web camera app.    */
+#define XKB_KEY_XF86MailForward  0x1008FF90   /* Forward in mail           */
+#define XKB_KEY_XF86Pictures   0x1008FF91   /* Show pictures             */
+#define XKB_KEY_XF86Music    0x1008FF92   /* Launch music application  */
+
+#define XKB_KEY_XF86Battery    0x1008FF93   /* Display battery information */
+#define XKB_KEY_XF86Bluetooth  0x1008FF94   /* Enable/disable Bluetooth    */
+#define XKB_KEY_XF86WLAN   0x1008FF95   /* Enable/disable WLAN         */
+#define XKB_KEY_XF86UWB    0x1008FF96   /* Enable/disable UWB      */
+
+#define XKB_KEY_XF86AudioForward 0x1008FF97   /* fast-forward audio track    */
+#define XKB_KEY_XF86AudioRepeat  0x1008FF98   /* toggle repeat mode          */
+#define XKB_KEY_XF86AudioRandomPlay  0x1008FF99   /* toggle shuffle mode         */
+#define XKB_KEY_XF86Subtitle   0x1008FF9A   /* cycle through subtitle      */
+#define XKB_KEY_XF86AudioCycleTrack  0x1008FF9B   /* cycle through audio tracks  */
+#define XKB_KEY_XF86CycleAngle 0x1008FF9C   /* cycle through angles        */
+#define XKB_KEY_XF86FrameBack  0x1008FF9D   /* video: go one frame back    */
+#define XKB_KEY_XF86FrameForward 0x1008FF9E   /* video: go one frame forward */
+#define XKB_KEY_XF86Time   0x1008FF9F   /* display, or shows an entry for time seeking */
+#define XKB_KEY_XF86Select   0x1008FFA0   /* Select button on joypads and remotes */
+#define XKB_KEY_XF86View   0x1008FFA1   /* Show a view options/properties */
+#define XKB_KEY_XF86TopMenu    0x1008FFA2   /* Go to a top-level menu in a video */
+
+#define XKB_KEY_XF86Red    0x1008FFA3   /* Red button                  */
+#define XKB_KEY_XF86Green    0x1008FFA4   /* Green button                */
+#define XKB_KEY_XF86Yellow   0x1008FFA5   /* Yellow button               */
+#define XKB_KEY_XF86Blue             0x1008FFA6   /* Blue button                 */
+
+#define XKB_KEY_XF86Suspend    0x1008FFA7   /* Sleep to RAM                */
+#define XKB_KEY_XF86Hibernate  0x1008FFA8   /* Sleep to disk               */
+#define XKB_KEY_XF86TouchpadToggle 0x1008FFA9   /* Toggle between touchpad/trackstick */
+#define XKB_KEY_XF86TouchpadOn 0x1008FFB0   /* The touchpad got switched on */
+#define XKB_KEY_XF86TouchpadOff  0x1008FFB1   /* The touchpad got switched off */
+
+#define XKB_KEY_XF86AudioMicMute 0x1008FFB2   /* Mute the Mic from the system */
+
+/* Keys for special action keys (hot keys) */
+/* Virtual terminals on some operating systems */
+#define XKB_KEY_XF86Switch_VT_1  0x1008FE01
+#define XKB_KEY_XF86Switch_VT_2  0x1008FE02
+#define XKB_KEY_XF86Switch_VT_3  0x1008FE03
+#define XKB_KEY_XF86Switch_VT_4  0x1008FE04
+#define XKB_KEY_XF86Switch_VT_5  0x1008FE05
+#define XKB_KEY_XF86Switch_VT_6  0x1008FE06
+#define XKB_KEY_XF86Switch_VT_7  0x1008FE07
+#define XKB_KEY_XF86Switch_VT_8  0x1008FE08
+#define XKB_KEY_XF86Switch_VT_9  0x1008FE09
+#define XKB_KEY_XF86Switch_VT_10 0x1008FE0A
+#define XKB_KEY_XF86Switch_VT_11 0x1008FE0B
+#define XKB_KEY_XF86Switch_VT_12 0x1008FE0C
+
+#define XKB_KEY_XF86Ungrab   0x1008FE20   /* force ungrab               */
+#define XKB_KEY_XF86ClearGrab  0x1008FE21   /* kill application with grab */
+#define XKB_KEY_XF86Next_VMode 0x1008FE22   /* next video mode available  */
+#define XKB_KEY_XF86Prev_VMode 0x1008FE23   /* prev. video mode available */
+#define XKB_KEY_XF86LogWindowTree  0x1008FE24   /* print window tree to log   */
+#define XKB_KEY_XF86LogGrabInfo  0x1008FE25   /* print all active grabs to log */
+/*
+ * Copyright (c) 1991, Oracle and/or its affiliates. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+/************************************************************
+
+Copyright 1991, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+***********************************************************/
+
+/*
+ * Floating Accent
+ */
+
+#define XKB_KEY_SunFA_Grave    0x1005FF00
+#define XKB_KEY_SunFA_Circum   0x1005FF01
+#define XKB_KEY_SunFA_Tilde    0x1005FF02
+#define XKB_KEY_SunFA_Acute    0x1005FF03
+#define XKB_KEY_SunFA_Diaeresis  0x1005FF04
+#define XKB_KEY_SunFA_Cedilla  0x1005FF05
+
+/*
+ * Miscellaneous Functions
+ */
+
+#define XKB_KEY_SunF36   0x1005FF10  /* Labeled F11 */
+#define XKB_KEY_SunF37   0x1005FF11  /* Labeled F12 */
+
+#define XKB_KEY_SunSys_Req     0x1005FF60
+#define XKB_KEY_SunPrint_Screen  0x0000FF61  /* Same as XK_Print */
+
+/*
+ * International & Multi-Key Character Composition
+ */
+
+#define XKB_KEY_SunCompose   0x0000FF20  /* Same as XK_Multi_key */
+#define XKB_KEY_SunAltGraph    0x0000FF7E  /* Same as XK_Mode_switch */
+
+/*
+ * Cursor Control
+ */
+
+#define XKB_KEY_SunPageUp    0x0000FF55  /* Same as XK_Prior */
+#define XKB_KEY_SunPageDown    0x0000FF56  /* Same as XK_Next */
+
+/*
+ * Open Look Functions
+ */
+
+#define XKB_KEY_SunUndo    0x0000FF65  /* Same as XK_Undo */
+#define XKB_KEY_SunAgain   0x0000FF66  /* Same as XK_Redo */
+#define XKB_KEY_SunFind    0x0000FF68  /* Same as XK_Find */
+#define XKB_KEY_SunStop    0x0000FF69  /* Same as XK_Cancel */
+#define XKB_KEY_SunProps   0x1005FF70
+#define XKB_KEY_SunFront   0x1005FF71
+#define XKB_KEY_SunCopy    0x1005FF72
+#define XKB_KEY_SunOpen    0x1005FF73
+#define XKB_KEY_SunPaste   0x1005FF74
+#define XKB_KEY_SunCut   0x1005FF75
+
+#define XKB_KEY_SunPowerSwitch   0x1005FF76
+#define XKB_KEY_SunAudioLowerVolume    0x1005FF77
+#define XKB_KEY_SunAudioMute     0x1005FF78
+#define XKB_KEY_SunAudioRaiseVolume    0x1005FF79
+#define XKB_KEY_SunVideoDegauss    0x1005FF7A
+#define XKB_KEY_SunVideoLowerBrightness  0x1005FF7B
+#define XKB_KEY_SunVideoRaiseBrightness  0x1005FF7C
+#define XKB_KEY_SunPowerSwitchShift    0x1005FF7D
+/***********************************************************
+
+Copyright 1988, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1988 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+/*
+ * DEC private keysyms
+ * (29th bit set)
+ */
+
+/* two-key compose sequence initiators, chosen to map to Latin1 characters */
+
+#define XKB_KEY_Dring_accent         0x1000FEB0
+#define XKB_KEY_Dcircumflex_accent   0x1000FE5E
+#define XKB_KEY_Dcedilla_accent      0x1000FE2C
+#define XKB_KEY_Dacute_accent        0x1000FE27
+#define XKB_KEY_Dgrave_accent        0x1000FE60
+#define XKB_KEY_Dtilde               0x1000FE7E
+#define XKB_KEY_Ddiaeresis           0x1000FE22
+
+/* special keysym for LK2** "Remove" key on editing keypad */
+
+#define XKB_KEY_DRemove  0x1000FF00   /* Remove */
+/*
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the names of Hewlett Packard
+or Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD
+TO THIS SOFWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  Hewlett-Packard shall not be liable for errors
+contained herein or direct, indirect, special, incidental or
+consequential damages in connection with the furnishing,
+performance, or use of this material.
+
+*/
+
+
+
+#define XKB_KEY_hpClearLine    0x1000FF6F
+#define XKB_KEY_hpInsertLine   0x1000FF70
+#define XKB_KEY_hpDeleteLine   0x1000FF71
+#define XKB_KEY_hpInsertChar   0x1000FF72
+#define XKB_KEY_hpDeleteChar   0x1000FF73
+#define XKB_KEY_hpBackTab    0x1000FF74
+#define XKB_KEY_hpKP_BackTab   0x1000FF75
+#define XKB_KEY_hpModelock1    0x1000FF48
+#define XKB_KEY_hpModelock2    0x1000FF49
+#define XKB_KEY_hpReset    0x1000FF6C
+#define XKB_KEY_hpSystem   0x1000FF6D
+#define XKB_KEY_hpUser   0x1000FF6E
+#define XKB_KEY_hpmute_acute   0x100000A8
+#define XKB_KEY_hpmute_grave   0x100000A9
+#define XKB_KEY_hpmute_asciicircum 0x100000AA
+#define XKB_KEY_hpmute_diaeresis 0x100000AB
+#define XKB_KEY_hpmute_asciitilde  0x100000AC
+#define XKB_KEY_hplira   0x100000AF
+#define XKB_KEY_hpguilder    0x100000BE
+#define XKB_KEY_hpYdiaeresis   0x100000EE
+#define XKB_KEY_hpIO     0x100000EE
+#define XKB_KEY_hplongminus    0x100000F6
+#define XKB_KEY_hpblock    0x100000FC
+
+
+
+#define XKB_KEY_osfCopy    0x1004FF02
+#define XKB_KEY_osfCut   0x1004FF03
+#define XKB_KEY_osfPaste   0x1004FF04
+#define XKB_KEY_osfBackTab   0x1004FF07
+#define XKB_KEY_osfBackSpace   0x1004FF08
+#define XKB_KEY_osfClear   0x1004FF0B
+#define XKB_KEY_osfEscape    0x1004FF1B
+#define XKB_KEY_osfAddMode   0x1004FF31
+#define XKB_KEY_osfPrimaryPaste  0x1004FF32
+#define XKB_KEY_osfQuickPaste  0x1004FF33
+#define XKB_KEY_osfPageLeft    0x1004FF40
+#define XKB_KEY_osfPageUp    0x1004FF41
+#define XKB_KEY_osfPageDown    0x1004FF42
+#define XKB_KEY_osfPageRight   0x1004FF43
+#define XKB_KEY_osfActivate    0x1004FF44
+#define XKB_KEY_osfMenuBar   0x1004FF45
+#define XKB_KEY_osfLeft    0x1004FF51
+#define XKB_KEY_osfUp    0x1004FF52
+#define XKB_KEY_osfRight   0x1004FF53
+#define XKB_KEY_osfDown    0x1004FF54
+#define XKB_KEY_osfEndLine   0x1004FF57
+#define XKB_KEY_osfBeginLine   0x1004FF58
+#define XKB_KEY_osfEndData   0x1004FF59
+#define XKB_KEY_osfBeginData   0x1004FF5A
+#define XKB_KEY_osfPrevMenu    0x1004FF5B
+#define XKB_KEY_osfNextMenu    0x1004FF5C
+#define XKB_KEY_osfPrevField   0x1004FF5D
+#define XKB_KEY_osfNextField   0x1004FF5E
+#define XKB_KEY_osfSelect    0x1004FF60
+#define XKB_KEY_osfInsert    0x1004FF63
+#define XKB_KEY_osfUndo    0x1004FF65
+#define XKB_KEY_osfMenu    0x1004FF67
+#define XKB_KEY_osfCancel    0x1004FF69
+#define XKB_KEY_osfHelp    0x1004FF6A
+#define XKB_KEY_osfSelectAll   0x1004FF71
+#define XKB_KEY_osfDeselectAll 0x1004FF72
+#define XKB_KEY_osfReselect    0x1004FF73
+#define XKB_KEY_osfExtend    0x1004FF74
+#define XKB_KEY_osfRestore   0x1004FF78
+#define XKB_KEY_osfDelete    0x1004FFFF
+
+
+
+/**************************************************************
+ * The use of the following macros is deprecated.
+ * They are listed below only for backwards compatibility.
+ */
+#define XKB_KEY_Reset                0x1000FF6C
+#define XKB_KEY_System               0x1000FF6D
+#define XKB_KEY_User                 0x1000FF6E
+#define XKB_KEY_ClearLine            0x1000FF6F
+#define XKB_KEY_InsertLine           0x1000FF70
+#define XKB_KEY_DeleteLine           0x1000FF71
+#define XKB_KEY_InsertChar           0x1000FF72
+#define XKB_KEY_DeleteChar           0x1000FF73
+#define XKB_KEY_BackTab              0x1000FF74
+#define XKB_KEY_KP_BackTab           0x1000FF75
+#define XKB_KEY_Ext16bit_L           0x1000FF76
+#define XKB_KEY_Ext16bit_R           0x1000FF77
+#define XKB_KEY_mute_acute           0x100000a8
+#define XKB_KEY_mute_grave           0x100000a9
+#define XKB_KEY_mute_asciicircum     0x100000aa
+#define XKB_KEY_mute_diaeresis       0x100000ab
+#define XKB_KEY_mute_asciitilde      0x100000ac
+#define XKB_KEY_lira                 0x100000af
+#define XKB_KEY_guilder              0x100000be
+#define XKB_KEY_IO                   0x100000ee
+#define XKB_KEY_longminus            0x100000f6
+#define XKB_KEY_block                0x100000fc
+
+
+
+#endif
diff --git a/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-names.h b/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-names.h
new file mode 100644
index 0000000..ecb551f
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-names.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright  2012 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Daniel Stone <daniel@fooishbar.org>
+ */
+
+#ifndef _XKBCOMMON_NAMES_H
+#define _XKBCOMMON_NAMES_H
+
+/**
+ * @file
+ * @brief Predefined names for common modifiers and LEDs.
+ */
+
+#define XKB_MOD_NAME_SHIFT      "Shift"
+#define XKB_MOD_NAME_CAPS       "Lock"
+#define XKB_MOD_NAME_CTRL       "Control"
+#define XKB_MOD_NAME_ALT        "Mod1"
+#define XKB_MOD_NAME_NUM        "Mod2"
+#define XKB_MOD_NAME_LOGO       "Mod4"
+
+#define XKB_LED_NAME_CAPS       "Caps Lock"
+#define XKB_LED_NAME_NUM        "Num Lock"
+#define XKB_LED_NAME_SCROLL     "Scroll Lock"
+
+#endif
diff --git a/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-x11.h b/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-x11.h
new file mode 100644
index 0000000..0158315
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon-x11.h
@@ -0,0 +1,244 @@
+/*
+ * Copyright  2013 Ran Benita
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _XKBCOMMON_X11_H
+#define _XKBCOMMON_X11_H
+
+#include <xcb/xcb.h>
+#include <xkbcommon/xkbcommon.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @file
+ * libxkbcommon-x11 API - Additional X11 support for xkbcommon.
+ */
+
+/**
+ * @defgroup x11 X11 support
+ * Additional X11 support for xkbcommon.
+ * @since 0.4.0
+ *
+ * @{
+ */
+
+/**
+ * @page x11-overview Overview
+ * @parblock
+ *
+ * The xkbcommon-x11 module provides a means for creating an xkb_keymap
+ * corresponding to the currently active keymap on the X server.  To do
+ * so, it queries the XKB X11 extension using the xcb-xkb library.  It
+ * can be used as a replacement for Xlib's keyboard handling.
+ *
+ * Following is an example workflow using xkbcommon-x11.  A complete
+ * example may be found in the test/interactive-x11.c file in the
+ * xkbcommon source repository.  On startup:
+ *
+ * 1. Connect to the X server using xcb_connect().
+ * 2. Setup the XKB X11 extension.  You can do this either by using the
+ *    xcb_xkb_use_extension() request directly, or by using the
+ *    xkb_x11_setup_xkb_extension() helper function.
+ *
+ * The XKB extension supports using separate keymaps and states for
+ * different keyboard devices.  The devices are identified by an integer
+ * device ID and are managed by another X11 extension, XInput (or its
+ * successor, XInput2).  The original X11 protocol only had one keyboard
+ * device, called the "core keyboard", which is still supported as a
+ * "virtual device".
+ *
+ * 3. We will use the core keyboard as an example.  To get its device ID,
+ *    use either the xcb_xkb_get_device_info() request directly, or the
+ *    xkb_x11_get_core_keyboard_device_id() helper function.
+ * 4. Create an initial xkb_keymap for this device, using the
+ *    xkb_x11_keymap_new_from_device() function.
+ * 5. Create an initial xkb_state for this device, using the
+ *    xkb_x11_state_new_from_device() function.
+ *
+ * @note At this point, you may consider setting various XKB controls and
+ * XKB per-client flags.  For example, enabling detectable autorepeat: \n
+ * http://www.x.org/releases/current/doc/kbproto/xkbproto.html#Detectable_Autorepeat
+ *
+ * Next, you need to react to state changes (e.g. a modifier was pressed,
+ * the layout was changed) and to keymap changes (e.g. a tool like xkbcomp,
+ * setxkbmap or xmodmap was used):
+ *
+ * 6. Select to listen to at least the following XKB events:
+ *    NewKeyboardNotify, MapNotify, StateNotify; using the
+ *    xcb_xkb_select_events_aux() request.
+ * 7. When NewKeyboardNotify or MapNotify are received, recreate the
+ *    xkb_keymap and xkb_state as described above.
+ * 8. When StateNotify is received, update the xkb_state accordingly
+ *    using the xkb_state_update_mask() function.
+ *
+ * @note It is also possible to use the KeyPress/KeyRelease @p state
+ * field to find the effective modifier and layout state, instead of
+ * using XkbStateNotify: \n
+ * http://www.x.org/releases/current/doc/kbproto/xkbproto.html#Computing_A_State_Field_from_an_XKB_State
+ * \n However, XkbStateNotify is more accurate.
+ *
+ * @note There is no need to call xkb_state_update_key(); the state is
+ * already synchronized.
+ *
+ * Finally, when a key event is received, you can use ordinary xkbcommon
+ * functions, like xkb_state_key_get_one_sym() and xkb_state_key_get_utf8(),
+ * as you normally would.
+ *
+ * @endparblock
+ */
+
+/**
+ * The minimal compatible major version of the XKB X11 extension which
+ * this library can use.
+ */
+#define XKB_X11_MIN_MAJOR_XKB_VERSION 1
+/**
+ * The minimal compatible minor version of the XKB X11 extension which
+ * this library can use (for the minimal major version).
+ */
+#define XKB_X11_MIN_MINOR_XKB_VERSION 0
+
+/** Flags for the xkb_x11_setup_xkb_extension() function. */
+enum xkb_x11_setup_xkb_extension_flags {
+    /** Do not apply any flags. */
+    XKB_X11_SETUP_XKB_EXTENSION_NO_FLAGS = 0
+};
+
+/**
+ * Setup the XKB X11 extension for this X client.
+ *
+ * The xkbcommon-x11 library uses various XKB requests.  Before doing so,
+ * an X client must notify the server that it will be using the extension.
+ * This function (or an XCB equivalent) must be called before any other
+ * function in this library is used.
+ *
+ * Some X servers may not support or disable the XKB extension.  If you
+ * want to support such servers, you need to use a different fallback.
+ *
+ * You may call this function several times; it is idempotent.
+ *
+ * @param connection
+ *     An XCB connection to the X server.
+ * @param major_xkb_version
+ *     See @p minor_xkb_version.
+ * @param minor_xkb_version
+ *     The XKB extension version to request.  To operate correctly, you
+ *     must have (major_xkb_version, minor_xkb_version) >=
+ *     (XKB_X11_MIN_MAJOR_XKB_VERSION, XKB_X11_MIN_MINOR_XKB_VERSION),
+ *     though this is not enforced.
+ * @param flags
+ *     Optional flags, or 0.
+ * @param[out] major_xkb_version_out
+ *     See @p minor_xkb_version_out.
+ * @param[out] minor_xkb_version_out
+ *     Backfilled with the compatible XKB extension version numbers picked
+ *     by the server.  Can be NULL.
+ * @param[out] base_event_out
+ *     Backfilled with the XKB base (also known as first) event code, needed
+ *     to distinguish XKB events.  Can be NULL.
+ * @param[out] base_error_out
+ *     Backfilled with the XKB base (also known as first) error code, needed
+ *     to distinguish XKB errors.  Can be NULL.
+ *
+ * @returns 1 on success, or 0 on failure.
+ */
+int
+xkb_x11_setup_xkb_extension(xcb_connection_t *connection,
+                            uint16_t major_xkb_version,
+                            uint16_t minor_xkb_version,
+                            enum xkb_x11_setup_xkb_extension_flags flags,
+                            uint16_t *major_xkb_version_out,
+                            uint16_t *minor_xkb_version_out,
+                            uint8_t *base_event_out,
+                            uint8_t *base_error_out);
+
+/**
+ * Get the keyboard device ID of the core X11 keyboard.
+ *
+ * @param connection An XCB connection to the X server.
+ *
+ * @returns A device ID which may be used with other xkb_x11_* functions,
+ *          or -1 on failure.
+ */
+int32_t
+xkb_x11_get_core_keyboard_device_id(xcb_connection_t *connection);
+
+/**
+ * Create a keymap from an X11 keyboard device.
+ *
+ * This function queries the X server with various requests, fetches the
+ * details of the active keymap on a keyboard device, and creates an
+ * xkb_keymap from these details.
+ *
+ * @param context
+ *     The context in which to create the keymap.
+ * @param connection
+ *     An XCB connection to the X server.
+ * @param device_id
+ *     An XInput 1 device ID (in the range 0-255) with input class KEY.
+ *     Passing values outside of this range is an error.
+ * @param flags
+ *     Optional flags for the keymap, or 0.
+ *
+ * @returns A keymap retrieved from the X server, or NULL on failure.
+ *
+ * @memberof xkb_keymap
+ */
+struct xkb_keymap *
+xkb_x11_keymap_new_from_device(struct xkb_context *context,
+                               xcb_connection_t *connection,
+                               int32_t device_id,
+                               enum xkb_keymap_compile_flags flags);
+
+/**
+ * Create a new keyboard state object from an X11 keyboard device.
+ *
+ * This function is the same as xkb_state_new(), only pre-initialized
+ * with the state of the device at the time this function is called.
+ *
+ * @param keymap
+ *     The keymap for which to create the state.
+ * @param connection
+ *     An XCB connection to the X server.
+ * @param device_id
+ *     An XInput 1 device ID (in the range 0-255) with input class KEY.
+ *     Passing values outside of this range is an error.
+ *
+ * @returns A new keyboard state object, or NULL on failure.
+ *
+ * @memberof xkb_state
+ */
+struct xkb_state *
+xkb_x11_state_new_from_device(struct xkb_keymap *keymap,
+                              xcb_connection_t *connection,
+                              int32_t device_id);
+
+/** @} */
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* _XKBCOMMON_X11_H */
diff --git a/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon.h b/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon.h
new file mode 100644
index 0000000..f0c9202
--- /dev/null
+++ b/src/plugins/platforminputcontexts/fcitx/xkbcommon/xkbcommon.h
@@ -0,0 +1,1723 @@
+/*
+ * Copyright 1985, 1987, 1990, 1998  The Open Group
+ * Copyright 2008  Dan Nicholson
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the names of the authors or their
+ * institutions shall not be used in advertising or otherwise to promote the
+ * sale, use or other dealings in this Software without prior written
+ * authorization from the authors.
+ */
+
+/************************************************************
+ * Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, and distribute this
+ * software and its documentation for any purpose and without
+ * fee is hereby granted, provided that the above copyright
+ * notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting
+ * documentation, and that the name of Silicon Graphics not be
+ * used in advertising or publicity pertaining to distribution
+ * of the software without specific prior written permission.
+ * Silicon Graphics makes no representation about the suitability
+ * of this software for any purpose. It is provided "as is"
+ * without any express or implied warranty.
+ *
+ * SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
+ * GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
+ * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
+ * THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ ********************************************************/
+
+/*
+ * Copyright  2009-2012 Daniel Stone
+ * Copyright  2012 Intel Corporation
+ * Copyright  2012 Ran Benita
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Daniel Stone <daniel@fooishbar.org>
+ */
+
+#ifndef _XKBCOMMON_H_
+#define _XKBCOMMON_H_
+
+#include <stdint.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include <xkbcommon/xkbcommon-names.h>
+#include <xkbcommon/xkbcommon-keysyms.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @file
+ * Main libxkbcommon API.
+ */
+
+/**
+ * @struct xkb_context
+ * Opaque top level library context object.
+ *
+ * The context contains various general library data and state, like
+ * logging level and include paths.
+ *
+ * Objects are created in a specific context, and multiple contexts may
+ * coexist simultaneously.  Objects from different contexts are completely
+ * separated and do not share any memory or state.
+ */
+struct xkb_context;
+
+/**
+ * @struct xkb_keymap
+ * Opaque compiled keymap object.
+ *
+ * The keymap object holds all of the static keyboard information obtained
+ * from compiling XKB files.
+ *
+ * A keymap is immutable after it is created (besides reference counts, etc.);
+ * if you need to change it, you must create a new one.
+ */
+struct xkb_keymap;
+
+/**
+ * @struct xkb_state
+ * Opaque keyboard state object.
+ *
+ * State objects contain the active state of a keyboard (or keyboards), such
+ * as the currently effective layout and the active modifiers.  It acts as a
+ * simple state machine, wherein key presses and releases are the input, and
+ * key symbols (keysyms) are the output.
+ */
+struct xkb_state;
+
+/**
+ * A number used to represent a physical key on a keyboard.
+ *
+ * A standard PC-compatible keyboard might have 102 keys.  An appropriate
+ * keymap would assign each of them a keycode, by which the user should
+ * refer to the key throughout the library.
+ *
+ * Historically, the X11 protocol, and consequentially the XKB protocol,
+ * assign only 8 bits for keycodes.  This limits the number of different
+ * keys that can be used simultaneously in a single keymap to 256
+ * (disregarding other limitations).  This library does not share this limit;
+ * keycodes beyond 255 ('extended keycodes') are not treated specially.
+ * Keymaps and applications which are compatible with X11 should not use
+ * these keycodes.
+ *
+ * The values of specific keycodes are determined by the keymap and the
+ * underlying input system.  For example, with an X11-compatible keymap
+ * and Linux evdev scan codes (see linux/input.h), a fixed offset is used:
+ *
+ * @code
+ * xkb_keycode_t keycode_A = KEY_A + 8;
+ * @endcode
+ *
+ * @sa xkb_keycode_is_legal_ext() xkb_keycode_is_legal_x11()
+ */
+typedef uint32_t xkb_keycode_t;
+
+/**
+ * A number used to represent the symbols generated from a key on a keyboard.
+ *
+ * A key, represented by a keycode, may generate different symbols according
+ * to keyboard state.  For example, on a QWERTY keyboard, pressing the key
+ * labled \<A\> generates the symbol 'a'.  If the Shift key is held, it
+ * generates the symbol 'A'.  If a different layout is used, say Greek,
+ * it generates the symbol ''.  And so on.
+ *
+ * Each such symbol is represented by a keysym.  Note that keysyms are
+ * somewhat more general, in that they can also represent some "function",
+ * such as "Left" or "Right" for the arrow keys.  For more information,
+ * see:
+ * http://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html#keysym_encoding
+ *
+ * Specifically named keysyms can be found in the
+ * xkbcommon/xkbcommon-keysyms.h header file.  Their name does not include
+ * the XKB_KEY_ prefix.
+ *
+ * Besides those, any Unicode/ISO 10646 character in the range U0100 to
+ * U10FFFF can be represented by a keysym value in the range 0x01000100 to
+ * 0x0110FFFF.  The name of Unicode keysyms is "U<codepoint>", e.g. "UA1B2".
+ *
+ * The name of other unnamed keysyms is the hexadecimal representation of
+ * their value, e.g. "0xabcd1234".
+ *
+ * Keysym names are case-sensitive.
+ */
+typedef uint32_t xkb_keysym_t;
+
+/**
+ * Index of a keyboard layout.
+ *
+ * The layout index is a state component which detemines which <em>keyboard
+ * layout</em> is active.  These may be different alphabets, different key
+ * arrangements, etc.
+ *
+ * Layout indices are consecutive.  The first layout has index 0.
+ *
+ * Each layout is not required to have a name, and the names are not
+ * guaranteed to be unique (though they are usually provided and unique).
+ * Therefore, it is not safe to use the name as a unique identifier for a
+ * layout.  Layout names are case-sensitive.
+ *
+ * Layouts are also called "groups" by XKB.
+ *
+ * @sa xkb_keymap_num_layouts() xkb_keymap_num_layouts_for_key()
+ */
+typedef uint32_t xkb_layout_index_t;
+/** A mask of layout indices. */
+typedef uint32_t xkb_layout_mask_t;
+
+/**
+ * Index of a shift level.
+ *
+ * Any key, in any layout, can have several <em>shift levels</em>.  Each
+ * shift level can assign different keysyms to the key.  The shift level
+ * to use is chosen according to the current keyboard state; for example,
+ * if no keys are pressed, the first level may be used; if the Left Shift
+ * key is pressed, the second; if Num Lock is pressed, the third; and
+ * many such combinations are possible (see xkb_mod_index_t).
+ *
+ * Level indices are consecutive.  The first level has index 0.
+ */
+typedef uint32_t xkb_level_index_t;
+
+/**
+ * Index of a modifier.
+ *
+ * A @e modifier is a state component which changes the way keys are
+ * interpreted.  A keymap defines a set of modifiers, such as Alt, Shift,
+ * Num Lock or Meta, and specifies which keys may @e activate which
+ * modifiers (in a many-to-many relationship, i.e. a key can activate
+ * several modifiers, and a modifier may be activated by several keys.
+ * Different keymaps do this differently).
+ *
+ * When retrieving the keysyms for a key, the active modifier set is
+ * consulted; this detemines the correct shift level to use within the
+ * currently active layout (see xkb_level_index_t).
+ *
+ * Modifier indices are consecutive.  The first modifier has index 0.
+ *
+ * Each modifier must have a name, and the names are unique.  Therefore, it
+ * is safe to use the name as a unique identifier for a modifier.  The names
+ * of some common modifiers are provided in the xkbcommon/xkbcommon-names.h
+ * header file.  Modifier names are case-sensitive.
+ *
+ * @sa xkb_keymap_num_mods()
+ */
+typedef uint32_t xkb_mod_index_t;
+/** A mask of modifier indices. */
+typedef uint32_t xkb_mod_mask_t;
+
+/**
+ * Index of a keyboard LED.
+ *
+ * LEDs are logical objects which may be @e active or @e inactive.  They
+ * typically correspond to the lights on the keyboard. Their state is
+ * determined by the current keyboard state.
+ *
+ * LED indices are non-consecutive.  The first LED has index 0.
+ *
+ * Each LED must have a name, and the names are unique. Therefore,
+ * it is safe to use the name as a unique identifier for a LED.  The names
+ * of some common LEDs are provided in the xkbcommon/xkbcommon-names.h
+ * header file.  LED names are case-sensitive.
+ *
+ * @warning A given keymap may specify an exact index for a given LED.
+ * Therefore, LED indexing is not necessarily sequential, as opposed to
+ * modifiers and layouts.  This means that when iterating over the LEDs
+ * in a keymap using e.g. xkb_keymap_num_leds(), some indices might be
+ * invalid.  Given such an index, functions like xkb_keymap_led_get_name()
+ * will return NULL, and xkb_state_led_index_is_active() will return -1.
+ *
+ * LEDs are also called "indicators" by XKB.
+ *
+ * @sa xkb_keymap_num_leds()
+ */
+typedef uint32_t xkb_led_index_t;
+/** A mask of LED indices. */
+typedef uint32_t xkb_led_mask_t;
+
+#define XKB_KEYCODE_INVALID (0xffffffff)
+#define XKB_LAYOUT_INVALID  (0xffffffff)
+#define XKB_LEVEL_INVALID   (0xffffffff)
+#define XKB_MOD_INVALID     (0xffffffff)
+#define XKB_LED_INVALID     (0xffffffff)
+
+#define XKB_KEYCODE_MAX     (0xffffffff - 1)
+
+/**
+ * Test whether a value is a valid extended keycode.
+ * @sa xkb_keycode_t
+ **/
+#define xkb_keycode_is_legal_ext(key) (key <= XKB_KEYCODE_MAX)
+
+/**
+ * Test whether a value is a valid X11 keycode.
+ * @sa xkb_keycode_t
+ */
+#define xkb_keycode_is_legal_x11(key) (key >= 8 && key <= 255)
+
+/**
+ * Names to compile a keymap with, also known as RMLVO.
+ *
+ * The names are the common configuration values by which a user picks
+ * a keymap.
+ *
+ * If the entire struct is NULL, then each field is taken to be NULL.
+ * You should prefer passing NULL instead of choosing your own defaults.
+ */
+struct xkb_rule_names {
+    /**
+     * The rules file to use. The rules file describes how to interpret
+     * the values of the model, layout, variant and options fields.
+     *
+     * If NULL or the empty string "", a default value is used.
+     * If the XKB_DEFAULT_RULES environment variable is set, it is used
+     * as the default.  Otherwise the system default is used.
+     */
+    const char *rules;
+    /**
+     * The keyboard model by which to interpret keycodes and LEDs.
+     *
+     * If NULL or the empty string "", a default value is used.
+     * If the XKB_DEFAULT_MODEL environment variable is set, it is used
+     * as the default.  Otherwise the system default is used.
+     */
+    const char *model;
+    /**
+     * A comma separated list of layouts (languages) to include in the
+     * keymap.
+     *
+     * If NULL or the empty string "", a default value is used.
+     * If the XKB_DEFAULT_LAYOUT environment variable is set, it is used
+     * as the default.  Otherwise the system default is used.
+     */
+    const char *layout;
+    /**
+     * A comma separated list of variants, one per layout, which may
+     * modify or augment the respective layout in various ways.
+     *
+     * If NULL or the empty string "", and a default value is also used
+     * for the layout, a default value is used.  Otherwise no variant is
+     * used.
+     * If the XKB_DEFAULT_VARIANT environment variable is set, it is used
+     * as the default.  Otherwise the system default is used.
+     */
+    const char *variant;
+    /**
+     * A comma separated list of options, through which the user specifies
+     * non-layout related preferences, like which key combinations are used
+     * for switching layouts, or which key is the Compose key.
+     *
+     * If NULL, a default value is used.  If the empty string "", no
+     * options are used.
+     * If the XKB_DEFAULT_OPTIONS environment variable is set, it is used
+     * as the default.  Otherwise the system default is used.
+     */
+    const char *options;
+};
+
+/**
+ * @defgroup keysyms Keysyms
+ * Utility functions related to keysyms.
+ *
+ * @{
+ */
+
+/**
+ * @page keysym-transformations Keysym Transformations
+ *
+ * Keysym translation is subject to several "keysym transformations",
+ * as described in the XKB specification.  These are:
+ *
+ * - Capitalization transformation.  If the Caps Lock modifier is
+ *   active and was not consumed by the translation process, a single
+ *   keysym is transformed to its upper-case form (if applicable).
+ *   Similarly, the UTF-8/UTF-32 string produced is capitalized.
+ *
+ *   This is described in:
+ *   http://www.x.org/releases/current/doc/kbproto/xkbproto.html#Interpreting_the_Lock_Modifier
+ *
+ * - Control transformation.  If the Control modifier is active and
+ *   was not consumed by the translation process, the string produced
+ *   is transformed to its matching ASCII control character (if
+ *   applicable).  Keysyms are not affected.
+ *
+ *   This is described in:
+ *   http://www.x.org/releases/current/doc/kbproto/xkbproto.html#Interpreting_the_Control_Modifier
+ *
+ * Each relevant function discusses which transformations it performs.
+ *
+ * These transformations are not applicable when a key produces multiple
+ * keysyms.
+ */
+
+
+/**
+ * Get the name of a keysym.
+ *
+ * For a description of how keysyms are named, see @ref xkb_keysym_t.
+ *
+ * @param[in]  keysym The keysym.
+ * @param[out] buffer A string buffer to write the name into.
+ * @param[in]  size   Size of the buffer.
+ *
+ * @warning If the buffer passed is too small, the string is truncated
+ * (though still NUL-terminated); a size of at least 64 bytes is recommended.
+ *
+ * @returns The number of bytes in the name, excluding the NUL byte. If
+ * the keysym is invalid, returns -1.
+ *
+ * You may check if truncation has occurred by comparing the return value
+ * with the length of buffer, similarly to the snprintf(3) function.
+ *
+ * @sa xkb_keysym_t
+ */
+int
+xkb_keysym_get_name(xkb_keysym_t keysym, char *buffer, size_t size);
+
+/** Flags for xkb_keysym_from_name(). */
+enum xkb_keysym_flags {
+    /** Do not apply any flags. */
+    XKB_KEYSYM_NO_FLAGS = 0,
+    /** Find keysym by case-insensitive search. */
+    XKB_KEYSYM_CASE_INSENSITIVE = (1 << 0)
+};
+
+/**
+ * Get a keysym from its name.
+ *
+ * @param name The name of a keysym. See remarks in xkb_keysym_get_name();
+ * this function will accept any name returned by that function.
+ * @param flags A set of flags controlling how the search is done. If
+ * invalid flags are passed, this will fail with XKB_KEY_NoSymbol.
+ *
+ * If you use the XKB_KEYSYM_CASE_INSENSITIVE flag and two keysym names
+ * differ only by case, then the lower-case keysym is returned.  For
+ * instance, for KEY_a and KEY_A, this function would return KEY_a for the
+ * case-insensitive search.  If this functionality is needed, it is
+ * recommended to first call this function without this flag; and if that
+ * fails, only then to try with this flag, while possibly warning the user
+ * he had misspelled the name, and might get wrong results.
+ *
+ * @returns The keysym. If the name is invalid, returns XKB_KEY_NoSymbol.
+ *
+ * @sa xkb_keysym_t
+ */
+xkb_keysym_t
+xkb_keysym_from_name(const char *name, enum xkb_keysym_flags flags);
+
+/**
+ * Get the Unicode/UTF-8 representation of a keysym.
+ *
+ * @param[in]  keysym The keysym.
+ * @param[out] buffer A buffer to write the UTF-8 string into.
+ * @param[in]  size   The size of buffer.  Must be at least 7.
+ *
+ * @returns The number of bytes written to the buffer (including the
+ * terminating byte).  If the keysym does not have a Unicode
+ * representation, returns 0.  If the buffer is too small, returns -1.
+ *
+ * This function does not perform any @ref keysym-transformations.
+ * Therefore, prefer to use xkb_state_key_get_utf8() if possible.
+ *
+ * @sa xkb_state_key_get_utf8()
+ */
+int
+xkb_keysym_to_utf8(xkb_keysym_t keysym, char *buffer, size_t size);
+
+/**
+ * Get the Unicode/UTF-32 representation of a keysym.
+ *
+ * @returns The Unicode/UTF-32 representation of keysym, which is also
+ * compatible with UCS-4.  If the keysym does not have a Unicode
+ * representation, returns 0.
+ *
+ * This function does not perform any @ref keysym-transformations.
+ * Therefore, prefer to use xkb_state_key_get_utf32() if possible.
+ *
+ * @sa xkb_state_key_get_utf32()
+ */
+uint32_t
+xkb_keysym_to_utf32(xkb_keysym_t keysym);
+
+/** @} */
+
+/**
+ * @defgroup context Library Context
+ * Creating, destroying and using library contexts.
+ *
+ * Every keymap compilation request must have a context associated with
+ * it.  The context keeps around state such as the include path.
+ *
+ * @{
+ */
+
+/** Flags for context creation. */
+enum xkb_context_flags {
+    /** Do not apply any context flags. */
+    XKB_CONTEXT_NO_FLAGS = 0,
+    /** Create this context with an empty include path. */
+    XKB_CONTEXT_NO_DEFAULT_INCLUDES = (1 << 0),
+    /**
+     * Don't take RMLVO names from the environment.
+     * @since 0.3.0
+     */
+    XKB_CONTEXT_NO_ENVIRONMENT_NAMES = (1 << 1)
+};
+
+/**
+ * Create a new context.
+ *
+ * @param flags Optional flags for the context, or 0.
+ *
+ * @returns A new context, or NULL on failure.
+ *
+ * The user may set some environment variables to affect default values in
+ * the context. See e.g. xkb_context_set_log_level() and
+ * xkb_context_set_log_verbosity().
+ *
+ * @memberof xkb_context
+ */
+struct xkb_context *
+xkb_context_new(enum xkb_context_flags flags);
+
+/**
+ * Take a new reference on a context.
+ *
+ * @returns The passed in context.
+ *
+ * @memberof xkb_context
+ */
+struct xkb_context *
+xkb_context_ref(struct xkb_context *context);
+
+/**
+ * Release a reference on a context, and possibly free it.
+ *
+ * @param context The context.  If it is NULL, this function does nothing.
+ *
+ * @memberof xkb_context
+ */
+void
+xkb_context_unref(struct xkb_context *context);
+
+/**
+ * Store custom user data in the context.
+ *
+ * This may be useful in conjunction with xkb_context_set_log_fn() or other
+ * callbacks.
+ *
+ * @memberof xkb_context
+ */
+void
+xkb_context_set_user_data(struct xkb_context *context, void *user_data);
+
+/**
+ * Retrieves stored user data from the context.
+ *
+ * @returns The stored user data.  If the user data wasn't set, or the
+ * passed in context is NULL, returns NULL.
+ *
+ * This may be useful to access private user data from callbacks like a
+ * custom logging function.
+ *
+ * @memberof xkb_context
+ **/
+void *
+xkb_context_get_user_data(struct xkb_context *context);
+
+/** @} */
+
+/**
+ * @defgroup include-path Include Paths
+ * Manipulating the include paths in a context.
+ *
+ * The include paths are the file-system paths that are searched when an
+ * include statement is encountered during keymap compilation.
+ * In most cases, the default include paths are sufficient.
+ *
+ * @{
+ */
+
+/**
+ * Append a new entry to the context's include path.
+ *
+ * @returns 1 on success, or 0 if the include path could not be added or is
+ * inaccessible.
+ *
+ * @memberof xkb_context
+ */
+int
+xkb_context_include_path_append(struct xkb_context *context, const char *path);
+
+/**
+ * Append the default include paths to the context's include path.
+ *
+ * @returns 1 on success, or 0 if the primary include path could not be added.
+ *
+ * @memberof xkb_context
+ */
+int
+xkb_context_include_path_append_default(struct xkb_context *context);
+
+/**
+ * Reset the context's include path to the default.
+ *
+ * Removes all entries from the context's include path, and inserts the
+ * default paths.
+ *
+ * @returns 1 on success, or 0 if the primary include path could not be added.
+ *
+ * @memberof xkb_context
+ */
+int
+xkb_context_include_path_reset_defaults(struct xkb_context *context);
+
+/**
+ * Remove all entries from the context's include path.
+ *
+ * @memberof xkb_context
+ */
+void
+xkb_context_include_path_clear(struct xkb_context *context);
+
+/**
+ * Get the number of paths in the context's include path.
+ *
+ * @memberof xkb_context
+ */
+unsigned int
+xkb_context_num_include_paths(struct xkb_context *context);
+
+/**
+ * Get a specific include path from the context's include path.
+ *
+ * @returns The include path at the specified index.  If the index is
+ * invalid, returns NULL.
+ *
+ * @memberof xkb_context
+ */
+const char *
+xkb_context_include_path_get(struct xkb_context *context, unsigned int index);
+
+/** @} */
+
+/**
+ * @defgroup logging Logging Handling
+ * Manipulating how logging from this library is handled.
+ *
+ * @{
+ */
+
+/** Specifies a logging level. */
+enum xkb_log_level {
+    XKB_LOG_LEVEL_CRITICAL = 10, /**< Log critical internal errors only. */
+    XKB_LOG_LEVEL_ERROR = 20,    /**< Log all errors. */
+    XKB_LOG_LEVEL_WARNING = 30,  /**< Log warnings and errors. */
+    XKB_LOG_LEVEL_INFO = 40,     /**< Log information, warnings, and errors. */
+    XKB_LOG_LEVEL_DEBUG = 50     /**< Log everything. */
+};
+
+/**
+ * Set the current logging level.
+ *
+ * @param context The context in which to set the logging level.
+ * @param level   The logging level to use.  Only messages from this level
+ * and below will be logged.
+ *
+ * The default level is XKB_LOG_LEVEL_ERROR.  The environment variable
+ * XKB_LOG_LEVEL, if set in the time the context was created, overrides the
+ * default value.  It may be specified as a level number or name.
+ *
+ * @memberof xkb_context
+ */
+void
+xkb_context_set_log_level(struct xkb_context *context,
+                          enum xkb_log_level level);
+
+/**
+ * Get the current logging level.
+ *
+ * @memberof xkb_context
+ */
+enum xkb_log_level
+xkb_context_get_log_level(struct xkb_context *context);
+
+/**
+ * Sets the current logging verbosity.
+ *
+ * The library can generate a number of warnings which are not helpful to
+ * ordinary users of the library.  The verbosity may be increased if more
+ * information is desired (e.g. when developing a new keymap).
+ *
+ * The default verbosity is 0.  The environment variable XKB_LOG_VERBOSITY,
+ * if set in the time the context was created, overrides the default value.
+ *
+ * @param context   The context in which to use the set verbosity.
+ * @param verbosity The verbosity to use.  Currently used values are
+ * 1 to 10, higher values being more verbose.  0 would result in no verbose
+ * messages being logged.
+ *
+ * Most verbose messages are of level XKB_LOG_LEVEL_WARNING or lower.
+ *
+ * @memberof xkb_context
+ */
+void
+xkb_context_set_log_verbosity(struct xkb_context *context, int verbosity);
+
+/**
+ * Get the current logging verbosity of the context.
+ *
+ * @memberof xkb_context
+ */
+int
+xkb_context_get_log_verbosity(struct xkb_context *context);
+
+/**
+ * Set a custom function to handle logging messages.
+ *
+ * @param context The context in which to use the set logging function.
+ * @param log_fn  The function that will be called for logging messages.
+ * Passing NULL restores the default function, which logs to stderr.
+ *
+ * By default, log messages from this library are printed to stderr.  This
+ * function allows you to replace the default behavior with a custom
+ * handler.  The handler is only called with messages which match the
+ * current logging level and verbosity settings for the context.
+ * level is the logging level of the message.  @a format and @a args are
+ * the same as in the vprintf(3) function.
+ *
+ * You may use xkb_context_set_user_data() on the context, and then call
+ * xkb_context_get_user_data() from within the logging function to provide
+ * it with additional private context.
+ *
+ * @memberof xkb_context
+ */
+void
+xkb_context_set_log_fn(struct xkb_context *context,
+                       void (*log_fn)(struct xkb_context *context,
+                                      enum xkb_log_level level,
+                                      const char *format, va_list args));
+
+/** @} */
+
+/**
+ * @defgroup keymap Keymap Creation
+ * Creating and destroying keymaps.
+ *
+ * @{
+ */
+
+/** Flags for keymap compilation. */
+enum xkb_keymap_compile_flags {
+    /** Do not apply any flags. */
+    XKB_KEYMAP_COMPILE_NO_FLAGS = 0
+};
+
+/**
+ * Create a keymap from RMLVO names.
+ *
+ * The primary keymap entry point: creates a new XKB keymap from a set of
+ * RMLVO (Rules + Model + Layouts + Variants + Options) names.
+ *
+ * @param context The context in which to create the keymap.
+ * @param names   The RMLVO names to use.  See xkb_rule_names.
+ * @param flags   Optional flags for the keymap, or 0.
+ *
+ * @returns A keymap compiled according to the RMLVO names, or NULL if
+ * the compilation failed.
+ *
+ * @sa xkb_rule_names
+ * @memberof xkb_keymap
+ */
+struct xkb_keymap *
+xkb_keymap_new_from_names(struct xkb_context *context,
+                          const struct xkb_rule_names *names,
+                          enum xkb_keymap_compile_flags flags);
+
+/** The possible keymap formats. */
+enum xkb_keymap_format {
+    /** The current/classic XKB text format, as generated by xkbcomp -xkb. */
+    XKB_KEYMAP_FORMAT_TEXT_V1 = 1
+};
+
+/**
+ * Create a keymap from a keymap file.
+ *
+ * @param context The context in which to create the keymap.
+ * @param file    The keymap file to compile.
+ * @param format  The text format of the keymap file to compile.
+ * @param flags   Optional flags for the keymap, or 0.
+ *
+ * @returns A keymap compiled from the given XKB keymap file, or NULL if
+ * the compilation failed.
+ *
+ * The file must contain a complete keymap.  For example, in the
+ * XKB_KEYMAP_FORMAT_TEXT_V1 format, this means the file must contain one
+ * top level '%xkb_keymap' section, which in turn contains other required
+ * sections.
+ *
+ * @memberof xkb_keymap
+ */
+struct xkb_keymap *
+xkb_keymap_new_from_file(struct xkb_context *context, FILE *file,
+                         enum xkb_keymap_format format,
+                         enum xkb_keymap_compile_flags flags);
+
+/**
+ * Create a keymap from a keymap string.
+ *
+ * This is just like xkb_keymap_new_from_file(), but instead of a file, gets
+ * the keymap as one enormous string.
+ *
+ * @see xkb_keymap_new_from_file()
+ * @memberof xkb_keymap
+ */
+struct xkb_keymap *
+xkb_keymap_new_from_string(struct xkb_context *context, const char *string,
+                           enum xkb_keymap_format format,
+                           enum xkb_keymap_compile_flags flags);
+
+/**
+ * Create a keymap from a memory buffer.
+ *
+ * This is just like xkb_keymap_new_from_string(), but takes a length argument
+ * so the input string does not have to be zero-terminated.
+ *
+ * @see xkb_keymap_new_from_string()
+ * @memberof xkb_keymap
+ * @since 0.3.0
+ */
+struct xkb_keymap *
+xkb_keymap_new_from_buffer(struct xkb_context *context, const char *buffer,
+                           size_t length, enum xkb_keymap_format format,
+                           enum xkb_keymap_compile_flags flags);
+
+/**
+ * Take a new reference on a keymap.
+ *
+ * @returns The passed in keymap.
+ *
+ * @memberof xkb_keymap
+ */
+struct xkb_keymap *
+xkb_keymap_ref(struct xkb_keymap *keymap);
+
+/**
+ * Release a reference on a keymap, and possibly free it.
+ *
+ * @param keymap The keymap.  If it is NULL, this function does nothing.
+ *
+ * @memberof xkb_keymap
+ */
+void
+xkb_keymap_unref(struct xkb_keymap *keymap);
+
+/**
+ * Get the keymap as a string in the format from which it was created.
+ * @sa xkb_keymap_get_as_string()
+ **/
+#define XKB_KEYMAP_USE_ORIGINAL_FORMAT ((enum xkb_keymap_format) -1)
+
+/**
+ * Get the compiled keymap as a string.
+ *
+ * @param keymap The keymap to get as a string.
+ * @param format The keymap format to use for the string.  You can pass
+ * in the special value XKB_KEYMAP_USE_ORIGINAL_FORMAT to use the format
+ * from which the keymap was originally created.
+ *
+ * @returns The keymap as a NUL-terminated string, or NULL if unsuccessful.
+ *
+ * The returned string may be fed back into xkb_map_new_from_string() to get
+ * the exact same keymap (possibly in another process, etc.).
+ *
+ * The returned string is dynamically allocated and should be freed by the
+ * caller.
+ *
+ * @memberof xkb_keymap
+ */
+char *
+xkb_keymap_get_as_string(struct xkb_keymap *keymap,
+                         enum xkb_keymap_format format);
+
+/** @} */
+
+/**
+ * @defgroup components Keymap Components
+ * Enumeration of state components in a keymap.
+ *
+ * @{
+ */
+
+/**
+ * Get the minimum keycode in the keymap.
+ *
+ * @sa xkb_keycode_t
+ * @memberof xkb_keymap
+ * @since 0.3.1
+ */
+xkb_keycode_t
+xkb_keymap_min_keycode(struct xkb_keymap *keymap);
+
+/**
+ * Get the maximum keycode in the keymap.
+ *
+ * @sa xkb_keycode_t
+ * @memberof xkb_keymap
+ * @since 0.3.1
+ */
+xkb_keycode_t
+xkb_keymap_max_keycode(struct xkb_keymap *keymap);
+
+/**
+ * The iterator used by xkb_keymap_key_for_each().
+ *
+ * @sa xkb_keymap_key_for_each
+ * @memberof xkb_keymap
+ * @since 0.3.1
+ */
+typedef void
+(*xkb_keymap_key_iter_t)(struct xkb_keymap *keymap, xkb_keycode_t key,
+                         void *data);
+
+/**
+ * Run a specified function for every valid keycode in the keymap.  If a
+ * keymap is sparse, this function may be called fewer than
+ * (max_keycode - min_keycode + 1) times.
+ *
+ * @sa xkb_keymap_min_keycode() xkb_keymap_max_keycode() xkb_keycode_t
+ * @memberof xkb_keymap
+ * @since 0.3.1
+ */
+void
+xkb_keymap_key_for_each(struct xkb_keymap *keymap, xkb_keymap_key_iter_t iter,
+                        void *data);
+
+/**
+ * Get the number of modifiers in the keymap.
+ *
+ * @sa xkb_mod_index_t
+ * @memberof xkb_keymap
+ */
+xkb_mod_index_t
+xkb_keymap_num_mods(struct xkb_keymap *keymap);
+
+/**
+ * Get the name of a modifier by index.
+ *
+ * @returns The name.  If the index is invalid, returns NULL.
+ *
+ * @sa xkb_mod_index_t
+ * @memberof xkb_keymap
+ */
+const char *
+xkb_keymap_mod_get_name(struct xkb_keymap *keymap, xkb_mod_index_t idx);
+
+/**
+ * Get the index of a modifier by name.
+ *
+ * @returns The index.  If no modifier with this name exists, returns
+ * XKB_MOD_INVALID.
+ *
+ * @sa xkb_mod_index_t
+ * @memberof xkb_keymap
+ */
+xkb_mod_index_t
+xkb_keymap_mod_get_index(struct xkb_keymap *keymap, const char *name);
+
+/**
+ * Get the number of layouts in the keymap.
+ *
+ * @sa xkb_layout_index_t xkb_rule_names xkb_keymap_num_layouts_for_key()
+ * @memberof xkb_keymap
+ */
+xkb_layout_index_t
+xkb_keymap_num_layouts(struct xkb_keymap *keymap);
+
+/**
+ * Get the name of a layout by index.
+ *
+ * @returns The name.  If the index is invalid, or the layout does not have
+ * a name, returns NULL.
+ *
+ * @sa xkb_layout_index_t
+ * @memberof xkb_keymap
+ */
+const char *
+xkb_keymap_layout_get_name(struct xkb_keymap *keymap, xkb_layout_index_t idx);
+
+/**
+ * Get the index of a layout by name.
+ *
+ * @returns The index.  If no layout exists with this name, returns
+ * XKB_LAYOUT_INVALID.  If more than one layout in the keymap has this name,
+ * returns the lowest index among them.
+ *
+ * @memberof xkb_keymap
+ */
+xkb_layout_index_t
+xkb_keymap_layout_get_index(struct xkb_keymap *keymap, const char *name);
+
+/**
+ * Get the number of LEDs in the keymap.
+ *
+ * @warning The range [ 0...xkb_keymap_num_leds() ) includes all of the LEDs
+ * in the keymap, but may also contain inactive LEDs.  When iterating over
+ * this range, you need the handle this case when calling functions such as
+ * xkb_keymap_led_get_name() or xkb_state_led_index_is_active().
+ *
+ * @sa xkb_led_index_t
+ * @memberof xkb_keymap
+ */
+xkb_led_index_t
+xkb_keymap_num_leds(struct xkb_keymap *keymap);
+
+/**
+ * Get the name of a LED by index.
+ *
+ * @returns The name.  If the index is invalid, returns NULL.
+ *
+ * @memberof xkb_keymap
+ */
+const char *
+xkb_keymap_led_get_name(struct xkb_keymap *keymap, xkb_led_index_t idx);
+
+/**
+ * Get the index of a LED by name.
+ *
+ * @returns The index.  If no LED with this name exists, returns
+ * XKB_LED_INVALID.
+ *
+ * @memberof xkb_keymap
+ */
+xkb_led_index_t
+xkb_keymap_led_get_index(struct xkb_keymap *keymap, const char *name);
+
+/**
+ * Get the number of layouts for a specific key.
+ *
+ * This number can be different from xkb_keymap_num_layouts(), but is always
+ * smaller.  It is the appropriate value to use when iterating over the
+ * layouts of a key.
+ *
+ * @sa xkb_layout_index_t
+ * @memberof xkb_keymap
+ */
+xkb_layout_index_t
+xkb_keymap_num_layouts_for_key(struct xkb_keymap *keymap, xkb_keycode_t key);
+
+/**
+ * Get the number of shift levels for a specific key and layout.
+ *
+ * If @c layout is out of range for this key (that is, larger or equal to
+ * the value returned by xkb_keymap_num_layouts_for_key()), it is brought
+ * back into range in a manner consistent with xkb_state_key_get_layout().
+ *
+ * @sa xkb_level_index_t
+ * @memberof xkb_keymap
+ */
+xkb_level_index_t
+xkb_keymap_num_levels_for_key(struct xkb_keymap *keymap, xkb_keycode_t key,
+                              xkb_layout_index_t layout);
+
+/**
+ * Get the keysyms obtained from pressing a key in a given layout and
+ * shift level.
+ *
+ * This function is like xkb_state_key_get_syms(), only the layout and
+ * shift level are not derived from the keyboard state but are instead
+ * specified explicitly.
+ *
+ * @param[in] keymap    The keymap.
+ * @param[in] key       The keycode of the key.
+ * @param[in] layout    The layout for which to get the keysyms.
+ * @param[in] level     The shift level in the layout for which to get the
+ * keysyms. This must be smaller than:
+ * @code xkb_keymap_num_levels_for_key(keymap, key) @endcode
+ * @param[out] syms_out An immutable array of keysyms corresponding to the
+ * key in the given layout and shift level.
+ *
+ * If @c layout is out of range for this key (that is, larger or equal to
+ * the value returned by xkb_keymap_num_layouts_for_key()), it is brought
+ * back into range in a manner consistent with xkb_state_key_get_layout().
+ *
+ * @returns The number of keysyms in the syms_out array.  If no keysyms
+ * are produced by the key in the given layout and shift level, returns 0
+ * and sets syms_out to NULL.
+ *
+ * @sa xkb_state_key_get_syms()
+ * @memberof xkb_keymap
+ */
+int
+xkb_keymap_key_get_syms_by_level(struct xkb_keymap *keymap,
+                                 xkb_keycode_t key,
+                                 xkb_layout_index_t layout,
+                                 xkb_level_index_t level,
+                                 const xkb_keysym_t **syms_out);
+
+/**
+ * Determine whether a key should repeat or not.
+ *
+ * A keymap may specify different repeat behaviors for different keys.
+ * Most keys should generally exhibit repeat behavior; for example, holding
+ * the 'a' key down in a text editor should normally insert a single 'a'
+ * character every few milliseconds, until the key is released.  However,
+ * there are keys which should not or do not need to be repeated.  For
+ * example, repeating modifier keys such as Left/Right Shift or Caps Lock
+ * is not generally useful or desired.
+ *
+ * @returns 1 if the key should repeat, 0 otherwise.
+ *
+ * @memberof xkb_keymap
+ */
+int
+xkb_keymap_key_repeats(struct xkb_keymap *keymap, xkb_keycode_t key);
+
+/** @} */
+
+/**
+ * @defgroup state Keyboard State
+ * Creating, destroying and manipulating keyboard state objects.
+ *
+ * @{
+ */
+
+/**
+ * Create a new keyboard state object.
+ *
+ * @param keymap The keymap which the state will use.
+ *
+ * @returns A new keyboard state object, or NULL on failure.
+ *
+ * @memberof xkb_state
+ */
+struct xkb_state *
+xkb_state_new(struct xkb_keymap *keymap);
+
+/**
+ * Take a new reference on a keyboard state object.
+ *
+ * @returns The passed in object.
+ *
+ * @memberof xkb_state
+ */
+struct xkb_state *
+xkb_state_ref(struct xkb_state *state);
+
+/**
+ * Release a reference on a keybaord state object, and possibly free it.
+ *
+ * @param state The state.  If it is NULL, this function does nothing.
+ *
+ * @memberof xkb_state
+ */
+void
+xkb_state_unref(struct xkb_state *state);
+
+/**
+ * Get the keymap which a keyboard state object is using.
+ *
+ * @returns The keymap which was passed to xkb_state_new() when creating
+ * this state object.
+ *
+ * This function does not take a new reference on the keymap; you must
+ * explicitly reference it yourself if you plan to use it beyond the
+ * lifetime of the state.
+ *
+ * @memberof xkb_state
+ */
+struct xkb_keymap *
+xkb_state_get_keymap(struct xkb_state *state);
+
+/** Specifies the direction of the key (press / release). */
+enum xkb_key_direction {
+    XKB_KEY_UP,   /**< The key was released. */
+    XKB_KEY_DOWN  /**< The key was pressed. */
+};
+
+/**
+ * Modifier and layout types for state objects.  This enum is bitmaskable,
+ * e.g. (XKB_STATE_MODS_DEPRESSED | XKB_STATE_MODS_LATCHED) is valid to
+ * exclude locked modifiers.
+ *
+ * In XKB, the DEPRESSED components are also known as 'base'.
+ */
+enum xkb_state_component {
+    /** Depressed modifiers, i.e. a key is physically holding them. */
+    XKB_STATE_MODS_DEPRESSED = (1 << 0),
+    /** Latched modifiers, i.e. will be unset after the next non-modifier
+     *  key press. */
+    XKB_STATE_MODS_LATCHED = (1 << 1),
+    /** Locked modifiers, i.e. will be unset after the key provoking the
+     *  lock has been pressed again. */
+    XKB_STATE_MODS_LOCKED = (1 << 2),
+    /** Effective modifiers, i.e. currently active and affect key
+     *  processing (derived from the other state components).
+     *  Use this unless you explictly care how the state came about. */
+    XKB_STATE_MODS_EFFECTIVE = (1 << 3),
+    /** Depressed layout, i.e. a key is physically holding it. */
+    XKB_STATE_LAYOUT_DEPRESSED = (1 << 4),
+    /** Latched layout, i.e. will be unset after the next non-modifier
+     *  key press. */
+    XKB_STATE_LAYOUT_LATCHED = (1 << 5),
+    /** Locked layout, i.e. will be unset after the key provoking the lock
+     *  has been pressed again. */
+    XKB_STATE_LAYOUT_LOCKED = (1 << 6),
+    /** Effective layout, i.e. currently active and affects key processing
+     *  (derived from the other state components).
+     *  Use this unless you explictly care how the state came about. */
+    XKB_STATE_LAYOUT_EFFECTIVE = (1 << 7),
+    /** LEDs (derived from the other state components). */
+    XKB_STATE_LEDS = (1 << 8)
+};
+
+/**
+ * Update the keyboard state to reflect a given key being pressed or
+ * released.
+ *
+ * This entry point is intended for programs which track the keyboard state
+ * explictly (like an evdev client).  If the state is serialized to you by
+ * a master process (like a Wayland compositor) using functions like
+ * xkb_state_serialize_mods(), you should use xkb_state_update_mask() instead.
+ * The two functins should not generally be used together.
+ *
+ * A series of calls to this function should be consistent; that is, a call
+ * with XKB_KEY_DOWN for a key should be matched by an XKB_KEY_UP; if a key
+ * is pressed twice, it should be released twice; etc. Otherwise (e.g. due
+ * to missed input events), situations like "stuck modifiers" may occur.
+ *
+ * This function is often used in conjunction with the function
+ * xkb_state_key_get_syms() (or xkb_state_key_get_one_sym()), for example,
+ * when handling a key event.  In this case, you should prefer to get the
+ * keysyms *before* updating the key, such that the keysyms reported for
+ * the key event are not affected by the event itself.  This is the
+ * conventional behavior.
+ *
+ * @returns A mask of state components that have changed as a result of
+ * the update.  If nothing in the state has changed, returns 0.
+ *
+ * @memberof xkb_state
+ *
+ * @sa xkb_state_update_mask()
+ */
+enum xkb_state_component
+xkb_state_update_key(struct xkb_state *state, xkb_keycode_t key,
+                     enum xkb_key_direction direction);
+
+/**
+ * Update a keyboard state from a set of explicit masks.
+ *
+ * This entry point is intended for window systems and the like, where a
+ * master process holds an xkb_state, then serializes it over a wire
+ * protocol, and clients then use the serialization to feed in to their own
+ * xkb_state.
+ *
+ * All parameters must always be passed, or the resulting state may be
+ * incoherent.
+ *
+ * The serialization is lossy and will not survive round trips; it must only
+ * be used to feed slave state objects, and must not be used to update the
+ * master state.
+ *
+ * If you do not fit the description above, you should use
+ * xkb_state_update_key() instead.  The two functions should not generally be
+ * used together.
+ *
+ * @returns A mask of state components that have changed as a result of
+ * the update.  If nothing in the state has changed, returns 0.
+ *
+ * @memberof xkb_state
+ *
+ * @sa xkb_state_component
+ * @sa xkb_state_update_key
+ */
+enum xkb_state_component
+xkb_state_update_mask(struct xkb_state *state,
+                      xkb_mod_mask_t depressed_mods,
+                      xkb_mod_mask_t latched_mods,
+                      xkb_mod_mask_t locked_mods,
+                      xkb_layout_index_t depressed_layout,
+                      xkb_layout_index_t latched_layout,
+                      xkb_layout_index_t locked_layout);
+
+/**
+ * Get the keysyms obtained from pressing a particular key in a given
+ * keyboard state.
+ *
+ * Get the keysyms for a key according to the current active layout,
+ * modifiers and shift level for the key, as determined by a keyboard
+ * state.
+ *
+ * @param[in]  state    The keyboard state object.
+ * @param[in]  key      The keycode of the key.
+ * @param[out] syms_out An immutable array of keysyms corresponding the
+ * key in the given keyboard state.
+ *
+ * As an extension to XKB, this function can return more than one keysym.
+ * If you do not want to handle this case, you can use
+ * xkb_state_key_get_one_sym() for a simpler interface.
+ *
+ * This function does not perform any @ref keysym-transformations.
+ * (This might change).
+ *
+ * @returns The number of keysyms in the syms_out array.  If no keysyms
+ * are produced by the key in the given keyboard state, returns 0 and sets
+ * syms_out to NULL.
+ *
+ * @memberof xkb_state
+ */
+int
+xkb_state_key_get_syms(struct xkb_state *state, xkb_keycode_t key,
+                       const xkb_keysym_t **syms_out);
+
+/**
+ * Get the Unicode/UTF-8 string obtained from pressing a particular key
+ * in a given keyboard state.
+ *
+ * @param[in]  state  The keyboard state object.
+ * @param[in]  key    The keycode of the key.
+ * @param[out] buffer A buffer to write the string into.
+ * @param[in]  size   Size of the buffer.
+ *
+ * @warning If the buffer passed is too small, the string is truncated
+ * (though still NUL-terminated).
+ *
+ * @returns The number of bytes required for the string, excluding the
+ * NUL byte.  If there is nothing to write, returns 0.
+ *
+ * You may check if truncation has occurred by comparing the return value
+ * with the size of @p buffer, similarly to the snprintf(3) function.
+ * You may safely pass NULL and 0 to @p buffer and @p size to find the
+ * required size (without the NUL-byte).
+ *
+ * This function performs Capitalization and Control @ref
+ * keysym-transformations.
+ *
+ * @memberof xkb_state
+ * @since 0.4.1
+ */
+int
+xkb_state_key_get_utf8(struct xkb_state *state, xkb_keycode_t key,
+                       char *buffer, size_t size);
+
+/**
+ * Get the Unicode/UTF-32 codepoint obtained from pressing a particular
+ * key in a a given keyboard state.
+ *
+ * @returns The UTF-32 representation for the key, if it consists of only
+ * a single codepoint.  Otherwise, returns 0.
+ *
+ * This function performs Capitalization and Control @ref
+ * keysym-transformations.
+ *
+ * @memberof xkb_state
+ * @since 0.4.1
+ */
+uint32_t
+xkb_state_key_get_utf32(struct xkb_state *state, xkb_keycode_t key);
+
+/**
+ * Get the single keysym obtained from pressing a particular key in a
+ * given keyboard state.
+ *
+ * This function is similar to xkb_state_key_get_syms(), but intended
+ * for users which cannot or do not want to handle the case where
+ * multiple keysyms are returned (in which case this function is
+ * preferred).
+ *
+ * @returns The keysym.  If the key does not have exactly one keysym,
+ * returns XKB_KEY_NoSymbol
+ *
+ * This function performs Capitalization @ref keysym-transformations.
+ *
+ * @sa xkb_state_key_get_syms()
+ * @memberof xkb_state
+ */
+xkb_keysym_t
+xkb_state_key_get_one_sym(struct xkb_state *state, xkb_keycode_t key);
+
+/**
+ * Get the effective layout index for a key in a given keyboard state.
+ *
+ * @returns The layout index for the key in the given keyboard state.  If
+ * the given keycode is invalid, or if the key is not included in any
+ * layout at all, returns XKB_LAYOUT_INVALID.
+ *
+ * @invariant If the returned layout is valid, the following always holds:
+ * @code
+ * xkb_state_key_get_layout(state, key) < xkb_keymap_num_layouts_for_key(keymap, key)
+ * @endcode
+ *
+ * @memberof xkb_state
+ */
+xkb_layout_index_t
+xkb_state_key_get_layout(struct xkb_state *state, xkb_keycode_t key);
+
+/**
+ * Get the effective shift level for a key in a given keyboard state and
+ * layout.
+ *
+ * @param state The keyboard state.
+ * @param key The keycode of the key.
+ * @param layout The layout for which to get the shift level.  This must be
+ * smaller than:
+ * @code xkb_keymap_num_layouts_for_key(keymap, key) @endcode
+ * usually it would be:
+ * @code xkb_state_key_get_layout(state, key) @endcode
+ *
+ * @return The shift level index.  If the key or layout are invalid,
+ * returns XKB_LEVEL_INVALID.
+ *
+ * @invariant If the returned level is valid, the following always holds:
+ * @code
+ * xkb_state_key_get_level(state, key, layout) < xkb_keymap_num_levels_for_key(keymap, key, layout)
+ * @endcode
+ *
+ * @memberof xkb_state
+ */
+xkb_level_index_t
+xkb_state_key_get_level(struct xkb_state *state, xkb_keycode_t key,
+                        xkb_layout_index_t layout);
+
+/**
+ * Match flags for xkb_state_mod_indices_are_active() and
+ * xkb_state_mod_names_are_active(), specifying the conditions for a
+ * successful match.  XKB_STATE_MATCH_NON_EXCLUSIVE is bitmaskable with
+ * the other modes.
+ */
+enum xkb_state_match {
+    /** Returns true if any of the modifiers are active. */
+    XKB_STATE_MATCH_ANY = (1 << 0),
+    /** Returns true if all of the modifiers are active. */
+    XKB_STATE_MATCH_ALL = (1 << 1),
+    /** Makes matching non-exclusive, i.e. will not return false if a
+     *  modifier not specified in the arguments is active. */
+    XKB_STATE_MATCH_NON_EXCLUSIVE = (1 << 16)
+};
+
+/**
+ * The counterpart to xkb_state_update_mask for modifiers, to be used on
+ * the server side of serialization.
+ *
+ * @param state      The keyboard state.
+ * @param components A mask of the modifier state components to serialize.
+ * State components other than XKB_STATE_MODS_* are ignored.
+ * If XKB_STATE_MODS_EFFECTIVE is included, all other state components are
+ * ignored.
+ *
+ * @returns A xkb_mod_mask_t representing the given components of the
+ * modifier state.
+ *
+ * This function should not be used in regular clients; please use the
+ * xkb_state_mod_*_is_active API instead.
+ *
+ * @memberof xkb_state
+ */
+xkb_mod_mask_t
+xkb_state_serialize_mods(struct xkb_state *state,
+                         enum xkb_state_component components);
+
+/**
+ * The counterpart to xkb_state_update_mask for layouts, to be used on
+ * the server side of serialization.
+ *
+ * @param state      The keyboard state.
+ * @param components A mask of the layout state components to serialize.
+ * State components other than XKB_STATE_LAYOUT_* are ignored.
+ * If XKB_STATE_LAYOUT_EFFECTIVE is included, all other state components are
+ * ignored.
+ *
+ * @returns A layout index representing the given components of the
+ * layout state.
+ *
+ * This function should not be used in regular clients; please use the
+ * xkb_state_layout_*_is_active API instead.
+ *
+ * @memberof xkb_state
+ */
+xkb_layout_index_t
+xkb_state_serialize_layout(struct xkb_state *state,
+                           enum xkb_state_component components);
+
+/**
+ * Test whether a modifier is active in a given keyboard state by name.
+ *
+ * @returns 1 if the modifier is active, 0 if it is not.  If the modifier
+ * name does not exist in the keymap, returns -1.
+ *
+ * @memberof xkb_state
+ */
+int
+xkb_state_mod_name_is_active(struct xkb_state *state, const char *name,
+                             enum xkb_state_component type);
+
+/**
+ * Test whether a set of modifiers are active in a given keyboard state by
+ * name.
+ *
+ * @param state The keyboard state.
+ * @param type  The component of the state against which to match the
+ * given modifiers.
+ * @param match The manner by which to match the state against the
+ * given modifiers.
+ * @param ...   The set of of modifier names to test, terminated by a NULL
+ * argument (sentinel).
+ *
+ * @returns 1 if the modifiers are active, 0 if they are not.  If any of
+ * the modifier names do not exist in the keymap, returns -1.
+ *
+ * @memberof xkb_state
+ */
+int
+xkb_state_mod_names_are_active(struct xkb_state *state,
+                               enum xkb_state_component type,
+                               enum xkb_state_match match,
+                               ...);
+
+/**
+ * Test whether a modifier is active in a given keyboard state by index.
+ *
+ * @returns 1 if the modifier is active, 0 if it is not.  If the modifier
+ * index is invalid in the keymap, returns -1.
+ *
+ * @memberof xkb_state
+ */
+int
+xkb_state_mod_index_is_active(struct xkb_state *state, xkb_mod_index_t idx,
+                              enum xkb_state_component type);
+
+/**
+ * Test whether a set of modifiers are active in a given keyboard state by
+ * index.
+ *
+ * @param state The keyboard state.
+ * @param type  The component of the state against which to match the
+ * given modifiers.
+ * @param match The manner by which to match the state against the
+ * given modifiers.
+ * @param ...   The set of of modifier indices to test, terminated by a
+ * XKB_MOD_INVALID argument (sentinel).
+ *
+ * @returns 1 if the modifiers are active, 0 if they are not.  If any of
+ * the modifier indices are invalid in the keymap, returns -1.
+ *
+ * @memberof xkb_state
+ */
+int
+xkb_state_mod_indices_are_active(struct xkb_state *state,
+                                 enum xkb_state_component type,
+                                 enum xkb_state_match match,
+                                 ...);
+
+/**
+ * @page consumed-modifiers Consumed Modifiers
+ * @parblock
+ *
+ * Some functions, like xkb_state_key_get_syms(), look at the state of
+ * the modifiers in the keymap and derive from it the correct shift level
+ * to use for the key.  For example, in a US layout, pressing the key
+ * labeled \<A\> while the Shift modifier is active, generates the keysym
+ * 'A'.  In this case, the Shift modifier is said to be "consumed".
+ * However, the Num Lock modifier does not affect this translation at all,
+ * even if it is active, so it is not consumed by this translation.
+ *
+ * It may be desirable for some application to not reuse consumed modifiers
+ * for further processing, e.g. for hotkeys or keyboard shortcuts.  To
+ * understand why, consider some requirements from a standard shortcut
+ * mechanism, and how they are implemented:
+ *
+ * 1. The shortcut's modifiers must match exactly to the state.  For
+ *    example, it is possible to bind separate actions to \<Alt\>\<Tab\>
+ *    and to \<Alt\>\<Shift\>\<Tab\>.  Further, if only \<Alt\>\<Tab\> is
+ *    bound to an action, pressing \<Alt\>\<Shift\>\<Tab\> should not
+ *    trigger the shortcut.
+ *    Effectively, this means that the modifiers are compared using the
+ *    equality operator (==).
+ *
+ * 2. Only relevant modifiers are considered for the matching.  For example,
+ *    Caps Lock and Num Lock should not generally affect the matching, e.g.
+ *    when matching \<Alt\>\<Tab\> against the state, it does not matter
+ *    whether Num Lock is active or not.  These relevant, or "significant",
+ *    modifiers usually include Alt, Control, Shift, Super and similar.
+ *    Effectively, this means that non-significant modifiers are masked out,
+ *    before doing the comparison as described above.
+ *
+ * 3. The matching must be independent of the layout/keymap.  For example,
+ *    the \<Plus\> (+) symbol is found on the first level on some layouts,
+ *    but requires holding Shift on others.  If you simply bind the action
+ *    to the \<Plus\> keysym, it would work for the unshifted kind, but
+ *    not for the others, because the match against Shift would fail.  If
+ *    you bind the action to \<Shift\>\<Plus\>, only the shifted kind would
+ *    work.  So what is needed is to recognize that Shift is used up in the
+ *    translation of the keysym itself, and therefore should not be included
+ *    in the matching.
+ *    Effectively, this means that consumed modifiers (Shift in this example)
+ *    are masked out as well, before doing the comparison.
+ *
+ * In summary, this is how the matching would be performed:
+ * @code
+ *   (keysym == shortcut_keysym) &&
+ *   ((state_mods & ~consumed_mods & significant_mods) == shortcut_mods)
+ * @endcode
+ *
+ * @c state_mods are the modifiers reported by
+ * xkb_state_mod_index_is_active() and similar functions.
+ * @c consumed_mods are the modifiers reported by
+ * xkb_state_mod_index_is_consumed() and similar functions.
+ * @c significant_mods are decided upon by the application/toolkit/user;
+ * it is up to them to decide whether these are configurable or hard-coded.
+ *
+ * @endparblock
+ */
+
+/**
+ * Test whether a modifier is consumed by keyboard state translation for
+ * a key.
+ *
+ * @returns 1 if the modifier is consumed, 0 if it is not.  If the modifier
+ * index is not valid in the keymap, returns -1.
+ *
+ * @sa xkb_state_mod_mask_remove_consumed()
+ * @sa xkb_state_key_get_consumed_mods()
+ * @memberof xkb_state
+ */
+int
+xkb_state_mod_index_is_consumed(struct xkb_state *state, xkb_keycode_t key,
+                                xkb_mod_index_t idx);
+
+/**
+ * Remove consumed modifiers from a modifier mask for a key.
+ *
+ * Takes the given modifier mask, and removes all modifiers which are
+ * consumed for that particular key (as in xkb_state_mod_index_is_consumed()).
+ *
+ * @sa xkb_state_mod_index_is_consumed()
+ * @memberof xkb_state
+ */
+xkb_mod_mask_t
+xkb_state_mod_mask_remove_consumed(struct xkb_state *state, xkb_keycode_t key,
+                                   xkb_mod_mask_t mask);
+
+/**
+ * Get the mask of modifiers consumed by translating a given key.
+ *
+ * @returns a mask of the consumed modifiers.
+ *
+ * @sa xkb_state_mod_index_is_consumed()
+ * @memberof xkb_state
+ * @since 0.4.1
+ */
+xkb_mod_mask_t
+xkb_state_key_get_consumed_mods(struct xkb_state *state, xkb_keycode_t key);
+
+/**
+ * Test whether a layout is active in a given keyboard state by name.
+ *
+ * @returns 1 if the layout is active, 0 if it is not.  If no layout with
+ * this name exists in the keymap, return -1.
+ *
+ * If multiple layouts in the keymap have this name, the one with the lowest
+ * index is tested.
+ *
+ * @sa xkb_layout_index_t
+ * @memberof xkb_state
+ */
+int
+xkb_state_layout_name_is_active(struct xkb_state *state, const char *name,
+                                enum xkb_state_component type);
+
+/**
+ * Test whether a layout is active in a given keyboard state by index.
+ *
+ * @returns 1 if the layout is active, 0 if it is not.  If the layout index
+ * is not valid in the keymap, returns -1.
+ *
+ * @sa xkb_layout_index_t
+ * @memberof xkb_state
+ */
+int
+xkb_state_layout_index_is_active(struct xkb_state *state,
+                                 xkb_layout_index_t idx,
+                                 enum xkb_state_component type);
+
+/**
+ * Test whether a LED is active in a given keyboard state by name.
+ *
+ * @returns 1 if the LED is active, 0 if it not.  If no LED with this name
+ * exists in the keymap, returns -1.
+ *
+ * @sa xkb_led_index_t
+ * @memberof xkb_state
+ */
+int
+xkb_state_led_name_is_active(struct xkb_state *state, const char *name);
+
+/**
+ * Test whether a LED is active in a given keyboard state by index.
+ *
+ * @returns 1 if the LED is active, 0 if it not.  If the LED index is not
+ * valid in the keymap, returns -1.
+ *
+ * @sa xkb_led_index_t
+ * @memberof xkb_state
+ */
+int
+xkb_state_led_index_is_active(struct xkb_state *state, xkb_led_index_t idx);
+
+/** @} */
+
+/* Leave this include last, so it can pick up our types, etc. */
+#include <xkbcommon/xkbcommon-compat.h>
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* _XKBCOMMON_H_ */
diff --git a/src/plugins/platforminputcontexts/hime/hime-imcontext-qt.cpp b/src/plugins/platforminputcontexts/hime/hime-imcontext-qt.cpp
new file mode 100644
index 0000000..0ffc6f4
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/hime-imcontext-qt.cpp
@@ -0,0 +1,341 @@
+#include <QtGui/QKeyEvent>
+#include <QtGui/QGuiApplication>
+#include <QtGui/QInputMethod>
+#include <QtGui/QTextCharFormat>
+#include <QtGui/QPalette>
+#include <QtGui/QWindow>
+
+#include <unistd.h>
+#include <errno.h>
+#include <signal.h>
+
+// confliction of qt & x11
+typedef unsigned int KeySym;
+struct Display;
+typedef unsigned int Window;
+typedef struct {
+    short x, y;
+} XPoint;
+
+#include "include/util.h"
+#include "include/im-client/hime-im-client.h"
+#include "hime-imcontext-qt.h"
+
+static WId focused_win;
+
+#include <QtGui/qpa/qplatformnativeinterface.h>
+
+#if DEBUG
+FILE *out_fp;
+void __hime_dbg_(const char *fmt,...)
+{
+    va_list args;
+
+    if (!out_fp) {
+#if 0
+        out_fp = fopen("/tmp/a.txt", "w");
+#else
+        out_fp = stdout;
+#endif
+    }
+
+    va_start(args, fmt);
+    vfprintf(out_fp, fmt, args);
+    fflush(out_fp);
+    va_end(args);
+}
+#endif
+
+QHimePlatformInputContext::QHimePlatformInputContext()
+{
+    dbg("QHimePlatformInputContext::QHimePlatformInputContext() \n");
+    QPlatformNativeInterface *native = QGuiApplication::platformNativeInterface();
+    if(!native)
+        return;
+    Display *display = static_cast<Display *>(native->nativeResourceForWindow("display", NULL));
+
+    if (!(hime_ch = hime_im_client_open(display))) {
+        perror("cannot open hime_ch");
+        dbg("hime_im_client_open error\n");
+        return;
+    }
+
+    dbg("QHimePlatformInputContext succ\n");
+}
+
+QHimePlatformInputContext::~QHimePlatformInputContext()
+{
+    if (hime_ch==NULL)
+        return;
+      hime_im_client_close(hime_ch);
+    hime_ch = NULL;
+}
+
+
+bool QHimePlatformInputContext::isValid() const
+{
+    dbg("QHimePlatformInputContext::isValid()\n");
+    return true;
+}
+
+void QHimePlatformInputContext::invokeAction(QInputMethod::Action action, int cursorPosition)
+{
+    dbg("QHimePlatformInputContext::invokeAction(n");
+    // FIXME nop? remove me
+}
+
+void QHimePlatformInputContext::commitPreedit()
+{
+    dbg("QHimePlatformInputContext::commitPreedit\n");
+    // use this to flush
+    int preedit_cursor_position=0;
+    int sub_comp_len;
+    char *str=NULL;
+    HIME_PREEDIT_ATTR att[HIME_PREEDIT_ATTR_MAX_N];
+    hime_im_client_get_preedit(hime_ch, &str, att, &preedit_cursor_position, &sub_comp_len);
+    if (str) {
+        if (strlen(str) > 0) {
+            dbg("send enter to flush\n");
+            send_key_press(0xff0d, 0); // Enter
+        } else {
+            dbg("empty string\n");
+        }
+
+        free(str);
+        update_preedit();
+    } else {
+        dbg("no str\n");
+    }
+}
+
+
+void QHimePlatformInputContext::reset()
+{
+    dbg("QHimePlatformInputContext::reset()\n");
+    if (hime_ch) {
+        hime_im_client_reset(hime_ch);
+        update_preedit();
+    }
+}
+
+void QHimePlatformInputContext::update(Qt::InputMethodQueries queries )
+{
+    dbg("QHimePlatformInputContext::update\n");
+    QObject *input = qApp->focusObject();
+    if (!input)
+        return;
+
+    QInputMethodQueryEvent query(queries);
+    QGuiApplication::sendEvent(input, &query);
+
+    if (queries & Qt::ImCursorRectangle) {
+        cursorMoved();
+    }
+}
+
+// this one is essential
+void QHimePlatformInputContext::commit()
+{
+    dbg("QHimePlatformInputContext::commit()\n");
+    commitPreedit();
+}
+
+
+void QHimePlatformInputContext::setFocusObject(QObject* object)
+{
+    dbg("QHimePlatformInputContext::setFocusObject\n");
+    QWindow *window = qApp->focusWindow();
+    if (!window) {
+        dbg("no window, focus out\n");
+        focused_win = 0;
+        char *rstr = NULL;
+        hime_im_client_focus_out2(hime_ch, &rstr);
+        if (rstr) {
+            send_str(rstr);
+        } else {
+            dbg("no str in preedit\n");
+        }
+        return;
+    }
+
+    WId win = window->winId();
+
+    if (focused_win && win != focused_win) {
+        if (hime_ch) {
+            hime_im_client_focus_out(hime_ch);
+        }
+    }
+
+    focused_win = win;
+
+    if (hime_ch) {
+        hime_im_client_set_window(hime_ch, win);
+        hime_im_client_focus_in(hime_ch);
+        cursorMoved();
+    }
+}
+
+static int last_x=-1, last_y=-1;
+
+void QHimePlatformInputContext::cursorMoved()
+{
+    dbg(" QHimePlatformInputContext::cursorMoved()\n");
+
+    QWindow *inputWindow = qApp->focusWindow();
+    if (!inputWindow)
+        return;
+
+    QRect r = qApp->inputMethod()->cursorRectangle().toRect();
+    if(!r.isValid())
+        return;
+
+    // hime server will clear the string if the cursor is moved, make sure the x,y is valid
+    int x = r.left(),  y = r.bottom();
+    if (x > inputWindow->width() || y > inputWindow->height() || x < 0 || y < 0)
+        return;
+
+    if (hime_ch && (x !=  last_x || y != last_y)) {
+        last_x = x; last_y = y;
+        dbg("move cursor %d, %d\n", x, y);
+        hime_im_client_set_cursor_location(hime_ch, x,  y);
+    }
+}
+
+
+
+void QHimePlatformInputContext::update_preedit()
+{
+    if (!hime_ch)
+        return;
+    QList<QInputMethodEvent::Attribute> attrList;
+//  QString preedit_string;
+    int preedit_cursor_position=0;
+    int sub_comp_len;
+    char *str=NULL;
+    HIME_PREEDIT_ATTR att[HIME_PREEDIT_ATTR_MAX_N];
+    int attN = hime_im_client_get_preedit(hime_ch, &str, att, &preedit_cursor_position, &sub_comp_len);
+
+    int ret;
+    hime_im_client_set_flags(hime_ch, FLAG_HIME_client_handle_use_preedit, &ret);
+
+    QObject *input = qApp->focusObject();
+
+    if (!input || !str) {
+      free(str);
+      return;
+    }
+
+
+#if DEBUG
+    dbg("update_preedit attN:%d '%s'\n", attN, str);
+#endif
+
+    int i;
+    for(i=0; i < attN; i++) {
+        int ofs0 = att[i].ofs0;
+        int len = att[i].ofs1 - att[i].ofs0;
+        QTextCharFormat format;
+
+        switch (att[i].flag) {
+            case HIME_PREEDIT_ATTR_FLAG_REVERSE:
+            {
+                QBrush brush;
+                QPalette palette;
+                palette = QGuiApplication::palette();
+                format.setBackground(QBrush(QColor(palette.color(QPalette::Active, QPalette::Highlight))));
+                format.setForeground(QBrush(QColor(palette.color(QPalette::Active, QPalette::HighlightedText))));
+            }
+            break;
+            case HIME_PREEDIT_ATTR_FLAG_UNDERLINE:
+            {
+                format.setUnderlineStyle(QTextCharFormat::DashUnderline);
+            }
+            break;
+            default:
+                ;
+        }
+
+        attrList.append(QInputMethodEvent::Attribute(QInputMethodEvent::TextFormat, ofs0,  len, format));
+    }
+
+    attrList.append(QInputMethodEvent::Attribute(QInputMethodEvent::Cursor,  preedit_cursor_position, 1, 0));
+
+    QInputMethodEvent im_event (QString::fromUtf8(str), attrList);
+    send_event (im_event);
+    free(str);
+}
+
+void QHimePlatformInputContext::send_event(QInputMethodEvent e) {
+    QObject *input = qApp->focusObject();
+    if (!input)
+        return;
+    QCoreApplication::sendEvent(input, &e);
+}
+
+void QHimePlatformInputContext::send_str(char *rstr) {
+    dbg("send_str %s\n",  rstr);
+    QString inputText = QString::fromUtf8(rstr);
+    free(rstr);
+    QInputMethodEvent commit_event;
+    commit_event.setCommitString (inputText);
+    send_event (commit_event);
+}
+
+bool QHimePlatformInputContext::send_key_press(quint32 keysym, quint32 state) {
+    dbg("send_key_press\n");
+    char *rstr  = NULL;
+    int result = hime_im_client_forward_key_press(hime_ch, keysym, state, &rstr);
+
+    if (rstr) {
+        send_str(rstr);
+    }
+
+    return result;
+}
+
+bool QHimePlatformInputContext::filterEvent(const QEvent* event)
+{
+    dbg("QHimePlatformInputContext::filterEvent\n");
+    if (event->type() != QEvent::KeyPress && event->type() != QEvent::KeyRelease) {
+        goto ret;
+    }
+
+    const QKeyEvent* keyEvent;
+    keyEvent = static_cast<const QKeyEvent*>(event);
+    quint32 keysym ;
+    keysym = keyEvent->nativeVirtualKey();
+    quint32  state;
+    state = keyEvent->nativeModifiers();
+
+    if (!inputMethodAccepted()) {
+        goto ret;
+    }
+
+    QObject *input;
+    input = qApp->focusObject();
+
+    if (!input) {
+        goto ret;
+    }
+
+    int result;
+    if (event->type() == QEvent::KeyPress) {
+        if (send_key_press(keysym, state)) {
+            update_preedit();
+            return true;
+        }
+    } else {
+        char *rstr = NULL;
+        result = hime_im_client_forward_key_release(hime_ch,   keysym, state, &rstr);
+        if (rstr) {
+            free(rstr);
+        }
+
+        if (result) {
+            return true;
+        }
+    }
+
+ret:
+    return QPlatformInputContext::filterEvent(event);
+}
diff --git a/src/plugins/platforminputcontexts/hime/hime-imcontext-qt.h b/src/plugins/platforminputcontexts/hime/hime-imcontext-qt.h
new file mode 100644
index 0000000..784396f
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/hime-imcontext-qt.h
@@ -0,0 +1,34 @@
+#ifndef HIME_QT5_IM_H
+#define HIME_QT5_IM_H
+
+#include <QtGui/qpa/qplatforminputcontext.h>
+
+class QInputMethodEvent;
+struct HIME_client_handle_S;
+
+class QHimePlatformInputContext : public QPlatformInputContext
+{
+    Q_OBJECT
+public:
+    QHimePlatformInputContext();
+    virtual ~QHimePlatformInputContext();
+
+    virtual bool filterEvent(const QEvent* event);
+    virtual bool isValid() const;
+    virtual void invokeAction(QInputMethod::Action , int cursorPosition);
+    virtual void reset();
+    virtual void commit();
+    virtual void update(Qt::InputMethodQueries quries );
+    virtual void setFocusObject(QObject* object);
+
+private:
+    HIME_client_handle_S *hime_ch;
+    void send_event(QInputMethodEvent e);
+    void update_preedit();
+    void cursorMoved();
+    bool send_key_press(quint32 keysym, quint32 state);
+    void commitPreedit();
+    void send_str(char *s);
+};
+
+#endif
diff --git a/src/plugins/platforminputcontexts/hime/hime-qt.cpp b/src/plugins/platforminputcontexts/hime/hime-qt.cpp
new file mode 100644
index 0000000..c7786a8
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/hime-qt.cpp
@@ -0,0 +1,24 @@
+#include <cstdio>
+
+#include "hime-qt.h"
+#include "include/util.h"
+
+#define HIMEID "hime"
+
+
+QStringList QHimePlatformInputContextPlugin::keys() const
+{
+    dbg("QStringList QHimePlatformInputContextPlugin::keys()\n");
+    return QStringList(QStringLiteral(HIMEID));
+
+}
+
+QHimePlatformInputContext *QHimePlatformInputContextPlugin::create(const QString& system, const QStringList& paramList)
+{
+    Q_UNUSED(paramList);
+    dbg("QHimePlatformInputContextPlugin::create()\n");
+
+    if (system.compare(system, QStringLiteral(HIMEID), Qt::CaseInsensitive) == 0)
+        return new QHimePlatformInputContext;
+    return 0;
+}
diff --git a/src/plugins/platforminputcontexts/hime/hime-qt.h b/src/plugins/platforminputcontexts/hime/hime-qt.h
new file mode 100644
index 0000000..0e98a17
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/hime-qt.h
@@ -0,0 +1,19 @@
+#ifndef HIME_QT5_PLUGIN_H
+#define HIME_QT5_PLUGIN_H
+
+#include <QtCore/QStringList>
+#include <QtGui/qpa/qplatforminputcontextplugin_p.h>
+
+#include "hime-imcontext-qt.h"
+
+
+class QHimePlatformInputContextPlugin : public QPlatformInputContextPlugin
+{
+    Q_OBJECT
+public:
+    Q_PLUGIN_METADATA(IID QPlatformInputContextFactoryInterface_iid FILE "hime.json")
+    QStringList keys() const;
+    QHimePlatformInputContext *create(const QString& system, const QStringList& paramList);
+};
+
+#endif
diff --git a/src/plugins/platforminputcontexts/hime/hime.json b/src/plugins/platforminputcontexts/hime/hime.json
new file mode 100644
index 0000000..f737430
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/hime.json
@@ -0,0 +1,3 @@
+{
+    "Keys": [ "hime" ]
+}
diff --git a/src/plugins/platforminputcontexts/hime/hime.pro b/src/plugins/platforminputcontexts/hime/hime.pro
new file mode 100644
index 0000000..cb0e098
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/hime.pro
@@ -0,0 +1,75 @@
+TARGET = himeplatforminputcontextplugin
+
+QT += dbus gui-private
+SOURCES += $$PWD/hime-imcontext-qt.cpp \
+           $$PWD/hime-qt.cpp \
+           $$PWD/include/gtab.c \
+           $$PWD/include/pho.c \
+           $$PWD/include/tsin-parse.c \
+           $$PWD/include/im-client/hime-im-client.c \
+           $$PWD/include/im-client/hime-send.c \
+           $$PWD/include/hime-conf.c \
+           $$PWD/include/IC.c \
+           $$PWD/include/util.c \
+           $$PWD/include/gtab-buf.c \
+           $$PWD/include/im-srv.c \
+           $$PWD/include/im-addr.c \
+           $$PWD/include/hime.c \
+           $$PWD/include/hime-crypt.c \
+           $$PWD/include/lang.c \
+           $$PWD/include/win1.c \
+           $$PWD/include/tsin.c \
+           $$PWD/include/win-save-phrase.c \
+           $$PWD/include/IMdkit/lib/i18nX.c \
+           $$PWD/include/IMdkit/lib/i18nClbk.c \
+           $$PWD/include/IMdkit/lib/i18nPtHdr.c \
+           $$PWD/include/IMdkit/lib/IMConn.c \
+           $$PWD/include/IMdkit/lib/IMMethod.c \
+           $$PWD/include/IMdkit/lib/i18nIMProto.c \
+           $$PWD/include/IMdkit/lib/FrameMgr.c \
+           $$PWD/include/IMdkit/lib/i18nIc.c \
+           $$PWD/include/IMdkit/lib/i18nUtil.c \
+           $$PWD/include/IMdkit/lib/i18nMethod.c \
+           $$PWD/include/IMdkit/lib/i18nAttr.c
+
+
+HEADERS += $$PWD/hime-imcontext-qt.h \
+           $$PWD/hime-qt.h \
+           $$PWD/include/os-dep.h \
+           $$PWD/include/pho-status.h \
+           $$PWD/include/hime-gtk-compatible.h \
+           $$PWD/include/pho.h \
+           $$PWD/include/util.h \
+           $$PWD/include/im-client/hime-im-client.h \
+           $$PWD/include/im-client/hime-protocol.h \
+           $$PWD/include/im-client/hime-im-client-attr.h \
+           $$PWD/include/tsin-parse.h \
+           $$PWD/include/im-srv.h \
+           $$PWD/include/IC.h \
+           $$PWD/include/gtab.h \
+           $$PWD/include/hime-endian.h \
+           $$PWD/include/hime-conf.h \
+           $$PWD/include/lang.h \
+           $$PWD/include/hime.h \
+           $$PWD/include/win-save-phrase.h \
+           $$PWD/include/config.h \
+           $$PWD/include/gst.h \
+           $$PWD/include/gtab-buf.h \
+           $$PWD/include/IMdkit/lib/Xi18nX.h \
+           $$PWD/include/IMdkit/lib/XimFunc.h \
+           $$PWD/include/IMdkit/lib/FrameMgr.h \
+           $$PWD/include/IMdkit/include/IMdkit.h \
+           $$PWD/include/IMdkit/include/Xi18n.h \
+           $$PWD/include/IMdkit/include/XimProto.h \
+           $$PWD/include/tsin.h \
+           $$PWD/include/win1.h
+
+OTHER_FILES += $$PWD/hime.json
+
+DEFINES += HIME_VERSION=\"\\\"0.9.10\\\"\" USE_XIM HIME_TABLE_DIR=\"\\\"/usr/local/share/hime/table\\\"\" HIME_BIN_DIR=\"\\\"/usr/local/bin\\\"\"
+CONFIG += link_pkgconfig
+PKGCONFIG += glib-2.0 gtk+-2.0
+PLUGIN_TYPE = platforminputcontexts
+PLUGIN_EXTENDS = -
+PLUGIN_CLASS_NAME = QHimePlatformInputContextPlugin
+load(qt_plugin)
diff --git a/src/plugins/platforminputcontexts/hime/include/IC.c b/src/plugins/platforminputcontexts/hime/include/IC.c
new file mode 100644
index 0000000..eee4d3c
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IC.c
@@ -0,0 +1,467 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+******************************************************************/
+#include "hime.h"
+
+#undef DEBUG
+
+static IC *ic_list = (IC *)NULL;
+static IC *free_list = (IC *)NULL;
+
+void move_IC_in_win(ClientState *cs);
+
+static void free_IC_list(IC *list)
+{
+    while (list) {
+       IC *next = list->next;
+       free(list);
+       list = next;
+    }
+}
+
+void free_all_IC()
+{
+    free_IC_list(ic_list);
+    free_IC_list(free_list);
+}
+
+
+static IC
+*NewIC()
+{
+    static CARD16 icid = 0;
+    IC *rec;
+
+    if (free_list != NULL) {
+	rec = free_list;
+	free_list = free_list->next;
+    } else {
+	rec = (IC *)malloc(sizeof(IC));
+    }
+
+    bzero(rec, sizeof(IC));
+    rec->cs.input_style = InputStyleOverSpot;
+    rec->id = ++icid;
+
+    rec->next = ic_list;
+    ic_list = rec;
+    return rec;
+}
+
+IC *FindIC(CARD16 icid)
+{
+    IC *rec = ic_list;
+
+    while (rec != NULL) {
+	if (rec->id == icid)
+	  return rec;
+	rec = rec->next;
+    }
+
+    return NULL;
+}
+
+void hide_in_win(ClientState *ic);
+
+void DeleteIC(CARD16 icid)
+{
+    IC *rec, *last;
+
+    last = NULL;
+    for (rec = ic_list; rec != NULL; last = rec, rec = rec->next) {
+        if (rec->id == icid) {
+
+          if (&rec->cs == current_CS) {
+            hide_in_win(&rec->cs);
+          }
+
+          if (last != NULL)
+            last->next = rec->next;
+          else
+            ic_list = rec->next;
+
+          rec->next = free_list;
+          free_list = rec;
+          return;
+	}
+    }
+    return;
+}
+
+static int Is(char *attr, XICAttribute *attr_list) {
+	return !strcmp(attr, attr_list->name);
+}
+
+extern Window root;
+extern Display *dpy;
+
+
+void move_in_win(ClientState *cs, int x, int y);
+void show_in_win(ClientState *cs);
+extern Window focus_win;
+void save_CS_temp_to_current();
+
+void load_IC(IC *rec)
+{
+   ClientState *cs = &rec->cs;
+   Window win = cs->client_win;
+
+   if (win == focus_win && !current_CS) {
+     current_CS = cs;
+     save_CS_temp_to_current();
+   }
+
+   if (win == focus_win) {
+     if (cs->im_state == HIME_STATE_DISABLED)
+       hide_in_win(cs);
+     else
+     if (cs->im_state != HIME_STATE_DISABLED)
+       show_in_win(cs);
+   }
+
+   if (cs->input_style & InputStyleOnSpot) {
+     if (cs->im_state != HIME_STATE_DISABLED)
+       move_IC_in_win(cs);
+   } else
+   if (cs->input_style & InputStyleOverSpot) {
+     if (cs->im_state != HIME_STATE_DISABLED)
+       move_IC_in_win(cs);
+   } else
+   if (cs->input_style & InputStyleRoot) {
+     move_IC_in_win(cs);
+   }
+}
+
+
+static void
+StoreIC(IC *rec, IMChangeICStruct *call_data)
+{
+        ClientState *cs = &rec->cs;
+	XICAttribute *ic_attr = call_data->ic_attr;
+	XICAttribute *pre_attr = call_data->preedit_attr;
+	XICAttribute *sts_attr = call_data->status_attr;
+	register int i;
+
+	if (!current_CS) {
+          current_CS = cs;
+          save_CS_temp_to_current();
+        }
+#if DEBUG && 0
+        dbg(".... StoreIC\n");
+#endif
+	for (i = 0; i < (int)call_data->ic_attr_num; i++, ic_attr++) {
+		if (Is (XNInputStyle, ic_attr)) {
+                    INT32 input_style = *(INT32*)ic_attr->value;
+
+                    if (input_style & XIMPreeditCallbacks) {
+                      cs->input_style = InputStyleOnSpot;
+                    } else
+                    if (input_style & XIMPreeditPosition) {
+                      cs->input_style = InputStyleOverSpot;
+                    } else
+                    if (input_style & XIMPreeditNothing) {
+                        cs->input_style = InputStyleRoot;
+                    }
+		}
+
+		else if (Is (XNClientWindow, ic_attr)) {
+                    rec->cs.client_win = *(Window*)ic_attr->value;
+#if DEBUG
+		    dbg("rec->client_win %x\n", cs->client_win);
+#endif
+		}
+		else if (Is (XNFocusWindow, ic_attr)) {
+                    rec->focus_win = *(Window*)ic_attr->value;
+                }
+		else
+		    fprintf(stderr, "Unknown attr: %s a\n", ic_attr->name);
+	}
+
+	for (i = 0; i < (int)call_data->preedit_attr_num; i++, pre_attr++) {
+		if (Is (XNArea, pre_attr)) {
+                    rec->pre_attr.area = *(XRectangle*)pre_attr->value;
+#if DEBUG
+                   dbg("pre_attr->value: %d %d\n", rec->pre_attr.area.x, rec->pre_attr.area.y);
+#endif
+                }
+		else if (Is (XNAreaNeeded, pre_attr))
+		    rec->pre_attr.area_needed = *(XRectangle*)pre_attr->value;
+
+		else if (Is (XNSpotLocation, pre_attr)) {
+                    cs->spot_location = *(XPoint*)pre_attr->value;
+                    move_IC_in_win(cs);
+                }
+		else if (Is (XNColormap, pre_attr))
+		    rec->pre_attr.cmap = *(Colormap*)pre_attr->value;
+
+		else if (Is (XNStdColormap, pre_attr))
+		    rec->pre_attr.cmap = *(Colormap*)pre_attr->value;
+
+		else if (Is (XNForeground, pre_attr))
+		    rec->pre_attr.foreground = *(CARD32*)pre_attr->value;
+
+		else if (Is (XNBackground, pre_attr))
+		    rec->pre_attr.background = *(CARD32*)pre_attr->value;
+
+		else if (Is (XNBackgroundPixmap, pre_attr))
+		    rec->pre_attr.bg_pixmap = *(Pixmap*)pre_attr->value;
+
+		else if (Is (XNFontSet, pre_attr)) {
+			int str_length = strlen((char *)pre_attr->value);
+
+			if (rec->pre_attr.base_font != NULL) {
+				if (Is (rec->pre_attr.base_font, pre_attr))
+					continue;
+				XFree(rec->pre_attr.base_font);
+			}
+			rec->pre_attr.base_font = (char *)malloc(str_length + 1);
+			strcpy(rec->pre_attr.base_font, (char *)pre_attr->value);
+
+		} else if (Is (XNLineSpace, pre_attr))
+			    rec->pre_attr.line_space = *(CARD32*)pre_attr->value;
+
+		else if (Is (XNCursor, pre_attr))
+		    rec->pre_attr.cursor = *(Cursor*)pre_attr->value;
+
+		else
+		    fprintf(stderr, "Unknown attr: %s b\n", pre_attr->name);
+	}
+
+
+	for (i = 0; i < (int)call_data->status_attr_num; i++, sts_attr++) {
+                if (Is (XNArea, sts_attr)) {
+		    rec->sts_attr.area = *(XRectangle*)sts_attr->value;
+                }
+                else if (Is (XNAreaNeeded, sts_attr)) {
+		    rec->sts_attr.area_needed = *(XRectangle*)sts_attr->value;
+                }
+                else if (Is (XNColormap, sts_attr)) {
+		    rec->sts_attr.cmap = *(Colormap*)sts_attr->value;
+                }
+                else if (Is (XNStdColormap, sts_attr)) {
+		    rec->sts_attr.cmap = *(Colormap*)sts_attr->value;
+		}
+                else if (Is (XNForeground, sts_attr)) {
+		    rec->sts_attr.foreground = *(CARD32*)sts_attr->value;
+                }
+		else if (Is (XNBackground, sts_attr))
+		    rec->sts_attr.background = *(CARD32*)sts_attr->value;
+
+		else if (Is (XNBackgroundPixmap, sts_attr))
+		    rec->sts_attr.bg_pixmap = *(Pixmap*)sts_attr->value;
+
+                else if (Is (XNFontSet, sts_attr)) {
+			int str_length = strlen((char *)sts_attr->value);
+
+			if (rec->sts_attr.base_font != NULL) {
+				if (Is (rec->sts_attr.base_font, sts_attr))
+					continue;
+				XFree(rec->sts_attr.base_font);
+			}
+			rec->sts_attr.base_font = (char *)malloc(str_length + 1);
+			strcpy(rec->sts_attr.base_font, (char *)sts_attr->value);
+                } else if (Is (XNLineSpace, sts_attr)) {
+			    rec->sts_attr.line_space= *(CARD32*)sts_attr->value;
+                }
+		else if (Is (XNCursor, sts_attr))
+		    rec->sts_attr.cursor = *(Cursor*)sts_attr->value;
+
+		else
+		    fprintf(stderr, "Unknown attr: %s c\n", ic_attr->name);
+	}
+
+	load_IC(rec);
+#if DEBUG && 0
+        dbg("exit StoreIC\n");
+#endif
+}
+
+void CreateIC(IMChangeICStruct *call_data)
+{
+    IC *rec;
+
+    rec = NewIC();
+    if (rec == NULL)
+      return;
+
+    StoreIC(rec, call_data);
+    call_data->icid = rec->id;
+    load_IC(rec);
+#if DEBUG && 0
+    dbg("CreateIC  .. exit\n");
+#endif
+    return;
+}
+
+#if 0
+void
+DestroyIC(call_data)
+IMChangeICStruct *call_data;
+{
+    DeleteIC(call_data->icid);
+    return;
+}
+#endif
+
+void SetIC(IMChangeICStruct * call_data)
+{
+    IC *rec = FindIC(call_data->icid);
+
+    if (rec == NULL)
+      return;
+
+    load_IC(rec);
+
+    StoreIC(rec, call_data);
+#if DEBUG
+    dbg(".... exit SetIC\n");
+#endif
+    return;
+}
+
+void GetIC(IMChangeICStruct *call_data)
+{
+    XICAttribute *ic_attr = call_data->ic_attr;
+    XICAttribute *pre_attr = call_data->preedit_attr;
+    XICAttribute *sts_attr = call_data->status_attr;
+    register int i;
+    IC *rec = FindIC(call_data->icid);
+
+    if (rec == NULL)
+      return;
+
+    ClientState *cs = &rec->cs;
+
+    for (i = 0; i < (int)call_data->ic_attr_num; i++, ic_attr++) {
+	if (Is (XNFilterEvents, ic_attr)) {
+	    ic_attr->value = (void *)malloc(sizeof(CARD32));
+	    *(CARD32*)ic_attr->value = KeyPressMask|KeyReleaseMask;
+	    ic_attr->value_length = sizeof(CARD32);
+	}
+    }
+
+    /* preedit attributes */
+    for (i = 0; i < (int)call_data->preedit_attr_num; i++, pre_attr++) {
+	if (Is (XNArea, pre_attr)) {
+	    pre_attr->value = (void *)malloc(sizeof(XRectangle));
+            *(XRectangle*)pre_attr->value = rec->pre_attr.area;
+            pre_attr->value_length = sizeof(XRectangle);
+#if DEBUG
+            dbg("pre_attr->value: %d %d\n", rec->pre_attr.area.x, rec->pre_attr.area.y);
+#endif
+
+	} else if (Is (XNAreaNeeded, pre_attr)) {
+	    pre_attr->value = (void *)malloc(sizeof(XRectangle));
+	    *(XRectangle*)pre_attr->value = rec->pre_attr.area_needed;
+	    pre_attr->value_length = sizeof(XRectangle);
+
+	} else if (Is (XNSpotLocation, pre_attr)) {
+	    pre_attr->value = (void *)malloc(sizeof(XPoint));
+            *(XPoint*)pre_attr->value = cs->spot_location;
+	    pre_attr->value_length = sizeof(XPoint);
+#if DEBUG
+            dbg("over spot %d %d\n", cs->spot_location.x,  cs->spot_location.y);
+#endif
+	} else if (Is (XNFontSet, pre_attr)) {
+	    CARD16 base_len = (CARD16)strlen(rec->pre_attr.base_font);
+	    int total_len = sizeof(CARD16) + (CARD16)base_len;
+	    char *p;
+
+	    pre_attr->value = (void *)malloc(total_len);
+	    p = (char *)pre_attr->value;
+	    memmove(p, &base_len, sizeof(CARD16));
+	    p += sizeof(CARD16);
+	    strncpy(p, rec->pre_attr.base_font, base_len);
+	    pre_attr->value_length = total_len;
+
+	} else if (Is (XNForeground, pre_attr)) {
+	    pre_attr->value = (void *)malloc(sizeof(long));
+	    *(long*)pre_attr->value = rec->pre_attr.foreground;
+	    pre_attr->value_length = sizeof(long);
+
+	} else if (Is (XNBackground, pre_attr)) {
+	    pre_attr->value = (void *)malloc(sizeof(long));
+	    *(long*)pre_attr->value = rec->pre_attr.background;
+	    pre_attr->value_length = sizeof(long);
+
+	} else if (Is (XNLineSpace, pre_attr)) {
+	    pre_attr->value = (void *)malloc(sizeof(long));
+#if 0
+	    *(long*)pre_attr->value = rec->pre_attr.line_space;
+#endif
+	    *(long*)pre_attr->value = 18;
+	    pre_attr->value_length = sizeof(long);
+	}
+    }
+
+    /* status attributes */
+    for (i = 0; i < (int)call_data->status_attr_num; i++, sts_attr++) {
+	if (Is (XNArea, sts_attr)) {
+	    sts_attr->value = (void *)malloc(sizeof(XRectangle));
+	    *(XRectangle*)sts_attr->value = rec->sts_attr.area;
+	    sts_attr->value_length = sizeof(XRectangle);
+
+	} else if (Is (XNAreaNeeded, sts_attr)) {
+	    sts_attr->value = (void *)malloc(sizeof(XRectangle));
+	    *(XRectangle*)sts_attr->value = rec->sts_attr.area_needed;
+	    sts_attr->value_length = sizeof(XRectangle);
+
+	} else if (Is (XNFontSet, sts_attr)) {
+	    CARD16 base_len = (CARD16)strlen(rec->sts_attr.base_font);
+	    int total_len = sizeof(CARD16) + (CARD16)base_len;
+	    char *p;
+
+	    sts_attr->value = (void *)malloc(total_len);
+	    p = (char *)sts_attr->value;
+	    memmove(p, &base_len, sizeof(CARD16));
+	    p += sizeof(CARD16);
+	    strncpy(p, rec->sts_attr.base_font, base_len);
+	    sts_attr->value_length = total_len;
+
+	} else if (Is (XNForeground, sts_attr)) {
+	    sts_attr->value = (void *)malloc(sizeof(long));
+	    *(long*)sts_attr->value = rec->sts_attr.foreground;
+	    sts_attr->value_length = sizeof(long);
+
+	} else if (Is (XNBackground, sts_attr)) {
+	    sts_attr->value = (void *)malloc(sizeof(long));
+	    *(long*)sts_attr->value = rec->sts_attr.background;
+	    sts_attr->value_length = sizeof(long);
+
+	} else if (Is (XNLineSpace, sts_attr)) {
+	    sts_attr->value = (void *)malloc(sizeof(long));
+#if 0
+	    *(long*)sts_attr->value = rec->sts_attr.line_space;
+#endif
+	    *(long*)sts_attr->value = 18;
+	    sts_attr->value_length = sizeof(long);
+	}
+    }
+}
+
+
diff --git a/src/plugins/platforminputcontexts/hime/include/IC.h b/src/plugins/platforminputcontexts/hime/include/IC.h
new file mode 100644
index 0000000..d659f36
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IC.h
@@ -0,0 +1,85 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+******************************************************************/
+typedef struct {
+    XRectangle	area;		/* area */
+    XRectangle	area_needed;	/* area needed */
+    Colormap	cmap;		/* colormap */
+    CARD32	foreground;	/* foreground */
+    CARD32	background;	/* background */
+    Pixmap	bg_pixmap;	/* background pixmap */
+    char	*base_font;	/* base font of fontset */
+    CARD32	line_space;	/* line spacing */
+    Cursor	cursor;		/* cursor */
+} PreeditAttributes;
+
+typedef struct {
+    XRectangle	area;		/* area */
+    XRectangle	area_needed;	/* area needed */
+    Colormap	cmap;		/* colormap */
+    CARD32	foreground;	/* foreground */
+    CARD32	background;	/* background */
+    Pixmap	bg_pixmap;	/* background pixmap */
+    char	*base_font;	/* base font of fontset */
+    CARD32	line_space;	/* line spacing */
+    Cursor	cursor;		/* cursor */
+} StatusAttributes;
+
+typedef struct {
+    Window	client_win;	/* client window */
+    INT32	input_style;	/* input style */
+    HIME_STATE_E im_state;
+    gboolean    b_half_full_char;
+    gboolean    fixed_pos;
+    gboolean    b_hime_protocol; // TRUE : hime    FALSE: XIM
+    gboolean    b_raise_window;
+    gboolean    use_preedit;
+    gboolean    tsin_pho_mode;
+    short       fixed_x, fixed_y;
+    short       in_method;
+    XPoint	spot_location;	/* spot location, relative to client window */
+#if USE_XIM
+    gboolean xim_preedit_started;
+#endif
+} ClientState;
+
+
+typedef struct _IC {
+#if USE_XIM
+    CARD16	id;		/* ic id */
+#endif
+    Window	focus_win;	/* focus window */
+#if USE_XIM
+    char	*resource_name;	/* resource name */
+    char	*resource_class; /* resource class */
+    PreeditAttributes pre_attr; /* preedit attributes */
+    StatusAttributes sts_attr; /* status attributes */
+#endif
+    ClientState cs;
+    struct _IC	*next;
+} IC;
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/include/IMdkit.h b/src/plugins/platforminputcontexts/hime/include/IMdkit/include/IMdkit.h
new file mode 100644
index 0000000..6f8d673
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/include/IMdkit.h
@@ -0,0 +1,144 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#ifndef _IMdkit_h
+#define _IMdkit_h
+
+#include <X11/Xmd.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* IM Attributes Name */
+#define IMModifiers		"modifiers"
+#define IMServerWindow		"serverWindow"
+#define IMServerName		"serverName"
+#define IMServerTransport	"serverTransport"
+#define IMLocale		"locale"
+#define IMInputStyles		"inputStyles"
+#define IMProtocolHandler	"protocolHandler"
+#define IMOnKeysList		"onKeysList"
+#define IMOffKeysList		"offKeysList"
+#define IMEncodingList		"encodingList"
+#define IMFilterEventMask	"filterEventMask"
+#define IMProtocolDepend	"protocolDepend"
+
+/* Masks for IM Attributes Name */
+#define I18N_IMSERVER_WIN	0x0001 /* IMServerWindow */
+#define I18N_IM_NAME		0x0002 /* IMServerName */
+#define I18N_IM_LOCALE		0x0004 /* IMLocale */
+#define I18N_IM_ADDRESS		0x0008 /* IMServerTransport */
+#define I18N_INPUT_STYLES	0x0010 /* IMInputStyles */
+#define I18N_ON_KEYS		0x0020 /* IMOnKeysList */
+#define I18N_OFF_KEYS		0x0040 /* IMOffKeysList */
+#define I18N_IM_HANDLER		0x0080 /* IMProtocolHander */
+#define I18N_ENCODINGS		0x0100 /* IMEncodingList */
+#define I18N_FILTERMASK		0x0200 /* IMFilterEventMask */
+#define I18N_PROTO_DEPEND	0x0400 /* IMProtoDepend */
+
+typedef struct
+{
+    char	*name;
+    XPointer	value;
+} XIMArg;
+
+typedef struct
+{
+    CARD32	keysym;
+    CARD32	modifier;
+    CARD32	modifier_mask;
+} XIMTriggerKey;
+
+typedef struct
+{
+    unsigned short count_keys;
+    XIMTriggerKey *keylist;
+} XIMTriggerKeys;
+
+typedef char *XIMEncoding;
+
+typedef struct
+{
+    unsigned short count_encodings;
+    XIMEncoding *supported_encodings;
+} XIMEncodings;
+
+typedef struct _XIMS *XIMS;
+
+typedef struct
+{
+    void*	(*setup) (Display *, XIMArg *);
+    Status	(*openIM) (XIMS);
+    Status	(*closeIM) (XIMS);
+    char*	(*setIMValues) (XIMS, XIMArg *);
+    char*	(*getIMValues) (XIMS, XIMArg *);
+    Status	(*forwardEvent) (XIMS, XPointer);
+    Status	(*commitString) (XIMS, XPointer);
+    int		(*callCallback) (XIMS, XPointer);
+    int		(*preeditStart) (XIMS, XPointer);
+    int		(*preeditEnd) (XIMS, XPointer);
+    int		(*syncXlib) (XIMS, XPointer);
+} IMMethodsRec, *IMMethods;
+
+typedef struct
+{
+    Display	*display;
+    int		screen;
+} IMCoreRec, *IMCore;
+
+typedef struct _XIMS
+{
+    IMMethods	methods;
+    IMCoreRec	core;
+    Bool	sync;
+    void	*protocol;
+} XIMProtocolRec;
+
+/*
+ * X function declarations.
+ */
+extern XIMS IMOpenIM (Display *, ...);
+extern Status IMCloseIM (XIMS);
+extern char *IMSetIMValues (XIMS, ...);
+extern char *IMGetIMValues (XIMS, ...);
+void IMForwardEvent (XIMS, XPointer);
+void IMCommitString (XIMS, XPointer);
+int IMCallCallback (XIMS, XPointer);
+int IMPreeditStart (XIMS, XPointer);
+int IMPreeditEnd (XIMS, XPointer);
+int IMSyncXlib (XIMS, XPointer);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* IMdkit_h */
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/include/Xi18n.h b/src/plugins/platforminputcontexts/hime/include/IMdkit/include/Xi18n.h
new file mode 100644
index 0000000..aaf7768
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/include/Xi18n.h
@@ -0,0 +1,505 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#ifndef _Xi18n_h
+#define _Xi18n_h
+#include <X11/Xlib.h>
+#include <X11/Xfuncs.h>
+#include <X11/Xos.h>
+#include "XimProto.h"
+
+/*
+ * Minor Protocol Number for Extension Protocol
+ */
+#define XIM_EXTENSION				128
+#define XIM_EXT_SET_EVENT_MASK			(0x30)
+#define	XIM_EXT_FORWARD_KEYEVENT		(0x32)
+#define	XIM_EXT_MOVE				(0x33)
+#define COMMON_EXTENSIONS_NUM   		3
+
+#include <stdlib.h>
+#include "IMdkit.h"
+
+/* XI18N Valid Attribute Name Definition */
+#define ExtForwardKeyEvent	"extForwardKeyEvent"
+#define ExtMove			"extMove"
+#define ExtSetEventMask		"extSetEventMask"
+
+/*
+ * Padding macro
+ */
+#define	IMPAD(length) ((4 - ((length)%4))%4)
+
+/*
+ * Target Atom for Transport Connection
+ */
+#define LOCALES		"LOCALES"
+#define TRANSPORT	"TRANSPORT"
+
+#define I18N_OPEN	0
+#define I18N_SET	1
+#define I18N_GET	2
+
+typedef struct
+{
+    char        *transportname;
+    int         namelen;
+    Bool        (*checkAddr) ();
+} TransportSW;
+
+typedef struct _XIMPending
+{
+    unsigned    char *p;
+    struct _XIMPending *next;
+} XIMPending;
+
+typedef struct _XimProtoHdr
+{
+    CARD8	major_opcode;
+    CARD8	minor_opcode;
+    CARD16	length;
+} XimProtoHdr;
+
+typedef struct
+{
+    CARD16	attribute_id;
+    CARD16	type;
+    CARD16	length;
+    char	*name;
+} XIMAttr;
+
+typedef struct
+{
+    CARD16	attribute_id;
+    CARD16	type;
+    CARD16	length;
+    char	*name;
+} XICAttr;
+
+typedef struct
+{
+    int		attribute_id;
+    CARD16	name_length;
+    char	*name;
+    int		value_length;
+    void	*value;
+    int		type;
+} XIMAttribute;
+
+typedef struct
+{
+    int		attribute_id;
+    CARD16	name_length;
+    char	*name;
+    int		value_length;
+    void	*value;
+    int		type;
+} XICAttribute;
+
+typedef struct
+{
+    int		length;
+    char	*name;
+} XIMStr;
+
+typedef struct
+{
+    CARD16	major_opcode;
+    CARD16	minor_opcode;
+    CARD16	length;
+    char	*name;
+} XIMExt;
+
+typedef struct _Xi18nClient
+{
+    int		connect_id;
+    CARD8	byte_order;
+    /*
+       '?': initial value
+       'B': for Big-Endian
+       'l': for little-endian
+     */
+    int		sync;
+    XIMPending  *pending;
+    void *trans_rec;		/* contains transport specific data  */
+    struct _Xi18nClient *next;
+} Xi18nClient;
+
+typedef struct _Xi18nCore *Xi18n;
+
+/*
+ * Callback Struct for XIM Protocol
+ */
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+} IMAnyStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD8	byte_order;
+    CARD16	major_version;
+    CARD16	minor_version;
+} IMConnectStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+} IMDisConnectStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    XIMStr	lang;
+} IMOpenStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+} IMCloseStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	number;
+    XIMStr	*extension;
+} IMQueryExtensionStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	number;
+    char	**im_attr_list;
+} IMGetIMValuesStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+    CARD16	preedit_attr_num;
+    CARD16	status_attr_num;
+    CARD16	ic_attr_num;
+    XICAttribute *preedit_attr;
+    XICAttribute *status_attr;
+    XICAttribute *ic_attr;
+} IMChangeICStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+} IMDestroyICStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+    CARD16	length;
+    char	*commit_string;
+} IMResetICStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+} IMChangeFocusStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+    BITMASK16	sync_bit;
+    CARD16	serial_number;
+    XEvent	event;
+} IMForwardEventStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+    CARD16	flag;
+    KeySym	keysym;
+    char	*commit_string;
+} IMCommitStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+    CARD32	flag;
+    CARD32	key_index;
+    CARD32	event_mask;
+} IMTriggerNotifyStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	encoding_number;
+    XIMStr	*encoding;	/* name information */
+    CARD16	encoding_info_number;
+    XIMStr	*encodinginfo;	/* detailed information */
+    CARD16	category;	/* #0 for name, #1 for detail */
+    INT16	enc_index;	/* index of the encoding determined */
+} IMEncodingNegotiationStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+    CARD32	flag;
+    CARD32	forward_event_mask;
+    CARD32	sync_event_mask;
+} IMSetEventMaskStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+    CARD32	filter_event_mask;
+    CARD32	intercept_event_mask;
+    CARD32	select_event_mask;
+    CARD32	forward_event_mask;
+    CARD32	sync_event_mask;
+} IMExtSetEventMaskStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+    CARD16	x;
+    CARD16	y;
+} IMMoveStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+    BITMASK16	flag;
+    CARD16	error_code;
+    CARD16	str_length;
+    CARD16	error_type;
+    char	*error_detail;
+} IMErrorStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+} IMPreeditStateStruct;
+
+/* Callbacks */
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+} IMGeometryCBStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+    union
+    {
+	int return_value;			/* PreeditStart */
+	XIMPreeditDrawCallbackStruct draw;	/* PreeditDraw */
+	XIMPreeditCaretCallbackStruct caret; 	/* PreeditCaret */
+    } todo;
+} IMPreeditCBStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+    union
+    {
+	XIMStatusDrawCallbackStruct draw;	/* StatusDraw */
+    } todo;
+} IMStatusCBStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+    XIMStringConversionCallbackStruct strconv;
+} IMStrConvCBStruct;
+
+typedef struct
+{
+    int		major_code;
+    int		minor_code;
+    CARD16	connect_id;
+    CARD16	icid;
+} IMSyncXlibStruct;
+
+typedef union _IMProtocol
+{
+    int	major_code;
+    IMAnyStruct any;
+    IMConnectStruct imconnect;
+    IMDisConnectStruct imdisconnect;
+    IMOpenStruct imopen;
+    IMCloseStruct imclose;
+    IMQueryExtensionStruct queryext;
+    IMGetIMValuesStruct getim;
+    IMEncodingNegotiationStruct encodingnego;
+    IMExtSetEventMaskStruct extsetevent;
+    IMMoveStruct extmove;
+    IMSetEventMaskStruct setevent;
+    IMChangeICStruct changeic;
+    IMDestroyICStruct destroyic;
+    IMResetICStruct resetic;
+    IMChangeFocusStruct changefocus;
+    IMCommitStruct commitstring;
+    IMForwardEventStruct forwardevent;
+    IMTriggerNotifyStruct triggernotify;
+    IMPreeditStateStruct preedit_state;
+    IMErrorStruct imerror;
+    IMGeometryCBStruct geometry_callback;
+    IMPreeditCBStruct preedit_callback;
+    IMStatusCBStruct status_callback;
+    IMStrConvCBStruct strconv_callback;
+    IMSyncXlibStruct sync_xlib;
+    long pad[32];
+} IMProtocol;
+
+typedef int (*IMProtoHandler) (XIMS, IMProtocol*);
+
+#define DEFAULT_FILTER_MASK	(KeyPressMask)
+
+/* Xi18nAddressRec structure */
+typedef struct _Xi18nAddressRec
+{
+    Display	*dpy;
+    CARD8	im_byteOrder;	/* byte order 'B' or 'l' */
+    /* IM Values */
+    long	imvalue_mask;
+    Window	im_window;	/* IMServerWindow */
+    char	*im_name;	/* IMServerName */
+    char	*im_locale;	/* IMLocale */
+    char	*im_addr;	/* IMServerTransport */
+    XIMStyles	input_styles;	/* IMInputStyles */
+    XIMTriggerKeys on_keys;	/* IMOnKeysList */
+    XIMTriggerKeys off_keys;	/* IMOffKeysList */
+    XIMEncodings encoding_list; /* IMEncodingList */
+    IMProtoHandler improto;	/* IMProtocolHander */
+    long	filterevent_mask; /* IMFilterEventMask */
+    /* XIM_SERVERS target Atoms */
+    Atom	selection;
+    Atom	Localename;
+    Atom	Transportname;
+    /* XIM/XIC Attr */
+    int		im_attr_num;
+    XIMAttr	*xim_attr;
+    int		ic_attr_num;
+    XICAttr	*xic_attr;
+    CARD16	preeditAttr_id;
+    CARD16	statusAttr_id;
+    CARD16	separatorAttr_id;
+    /* XIMExtension List */
+    int		ext_num;
+    XIMExt	extension[COMMON_EXTENSIONS_NUM];
+    /* transport specific connection address */
+    void	*connect_addr;
+    /* actual data is defined:
+       XSpecRec in Xi18nX.h for X-based connection.
+       TransSpecRec in Xi18nTr.h for Socket-based connection.
+     */
+    /* clients table */
+    Xi18nClient *clients;
+    Xi18nClient *free_clients;
+} Xi18nAddressRec;
+
+typedef struct _Xi18nMethodsRec
+{
+    Bool (*begin) (XIMS);
+    Bool (*end) (XIMS);
+    Bool (*send) (XIMS, CARD16, unsigned char*, long);
+    Bool (*wait) (XIMS, CARD16, CARD8, CARD8);
+    Bool (*disconnect) (XIMS, CARD16);
+} Xi18nMethodsRec;
+
+typedef struct _Xi18nCore
+{
+    Xi18nAddressRec address;
+    Xi18nMethodsRec methods;
+} Xi18nCore;
+
+#endif
+
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/include/XimProto.h b/src/plugins/platforminputcontexts/hime/include/IMdkit/include/XimProto.h
new file mode 100644
index 0000000..e3ed168
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/include/XimProto.h
@@ -0,0 +1,230 @@
+/* $XConsortium: XimProto.h,v 1.2 94/01/20 18:02:24 rws Exp $ */
+/******************************************************************
+
+           Copyright 1992, 1993, 1994 by FUJITSU LIMITED
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of FUJITSU LIMITED
+not be used in advertising or publicity pertaining to distribution
+of the software without specific, written prior permission.
+FUJITSU LIMITED makes no representations about the suitability of
+this software for any purpose.
+It is provided "as is" without express or implied warranty.
+
+FUJITSU LIMITED DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+EVENT SHALL FUJITSU LIMITED BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Takashi Fujiwara     FUJITSU LIMITED
+                               fujiwara@a80.tech.yk.fujitsu.co.jp
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#ifndef _XIMPROTO_H
+#define _XIMPROTO_H
+
+/*
+ * Default Preconnection selection target
+ */
+#define XIM_SERVERS		"XIM_SERVERS"
+#define XIM_LOCALES		"LOCALES"
+#define XIM_TRANSPORT		"TRANSPORT"
+
+/*
+ * categories in XIM_SERVERS
+ */
+#define XIM_SERVER_CATEGORY	"@server="
+#define XIM_LOCAL_CATEGORY	"@locale="
+#define XIM_TRANSPORT_CATEGORY	"@transport="
+
+/*
+ * Xim implementation revision
+ */
+#define PROTOCOLMAJORVERSION		0
+#define PROTOCOLMINORVERSION		0
+
+/*
+ * Major Protocol number
+ */
+#define	XIM_CONNECT			  1
+#define	XIM_CONNECT_REPLY		  2
+#define	XIM_DISCONNECT			  3
+#define	XIM_DISCONNECT_REPLY		  4
+
+#define XIM_AUTH_REQUIRED		 10
+#define XIM_AUTH_REPLY			 11
+#define XIM_AUTH_NEXT			 12
+#define XIM_AUTH_SETUP			 13
+#define XIM_AUTH_NG			 14
+
+#define	XIM_ERROR			 20
+
+#define	XIM_OPEN			 30
+#define	XIM_OPEN_REPLY			 31
+#define	XIM_CLOSE			 32
+#define	XIM_CLOSE_REPLY			 33
+#define	XIM_REGISTER_TRIGGERKEYS	 34
+#define	XIM_TRIGGER_NOTIFY		 35
+#define	XIM_TRIGGER_NOTIFY_REPLY	 36
+#define	XIM_SET_EVENT_MASK		 37
+#define	XIM_ENCODING_NEGOTIATION	 38
+#define	XIM_ENCODING_NEGOTIATION_REPLY	 39
+#define	XIM_QUERY_EXTENSION		 40
+#define	XIM_QUERY_EXTENSION_REPLY	 41
+#define	XIM_SET_IM_VALUES		 42
+#define	XIM_SET_IM_VALUES_REPLY		 43
+#define	XIM_GET_IM_VALUES		 44
+#define	XIM_GET_IM_VALUES_REPLY		 45
+
+#define XIM_CREATE_IC			 50
+#define	XIM_CREATE_IC_REPLY		 51
+#define	XIM_DESTROY_IC			 52
+#define	XIM_DESTROY_IC_REPLY		 53
+#define XIM_SET_IC_VALUES		 54
+#define	XIM_SET_IC_VALUES_REPLY		 55
+#define XIM_GET_IC_VALUES		 56
+#define XIM_GET_IC_VALUES_REPLY		 57
+#define	XIM_SET_IC_FOCUS		 58
+#define	XIM_UNSET_IC_FOCUS		 59
+#define	XIM_FORWARD_EVENT		 60
+#define	XIM_SYNC			 61
+#define	XIM_SYNC_REPLY			 62
+#define	XIM_COMMIT			 63
+#define	XIM_RESET_IC			 64
+#define	XIM_RESET_IC_REPLY		 65
+
+#define	XIM_GEOMETRY			 70
+#define	XIM_STR_CONVERSION		 71
+#define	XIM_STR_CONVERSION_REPLY	 72
+#define	XIM_PREEDIT_START		 73
+#define	XIM_PREEDIT_START_REPLY		 74
+#define	XIM_PREEDIT_DRAW		 75
+#define	XIM_PREEDIT_CARET		 76
+#define XIM_PREEDIT_CARET_REPLY		 77
+#define	XIM_PREEDIT_DONE		 78
+#define	XIM_STATUS_START		 79
+#define	XIM_STATUS_DRAW			 80
+#define	XIM_STATUS_DONE			 81
+
+/*
+ * values for the flag of XIM_ERROR
+ */
+#define	XIM_IMID_VALID			0x0001
+#define	XIM_ICID_VALID			0x0002
+
+/*
+ * XIM Error Code
+ */
+#define XIM_BadAlloc			1
+#define XIM_BadStyle			2
+#define XIM_BadClientWindow		3
+#define XIM_BadFocusWindow		4
+#define XIM_BadArea			5
+#define XIM_BadSpotLocation		6
+#define XIM_BadColormap			7
+#define XIM_BadAtom			8
+#define XIM_BadPixel			9
+#define XIM_BadPixmap			10
+#define XIM_BadName			11
+#define XIM_BadCursor			12
+#define XIM_BadProtocol			13
+#define XIM_BadForeground		14
+#define XIM_BadBackground		15
+#define XIM_LocaleNotSupported		16
+#define XIM_BadSomething		999
+
+/*
+ * byte order
+ */
+#define BIGENDIAN	(CARD8) 0x42	/* MSB first */
+#define LITTLEENDIAN	(CARD8) 0x6c	/* LSB first */
+
+/*
+ * values for the type of XIMATTR & XICATTR
+ */
+#define	XimType_SeparatorOfNestedList	0
+#define	XimType_CARD8			1
+#define	XimType_CARD16			2
+#define	XimType_CARD32			3
+#define	XimType_STRING8			4
+#define	XimType_Window			5
+#define	XimType_XIMStyles		10
+#define	XimType_XRectangle		11
+#define	XimType_XPoint			12
+#define XimType_XFontSet		13
+#define XimType_XIMOptions		14
+#define XimType_XIMHotKeyTriggers	15
+#define XimType_XIMHotKeyState		16
+#define XimType_XIMStringConversion	17
+#define XimType_XIMValuesList		18
+#define	XimType_NEST			0x7FFF
+
+/*
+ * values for the category of XIM_ENCODING_NEGOTIATON_REPLY
+ */
+#define	XIM_Encoding_NameCategory	0
+#define	XIM_Encoding_DetailCategory	1
+
+/*
+ * value for the index of XIM_ENCODING_NEGOTIATON_REPLY
+ */
+#define	XIM_Default_Encoding_IDX	-1
+
+/*
+ * value for the flag of XIM_FORWARD_EVENT, XIM_COMMIT
+ */
+#define XimSYNCHRONUS		  0x0001
+#define XimLookupChars		  0x0002
+#define XimLookupKeySym		  0x0004
+#define XimLookupBoth		  0x0006
+
+/*
+ * request packet header size
+ */
+#define XIM_HEADER_SIZE						\
+	  sizeof(CARD8)		/* sizeof mejor-opcode */	\
+	+ sizeof(CARD8)		/* sizeof minor-opcode */	\
+	+ sizeof(INT16)		/* sizeof length */
+
+/*
+ * Client Message data size
+ */
+#define	XIM_CM_DATA_SIZE	20
+
+/*
+ * XIM data structure
+ */
+typedef CARD16	BITMASK16;
+typedef CARD32	BITMASK32;
+typedef CARD32	EVENTMASK;
+
+typedef CARD16	XIMID;		/* Input Method ID */
+typedef CARD16	XICID;		/* Input Context ID */
+
+/*
+ * Padding macro
+ */
+#define	XIM_PAD(length) ((4 - ((length) % 4)) % 4)
+
+#define XIM_SET_PAD(ptr, length)					\
+    {									\
+	register int	 Counter = XIM_PAD((int)length);		\
+	if (Counter) {							\
+	    register char	*Ptr = (char *)(ptr) + (length);	\
+	    length += Counter;						\
+	    for (; Counter; --Counter, ++Ptr)				\
+		*Ptr = '\0';						\
+	}								\
+    }
+
+#endif
+
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/FrameMgr.c b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/FrameMgr.c
new file mode 100644
index 0000000..9b49794
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/FrameMgr.c
@@ -0,0 +1,2466 @@
+/******************************************************************
+Copyright 1993, 1994 by Digital Equipment Corporation, Maynard, Massachusetts,
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the names of Digital or MIT not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+  Author: Hiroyuki Miyamoto  Digital Equipment Corporation
+                             miyamoto@jrd.dec.com
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#include <X11/Xlibint.h>
+#include <stdlib.h>
+#include "FrameMgr.h"
+
+/* Convenient macro */
+
+#define _UNIT(n)   ((int)(n) & 0xFF)
+#define _NUMBER(n) (((int)(n) >> 8) & 0xFF)
+
+/* For byte swapping */
+
+#define Swap16(p, n) ((p)->byte_swap ?       \
+(((n) << 8 & 0xFF00) | \
+ ((n) >> 8 & 0xFF)     \
+) : n)
+#define Swap32(p, n) ((p)->byte_swap ?            \
+        (((n) << 24 & 0xFF000000) | \
+         ((n) <<  8 & 0xFF0000) |   \
+         ((n) >>  8 & 0xFF00) |     \
+         ((n) >> 24 & 0xFF)         \
+        ) : n)
+#define Swap64(p, n) ((p)->byte_swap ?            \
+        (((n) << 56 & 0xFF00000000000000) | \
+         ((n) << 40 & 0xFF000000000000) |   \
+         ((n) << 24 & 0xFF0000000000) |     \
+         ((n) <<  8 & 0xFF00000000) |       \
+         ((n) >>  8 & 0xFF000000) |         \
+         ((n) >> 24 & 0xFF0000) |           \
+         ((n) >> 40 & 0xFF00) |             \
+         ((n) >> 56 & 0xFF)                 \
+        ) : n)
+
+/* Type definition */
+
+typedef struct _Iter *Iter;
+
+typedef struct _FrameInst *FrameInst;
+
+typedef union
+{
+    int num; 		/* For BARRAY */
+    FrameInst fi; 	/* For POINTER */
+    Iter iter; 		/* For ITER */
+} ExtraDataRec, *ExtraData;
+
+typedef struct _Chain
+{
+    ExtraDataRec d;
+    int frame_no;
+    struct _Chain *next;
+} ChainRec, *Chain;
+
+typedef struct _ChainMgr
+{
+    Chain top;
+    Chain tail;
+} ChainMgrRec, *ChainMgr;
+
+typedef struct _ChainIter
+{
+    Chain cur;
+} ChainIterRec, *ChainIter;
+
+typedef struct _FrameIter
+{
+    Iter iter;
+    Bool counting;
+    unsigned int counter;
+    int end;
+    struct _FrameIter* next;
+} FrameIterRec, *FrameIter;
+
+typedef struct _FrameInst
+{
+    XimFrame template;
+    ChainMgrRec cm;
+    int cur_no;
+} FrameInstRec;
+
+typedef void (*IterStartWatchProc) (Iter it, void *client_data);
+
+typedef struct _Iter
+{
+    XimFrame template;
+    int max_count;
+    Bool allow_expansion;
+    ChainMgrRec cm;
+    int cur_no;
+    IterStartWatchProc start_watch_proc;
+    void *client_data;
+    Bool start_counter;
+} IterRec;
+
+typedef struct _FrameMgr
+{
+    XimFrame frame;
+    FrameInst fi;
+    char *area;
+    int idx;
+    Bool byte_swap;
+    int total_size;
+    FrameIter iters;
+} FrameMgrRec;
+
+typedef union
+{
+    int num;           /* For BARRAY and PAD */
+    struct
+    {          /* For COUNTER_* */
+        Iter iter;
+        Bool is_byte_len;
+    } counter;
+} XimFrameTypeInfoRec, *XimFrameTypeInfo;
+
+/* Special values */
+#define NO_VALUE -1
+#define NO_VALID_FIELD -2
+
+static FrameInst FrameInstInit(XimFrame frame);
+static void FrameInstFree(FrameInst fi);
+static XimFrameType FrameInstGetNextType(FrameInst fi, XimFrameTypeInfo info);
+static XimFrameType FrameInstPeekNextType(FrameInst fi, XimFrameTypeInfo info);
+static FmStatus FrameInstSetSize(FrameInst fi, int num);
+static FmStatus FrameInstSetIterCount(FrameInst fi, int num);
+static int FrameInstGetTotalSize(FrameInst fi);
+static void FrameInstReset(FrameInst fi);
+
+static Iter IterInit(XimFrame frame, int count);
+static void IterFree(Iter it);
+static int FrameInstGetSize(FrameInst fi);
+static int IterGetSize(Iter it);
+static XimFrameType IterGetNextType(Iter it, XimFrameTypeInfo info);
+static XimFrameType IterPeekNextType(Iter it, XimFrameTypeInfo info);
+static FmStatus IterSetSize(Iter it, int num);
+static FmStatus IterSetIterCount(Iter it, int num);
+static int IterGetTotalSize(Iter it);
+static void IterReset(Iter it);
+static Bool IterIsLoopEnd(Iter it, Bool* myself);
+static void IterSetStartWatch(Iter it, IterStartWatchProc proc, void* client_data);
+static void _IterStartWatch(Iter it, void* client_data);
+
+static ExtraData ChainMgrGetExtraData(ChainMgr cm, int frame_no);
+static ExtraData ChainMgrSetData(ChainMgr cm, int frame_no,
+                                 ExtraDataRec data);
+static Bool ChainIterGetNext(ChainIter ci, int* frame_no, ExtraData d);
+static int _FrameInstIncrement(XimFrame frame, int count);
+static int _FrameInstDecrement(XimFrame frame, int count);
+static int _FrameInstGetItemSize(FrameInst fi, int cur_no);
+static Bool FrameInstIsIterLoopEnd(FrameInst fi);
+
+static FrameIter _FrameMgrAppendIter(FrameMgr fm, Iter it, int end);
+static FrameIter _FrameIterCounterIncr(FrameIter fitr, int i);
+static void _FrameMgrRemoveIter(FrameMgr fm, FrameIter it);
+static Bool _FrameMgrIsIterLoopEnd(FrameMgr fm);
+static Bool _FrameMgrProcessPadding(FrameMgr fm, FmStatus* status);
+
+#define IterGetIterCount(it) ((it)->allow_expansion ? \
+NO_VALUE : (it)->max_count)
+
+#define IterFixIteration(it) ((it)->allow_expansion = False)
+
+#define IterSetStarter(it) ((it)->start_counter = True)
+
+#define ChainMgrInit(cm) (cm)->top = (cm)->tail = NULL
+#define ChainMgrFree(cm)                \
+{                                       \
+    Chain tmp;                          \
+    Chain cur = (cm)->top;              \
+					\
+    while (cur)                         \
+    {                                   \
+        tmp = cur->next;                \
+        Xfree (cur);                    \
+	cur = tmp;                      \
+    }                                   \
+}
+
+#define ChainIterInit(ci, cm)           \
+{                                       \
+    (ci)->cur = (cm)->top;              \
+}
+
+/* ChainIterFree has nothing to do. */
+#define ChainIterFree(ci)
+
+#define FrameInstIsEnd(fi) ((fi)->template[(fi)->cur_no].type == EOL)
+
+FrameMgr FrameMgrInit (XimFrame frame, char* area, Bool byte_swap)
+{
+    FrameMgr fm;
+
+    fm = (FrameMgr) Xmalloc (sizeof (FrameMgrRec));
+
+    fm->frame = frame;
+    fm->fi = FrameInstInit (frame);
+    fm->area = (char *) area;
+    fm->idx = 0;
+    fm->byte_swap = byte_swap;
+    fm->total_size = NO_VALUE;
+    fm->iters = NULL;
+
+    return fm;
+}
+
+void FrameMgrInitWithData (FrameMgr fm,
+                           XimFrame frame,
+                           void * area,
+                           Bool byte_swap)
+{
+    fm->frame = frame;
+    fm->fi = FrameInstInit (frame);
+    fm->area = (char *) area;
+    fm->idx = 0;
+    fm->byte_swap = byte_swap;
+    fm->total_size = NO_VALUE;
+}
+
+void FrameMgrFree (FrameMgr fm)
+{
+    FrameIter p, cur;
+
+    p = fm->iters;
+    cur = p;
+
+    while (p)
+    {
+        p = p->next;
+        Xfree (cur);
+        cur = p;
+    }
+    /*endwhile*/
+
+    FrameInstFree (fm->fi);
+    Xfree (fm);
+}
+
+FmStatus FrameMgrSetBuffer (FrameMgr fm, void* area)
+{
+    if (fm->area)
+        return FmBufExist;
+    fm->area = (char *) area;
+    return FmSuccess;
+}
+
+FmStatus _FrameMgrPutToken (FrameMgr fm, void *data, int data_size)
+{
+    XimFrameType type;
+    XimFrameTypeInfoRec info;
+
+    if (fm->total_size != NO_VALUE  &&  fm->idx >= fm->total_size)
+        return FmNoMoreData;
+    /*endif*/
+
+    type = FrameInstGetNextType(fm->fi, &info);
+
+    if (type & COUNTER_MASK)
+    {
+        unsigned long input_length;
+
+        if (info.counter.is_byte_len)
+        {
+            if ((input_length = IterGetTotalSize (info.counter.iter))
+                    == NO_VALUE)
+            {
+                return FmCannotCalc;
+            }
+            /*endif*/
+        }
+        else
+        {
+            if ((input_length = IterGetIterCount (info.counter.iter))
+                == NO_VALUE)
+            {
+                return FmCannotCalc;
+            }
+            /*endif*/
+        }
+        /*endif*/
+        switch (type)
+        {
+        case COUNTER_BIT8:
+            *(CARD8 *) (fm->area + fm->idx) = input_length;
+            fm->idx++;
+            break;
+
+        case COUNTER_BIT16:
+            *(CARD16 *) (fm->area + fm->idx) = Swap16 (fm, input_length);
+            fm->idx += 2;
+            break;
+
+        case COUNTER_BIT32:
+            *(CARD32 *) (fm->area + fm->idx) = Swap32 (fm, input_length);
+            fm->idx += 4;
+            break;
+
+#if defined(_NEED64BIT)
+        case COUNTER_BIT64:
+            *(CARD64 *) (fm->area + fm->idx) = Swap64 (fm, input_length);
+            fm->idx += 8;
+            break;
+#endif
+	default:
+	    break;
+        }
+        /*endswitch*/
+        _FrameMgrPutToken(fm, data, data_size);
+        return FmSuccess;
+    }
+    /*endif*/
+
+    switch (type)
+    {
+    case BIT8:
+        if (data_size == sizeof (unsigned char))
+        {
+            unsigned long num = *(unsigned char *) data;
+            *(CARD8 *) (fm->area + fm->idx) = num;
+        }
+        else if (data_size == sizeof (unsigned short))
+        {
+            unsigned long num = *(unsigned short *) data;
+            *(CARD8 *) (fm->area + fm->idx) = num;
+        }
+        else if (data_size == sizeof (unsigned int))
+        {
+            unsigned long num = *(unsigned int *) data;
+            *(CARD8 *) (fm->area + fm->idx) = num;
+        }
+        else if (data_size == sizeof (unsigned long))
+        {
+            unsigned long num = *(unsigned long *) data;
+            *(CARD8 *) (fm->area + fm->idx) = num;
+        }
+        else
+        {
+            ; /* Should never be reached */
+        }
+        /*endif*/
+        fm->idx++;
+        return FmSuccess;
+
+    case BIT16:
+        if (data_size == sizeof (unsigned char))
+        {
+            unsigned long num = *(unsigned char *) data;
+            *(CARD16*)(fm->area + fm->idx) = Swap16 (fm, num);
+        }
+        else if (data_size == sizeof (unsigned short))
+        {
+            unsigned long num = *(unsigned short *) data;
+            *(CARD16 *) (fm->area + fm->idx) = Swap16 (fm, num);
+        }
+        else if (data_size == sizeof (unsigned int))
+        {
+            unsigned long num = *(unsigned int *) data;
+            *(CARD16 *) (fm->area + fm->idx) = Swap16 (fm, num);
+        }
+        else if (data_size == sizeof (unsigned long))
+        {
+            unsigned long num = *(unsigned long *) data;
+            *(CARD16 *) (fm->area + fm->idx) = Swap16 (fm, num);
+        }
+        else
+        {
+            ; /* Should never reached */
+        }
+        /*endif*/
+        fm->idx += 2;
+        return FmSuccess;
+
+    case BIT32:
+        if (data_size == sizeof (unsigned char))
+        {
+            unsigned long num = *(unsigned char *) data;
+            *(CARD32 *) (fm->area + fm->idx) = Swap32 (fm, num);
+        }
+        else if (data_size == sizeof (unsigned short))
+        {
+            unsigned long num = *(unsigned short *) data;
+            *(CARD32 *) (fm->area + fm->idx) = Swap32 (fm, num);
+        }
+        else if (data_size == sizeof (unsigned int))
+        {
+            unsigned long num = *(unsigned int *) data;
+            *(CARD32 *) (fm->area + fm->idx) = Swap32 (fm, num);
+        }
+        else if (data_size == sizeof (unsigned long))
+        {
+            unsigned long num = *(unsigned long *) data;
+            *(CARD32 *) (fm->area + fm->idx) = Swap32 (fm, num);
+        }
+        else
+        {
+            ; /* Should never reached */
+        }
+        /*endif*/
+        fm->idx += 4;
+        return FmSuccess;
+
+#if defined(_NEED64BIT)
+    case BIT64:
+        if (data_size == sizeof (unsigned char))
+        {
+            unsigned long num = *(unsigned char *) data;
+            *(CARD64 *) (fm->area + fm->idx) = Swap64 (fm, num);
+        }
+        else if (data_size == sizeof (unsigned short))
+        {
+            unsigned long num = *(unsigned short *) data;
+            *(CARD64 *) (fm->area + fm->idx) = Swap64 (fm, num);
+        }
+        else if (data_size == sizeof (unsigned int))
+        {
+            unsigned long num = *(unsigned int *) data;
+            *(CARD64 *) (fm->area + fm->idx) = Swap64 (fm, num);
+        }
+        else if (data_size == sizeof (unsigned long))
+        {
+            unsigned long num = *(unsigned long *) data;
+            *(CARD64 *) (fm->area + fm->idx) = Swap64 (fm, num);
+        }
+        else
+        {
+            ; /* Should never reached */
+        }
+        /*endif*/
+        fm->idx += 4;
+        return FmSuccess;
+#endif
+
+    case BARRAY:
+        if (info.num == NO_VALUE)
+            return FmInvalidCall;
+        /*endif*/
+        if (info.num > 0)
+        {
+            bcopy (*(char **) data, fm->area + fm->idx, info.num);
+            fm->idx += info.num;
+        }
+        /*endif*/
+        return FmSuccess;
+
+    case PADDING:
+        if (info.num == NO_VALUE)
+            return FmInvalidCall;
+        /*endif*/
+        fm->idx += info.num;
+        return _FrameMgrPutToken(fm, data, data_size);
+
+    case ITER:
+        return FmInvalidCall;
+
+    case EOL:
+        return FmEOD;
+    default:
+	break;
+    }
+    /*endswitch*/
+    return (FmStatus) NULL;  /* Should never be reached */
+}
+
+FmStatus _FrameMgrGetToken (FrameMgr fm , void* data, int data_size)
+{
+    XimFrameType type;
+    static XimFrameTypeInfoRec info;  /* memory */
+    FrameIter fitr;
+
+    if (fm->total_size != NO_VALUE  &&  fm->idx >= fm->total_size)
+        return FmNoMoreData;
+    /*endif*/
+
+    type = FrameInstGetNextType(fm->fi, &info);
+
+    if (type & COUNTER_MASK)
+    {
+        int end=0;
+        FrameIter client_data;
+
+        type &= ~COUNTER_MASK;
+        switch (type)
+        {
+        case BIT8:
+            end = *(CARD8 *) (fm->area + fm->idx);
+            break;
+
+        case BIT16:
+            end = Swap16 (fm, *(CARD16 *) (fm->area + fm->idx));
+            break;
+
+        case BIT32:
+            end = Swap32 (fm, *(CARD32 *) (fm->area + fm->idx));
+            break;
+
+#if defined(_NEED64BIT)
+        case BIT64:
+            end = Swap64 (fm, *(CARD64 *) (fm->area + fm->idx));
+            break;
+#endif
+	default:
+	    break;
+        }
+        /*endswitch*/
+
+        if ((client_data = _FrameMgrAppendIter (fm, info.counter.iter, end)))
+        {
+            IterSetStarter (info.counter.iter);
+            IterSetStartWatch (info.counter.iter,
+                               _IterStartWatch,
+                               (void *) client_data);
+        }
+        /*endif*/
+    }
+    /*endif*/
+
+    type &= ~COUNTER_MASK;
+    switch (type)
+    {
+    case BIT8:
+        if (data_size == sizeof (unsigned char))
+        {
+            *(unsigned char*) data = *(CARD8 *) (fm->area + fm->idx);
+        }
+        else if (data_size == sizeof (unsigned short))
+        {
+            *(unsigned short *) data = *(CARD8 *) (fm->area + fm->idx);
+        }
+        else if (data_size == sizeof (unsigned int))
+        {
+            *(unsigned int *) data = *(CARD8 *) (fm->area + fm->idx);
+        }
+        else if (data_size == sizeof (unsigned long))
+        {
+            *(unsigned long *) data = *(CARD8 *) (fm->area + fm->idx);
+        }
+        else
+        {
+            ; /* Should never reached */
+        }
+        /*endif*/
+        fm->idx++;
+        if ((fitr = _FrameIterCounterIncr (fm->iters, 1/*BIT8*/)))
+            _FrameMgrRemoveIter (fm, fitr);
+        /*endif*/
+        return FmSuccess;
+
+    case BIT16:
+        if (data_size == sizeof (unsigned char))
+        {
+            *(unsigned char *) data =
+                Swap16 (fm, *(CARD16 *) (fm->area + fm->idx));
+        }
+        else if (data_size == sizeof (unsigned short))
+        {
+            *(unsigned short *) data =
+                Swap16 (fm, *(CARD16 *) (fm->area + fm->idx));
+        }
+        else if (data_size == sizeof (unsigned int))
+        {
+            *(unsigned int *) data =
+                Swap16 (fm, *(CARD16 *) (fm->area + fm->idx));
+        }
+        else if (data_size == sizeof (unsigned long))
+        {
+            *(unsigned long *) data =
+                Swap16 (fm, *(CARD16 *) (fm->area + fm->idx));
+        }
+        else
+        {
+            ; /* Should never reached */
+        }
+        /*endif*/
+        fm->idx += 2;
+        if ((fitr = _FrameIterCounterIncr (fm->iters, 2/*BIT16*/)))
+            _FrameMgrRemoveIter(fm, fitr);
+        /*endif*/
+        return FmSuccess;
+
+    case BIT32:
+        if (data_size == sizeof (unsigned char))
+        {
+            *(unsigned char *) data =
+                Swap32 (fm, *(CARD32 *) (fm->area + fm->idx));
+        }
+        else if (data_size == sizeof (unsigned short))
+        {
+            *(unsigned short *) data =
+                Swap32 (fm, *(CARD32 *) (fm->area + fm->idx));
+        }
+        else if (data_size == sizeof (unsigned int))
+        {
+            *(unsigned int *) data =
+                Swap32 (fm, *(CARD32 *) (fm->area + fm->idx));
+        }
+        else if (data_size == sizeof (unsigned long))
+        {
+            *(unsigned long *) data =
+                Swap32 (fm, *(CARD32 *) (fm->area + fm->idx));
+        }
+        else
+        {
+            ; /* Should never reached */
+        }
+        /*endif*/
+        fm->idx += 4;
+        if ((fitr = _FrameIterCounterIncr (fm->iters, 4/*BIT32*/)))
+            _FrameMgrRemoveIter (fm, fitr);
+        /*endif*/
+        return FmSuccess;
+
+#if defined(_NEED64BIT)
+    case BIT64:
+        if (data_size == sizeof (unsigned char))
+        {
+            *(unsigned char *) data =
+                Swap64 (fm, *(CARD64 *) (fm->area + fm->idx));
+        }
+        else if (data_size == sizeof (unsigned short))
+        {
+            *(unsigned short *) data =
+                Swap64 (fm, *(CARD64 *) (fm->area + fm->idx));
+        }
+        else if (data_size == sizeof (unsigned int))
+        {
+            *(unsigned int *) data =
+                Swap64 (fm, *(CARD64 *) (fm->area + fm->idx));
+        }
+        else if (data_size == sizeof (unsigned long))
+        {
+            *(unsigned long *) data =
+                Swap64 (fm, *(CARD64 *) (fm->area + fm->idx));
+        }
+        else
+        {
+            ; /* Should never reached */
+        }
+        /*endif*/
+        fm->idx += 8;
+        if ((fitr = _FrameIterCounterIncr (fm->iters, 8/*BIT64*/)))
+            _FrameMgrRemoveIter (fm, fitr);
+        /*endif*/
+        return FmSuccess;
+#endif
+
+    case BARRAY:
+        if (info.num == NO_VALUE)
+            return FmInvalidCall;
+        /*endif*/
+        if (info.num > 0)
+        {
+            *(char **) data = fm->area + fm->idx;
+
+            fm->idx += info.num;
+            if ((fitr = _FrameIterCounterIncr (fm->iters, info.num)))
+                _FrameMgrRemoveIter (fm, fitr);
+            /*endif*/
+        }
+        else
+        {
+            *(char **) data = NULL;
+        }
+        /*endif*/
+        return FmSuccess;
+
+    case PADDING:
+        if (info.num == NO_VALUE)
+            return FmInvalidCall;
+        /*endif*/
+        fm->idx += info.num;
+        if ((fitr = _FrameIterCounterIncr (fm->iters, info.num)))
+            _FrameMgrRemoveIter (fm, fitr);
+        /*endif*/
+        return _FrameMgrGetToken (fm, data, data_size);
+
+    case ITER:
+        return FmInvalidCall; 	/* if comes here, it's a bug! */
+
+    case EOL:
+        return FmEOD;
+    default:
+	break;
+    }
+    /*endswitch*/
+    return (FmStatus) NULL;  /* Should never be reached */
+}
+
+FmStatus FrameMgrSetSize (FrameMgr fm, int barray_size)
+{
+    if (FrameInstSetSize (fm->fi, barray_size) == FmSuccess)
+        return FmSuccess;
+    /*endif*/
+    return FmNoMoreData;
+}
+
+FmStatus FrameMgrSetIterCount (FrameMgr fm, int count)
+{
+    if (FrameInstSetIterCount (fm->fi, count) == FmSuccess)
+        return FmSuccess;
+    /*endif*/
+    return FmNoMoreData;
+}
+
+FmStatus FrameMgrSetTotalSize (FrameMgr fm, int total_size)
+{
+    fm->total_size = total_size;
+    return FmSuccess;
+}
+
+int FrameMgrGetTotalSize (FrameMgr fm)
+{
+    return FrameInstGetTotalSize (fm->fi);
+}
+
+int FrameMgrGetSize (FrameMgr fm)
+{
+    register int ret_size;
+
+    ret_size = FrameInstGetSize (fm->fi);
+    if (ret_size == NO_VALID_FIELD)
+        return NO_VALUE;
+    /*endif*/
+    return ret_size;
+}
+
+FmStatus FrameMgrSkipToken (FrameMgr fm, int skip_count)
+{
+    XimFrameType type;
+    XimFrameTypeInfoRec info;
+    register int i;
+
+    if (fm->total_size != NO_VALUE  &&  fm->idx >= fm->total_size)
+        return FmNoMoreData;
+    /*endif*/
+    for (i = 0;  i < skip_count;  i++)
+    {
+        type = FrameInstGetNextType (fm->fi, &info);
+        type &= ~COUNTER_MASK;
+
+        switch (type)
+        {
+        case BIT8:
+            fm->idx++;
+            break;
+
+        case BIT16:
+            fm->idx += 2;
+            break;
+
+        case BIT32:
+            fm->idx += 4;
+            break;
+
+        case BIT64:
+            fm->idx += 8;
+            break;
+
+        case BARRAY:
+            if (info.num == NO_VALUE)
+                return FmInvalidCall;
+            /*endif*/
+            fm->idx += info.num;
+            break;
+
+        case PADDING:
+            if (info.num == NO_VALUE)
+                return FmInvalidCall;
+            /*endif*/
+            fm->idx += info.num;
+            return FrameMgrSkipToken (fm, skip_count);
+
+        case ITER:
+            return FmInvalidCall;
+
+        case EOL:
+            return FmEOD;
+	default:
+	    break;
+        }
+        /*endswitch*/
+    }
+    /*endfor*/
+    return FmSuccess;
+}
+
+void FrameMgrReset (FrameMgr fm)
+{
+    fm->idx = 0;
+    FrameInstReset (fm->fi);
+}
+
+Bool FrameMgrIsIterLoopEnd (FrameMgr fm, FmStatus* status)
+{
+    do
+    {
+        if (_FrameMgrIsIterLoopEnd (fm))
+            return  True;
+        /*endif*/
+    }
+    while (_FrameMgrProcessPadding (fm, status));
+
+    return False;
+}
+
+
+/* Internal routines */
+
+static Bool _FrameMgrIsIterLoopEnd (FrameMgr fm)
+{
+    return FrameInstIsIterLoopEnd (fm->fi);
+}
+
+static Bool _FrameMgrProcessPadding (FrameMgr fm, FmStatus* status)
+{
+    XimFrameTypeInfoRec info;
+    XimFrameType next_type = FrameInstPeekNextType (fm->fi, &info);
+    FrameIter fitr;
+
+    if (next_type == PADDING)
+    {
+        if (info.num == NO_VALUE)
+        {
+            *status = FmInvalidCall;
+            return True;
+        }
+        /*endif*/
+        next_type = FrameInstGetNextType (fm->fi, &info);
+        fm->idx += info.num;
+        if ((fitr = _FrameIterCounterIncr (fm->iters, info.num)))
+            _FrameMgrRemoveIter (fm, fitr);
+        /*endif*/
+        *status = FmSuccess;
+        return True;
+    }
+    /*endif*/
+    *status = FmSuccess;
+    return False;
+}
+
+static FrameInst FrameInstInit (XimFrame frame)
+{
+    FrameInst fi;
+
+    fi = (FrameInst) Xmalloc (sizeof (FrameInstRec));
+
+    fi->template = frame;
+    fi->cur_no = 0;
+    ChainMgrInit (&fi->cm);
+    return fi;
+}
+
+static void FrameInstFree (FrameInst fi)
+{
+    ChainIterRec ci;
+    int frame_no;
+    ExtraDataRec d;
+
+    ChainIterInit (&ci, &fi->cm);
+
+    while (ChainIterGetNext (&ci, &frame_no, &d))
+    {
+        register XimFrameType type;
+        type = fi->template[frame_no].type;
+        if (type == ITER)
+        {
+            if (d.iter)
+                IterFree (d.iter);
+            /*endif*/
+        }
+        else if (type == POINTER)
+        {
+            if (d.fi)
+                FrameInstFree (d.fi);
+            /*endif*/
+        }
+        /*endif*/
+    }
+    /*endwhile*/
+    ChainIterFree (&ci);
+    ChainMgrFree (&fi->cm);
+    Xfree (fi);
+}
+
+static XimFrameType FrameInstGetNextType(FrameInst fi, XimFrameTypeInfo info)
+{
+    XimFrameType ret_type;
+
+    ret_type = fi->template[fi->cur_no].type;
+
+    switch (ret_type)
+    {
+    case BIT8:
+    case BIT16:
+    case BIT32:
+    case BIT64:
+    case EOL:
+        fi->cur_no = _FrameInstIncrement(fi->template, fi->cur_no);
+        break;
+
+    case COUNTER_BIT8:
+    case COUNTER_BIT16:
+    case COUNTER_BIT32:
+    case COUNTER_BIT64:
+        if (info)
+        {
+            register int offset, iter_idx;
+
+            info->counter.is_byte_len =
+                (((long) fi->template[fi->cur_no].data & 0xFF)) == FmCounterByte;
+            offset = ((long) fi->template[fi->cur_no].data) >> 8;
+            iter_idx = fi->cur_no + offset;
+            if (fi->template[iter_idx].type == ITER)
+            {
+                ExtraData d;
+                ExtraDataRec dr;
+
+                if ((d = ChainMgrGetExtraData (&fi->cm, iter_idx)) == NULL)
+                {
+                    dr.iter = IterInit (&fi->template[iter_idx + 1], NO_VALUE);
+                    d = ChainMgrSetData (&fi->cm, iter_idx, dr);
+                }
+                /*endif*/
+                info->counter.iter = d->iter;
+            }
+            else
+            {
+                /* Should never reach here */
+            }
+            /*endif*/
+        }
+        /*endif*/
+        fi->cur_no = _FrameInstIncrement (fi->template, fi->cur_no);
+        break;
+
+    case BARRAY:
+        if (info)
+        {
+            ExtraData d;
+
+            if ((d = ChainMgrGetExtraData (&fi->cm, fi->cur_no)) == NULL)
+                info->num = NO_VALUE;
+            else
+                info->num = d->num;
+            /*endif*/
+        }
+        /*endif*/
+        fi->cur_no = _FrameInstIncrement (fi->template, fi->cur_no);
+        break;
+
+    case PADDING:
+        if (info)
+        {
+            register int unit;
+            register int number;
+            register int size;
+            register int i;
+
+            unit = _UNIT ((long) fi->template[fi->cur_no].data);
+            number = _NUMBER ((long) fi->template[fi->cur_no].data);
+
+            i = fi->cur_no;
+            size = 0;
+            while (number > 0)
+            {
+                i = _FrameInstDecrement (fi->template, i);
+                size += _FrameInstGetItemSize (fi, i);
+                number--;
+            }
+            /*endwhile*/
+            info->num = (unit - (size%unit))%unit;
+        }
+        /*endif*/
+        fi->cur_no = _FrameInstIncrement (fi->template, fi->cur_no);
+        break;
+
+    case ITER:
+        {
+            ExtraData d;
+            ExtraDataRec dr;
+            XimFrameType sub_type;
+
+
+            if ((d = ChainMgrGetExtraData (&fi->cm, fi->cur_no)) == NULL)
+            {
+                dr.iter = IterInit (&fi->template[fi->cur_no + 1], NO_VALUE);
+                d = ChainMgrSetData (&fi->cm, fi->cur_no, dr);
+            }
+            /*endif*/
+            sub_type = IterGetNextType (d->iter, info);
+            if (sub_type == EOL)
+            {
+                fi->cur_no = _FrameInstIncrement (fi->template, fi->cur_no);
+                ret_type = FrameInstGetNextType (fi, info);
+            }
+            else
+            {
+                ret_type = sub_type;
+            }
+            /*endif*/
+        }
+        break;
+
+    case POINTER:
+        {
+            ExtraData d;
+            ExtraDataRec dr;
+            XimFrameType sub_type;
+
+            if ((d = ChainMgrGetExtraData (&fi->cm, fi->cur_no)) == NULL)
+            {
+                dr.fi = FrameInstInit (fi->template[fi->cur_no + 1].data);
+                d = ChainMgrSetData (&fi->cm, fi->cur_no, dr);
+            }
+            /*endif*/
+            sub_type = FrameInstGetNextType (d->fi, info);
+            if (sub_type == EOL)
+            {
+                fi->cur_no = _FrameInstIncrement (fi->template, fi->cur_no);
+                ret_type = FrameInstGetNextType (fi, info);
+            }
+            else
+            {
+                ret_type = sub_type;
+            }
+            /*endif*/
+        }
+        break;
+    default:
+	break;
+    }
+    /*endswitch*/
+    return ret_type;
+}
+
+static XimFrameType FrameInstPeekNextType (FrameInst fi, XimFrameTypeInfo info)
+{
+    XimFrameType ret_type;
+
+    ret_type = fi->template[fi->cur_no].type;
+
+    switch (ret_type)
+    {
+    case BIT8:
+    case BIT16:
+    case BIT32:
+    case BIT64:
+    case EOL:
+        break;
+
+    case COUNTER_BIT8:
+    case COUNTER_BIT16:
+    case COUNTER_BIT32:
+    case COUNTER_BIT64:
+        if (info)
+        {
+            register int offset;
+	    register int iter_idx;
+
+            info->counter.is_byte_len =
+                (((long) fi->template[fi->cur_no].data) & 0xFF) == FmCounterByte;
+            offset = ((long)fi->template[fi->cur_no].data) >> 8;
+            iter_idx = fi->cur_no + offset;
+            if (fi->template[iter_idx].type == ITER)
+            {
+                ExtraData d;
+                ExtraDataRec dr;
+
+                if ((d = ChainMgrGetExtraData (&fi->cm, iter_idx)) == NULL)
+                {
+                    dr.iter = IterInit (&fi->template[iter_idx + 1], NO_VALUE);
+                    d = ChainMgrSetData (&fi->cm, iter_idx, dr);
+                }
+                /*endif*/
+                info->counter.iter = d->iter;
+            }
+            else
+            {
+                /* Should not be reached here */
+            }
+            /*endif*/
+        }
+        /*endif*/
+        break;
+
+    case BARRAY:
+        if (info)
+        {
+            ExtraData d;
+
+            if ((d = ChainMgrGetExtraData (&fi->cm, fi->cur_no)) == NULL)
+                info->num = NO_VALUE;
+            else
+                info->num = d->num;
+            /*endif*/
+        }
+        /*endif*/
+        break;
+
+    case PADDING:
+        if (info)
+        {
+            register int unit;
+            register int number;
+            register int size;
+            register int i;
+
+            unit = _UNIT ((long) fi->template[fi->cur_no].data);
+            number = _NUMBER ((long) fi->template[fi->cur_no].data);
+
+            i = fi->cur_no;
+            size = 0;
+            while (number > 0)
+            {
+                i = _FrameInstDecrement (fi->template, i);
+                size += _FrameInstGetItemSize (fi, i);
+                number--;
+            }
+            /*endwhile*/
+            info->num = (unit - (size%unit))%unit;
+        }
+        /*endif*/
+        break;
+
+    case ITER:
+        {
+            ExtraData d;
+            ExtraDataRec dr;
+            XimFrameType sub_type;
+
+            if ((d = ChainMgrGetExtraData (&fi->cm, fi->cur_no)) == NULL)
+            {
+                dr.iter = IterInit (&fi->template[fi->cur_no + 1], NO_VALUE);
+                d = ChainMgrSetData (&fi->cm, fi->cur_no, dr);
+            }
+            /*endif*/
+            sub_type = IterPeekNextType (d->iter, info);
+            if (sub_type == EOL)
+                ret_type = FrameInstPeekNextType (fi, info);
+            else
+                ret_type = sub_type;
+            /*endif*/
+        }
+        break;
+
+    case POINTER:
+        {
+            ExtraData d;
+            ExtraDataRec dr;
+            XimFrameType sub_type;
+
+            if ((d = ChainMgrGetExtraData (&fi->cm, fi->cur_no)) == NULL)
+            {
+                dr.fi = FrameInstInit (fi->template[fi->cur_no + 1].data);
+                d = ChainMgrSetData (&fi->cm, fi->cur_no, dr);
+            }
+            /*endif*/
+            sub_type = FrameInstPeekNextType (d->fi, info);
+            if (sub_type == EOL)
+                ret_type = FrameInstPeekNextType (fi, info);
+            else
+                ret_type = sub_type;
+            /*endif*/
+	default:
+	    break;
+        }
+        break;
+    }
+    /*endswitch*/
+    return ret_type;
+}
+
+static Bool FrameInstIsIterLoopEnd (FrameInst fi)
+{
+    Bool ret = False;
+
+    if (fi->template[fi->cur_no].type == ITER)
+    {
+        ExtraData d = ChainMgrGetExtraData (&fi->cm, fi->cur_no);
+        Bool yourself;
+
+        if (d)
+        {
+            ret = IterIsLoopEnd (d->iter, &yourself);
+            if (ret  &&  yourself)
+                fi->cur_no = _FrameInstIncrement (fi->template, fi->cur_no);
+            /*endif*/
+        }
+        /*endif*/
+    }
+    /*endif*/
+    return (ret);
+}
+
+static FrameIter _FrameMgrAppendIter (FrameMgr fm, Iter it, int end)
+{
+    FrameIter p = fm->iters;
+
+    while (p  &&  p->next)
+        p = p->next;
+    /*endwhile*/
+
+    if (!p)
+    {
+        fm->iters =
+        p = (FrameIter) Xmalloc (sizeof (FrameIterRec));
+    }
+    else
+    {
+        p->next = (FrameIter) Xmalloc (sizeof (FrameIterRec));
+        p = p->next;
+    }
+    /*endif*/
+    if (p)
+    {
+        p->iter = it;
+        p->counting = False;
+        p->counter = 0;
+        p->end = end;
+        p->next = NULL;
+    }
+    /*endif*/
+    return (p);
+}
+
+static void _FrameMgrRemoveIter (FrameMgr fm, FrameIter it)
+{
+    FrameIter prev;
+    FrameIter p;
+
+    prev = NULL;
+    p = fm->iters;
+    while (p)
+    {
+        if (p == it)
+        {
+            if (prev)
+                prev->next = p->next;
+            else
+                fm->iters = p->next;
+            /*endif*/
+            Xfree (p);
+            break;
+        }
+        /*endif*/
+        prev = p;
+        p = p->next;
+    }
+    /*endwhile*/
+}
+
+static FrameIter _FrameIterCounterIncr (FrameIter fitr, int i)
+{
+    FrameIter p = fitr;
+
+    while (p)
+    {
+        if (p->counting)
+        {
+            p->counter += i;
+            if (p->counter >= p->end)
+            {
+                IterFixIteration (p->iter);
+                return (p);
+            }
+            /*endif*/
+        }
+        /*endif*/
+        p = p->next;
+    }
+    /*endwhile*/
+    return (NULL);
+}
+
+static void _IterStartWatch (Iter it, void *client_data)
+{
+    FrameIter p = (FrameIter) client_data;
+    p->counting = True;
+}
+
+static FmStatus FrameInstSetSize (FrameInst fi, int num)
+{
+    ExtraData d;
+    ExtraDataRec dr;
+    XimFrameType type;
+    register int i;
+
+    i = 0;
+    while ((type = fi->template[i].type) != EOL)
+    {
+        switch (type)
+        {
+        case BARRAY:
+            if ((d = ChainMgrGetExtraData (&fi->cm, i)) == NULL)
+            {
+                dr.num = -1;
+                d = ChainMgrSetData (&fi->cm, i, dr);
+            }
+            /*endif*/
+            if (d->num == NO_VALUE)
+            {
+                d->num = num;
+                return FmSuccess;
+            }
+            /*endif*/
+            break;
+        case ITER:
+            if ((d = ChainMgrGetExtraData (&fi->cm, i)) == NULL)
+            {
+                dr.iter = IterInit (&fi->template[i + 1], NO_VALUE);
+                d = ChainMgrSetData (&fi->cm, i, dr);
+            }
+            /*endif*/
+            if (IterSetSize (d->iter, num) == FmSuccess)
+                return FmSuccess;
+            /*endif*/
+            break;
+
+        case POINTER:
+            if ((d = ChainMgrGetExtraData(&fi->cm, i)) == NULL)
+            {
+                dr.fi = FrameInstInit(fi->template[i + 1].data);
+                d = ChainMgrSetData(&fi->cm, i, dr);
+            }
+            /*endif*/
+            if (FrameInstSetSize(d->fi, num) == FmSuccess)
+                return FmSuccess;
+            /*endif*/
+            break;
+	default:
+	    break;
+        }
+        /*endswitch*/
+        i = _FrameInstIncrement(fi->template, i);
+    }
+    /*endwhile*/
+    return FmNoMoreData;
+}
+
+static int FrameInstGetSize (FrameInst fi)
+{
+    XimFrameType type;
+    register int i;
+    ExtraData d;
+    ExtraDataRec dr;
+    int ret_size;
+
+    i = fi->cur_no;
+    while ((type = fi->template[i].type) != EOL)
+    {
+        switch (type)
+        {
+        case BARRAY:
+            if ((d = ChainMgrGetExtraData (&fi->cm, i)) == NULL)
+                return NO_VALUE;
+            /*endif*/
+            return d->num;
+
+        case ITER:
+            if ((d = ChainMgrGetExtraData (&fi->cm, i)) == NULL)
+            {
+                dr.iter = IterInit (&fi->template[i + 1], NO_VALUE);
+                d = ChainMgrSetData (&fi->cm, i, dr);
+            }
+            /*endif*/
+            ret_size = IterGetSize(d->iter);
+            if (ret_size != NO_VALID_FIELD)
+                return ret_size;
+            /*endif*/
+            break;
+
+        case POINTER:
+            if ((d = ChainMgrGetExtraData (&fi->cm, i)) == NULL)
+            {
+                dr.fi = FrameInstInit (fi->template[i + 1].data);
+                d = ChainMgrSetData (&fi->cm, i, dr);
+            }
+            /*endif*/
+            ret_size = FrameInstGetSize (d->fi);
+            if (ret_size != NO_VALID_FIELD)
+                return ret_size;
+            /*endif*/
+            break;
+	default:
+	    break;
+        }
+        /*endswitch*/
+        i = _FrameInstIncrement (fi->template, i);
+    }
+    /*endwhile*/
+    return NO_VALID_FIELD;
+}
+
+static FmStatus FrameInstSetIterCount (FrameInst fi, int num)
+{
+    ExtraData d;
+    ExtraDataRec dr;
+    register int i;
+    XimFrameType type;
+
+    i = 0;
+    while ((type = fi->template[i].type) != EOL)
+    {
+        switch (type)
+        {
+        case ITER:
+            if ((d = ChainMgrGetExtraData (&fi->cm, i)) == NULL)
+            {
+                dr.iter = IterInit (&fi->template[i + 1], num);
+                (void)ChainMgrSetData (&fi->cm, i, dr);
+                return FmSuccess;
+            }
+            /*endif*/
+            if (IterSetIterCount (d->iter, num) == FmSuccess)
+                return FmSuccess;
+            /*endif*/
+            break;
+
+        case POINTER:
+            if ((d = ChainMgrGetExtraData (&fi->cm, i)) == NULL)
+            {
+                dr.fi = FrameInstInit (fi->template[i + 1].data);
+                d = ChainMgrSetData (&fi->cm, i, dr);
+            }
+            /*endif*/
+            if (FrameInstSetIterCount (d->fi, num) == FmSuccess)
+                return FmSuccess;
+            /*endif*/
+            break;
+
+	default:
+	    break;
+        }
+        /*endswitch*/
+        i = _FrameInstIncrement (fi->template, i);
+    }
+    /*endwhile*/
+    return FmNoMoreData;
+}
+
+static int FrameInstGetTotalSize (FrameInst fi)
+{
+    register int size;
+    register int i;
+
+    size = 0;
+    i = 0;
+
+    while (fi->template[i].type != EOL)
+    {
+        size += _FrameInstGetItemSize (fi, i);
+        i = _FrameInstIncrement (fi->template, i);
+    }
+    /*endwhile*/
+    return size;
+}
+
+static void FrameInstReset (FrameInst fi)
+{
+    ChainIterRec ci;
+    int frame_no;
+    ExtraDataRec d;
+
+    ChainIterInit (&ci, &fi->cm);
+
+    while (ChainIterGetNext (&ci, &frame_no, &d))
+    {
+        register XimFrameType type;
+        type = fi->template[frame_no].type;
+        if (type == ITER)
+        {
+            if (d.iter)
+                IterReset (d.iter);
+            /*endif*/
+        }
+        else if (type == POINTER)
+        {
+            if (d.fi)
+                FrameInstReset (d.fi);
+            /*endif*/
+        }
+        /*endif*/
+    }
+    /*endwhile*/
+    ChainIterFree (&ci);
+
+    fi->cur_no = 0;
+}
+
+static Iter IterInit (XimFrame frame, int count)
+{
+    Iter it;
+    register XimFrameType type;
+
+    it = (Iter) Xmalloc (sizeof (IterRec));
+    it->template = frame;
+    it->max_count = (count == NO_VALUE)  ?  0  :  count;
+    it->allow_expansion = (count == NO_VALUE);
+    it->cur_no = 0;
+    it->start_watch_proc = NULL;
+    it->client_data = NULL;
+    it->start_counter = False;
+
+    type = frame->type;
+    if (type & COUNTER_MASK)
+    {
+        /* COUNTER_XXX cannot be an item of a ITER */
+        Xfree (it);
+        return NULL;
+    }
+    /*endif*/
+
+    switch (type)
+    {
+    case BIT8:
+    case BIT16:
+    case BIT32:
+    case BIT64:
+        /* Do nothing */
+        break;
+
+    case BARRAY:
+    case ITER:
+    case POINTER:
+        ChainMgrInit (&it->cm);
+        break;
+
+    default:
+        Xfree (it);
+        return NULL; /* This should never occur */
+    }
+    /*endswitch*/
+    return it;
+}
+
+static void IterFree (Iter it)
+{
+    switch (it->template->type)
+    {
+    case BARRAY:
+        ChainMgrFree (&it->cm);
+        break;
+
+    case ITER:
+        {
+            ChainIterRec ci;
+            int count;
+            ExtraDataRec d;
+
+            ChainIterInit (&ci, &it->cm);
+            while (ChainIterGetNext (&ci, &count, &d))
+                IterFree (d.iter);
+            /*endwhile*/
+            ChainIterFree (&ci);
+            ChainMgrFree (&it->cm);
+        }
+        break;
+
+    case POINTER:
+        {
+            ChainIterRec ci;
+            int count;
+            ExtraDataRec dr;
+
+            ChainIterInit (&ci, &it->cm);
+            while (ChainIterGetNext (&ci, &count, &dr))
+                FrameInstFree (dr.fi);
+            /*endwhile*/
+            ChainIterFree (&ci);
+            ChainMgrFree (&it->cm);
+        }
+        break;
+
+    default:
+	break;
+    }
+    /*endswitch*/
+    Xfree (it);
+}
+
+static Bool IterIsLoopEnd (Iter it, Bool *myself)
+{
+    Bool ret = False;
+    *myself = False;
+
+    if (!it->allow_expansion  &&  (it->cur_no == it->max_count))
+    {
+        *myself = True;
+        return True;
+    }
+    /*endif*/
+
+    if (it->template->type == POINTER)
+    {
+        ExtraData d = ChainMgrGetExtraData (&it->cm, it->cur_no);
+        if (d)
+        {
+            if (FrameInstIsIterLoopEnd (d->fi))
+            {
+                ret = True;
+            }
+            else
+            {
+                if (FrameInstIsEnd (d->fi))
+                {
+                    it->cur_no++;
+                    if (!it->allow_expansion  &&  it->cur_no == it->max_count)
+                    {
+                        *myself = True;
+                        ret = True;
+                    }
+                    /*endif*/
+                }
+                /*endif*/
+            }
+            /*endif*/
+        }
+        /*endif*/
+    }
+    else if (it->template->type == ITER)
+    {
+        ExtraData d = ChainMgrGetExtraData (&it->cm, it->cur_no);
+        if (d)
+        {
+            Bool yourself;
+
+            if (IterIsLoopEnd (d->iter, &yourself))
+                ret = True;
+            /*endif*/
+        }
+        /*endif*/
+    }
+    /*endif*/
+
+    return ret;
+}
+
+static XimFrameType IterGetNextType (Iter it, XimFrameTypeInfo info)
+{
+    XimFrameType type = it->template->type;
+
+    if (it->start_counter)
+    {
+        (*it->start_watch_proc) (it, it->client_data);
+        it->start_counter = False;
+    }
+    /*endif*/
+    if (it->cur_no >= it->max_count)
+    {
+        if (it->allow_expansion)
+            it->max_count = it->cur_no + 1;
+        else
+            return EOL;
+        /*endif*/
+    }
+    /*endif*/
+
+    switch (type)
+    {
+    case BIT8:
+    case BIT16:
+    case BIT32:
+    case BIT64:
+        it->cur_no++;
+        return type;
+
+    case BARRAY:
+        if (info)
+        {
+            ExtraData d;
+
+            if ((d = ChainMgrGetExtraData (&it->cm, it->cur_no)) == NULL)
+                info->num = NO_VALUE;
+            else
+                info->num = d->num;
+            /*endif*/
+        }
+        /*endif*/
+        it->cur_no++;
+        return BARRAY;
+
+    case ITER:
+        {
+            XimFrameType ret_type;
+            ExtraData d;
+            ExtraDataRec dr;
+
+            if ((d = ChainMgrGetExtraData (&it->cm, it->cur_no)) == NULL)
+            {
+                dr.iter = IterInit (it->template + 1, NO_VALUE);
+                d = ChainMgrSetData (&it->cm, it->cur_no, dr);
+            }
+            /*endif*/
+
+            ret_type = IterGetNextType (d->iter, info);
+            if (ret_type == EOL)
+            {
+                it->cur_no++;
+                ret_type = IterGetNextType (it, info);
+            }
+            /*endif*/
+	    return ret_type;
+        }
+
+    case POINTER:
+        {
+            XimFrameType ret_type;
+            ExtraData d;
+            ExtraDataRec dr;
+
+            if ((d = ChainMgrGetExtraData (&it->cm, it->cur_no)) == NULL)
+            {
+                dr.fi = FrameInstInit (it->template[1].data);
+                d = ChainMgrSetData (&it->cm, it->cur_no, dr);
+            }
+            /*endif*/
+
+            ret_type = FrameInstGetNextType (d->fi, info);
+            if (ret_type == EOL)
+            {
+                it->cur_no++;
+                ret_type = IterGetNextType (it, info);
+            }
+            /*endif*/
+	    return ret_type;
+        }
+
+    default:
+	return (XimFrameType) NULL;
+    }
+    /*endswitch*/
+    return (XimFrameType) NULL;  /* This should never occur */
+}
+
+static XimFrameType IterPeekNextType (Iter it, XimFrameTypeInfo info)
+{
+    XimFrameType type = it->template->type;
+
+    if (!it->allow_expansion  &&  it->cur_no >= it->max_count)
+        return (EOL);
+    /*endif*/
+
+    switch (type)
+    {
+    case BIT8:
+    case BIT16:
+    case BIT32:
+    case BIT64:
+        return type;
+
+    case BARRAY:
+        if (info)
+        {
+            ExtraData d;
+
+            if ((d = ChainMgrGetExtraData (&it->cm, it->cur_no)) == NULL)
+                info->num = NO_VALUE;
+            else
+                info->num = d->num;
+            /*endif*/
+        }
+        /*endif*/
+        return BARRAY;
+
+    case ITER:
+        {
+            XimFrameType ret_type;
+            ExtraData d;
+            ExtraDataRec dr;
+
+            if ((d = ChainMgrGetExtraData (&it->cm, it->cur_no)) == NULL)
+            {
+                dr.iter = IterInit (it->template + 1, NO_VALUE);
+                d = ChainMgrSetData (&it->cm, it->cur_no, dr);
+            }
+            /*endif*/
+
+            ret_type = IterPeekNextType (d->iter, info);
+            if (ret_type == EOL)
+                ret_type = IterPeekNextType (it, info);
+            /*endif*/
+            return ret_type;
+        }
+
+    case POINTER:
+        {
+            XimFrameType ret_type;
+            ExtraData d;
+            ExtraDataRec dr;
+
+            if ((d = ChainMgrGetExtraData (&it->cm, it->cur_no)) == NULL)
+            {
+                dr.fi = FrameInstInit (it->template[1].data);
+                d = ChainMgrSetData (&it->cm, it->cur_no, dr);
+            }
+            /*endif*/
+
+            ret_type = FrameInstPeekNextType (d->fi, info);
+            if (ret_type == EOL)
+                ret_type = IterPeekNextType (it, info);
+            /*endif*/
+            return (ret_type);
+        }
+
+    default:
+	break;
+    }
+    /*endswitch*/
+    /* Reaching here is a bug! */
+    return (XimFrameType) NULL;
+}
+
+static FmStatus IterSetSize (Iter it, int num)
+{
+    XimFrameType type;
+    register int i;
+
+    if (!it->allow_expansion  &&  it->max_count == 0)
+        return FmNoMoreData;
+    /*endif*/
+
+    type = it->template->type;
+    switch (type)
+    {
+    case BARRAY:
+        {
+            ExtraData d;
+            ExtraDataRec dr;
+
+            for (i = 0;  i < it->max_count;  i++)
+            {
+                if ((d = ChainMgrGetExtraData (&it->cm, i)) == NULL)
+                {
+                    dr.num = NO_VALUE;
+                    d = ChainMgrSetData (&it->cm, i, dr);
+                }
+                /*endif*/
+                if (d->num == NO_VALUE)
+                {
+                    d->num = num;
+                    return FmSuccess;
+                }
+                /*endif*/
+            }
+            /*endfor*/
+            if (it->allow_expansion)
+            {
+                ExtraDataRec dr;
+
+                dr.num = num;
+                ChainMgrSetData (&it->cm, it->max_count, dr);
+                it->max_count++;
+
+                return FmSuccess;
+            }
+            /*endif*/
+        }
+        return FmNoMoreData;
+
+    case ITER:
+        {
+            ExtraData d;
+            ExtraDataRec dr;
+
+            for (i = 0;  i < it->max_count;  i++)
+            {
+                if ((d = ChainMgrGetExtraData (&it->cm, i)) == NULL)
+                {
+                    dr.iter = IterInit (it->template + 1, NO_VALUE);
+                    d = ChainMgrSetData (&it->cm, i, dr);
+                }
+                /*endif*/
+                if (IterSetSize (d->iter, num) == FmSuccess)
+                    return FmSuccess;
+                /*endif*/
+            }
+            /*endfor*/
+            if (it->allow_expansion)
+            {
+                ExtraDataRec dr;
+
+                dr.iter = IterInit (it->template + 1, NO_VALUE);
+                ChainMgrSetData (&it->cm, it->max_count, dr);
+                it->max_count++;
+
+                if (IterSetSize(dr.iter, num) == FmSuccess)
+                    return FmSuccess;
+                /*endif*/
+            }
+            /*endif*/
+        }
+        return FmNoMoreData;
+
+    case POINTER:
+        {
+            ExtraData d;
+            ExtraDataRec dr;
+
+            for (i = 0;  i < it->max_count;  i++)
+            {
+                if ((d = ChainMgrGetExtraData (&it->cm, i)) == NULL)
+                {
+                    dr.fi = FrameInstInit (it->template[1].data);
+                    d = ChainMgrSetData (&it->cm, i, dr);
+                }
+                /*endif*/
+                if (FrameInstSetSize (d->fi, num) == FmSuccess)
+                    return FmSuccess;
+                /*endif*/
+            }
+            /*endfor*/
+            if (it->allow_expansion)
+            {
+                ExtraDataRec dr;
+
+                dr.fi = FrameInstInit (it->template[1].data);
+                ChainMgrSetData (&it->cm, it->max_count, dr);
+                it->max_count++;
+
+                if (FrameInstSetSize (dr.fi, num) == FmSuccess)
+                    return FmSuccess;
+                /*endif*/
+            }
+            /*endif*/
+        }
+        return FmNoMoreData;
+
+    default:
+	break;
+    }
+    /*endswitch*/
+    return FmNoMoreData;
+}
+
+static int IterGetSize (Iter it)
+{
+    register int i;
+    ExtraData d;
+    ExtraDataRec dr;
+
+    if (it->cur_no >= it->max_count)
+        return NO_VALID_FIELD;
+    /*endif*/
+
+    switch (it->template->type)
+    {
+    case BARRAY:
+        if ((d = ChainMgrGetExtraData (&it->cm, it->cur_no)) == NULL)
+            return NO_VALUE;
+        /*endif*/
+        return d->num;
+
+    case ITER:
+        for (i = it->cur_no; i < it->max_count; i++)
+        {
+            int ret_size;
+
+            if ((d = ChainMgrGetExtraData (&it->cm, i)) == NULL)
+            {
+                dr.iter = IterInit (it->template + 1, NO_VALUE);
+                d = ChainMgrSetData (&it->cm, i, dr);
+            }
+            /*endif*/
+            ret_size = IterGetSize (d->iter);
+            if (ret_size != NO_VALID_FIELD)
+                return ret_size;
+            /*endif*/
+        }
+        /*endfor*/
+        return NO_VALID_FIELD;
+
+    case POINTER:
+        for (i = it->cur_no;  i < it->max_count;  i++)
+        {
+            int ret_size;
+
+            if ((d = ChainMgrGetExtraData (&it->cm, i)) == NULL)
+            {
+                dr.fi = FrameInstInit (it->template[1].data);
+                d = ChainMgrSetData (&it->cm, i, dr);
+            }
+            /*endif*/
+            ret_size = FrameInstGetSize (d->fi);
+            if (ret_size != NO_VALID_FIELD)
+                return ret_size;
+            /*endif*/
+        }
+        /*endfor*/
+        return NO_VALID_FIELD;
+
+    default:
+	break;
+    }
+    /*endswitch*/
+    return NO_VALID_FIELD;
+}
+
+static FmStatus IterSetIterCount (Iter it, int num)
+{
+    register int i;
+
+    if (it->allow_expansion)
+    {
+        it->max_count = num;
+        it->allow_expansion = False;
+        return FmSuccess;
+    }
+    /*endif*/
+
+    if (it->max_count == 0)
+        return FmNoMoreData;
+    /*endif*/
+
+    switch (it->template->type)
+    {
+    case ITER:
+        for (i = 0;  i < it->max_count;  i++)
+        {
+            ExtraData d;
+            ExtraDataRec dr;
+
+            if ((d = ChainMgrGetExtraData(&it->cm, i)) == NULL)
+            {
+                dr.iter = IterInit(it->template + 1, num);
+                (void)ChainMgrSetData(&it->cm, i, dr);
+                return FmSuccess;
+            }
+            /*endif*/
+            if (IterSetIterCount(d->iter, num) == FmSuccess)
+                return FmSuccess;
+            /*endif*/
+        }
+        /*endfor*/
+        if (it->allow_expansion)
+        {
+            ExtraDataRec dr;
+
+            dr.iter = IterInit (it->template + 1, num);
+            ChainMgrSetData (&it->cm, it->max_count, dr);
+            it->max_count++;
+
+            return FmSuccess;
+        }
+        /*endif*/
+        break;
+
+    case POINTER:
+        for (i = 0;  i < it->max_count;  i++)
+        {
+            ExtraData d;
+            ExtraDataRec dr;
+
+            if ((d = ChainMgrGetExtraData (&it->cm, i)) == NULL)
+            {
+                dr.fi = FrameInstInit (it->template[1].data);
+                d = ChainMgrSetData (&it->cm, i, dr);
+            }
+            /*endif*/
+            if (FrameInstSetIterCount (d->fi, num) == FmSuccess)
+                return FmSuccess;
+            /*endif*/
+        }
+        /*endfor*/
+        if (it->allow_expansion)
+        {
+            ExtraDataRec dr;
+
+            dr.fi = FrameInstInit (it->template[1].data);
+            ChainMgrSetData (&it->cm, it->max_count, dr);
+            it->max_count++;
+
+            if (FrameInstSetIterCount (dr.fi, num) == FmSuccess)
+                return FmSuccess;
+            /*endif*/
+        }
+        /*endif*/
+        break;
+
+    default:
+	break;
+    }
+    /*endswitch*/
+    return FmNoMoreData;
+}
+
+static int IterGetTotalSize (Iter it)
+{
+    register int size, i;
+    XimFrameType type;
+
+    if (it->allow_expansion)
+        return NO_VALUE;
+    /*endif*/
+    if (it->max_count == 0)
+        return 0;
+    /*endif*/
+
+    size = 0;
+    type = it->template->type;
+
+    switch (type)
+    {
+    case BIT8:
+        size = it->max_count;
+        break;
+
+    case BIT16:
+        size = it->max_count*2;
+        break;
+
+    case BIT32:
+        size = it->max_count*4;
+        break;
+
+    case BIT64:
+        size = it->max_count*8;
+        break;
+
+    case BARRAY:
+        for (i = 0;  i < it->max_count;  i++)
+        {
+            register int num;
+            ExtraData d;
+
+            if ((d = ChainMgrGetExtraData (&it->cm, i)) == NULL)
+                return  NO_VALUE;
+            /*endif*/
+            if ((num = d->num) == NO_VALUE)
+                return  NO_VALUE;
+            /*endif*/
+            size += num;
+        }
+        /*endfor*/
+        break;
+
+    case ITER:
+        for (i = 0;  i < it->max_count;  i++)
+        {
+            register int num;
+            ExtraData d;
+
+            if ((d = ChainMgrGetExtraData (&it->cm, i)) == NULL)
+                return  NO_VALUE;
+            /*endif*/
+            if ((num = IterGetTotalSize (d->iter)) == NO_VALUE)
+                return  NO_VALUE;
+            /*endif*/
+            size += num;
+        }
+        /*endfor*/
+        break;
+
+    case POINTER:
+        for (i = 0;  i < it->max_count;  i++)
+        {
+            register int num;
+            ExtraData d;
+            ExtraDataRec dr;
+
+            if ((d = ChainMgrGetExtraData (&it->cm, i)) == NULL)
+            {
+                dr.fi = FrameInstInit (it->template[1].data);
+                d = ChainMgrSetData (&it->cm, i, dr);
+            }
+            /*endif*/
+            if ((num = FrameInstGetTotalSize (d->fi)) == NO_VALUE)
+                return NO_VALUE;
+            /*endif*/
+            size += num;
+        }
+        /*endfor*/
+        break;
+
+    default:
+	break;
+    }
+    /*endswitch*/
+    return  size;
+}
+
+static void IterReset (Iter it)
+{
+    ChainIterRec ci;
+    int count;
+    ExtraDataRec d;
+
+    switch (it->template->type)
+    {
+    case ITER:
+        ChainIterInit (&ci, &it->cm);
+        while (ChainIterGetNext (&ci, &count, &d))
+            IterReset (d.iter);
+        /*endwhile*/
+        ChainIterFree (&ci);
+        break;
+
+    case POINTER:
+        ChainIterInit (&ci, &it->cm);
+        while (ChainIterGetNext (&ci, &count, &d))
+            FrameInstReset (d.fi);
+        /*endwhile*/
+        ChainIterFree (&ci);
+        break;
+
+    default:
+	break;
+    }
+    /*endswitch*/
+    it->cur_no = 0;
+}
+
+static void IterSetStartWatch (Iter it,
+                               IterStartWatchProc proc,
+                               void *client_data)
+{
+    it->start_watch_proc = proc;
+    it->client_data = client_data;
+}
+
+static ExtraData ChainMgrSetData (ChainMgr cm,
+                                  int frame_no,
+                                  ExtraDataRec data)
+{
+    Chain cur = (Chain) Xmalloc (sizeof (ChainRec));
+
+    cur->frame_no = frame_no;
+    cur->d = data;
+    cur->next = NULL;
+
+    if (cm->top == NULL)
+    {
+        cm->top = cm->tail = cur;
+    }
+    else
+    {
+        cm->tail->next = cur;
+        cm->tail = cur;
+    }
+    /*endif*/
+    return &cur->d;
+}
+
+static ExtraData ChainMgrGetExtraData (ChainMgr cm, int frame_no)
+{
+    Chain cur;
+
+    cur = cm->top;
+
+    while (cur)
+    {
+        if (cur->frame_no == frame_no)
+            return &cur->d;
+        /*endif*/
+        cur = cur->next;
+    }
+    /*endwhile*/
+    return NULL;
+}
+
+static Bool ChainIterGetNext (ChainIter ci, int *frame_no, ExtraData d)
+{
+    if (ci->cur == NULL)
+        return False;
+    /*endif*/
+
+    *frame_no = ci->cur->frame_no;
+    *d = ci->cur->d;
+
+    ci->cur = ci->cur->next;
+
+    return True;
+}
+
+static int _FrameInstIncrement (XimFrame frame, int count)
+{
+    XimFrameType type;
+
+    type = frame[count].type;
+    type &= ~COUNTER_MASK;
+
+    switch (type)
+    {
+    case BIT8:
+    case BIT16:
+    case BIT32:
+    case BIT64:
+    case BARRAY:
+    case PADDING:
+        return count + 1;
+
+    case POINTER:
+        return count + 2;
+
+    case ITER:
+        return _FrameInstIncrement (frame, count + 1);
+    default:
+	break;
+    }
+    /*endswitch*/
+    return - 1;    /* Error */
+}
+
+static int _FrameInstDecrement (XimFrame frame, int count)
+{
+    register int i;
+    XimFrameType type;
+
+    if (count == 0)
+        return - 1;    /* cannot decrement */
+    /*endif*/
+
+    if (count == 1)
+        return 0;     /* BOGUS - It should check the contents of data */
+    /*endif*/
+
+    type = frame[count - 2].type;
+    type &= ~COUNTER_MASK;
+
+    switch (type)
+    {
+    case BIT8:
+    case BIT16:
+    case BIT32:
+    case BIT64:
+    case BARRAY:
+    case PADDING:
+    case PTR_ITEM:
+        return count - 1;
+
+    case POINTER:
+    case ITER:
+        i = count - 3;
+        while (i >= 0)
+        {
+            if (frame[i].type != ITER)
+                return i + 1;
+            /*endif*/
+            i--;
+        }
+        /*endwhile*/
+        return 0;
+    default:
+	break;
+    }
+    /*enswitch*/
+    return - 1;    /* Error */
+}
+
+static int _FrameInstGetItemSize (FrameInst fi, int cur_no)
+{
+    XimFrameType type;
+
+    type = fi->template[cur_no].type;
+    type &= ~COUNTER_MASK;
+
+    switch (type)
+    {
+    case BIT8:
+        return 1;
+
+    case BIT16:
+        return 2;
+
+    case BIT32:
+        return 4;
+
+    case BIT64:
+        return 8;
+
+    case BARRAY:
+        {
+            ExtraData d;
+
+            if ((d = ChainMgrGetExtraData (&fi->cm, cur_no)) == NULL)
+                return NO_VALUE;
+            /*endif*/
+            if (d->num == NO_VALUE)
+                return NO_VALUE;
+            /*endif*/
+            return d->num;
+        }
+
+    case PADDING:
+        {
+            register int unit;
+            register int number;
+            register int size;
+            register int i;
+
+            unit = _UNIT ((long) fi->template[cur_no].data);
+            number = _NUMBER ((long) fi->template[cur_no].data);
+
+            i = cur_no;
+            size = 0;
+            while (number > 0)
+            {
+                i = _FrameInstDecrement (fi->template, i);
+                size += _FrameInstGetItemSize (fi, i);
+                number--;
+            }
+            /*endwhile*/
+            size = (unit - (size%unit))%unit;
+            return size;
+        }
+
+    case ITER:
+        {
+            ExtraData d;
+            int sub_size;
+
+            if ((d = ChainMgrGetExtraData (&fi->cm, cur_no)) == NULL)
+                return NO_VALUE;
+            /*endif*/
+            sub_size = IterGetTotalSize (d->iter);
+            if (sub_size == NO_VALUE)
+                return NO_VALUE;
+            /*endif*/
+            return sub_size;
+        }
+
+    case POINTER:
+        {
+            ExtraData d;
+            int sub_size;
+
+            if ((d = ChainMgrGetExtraData (&fi->cm, cur_no)) == NULL)
+                return NO_VALUE;
+            /*endif*/
+            sub_size = FrameInstGetTotalSize (d->fi);
+            if (sub_size == NO_VALUE)
+                return NO_VALUE;
+            /*endif*/
+            return sub_size;
+        }
+
+    default:
+	break;
+    }
+    /*endswitch*/
+    return NO_VALUE;
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/FrameMgr.h b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/FrameMgr.h
new file mode 100644
index 0000000..ce7ed50
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/FrameMgr.h
@@ -0,0 +1,131 @@
+/******************************************************************
+Copyright 1993, 1994 by Digital Equipment Corporation, Maynard, Massachusetts,
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the names of Digital or MIT not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+  Author: Hiroyuki Miyamoto  Digital Equipment Corporation
+                             miyamoto@jrd.dec.com
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#ifndef FRAMEMGR_H
+#define FRAMEMGR_H
+
+#include <X11/Xmd.h>
+#include <X11/Xlib.h>
+#include <stdio.h>
+
+#if defined(VAXC) && !defined(__DECC)
+#define xim_externalref globalref
+#define xim_externaldef globaldef
+#else
+#define xim_externalref extern
+#define xim_externaldef
+#endif
+
+/* Definitions for FrameMgr */
+
+#define COUNTER_MASK 0x10
+
+typedef enum
+{
+    BIT8     = 0x1,       /* {CARD8* | INT8*}   */
+    BIT16    = 0x2,       /* {CARD16* | INT16*} */
+    BIT32    = 0x3,       /* {CARD32* | INT32*} */
+    BIT64    = 0x4,	  /* {CARD64* | INT64*} */
+    BARRAY   = 0x5,       /* int*, void*        */
+    ITER     = 0x6,       /* int*               */
+    POINTER  = 0x7,       /* specifies next item is a PTR_ITEM */
+    PTR_ITEM = 0x8,       /* specifies the item has a pointer */
+    /* BOGUS - POINTER and PTR_ITEM
+     *   In the current implementation, PTR_ITEM should be lead by
+     *   POINTER.  But actually, it's just redundant logically.  Someone
+     *   may remove this redundancy and POINTER from the enum member but he
+     *   should also modify the logic in FrameMgr program.
+     */
+    PADDING  = 0x9,       /* specifies that a padding is needed.
+		           * This requires extra data in data field.
+		           */
+    EOL      = 0xA,       /* specifies the end of list */
+
+    COUNTER_BIT8  = COUNTER_MASK | 0x1,
+    COUNTER_BIT16 = COUNTER_MASK | 0x2,
+    COUNTER_BIT32 = COUNTER_MASK | 0x3,
+    COUNTER_BIT64 = COUNTER_MASK | 0x4
+} XimFrameType;
+
+/* Convenient macro */
+#define _FRAME(a) {a, NULL}
+#define _PTR(p)   {PTR_ITEM, (void *)p}
+/* PADDING's usage of data field
+ * B15-B8  : Shows the number of effective items.
+ * B7-B0   : Shows padding unit.  ex) 04 shows 4 unit padding.
+ */
+#define _PAD2(n)   {PADDING, (void*)((n)<<8|2)}
+#define _PAD4(n)   {PADDING, (void*)((n)<<8|4)}
+
+#define FmCounterByte 0
+#define FmCounterNumber 1
+
+#define _BYTE_COUNTER(type, offset) \
+               {(COUNTER_MASK|type), (void*)((offset)<<8|FmCounterByte)}
+
+#define _NUMBER_COUNTER(type, offset) \
+               {(COUNTER_MASK|type), (void*)((offset)<<8|FmCounterNumber)}
+
+typedef struct _XimFrame
+{
+    XimFrameType type;
+    void* data;       /* For PTR_ITEM and PADDING */
+} XimFrameRec, *XimFrame;
+
+typedef enum
+{
+    FmSuccess,
+    FmEOD,
+    FmInvalidCall,
+    FmBufExist,
+    FmCannotCalc,
+    FmNoMoreData
+} FmStatus;
+
+typedef struct _FrameMgr *FrameMgr;
+
+FrameMgr FrameMgrInit(XimFrame frame, char* area, Bool byte_swap);
+void FrameMgrInitWithData(FrameMgr fm, XimFrame frame, void* area,
+			  Bool byte_swap);
+void FrameMgrFree(FrameMgr fm);
+FmStatus FrameMgrSetBuffer(FrameMgr, void*);
+FmStatus _FrameMgrPutToken(FrameMgr, void*, int);
+FmStatus _FrameMgrGetToken(FrameMgr, void*, int);
+FmStatus FrameMgrSetSize(FrameMgr, int);
+FmStatus FrameMgrSetIterCount(FrameMgr, int);
+FmStatus FrameMgrSetTotalSize(FrameMgr, int);
+int FrameMgrGetTotalSize(FrameMgr);
+int FrameMgrGetSize(FrameMgr);
+FmStatus FrameMgrSkipToken(FrameMgr, int);
+void FrameMgrReset(FrameMgr);
+Bool FrameMgrIsIterLoopEnd(FrameMgr, FmStatus*);
+
+#define FrameMgrPutToken(fm, obj) _FrameMgrPutToken((fm), &(obj), sizeof(obj))
+#define FrameMgrGetToken(fm, obj) _FrameMgrGetToken((fm), &(obj), sizeof(obj))
+
+#endif /* FRAMEMGR_H */
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/IMConn.c b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/IMConn.c
new file mode 100644
index 0000000..44cd9e8
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/IMConn.c
@@ -0,0 +1,176 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#include <X11/Xlib.h>
+#include <stdlib.h>
+#include <string.h>
+#include "../include/IMdkit.h"
+#include <stdarg.h>
+
+#define Va_start(a,b) va_start(a,b)
+
+static void _IMCountVaList(va_list var, int *total_count)
+{
+    char *attr;
+
+    *total_count = 0;
+
+    for (attr = va_arg (var, char*);  attr;  attr = va_arg (var, char*))
+    {
+	(void)va_arg (var, XIMArg *);
+	++(*total_count);
+    }
+    /*endfor*/
+}
+
+static void _IMVaToNestedList(va_list var, int max_count, XIMArg **args_return)
+{
+    XIMArg *args;
+    char   *attr;
+
+    if (max_count <= 0)
+    {
+	*args_return = (XIMArg *) NULL;
+	return;
+    }
+    /*endif*/
+
+    args = (XIMArg *) malloc ((unsigned) (max_count + 1)*sizeof (XIMArg));
+    *args_return = args;
+    if (!args)
+        return;
+    /*endif*/
+
+    for (attr = va_arg (var, char*);  attr;  attr = va_arg (var, char *))
+    {
+	args->name = attr;
+	args->value = va_arg (var, XPointer);
+	args++;
+    }
+    /*endfor*/
+    args->name = (char*)NULL;
+}
+
+static char *_FindModifiers (XIMArg *args)
+{
+    char *modifiers;
+
+    while (args->name)
+    {
+	if (strcmp (args->name, IMModifiers) == 0)
+	{
+	    modifiers = args->value;
+	    return modifiers;
+	}
+	else
+	{
+	    args++;
+	}
+	/*endif*/
+    }
+    /*endwhile*/
+    return NULL;
+}
+
+XIMS _GetIMS (char *modifiers)
+{
+    XIMS ims;
+    extern IMMethodsRec Xi18n_im_methods;
+
+    if ((ims = (XIMS) malloc (sizeof (XIMProtocolRec))) == (XIMS) NULL)
+	return ((XIMS) NULL);
+    /*endif*/
+    memset ((void *) ims, 0, sizeof (XIMProtocolRec));
+
+    if (modifiers == NULL
+	||
+	modifiers[0] == '\0'
+	||
+	strcmp (modifiers, "Xi18n") == 0)
+    {
+	ims->methods = &Xi18n_im_methods;
+	return ims;
+    }
+    /*endif*/
+    XFree (ims);
+    return (XIMS) NULL;
+}
+
+XIMS IMOpenIM (Display *display, ...)
+{
+    va_list var;
+    int total_count;
+    XIMArg *args;
+    XIMS ims;
+    char *modifiers;
+    Status ret;
+
+    Va_start (var, display);
+    _IMCountVaList (var, &total_count);
+    va_end (var);
+
+    Va_start (var, display);
+    _IMVaToNestedList (var, total_count, &args);
+    va_end (var);
+
+    modifiers = _FindModifiers (args);
+
+    ims = _GetIMS (modifiers);
+    if (ims == (XIMS) NULL)
+        return (XIMS) NULL;
+    /*endif*/
+
+    ims->core.display = display;
+
+    ims->protocol = (*ims->methods->setup) (display, args);
+    XFree (args);
+    if (ims->protocol == (void *) NULL)
+    {
+	XFree (ims);
+	return (XIMS) NULL;
+    }
+    /*endif*/
+    ret = (ims->methods->openIM) (ims);
+    if (ret == False)
+    {
+	XFree (ims);
+	return (XIMS) NULL;
+    }
+    /*endif*/
+    return (XIMS) ims;
+}
+
+Status IMCloseIM (XIMS ims)
+{
+    (ims->methods->closeIM) (ims);
+    XFree (ims);
+    return True;
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/IMMethod.c b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/IMMethod.c
new file mode 100644
index 0000000..ff3fb2a
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/IMMethod.c
@@ -0,0 +1,65 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#include <X11/Xlib.h>
+#include "../include/IMdkit.h"
+
+/* Public Function */
+void IMForwardEvent (XIMS ims, XPointer call_data)
+{
+    (ims->methods->forwardEvent) (ims, call_data);
+}
+
+void IMCommitString (XIMS ims, XPointer call_data)
+{
+    (ims->methods->commitString) (ims, call_data);
+}
+
+int IMCallCallback (XIMS ims, XPointer call_data)
+{
+    return (ims->methods->callCallback) (ims, call_data);
+}
+
+int IMPreeditStart (XIMS ims, XPointer call_data)
+{
+    return (ims->methods->preeditStart) (ims, call_data);
+}
+
+int IMPreeditEnd (XIMS ims, XPointer call_data)
+{
+    return (ims->methods->preeditEnd) (ims, call_data);
+}
+
+int IMSyncXlib(XIMS ims, XPointer call_data)
+{
+    ims->sync = True;
+    return (ims->methods->syncXlib) (ims, call_data);
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/Xi18nX.h b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/Xi18nX.h
new file mode 100644
index 0000000..ff91b1a
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/Xi18nX.h
@@ -0,0 +1,52 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#ifndef _Xi18nTrX_h
+#define _Xi18nTrX_h
+
+#define _XIM_PROTOCOL           "_XIM_PROTOCOL"
+#define _XIM_XCONNECT           "_XIM_XCONNECT"
+
+#define XCM_DATA_LIMIT		20
+
+typedef struct _XClient
+{
+    Window	client_win;	/* client window */
+    Window	accept_win;	/* accept window */
+} XClient;
+
+typedef struct
+{
+    Atom	xim_request;
+    Atom	connect_request;
+} XSpecRec;
+
+#endif
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/XimFunc.h b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/XimFunc.h
new file mode 100644
index 0000000..a9f4a04
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/XimFunc.h
@@ -0,0 +1,72 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#ifndef _XimFunc_h
+#define _XimFunc_h
+
+/* i18nAttr.c */
+void _Xi18nInitAttrList (Xi18n i18n_core);
+void _Xi18nInitExtension(Xi18n i18n_core);
+
+/* i18nClbk.c */
+int _Xi18nGeometryCallback (XIMS ims, IMProtocol *call_data);
+int _Xi18nPreeditStartCallback (XIMS ims, IMProtocol *call_data);
+int _Xi18nPreeditDrawCallback (XIMS ims, IMProtocol *call_data);
+int _Xi18nPreeditCaretCallback (XIMS ims, IMProtocol *call_data);
+int _Xi18nPreeditDoneCallback (XIMS ims, IMProtocol *call_data);
+int _Xi18nStatusStartCallback (XIMS ims, IMProtocol *call_data);
+int _Xi18nStatusDrawCallback (XIMS ims, IMProtocol *call_data);
+int _Xi18nStatusDoneCallback (XIMS ims, IMProtocol *call_data);
+int _Xi18nStringConversionCallback (XIMS ims, IMProtocol *call_data);
+
+/* i18nIc.c */
+void _Xi18nChangeIC (XIMS ims, IMProtocol *call_data, unsigned char *p,
+                     int create_flag);
+void _Xi18nGetIC (XIMS ims, IMProtocol *call_data, unsigned char *p);
+
+/* i18nUtil.c */
+int _Xi18nNeedSwap (Xi18n i18n_core, CARD16 connect_id);
+Xi18nClient *_Xi18nNewClient(Xi18n i18n_core);
+Xi18nClient *_Xi18nFindClient (Xi18n i18n_core, CARD16 connect_id);
+void _Xi18nDeleteClient (Xi18n i18n_core, CARD16 connect_id);
+void _Xi18nSendMessage (XIMS ims, CARD16 connect_id, CARD8 major_opcode,
+                        CARD8 minor_opcode, unsigned char *data, long length);
+void _Xi18nSendTriggerKey (XIMS ims, CARD16 connect_id);
+void _Xi18nSetEventMask (XIMS ims, CARD16 connect_id, CARD16 im_id,
+                         CARD16 ic_id, CARD32 forward_mask, CARD32 sync_mask);
+
+/* Xlib internal */
+void _XRegisterFilterByType(Display*, Window, int, int,
+		Bool (*filter)(Display*, Window, XEvent*, XPointer), XPointer);
+void _XUnregisterFilter(Display*, Window,
+		Bool (*filter)(Display*, Window, XEvent*, XPointer), XPointer);
+
+#endif
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nAttr.c b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nAttr.c
new file mode 100644
index 0000000..1647639
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nAttr.c
@@ -0,0 +1,175 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#include <X11/Xlib.h>
+#include <X11/Xresource.h>
+#include "../include/IMdkit.h"
+#include "../include/Xi18n.h"
+#include "XimFunc.h"
+
+typedef struct
+{
+    char *name;
+    CARD16 type;
+} IMListOfAttr;
+
+typedef struct
+{
+    char *name;
+    CARD8 major_opcode;
+    CARD8 minor_opcode;
+} IMExtList;
+
+IMListOfAttr Default_IMattr[] =
+{
+    {XNQueryInputStyle,   XimType_XIMStyles},
+/*    {XNQueryIMValuesList, XimType_XIMValuesList},	*/
+    {(char *) NULL, (CARD16) 0}
+};
+
+IMListOfAttr Default_ICattr[] =
+{
+    {XNInputStyle,              XimType_CARD32},
+    {XNClientWindow,            XimType_Window},
+    {XNFocusWindow,             XimType_Window},
+    {XNFilterEvents,            XimType_CARD32},
+    {XNPreeditAttributes,       XimType_NEST},
+    {XNStatusAttributes,        XimType_NEST},
+    {XNFontSet,                 XimType_XFontSet},
+    {XNArea,                    XimType_XRectangle},
+    {XNAreaNeeded,              XimType_XRectangle},
+    {XNColormap,                XimType_CARD32},
+    {XNStdColormap,             XimType_CARD32},
+    {XNForeground,              XimType_CARD32},
+    {XNBackground,              XimType_CARD32},
+    {XNBackgroundPixmap,        XimType_CARD32},
+    {XNSpotLocation,            XimType_XPoint},
+    {XNLineSpace,               XimType_CARD32},
+    {XNPreeditState,            XimType_CARD32},
+    {XNSeparatorofNestedList,   XimType_SeparatorOfNestedList},
+    {(char *) NULL, 0}
+};
+
+IMExtList Default_Extension[] =
+{
+    {"XIM_EXT_MOVE", XIM_EXTENSION, XIM_EXT_MOVE},
+    {"XIM_EXT_SET_EVENT_MASK", XIM_EXTENSION, XIM_EXT_SET_EVENT_MASK},
+    {"XIM_EXT_FORWARD_KEYEVENT", XIM_EXTENSION, XIM_EXT_FORWARD_KEYEVENT},
+    {(char *) NULL, 0, 0}
+};
+
+static void CountAttrList(IMListOfAttr *attr, int *total_count)
+{
+    *total_count = 0;
+
+    while (attr->name != NULL)
+    {
+        attr++;
+        ++(*total_count);
+    }
+}
+
+static XIMAttr *CreateAttrList (Xi18n i18n_core,
+                                IMListOfAttr *attr,
+                                int *total_count)
+{
+    XIMAttr *args, *p;
+    unsigned int buf_size;
+
+    CountAttrList(attr, total_count);
+
+    buf_size = (unsigned) (*total_count + 1)*sizeof (XIMAttr);
+    args = (XIMAttr *) malloc (buf_size);
+    if (!args)
+        return (XIMAttr *) NULL;
+    /*endif*/
+    memset (args, 0, buf_size);
+
+    for (p = args;  attr->name != NULL;  attr++, p++)
+    {
+        p->name = attr->name;
+        p->length = strlen (attr->name);
+        p->type = (CARD16) attr->type;
+        p->attribute_id = XrmStringToQuark (p->name);
+        if (strcmp (p->name, XNPreeditAttributes) == 0)
+            i18n_core->address.preeditAttr_id = p->attribute_id;
+        else if (strcmp (p->name, XNStatusAttributes) == 0)
+            i18n_core->address.statusAttr_id = p->attribute_id;
+        else if (strcmp (p->name, XNSeparatorofNestedList) == 0)
+            i18n_core->address.separatorAttr_id = p->attribute_id;
+        /*endif*/
+    }
+    /*endfor*/
+    p->name = (char *) NULL;
+
+    return args;
+}
+
+void _Xi18nInitAttrList (Xi18n i18n_core)
+{
+    XIMAttr *args;
+    int	total_count;
+
+    /* init IMAttr list */
+    if (i18n_core->address.xim_attr)
+        XFree ((char *)i18n_core->address.xim_attr);
+    /*endif*/
+    args = CreateAttrList (i18n_core, Default_IMattr, &total_count);
+
+    i18n_core->address.im_attr_num = total_count;
+    i18n_core->address.xim_attr = (XIMAttr *)args;
+
+    /* init ICAttr list */
+    if (i18n_core->address.xic_attr)
+        XFree ((char *) i18n_core->address.xic_attr);
+    /*endif*/
+    args = CreateAttrList (i18n_core, Default_ICattr, &total_count);
+
+    i18n_core->address.ic_attr_num = total_count;
+    i18n_core->address.xic_attr = (XICAttr *) args;
+}
+
+void _Xi18nInitExtension(Xi18n i18n_core)
+{
+    register int i;
+    IMExtList *extensions = (IMExtList *) Default_Extension;
+    XIMExt *ext_list = (XIMExt *) i18n_core->address.extension;
+
+    for (i = 0;  extensions->name;  i++, ext_list++, extensions++)
+    {
+        ext_list->major_opcode = extensions->major_opcode;
+        ext_list->minor_opcode = extensions->minor_opcode;
+        ext_list->name = extensions->name;
+        ext_list->length = strlen(ext_list->name);
+    }
+    /*endfor*/
+    i18n_core->address.ext_num = i;
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nClbk.c b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nClbk.c
new file mode 100644
index 0000000..887d769
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nClbk.c
@@ -0,0 +1,513 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#include <X11/Xlib.h>
+#include "../include/IMdkit.h"
+#include "../include/Xi18n.h"
+#include "FrameMgr.h"
+#include "XimFunc.h"
+
+int _Xi18nGeometryCallback (XIMS ims, IMProtocol *call_data)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec geometry_fr[];
+    register int total_size;
+    unsigned char *reply = NULL;
+    IMGeometryCBStruct *geometry_CB =
+        (IMGeometryCBStruct *) &call_data->geometry_callback;
+    CARD16 connect_id = call_data->any.connect_id;
+
+    fm = FrameMgrInit (geometry_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return False;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, connect_id);
+    FrameMgrPutToken (fm, geometry_CB->icid);
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_GEOMETRY,
+                       0,
+                       reply,
+                       total_size);
+    FrameMgrFree (fm);
+    XFree (reply);
+
+    /* XIM_GEOMETRY is an asyncronous protocol,
+       so return immediately. */
+    return True;
+}
+
+int _Xi18nPreeditStartCallback (XIMS ims, IMProtocol *call_data)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec preedit_start_fr[];
+    register int total_size;
+    unsigned char *reply = NULL;
+    IMPreeditCBStruct *preedit_CB =
+        (IMPreeditCBStruct*) &call_data->preedit_callback;
+    CARD16 connect_id = call_data->any.connect_id;
+
+    fm = FrameMgrInit (preedit_start_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage(ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return False;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, connect_id);
+    FrameMgrPutToken (fm, preedit_CB->icid);
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_PREEDIT_START,
+                       0,
+                       reply,
+                       total_size);
+    FrameMgrFree (fm);
+    XFree (reply);
+
+    return True;
+}
+
+int _Xi18nPreeditDrawCallback (XIMS ims, IMProtocol *call_data)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec preedit_draw_fr[];
+    register int total_size;
+    unsigned char *reply = NULL;
+    IMPreeditCBStruct *preedit_CB =
+        (IMPreeditCBStruct *) &call_data->preedit_callback;
+    XIMPreeditDrawCallbackStruct *draw =
+        (XIMPreeditDrawCallbackStruct *) &preedit_CB->todo.draw;
+    CARD16 connect_id = call_data->any.connect_id;
+    register int feedback_count;
+    register int i;
+    BITMASK32 status = 0x0;
+
+    if (draw->text->length == 0)
+        status = 0x00000001;
+    else if (draw->text->feedback[0] == 0)
+        status = 0x00000002;
+    /*endif*/
+
+    fm = FrameMgrInit (preedit_draw_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    /* set length of preedit string */
+    FrameMgrSetSize (fm, draw->text->length);
+
+    /* set iteration count for list of feedback */
+    for (i = 0;  draw->text->feedback[i] != 0;  i++)
+        ;
+    /*endfor*/
+    feedback_count = i;
+    FrameMgrSetIterCount (fm, feedback_count);
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return False;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, connect_id);
+    FrameMgrPutToken (fm, preedit_CB->icid);
+    FrameMgrPutToken (fm, draw->caret);
+    FrameMgrPutToken (fm, draw->chg_first);
+    FrameMgrPutToken (fm, draw->chg_length);
+    FrameMgrPutToken (fm, status);
+    FrameMgrPutToken (fm, draw->text->length);
+    FrameMgrPutToken (fm, draw->text->string);
+    for (i = 0;  i < feedback_count;  i++)
+        FrameMgrPutToken (fm, draw->text->feedback[i]);
+    /*endfor*/
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_PREEDIT_DRAW,
+                       0,
+                       reply,
+                       total_size);
+    FrameMgrFree (fm);
+    XFree (reply);
+
+    /* XIM_PREEDIT_DRAW is an asyncronous protocol, so return immediately. */
+    return True;
+}
+
+int _Xi18nPreeditCaretCallback (XIMS ims, IMProtocol *call_data)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec preedit_caret_fr[];
+    register int total_size;
+    unsigned char *reply = NULL;
+    IMPreeditCBStruct *preedit_CB =
+        (IMPreeditCBStruct*) &call_data->preedit_callback;
+    XIMPreeditCaretCallbackStruct *caret =
+        (XIMPreeditCaretCallbackStruct *) &preedit_CB->todo.caret;
+    CARD16 connect_id = call_data->any.connect_id;
+
+    fm = FrameMgrInit (preedit_caret_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return False;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, connect_id);
+    FrameMgrPutToken (fm, preedit_CB->icid);
+    FrameMgrPutToken (fm, caret->position);
+    FrameMgrPutToken (fm, caret->direction);
+    FrameMgrPutToken (fm, caret->style);
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_PREEDIT_CARET,
+                       0,
+                       reply,
+                       total_size);
+    FrameMgrFree (fm);
+    XFree (reply);
+
+    return True;
+}
+
+int _Xi18nPreeditDoneCallback (XIMS ims, IMProtocol *call_data)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec preedit_done_fr[];
+    register int total_size;
+    unsigned char *reply = NULL;
+    IMPreeditCBStruct *preedit_CB =
+        (IMPreeditCBStruct *) &call_data->preedit_callback;
+    CARD16 connect_id = call_data->any.connect_id;
+
+    fm = FrameMgrInit (preedit_done_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return False;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, connect_id);
+    FrameMgrPutToken (fm, preedit_CB->icid);
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_PREEDIT_DONE,
+                       0,
+                       reply,
+                       total_size);
+    FrameMgrFree (fm);
+    XFree (reply);
+
+    /* XIM_PREEDIT_DONE is an asyncronous protocol, so return immediately. */
+    return True;
+}
+
+int _Xi18nStatusStartCallback (XIMS ims, IMProtocol *call_data)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec status_start_fr[];
+    register int total_size;
+    unsigned char *reply = NULL;
+    IMStatusCBStruct *status_CB =
+        (IMStatusCBStruct*) &call_data->status_callback;
+    CARD16 connect_id = call_data->any.connect_id;
+
+    fm = FrameMgrInit (status_start_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return False;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, connect_id);
+    FrameMgrPutToken (fm, status_CB->icid);
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_STATUS_START,
+                       0,
+                       reply,
+                       total_size);
+    FrameMgrFree (fm);
+    XFree (reply);
+
+    /* XIM_STATUS_START is an asyncronous protocol, so return immediately. */
+    return True;
+}
+
+int _Xi18nStatusDrawCallback (XIMS ims, IMProtocol *call_data)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm = (FrameMgr)0;
+    extern XimFrameRec status_draw_text_fr[];
+    extern XimFrameRec status_draw_bitmap_fr[];
+    register int total_size = 0;
+    unsigned char *reply = NULL;
+    IMStatusCBStruct *status_CB =
+        (IMStatusCBStruct *) &call_data->status_callback;
+    XIMStatusDrawCallbackStruct *draw =
+        (XIMStatusDrawCallbackStruct *) &status_CB->todo.draw;
+    CARD16 connect_id = call_data->any.connect_id;
+    register int feedback_count;
+    register int i;
+    BITMASK32 status = 0x0;
+
+    switch (draw->type)
+    {
+    case XIMTextType:
+        fm = FrameMgrInit (status_draw_text_fr,
+                           NULL,
+                           _Xi18nNeedSwap (i18n_core, connect_id));
+
+        if (draw->data.text->length == 0)
+            status = 0x00000001;
+        else if (draw->data.text->feedback[0] == 0)
+            status = 0x00000002;
+        /*endif*/
+
+        /* set length of status string */
+        FrameMgrSetSize(fm, draw->data.text->length);
+        /* set iteration count for list of feedback */
+        for (i = 0;  draw->data.text->feedback[i] != 0;  i++)
+            ;
+        /*endfor*/
+        feedback_count = i;
+        FrameMgrSetIterCount (fm, feedback_count);
+
+        total_size = FrameMgrGetTotalSize (fm);
+        reply = (unsigned char *) malloc (total_size);
+        if (!reply)
+        {
+            _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+            return False;
+        }
+        /*endif*/
+        memset (reply, 0, total_size);
+        FrameMgrSetBuffer (fm, reply);
+
+        FrameMgrPutToken (fm, connect_id);
+        FrameMgrPutToken (fm, status_CB->icid);
+        FrameMgrPutToken (fm, draw->type);
+        FrameMgrPutToken (fm, status);
+        FrameMgrPutToken (fm, draw->data.text->length);
+        FrameMgrPutToken (fm, draw->data.text->string);
+        for (i = 0;  i < feedback_count;  i++)
+            FrameMgrPutToken (fm, draw->data.text->feedback[i]);
+        /*endfor*/
+        break;
+
+    case XIMBitmapType:
+        fm = FrameMgrInit (status_draw_bitmap_fr,
+                           NULL,
+                           _Xi18nNeedSwap (i18n_core, connect_id));
+
+        total_size = FrameMgrGetTotalSize (fm);
+        reply = (unsigned char *) malloc (total_size);
+        if (!reply)
+        {
+            _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+            return False;
+        }
+        /*endif*/
+        memset (reply, 0, total_size);
+        FrameMgrSetBuffer (fm, reply);
+
+        FrameMgrPutToken (fm, connect_id);
+        FrameMgrPutToken (fm, status_CB->icid);
+        FrameMgrPutToken (fm, draw->data.bitmap);
+        break;
+    }
+    /*endswitch*/
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_STATUS_DRAW,
+                       0,
+                       reply,
+                       total_size);
+    FrameMgrFree (fm);
+    XFree (reply);
+
+    /* XIM_STATUS_DRAW is an asyncronous protocol, so return immediately. */
+    return True;
+}
+
+int _Xi18nStatusDoneCallback (XIMS ims, IMProtocol *call_data)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec status_done_fr[];
+    register int total_size;
+    unsigned char *reply = NULL;
+    IMStatusCBStruct *status_CB =
+        (IMStatusCBStruct *) &call_data->status_callback;
+    CARD16 connect_id = call_data->any.connect_id;
+
+    fm = FrameMgrInit (status_done_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return False;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, connect_id);
+    FrameMgrPutToken (fm, status_CB->icid);
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_STATUS_DONE,
+                       0,
+                       reply,
+                       total_size);
+    FrameMgrFree (fm);
+    XFree (reply);
+
+    /* XIM_STATUS_DONE is an asyncronous protocol, so return immediately. */
+    return True;
+}
+
+int _Xi18nStringConversionCallback (XIMS ims, IMProtocol *call_data)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec str_conversion_fr[];
+    register int total_size;
+    unsigned char *reply = NULL;
+    IMStrConvCBStruct *call_back =
+        (IMStrConvCBStruct *) &call_data->strconv_callback;
+    XIMStringConversionCallbackStruct *strconv =
+        (XIMStringConversionCallbackStruct *) &call_back->strconv;
+    CARD16 connect_id = call_data->any.connect_id;
+
+    fm = FrameMgrInit (str_conversion_fr,
+                       NULL,
+                      _Xi18nNeedSwap (i18n_core, connect_id));
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return False;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, connect_id);
+    FrameMgrPutToken (fm, call_back->icid);
+    FrameMgrPutToken (fm, strconv->position);
+    FrameMgrPutToken (fm, strconv->direction);
+    FrameMgrPutToken (fm, strconv->operation);
+
+    _Xi18nSendMessage (ims, connect_id,
+                       XIM_STR_CONVERSION,
+                       0,
+                       reply,
+                       total_size);
+    FrameMgrFree (fm);
+    XFree (reply);
+
+    /* XIM_STR_CONVERSION is a syncronous protocol,
+       so should wait here for XIM_STR_CONVERSION_REPLY. */
+    if (i18n_core->methods.wait (ims,
+                                 connect_id,
+                                 XIM_STR_CONVERSION_REPLY,
+                                 0) == False)
+    {
+        return False;
+    }
+    /*endif*/
+    return True;
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nIMProto.c b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nIMProto.c
new file mode 100644
index 0000000..618da9d
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nIMProto.c
@@ -0,0 +1,773 @@
+/******************************************************************
+Copyright 1993, 1994 by Digital Equipment Corporation, Maynard, Massachusetts,
+Copyright 1993, 1994 by Hewlett-Packard Company
+
+Copyright 1994, 1995 by Sun Microsystems, Inc.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the names of Digital or MIT not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL DIGITAL AND HEWLETT-PACKARD COMPANY BE LIABLE
+FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hiroyuki Miyamoto  Digital Equipment Corporation
+                             miyamoto@jrd.dec.com
+	  Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+/* Protocol Packet frames */
+
+#include "FrameMgr.h"
+
+/* Data type definitions */
+
+static XimFrameRec ximattr_fr[] =
+{
+    _FRAME(BIT16), 		/* attribute ID */
+    _FRAME(BIT16), 		/* type of the value */
+    _FRAME(BIT16), 		/* length of im-attribute */
+    _FRAME(BARRAY), 		/* im-attribute */
+    _PAD4(2),
+    _FRAME(EOL),
+};
+
+static XimFrameRec xicattr_fr[] =
+{
+    _FRAME(BIT16), 		/* attribute ID */
+    _FRAME(BIT16), 		/* type of the value */
+    _FRAME(BIT16), 		/* length of ic-attribute */
+    _FRAME(BARRAY), 		/* ic-attribute */
+    _PAD4(2),
+    _FRAME(EOL),
+};
+
+static XimFrameRec ximattribute_fr[] =
+{
+    _FRAME(BIT16), 		/* attribute ID */
+    _FRAME(BIT16), 		/* value length */
+    _FRAME(BARRAY),             /* value */
+    _PAD4(1),
+    _FRAME(EOL),
+};
+
+static XimFrameRec xicattribute_fr[] =
+{
+    _FRAME(BIT16), 		/* attribute ID */
+    _FRAME(BIT16), 		/* value length */
+    _FRAME(BARRAY),             /* value */
+    _PAD4(1),
+    _FRAME(EOL),
+};
+
+static XimFrameRec ximtriggerkey_fr[] =
+{
+    _FRAME(BIT32), 		/* keysym */
+    _FRAME(BIT32), 		/* modifier */
+    _FRAME(BIT32), 		/* modifier mask */
+    _FRAME(EOL),
+};
+
+static XimFrameRec encodinginfo_fr[] =
+{
+    _FRAME(BIT16), 		/* length of encoding info */
+    _FRAME(BARRAY), 		/* encoding info */
+    _PAD4(2),
+    _FRAME(EOL),
+};
+
+static XimFrameRec str_fr[] =
+{
+    _FRAME(BIT8), 		/* number of byte */
+    _FRAME(BARRAY), 		/* string */
+    _FRAME(EOL),
+};
+
+static XimFrameRec xpcs_fr[] =
+{
+    _FRAME(BIT16), 		/* length of string in bytes */
+    _FRAME(BARRAY), 		/* string */
+    _PAD4(2),
+};
+
+static XimFrameRec ext_fr[] =
+{
+    _FRAME(BIT8), 		/* extension major-opcode */
+    _FRAME(BIT8), 		/* extension minor-opcode */
+    _FRAME(BIT16), 		/* length of extension name */
+    _FRAME(BARRAY), 		/* extension name */
+    _PAD4(1),
+    _FRAME(EOL),
+};
+
+static XimFrameRec inputstyle_fr[] =
+{
+    _FRAME(BIT32), 		/* inputstyle */
+    _FRAME(EOL),
+};
+/* Protocol definitions */
+
+xim_externaldef XimFrameRec attr_head_fr[] =
+{
+    _FRAME(BIT16), 	/* attribute id */
+    _FRAME(BIT16), 	/* attribute length */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec short_fr[] =
+{
+    _FRAME(BIT16), 	/* value */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec long_fr[] =
+{
+    _FRAME(BIT32), 	/* value */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec xrectangle_fr[] =
+{
+    _FRAME(BIT16), 	/* x */
+    _FRAME(BIT16), 	/* y */
+    _FRAME(BIT16), 	/* width */
+    _FRAME(BIT16), 	/* height */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec xpoint_fr[] =
+{
+    _FRAME(BIT16), 	/* x */
+    _FRAME(BIT16), 	/* y */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec fontset_fr[] =
+{
+    _FRAME(BIT16), 	/* length of base font name */
+    _FRAME(BARRAY), 	/* base font name list */
+    _PAD4(2), 		/* unused */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec input_styles_fr[] =
+{
+    _FRAME(BIT16), 		/* number of list */
+    _PAD4(1), 			/* unused */
+    _FRAME(ITER), 		/* XIMStyle list */
+    _FRAME(POINTER),
+    _PTR(inputstyle_fr),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec packet_header_fr[] =
+{
+    _FRAME(BIT8), 		/* major-opcode */
+    _FRAME(BIT8), 		/* minor-opcode */
+    _FRAME(BIT16), 		/* length */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec error_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT16), 		/* flag */
+    _FRAME(BIT16), 		/* Error Code */
+    _FRAME(BIT16), 		/* length of error detail */
+    _FRAME(BIT16), 		/* type of error detail */
+    _FRAME(BARRAY), 		/* error detail */
+    _PAD4(1),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec connect_fr[] =
+{
+    _FRAME(BIT8), 		/* byte order */
+    _PAD2(1), 			/* unused */
+    _FRAME(BIT16), 		/* client-major-protocol-version */
+    _FRAME(BIT16), 		/* client-minor-protocol-version */
+    _BYTE_COUNTER(BIT16, 1), 	/* length of client-auth-protocol-names */
+    _FRAME(ITER), 		/* client-auth-protocol-names */
+    _FRAME(POINTER),
+    _PTR(xpcs_fr),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec connect_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* server-major-protocol-version */
+    _FRAME(BIT16), 		/* server-minor-protocol-version */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec auth_required_fr[] =
+{
+    _FRAME(BIT8), 		/* auth-protocol-index */
+    _FRAME(BIT8), 		/* auth-data1 */
+    _FRAME(BARRAY), 		/* auth-data2 */
+    _PAD4(3),
+    _FRAME(EOL),
+};
+
+
+xim_externaldef XimFrameRec auth_reply_fr[] =
+{
+    _FRAME(BIT8),
+    _FRAME(BARRAY),
+    _PAD4(2),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec auth_next_fr[] =
+{
+    _FRAME(BIT8), 		/* auth-data1 */
+    _FRAME(BARRAY), 		/* auth-data2 */
+    _PAD4(2),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec auth_setup_fr[] =
+{
+    _BYTE_COUNTER(BIT16, 2), 	/* number of client-auth-protocol-names */
+    _PAD4(1), 			/* unused */
+    _FRAME(ITER), 		/* server-auth-protocol-names */
+    _FRAME(POINTER),
+    _PTR(xpcs_fr),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec auth_ng_fr[] =
+{
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec disconnect_fr[] =
+{
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec disconnect_reply_fr[] =
+{
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec open_fr[] =
+{
+    _FRAME(POINTER), 		/* locale name */
+    _PTR(str_fr),
+    _PAD4(1),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec open_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _BYTE_COUNTER(BIT16, 1), 	/* byte length of IM attributes supported */
+    _FRAME(ITER), 		/* IM attribute supported */
+    _FRAME(POINTER),
+    _PTR(ximattr_fr),
+    _BYTE_COUNTER(BIT16, 2), 	/* number of IC attribute supported */
+    _PAD4(1), 			/* unused */
+    _FRAME(ITER), 		/* IC attribute supported */
+    _FRAME(POINTER),
+    _PTR(xicattr_fr),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec close_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _PAD4(1), 			/* unused */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec close_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _PAD4(1), 			/* unused */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec register_triggerkeys_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _PAD4(1), 			/* unused */
+    _BYTE_COUNTER(BIT32, 1),    /* byte length of on-keys */
+    _FRAME(ITER), 		/* on-keys list */
+    _FRAME(POINTER),
+    _PTR(ximtriggerkey_fr),
+    _BYTE_COUNTER(BIT32, 1), 	/* byte length of off-keys */
+    _FRAME(ITER), 		/* off-keys list */
+    _FRAME(POINTER),
+    _PTR(ximtriggerkey_fr),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec trigger_notify_fr[] =
+{
+    _FRAME(BIT16), 		/* input-mehotd-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT32), 		/* flag */
+    _FRAME(BIT32), 		/* index of keys list */
+    _FRAME(BIT32), 		/* client-select-event-mask */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec trigger_notify_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec set_event_mask_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT32), 		/* forward-event-mask */
+    _FRAME(BIT32), 		/* synchronous-event-mask */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec encoding_negotiation_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _BYTE_COUNTER(BIT16, 1), 	/* byte length of encodings listed by name */
+    _FRAME(ITER), 		/* supported list of encoding in IM library */
+    _FRAME(POINTER),
+    _PTR(str_fr),
+    _PAD4(1),
+    _BYTE_COUNTER(BIT16, 2), 	/* byte length of encodings listed by
+                                       detailed data */
+    _PAD4(1),
+    _FRAME(ITER), 		/* list of encodings supported in the
+    				   IM library */
+    _FRAME(POINTER),
+    _PTR(encodinginfo_fr),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec encoding_negotiation_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* category of the encoding determined */
+    _FRAME(BIT16), 		/* index of the encoding dterminated */
+    _PAD4(1),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec query_extension_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _BYTE_COUNTER(BIT16, 1), 	/* byte length of extensions supported
+    				   by the IM library */
+    _FRAME(ITER), 		/* extensions supported by the IM library */
+    _FRAME(POINTER),
+    _PTR(str_fr),
+    _PAD4(1),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec query_extension_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _BYTE_COUNTER(BIT16, 1), 	/* byte length of extensions supported
+    				   by the IM server */
+    _FRAME(ITER), 		/* list of extensions supported by the
+    				   IM server */
+    _FRAME(POINTER),
+    _PTR(ext_fr),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec get_im_values_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _BYTE_COUNTER(BIT16, 1), 	/* byte length of im-attribute-id */
+    _FRAME(ITER), 		/* im-attribute-id */
+    _FRAME(BIT16),
+    _PAD4(1),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec get_im_values_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _BYTE_COUNTER(BIT16, 1), 	/* byte length of im-attribute returned */
+    _FRAME(ITER), 		/* im-attribute returned */
+    _FRAME(POINTER),
+    _PTR(ximattribute_fr),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec create_ic_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _BYTE_COUNTER(BIT16, 1), 	/* byte length of ic-attributes */
+    _FRAME(ITER), 		/* ic-attributes */
+    _FRAME(POINTER),
+    _PTR(xicattribute_fr),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec create_ic_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec destroy_ic_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec destroy_ic_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec set_ic_values_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _BYTE_COUNTER(BIT16, 2), 	/* byte length of ic-attributes */
+    _PAD4(1),
+    _FRAME(ITER), 		/* ic-attribute */
+    _FRAME(POINTER),
+    _PTR(xicattribute_fr),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec set_ic_values_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec get_ic_values_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _BYTE_COUNTER(BIT16, 1), 	/* byte length of ic-attribute-id */
+    _FRAME(ITER), 		/* ic-attribute */
+    _FRAME(BIT16),
+    _PAD4(2),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec get_ic_values_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _BYTE_COUNTER(BIT16, 2), 	/* byte length of ic-attribute */
+    _PAD4(1),
+    _FRAME(ITER), 		/* ic-attribute */
+    _FRAME(POINTER),
+    _PTR(xicattribute_fr),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec set_ic_focus_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec unset_ic_focus_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec forward_event_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT16), 		/* flag */
+    _FRAME(BIT16), 		/* sequence number */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec wire_keyevent_fr[] = {
+    _FRAME(BIT8),		/* type */
+    _FRAME(BIT8),		/* detail */
+    _FRAME(BIT16),		/* serial number */
+    _FRAME(BIT32),		/* time */
+    _FRAME(BIT32),		/* root */
+    _FRAME(BIT32),		/* window */
+    _FRAME(BIT32),		/* subwindow */
+    _FRAME(BIT16),		/* rootX */
+    _FRAME(BIT16),		/* rootY */
+    _FRAME(BIT16),		/* X */
+    _FRAME(BIT16),		/* Y */
+    _FRAME(BIT16),		/* state */
+    _FRAME(BIT8),		/* sameScreen */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec sync_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec sync_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+#if 0
+xim_externaldef XimFrameRec commit_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT16), 		/* flag */
+    _FRAME(BIT16), 		/* byte length of committed string */
+    _FRAME(BARRAY), 		/* committed string */
+    _PAD4(1),
+    _BYTE_COUNTER(BIT16, 1), 	/* byte length of keysym */
+    _FRAME(ITER), 		/* keysym */
+    _FRAME(BIT32),
+    _PAD4(1),
+    _FRAME(EOL),
+};
+#endif
+
+xim_externaldef XimFrameRec commit_chars_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT16), 		/* flag */
+    _FRAME(BIT16), 		/* byte length of committed string */
+    _FRAME(BARRAY), 		/* committed string */
+    _PAD4(1),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec commit_both_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT16), 		/* flag */
+    _PAD4(1), 			/* unused */
+    _FRAME(BIT32), 		/* keysym */
+    _FRAME(BIT16), 		/* byte length of committed string */
+    _FRAME(BARRAY), 		/* committed string */
+    _PAD4(2),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec reset_ic_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec reset_ic_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT16), 		/* byte length of committed string */
+    _FRAME(BARRAY), 		/* committed string */
+    _PAD4(2),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec geometry_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec str_conversion_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT32), 		/* XIMStringConversionPosition */
+    _FRAME(BIT32), 		/* XIMStringConversionType */
+    _FRAME(BIT32), 		/* XIMStringConversionOperation */
+    _FRAME(BIT16), 		/* length to multiply the
+    				   XIMStringConversionType */
+    _FRAME(BIT16), 		/* length of the string to be
+    				   substituted */
+#if 0
+    _FRAME(BARRAY), 		/* string */
+    _PAD4(1),
+#endif
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec str_conversion_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT32), 		/* XIMStringConversionFeedback */
+    _FRAME(BIT16), 		/* length of the retrieved string */
+    _FRAME(BARRAY), 		/* retrieved string */
+    _PAD4(2),
+    _BYTE_COUNTER(BIT16, 2), 	/* number of feedback array */
+    _PAD4(1),
+    _FRAME(ITER), 		/* feedback array */
+    _FRAME(BIT32),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec preedit_start_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec preedit_start_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT32), 		/* return value */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec preedit_draw_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT32), 		/* caret */
+    _FRAME(BIT32), 		/* chg_first */
+    _FRAME(BIT32), 		/* chg_length */
+    _FRAME(BIT32), 		/* status */
+    _FRAME(BIT16), 		/* length of preedit string */
+    _FRAME(BARRAY), 		/* preedit string */
+    _PAD4(2),
+    _BYTE_COUNTER(BIT16, 2), 	/* number of feedback array */
+    _PAD4(1),
+    _FRAME(ITER), 		/* feedback array */
+    _FRAME(BIT32),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec preedit_caret_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT32), 		/* position */
+    _FRAME(BIT32), 		/* direction */
+    _FRAME(BIT32), 		/* style */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec preedit_caret_reply_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT32), 		/* position */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec preedit_done_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec status_start_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec status_draw_text_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT32), 		/* type */
+    _FRAME(BIT32), 		/* status */
+    _FRAME(BIT16), 		/* length of status string */
+    _FRAME(BARRAY), 		/* status string */
+    _PAD4(2),
+    _BYTE_COUNTER(BIT16, 2), 	/* number of feedback array */
+    _PAD4(1),
+    _FRAME(ITER), 		/* feedback array */
+    _FRAME(BIT32),
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec status_draw_bitmap_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT32), 		/* type */
+    _FRAME(BIT32), 		/* pixmap data */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec status_done_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec ext_set_event_mask_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT32), 		/* filter-event-mask */
+    _FRAME(BIT32), 		/* intercept-event-mask */
+    _FRAME(BIT32), 		/* select-event-mask */
+    _FRAME(BIT32), 		/* forward-event-mask */
+    _FRAME(BIT32), 		/* synchronous-event-mask */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec ext_forward_keyevent_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT16), 		/* flag */
+    _FRAME(BIT16), 		/* sequence number */
+    _FRAME(BIT8), 		/* xEvent.u.u.type */
+    _FRAME(BIT8), 		/* keycode */
+    _FRAME(BIT16), 		/* state */
+    _FRAME(BIT32), 		/* time */
+    _FRAME(BIT32), 		/* window */
+    _FRAME(EOL),
+};
+
+xim_externaldef XimFrameRec ext_move_fr[] =
+{
+    _FRAME(BIT16), 		/* input-method-ID */
+    _FRAME(BIT16), 		/* input-context-ID */
+    _FRAME(BIT16), 		/* X */
+    _FRAME(BIT16), 		/* Y */
+    _FRAME(EOL),
+};
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nIc.c b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nIc.c
new file mode 100644
index 0000000..47e74c5
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nIc.c
@@ -0,0 +1,1106 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#include <X11/Xlib.h>
+#include "../include/IMdkit.h"
+#include "../include/Xi18n.h"
+#include "FrameMgr.h"
+#include "XimFunc.h"
+
+#define IC_SIZE 64
+
+/* Set IC values */
+static void SetCardAttribute (XICAttribute *value_ret,
+                              char *p,
+                              XICAttr *ic_attr,
+                              int value_length,
+                              int need_swap,
+                              void **value_buf)
+{
+    FrameMgr fm;
+
+    /*endif*/
+    if (value_length == sizeof (CARD8))
+    {
+        memmove (*value_buf, p, value_length);
+    }
+    else if (value_length == sizeof (CARD16))
+    {
+        INT16 value;
+        extern XimFrameRec short_fr[];
+
+        fm = FrameMgrInit (short_fr, (char *) p, need_swap);
+        /* get data */
+        FrameMgrGetToken (fm, value);
+        FrameMgrFree (fm);
+        memmove (*value_buf, &value, value_length);
+    }
+    else if (value_length == sizeof(CARD32))
+    {
+        INT32 value;
+        extern XimFrameRec long_fr[];
+
+        fm = FrameMgrInit (long_fr, (char *) p, need_swap);
+        /* get data */
+        FrameMgrGetToken (fm, value);
+        FrameMgrFree (fm);
+        memmove (*value_buf, &value, value_length);
+    }
+    /*endif*/
+    value_ret->attribute_id = ic_attr->attribute_id;
+    value_ret->name = ic_attr->name;
+    value_ret->name_length = ic_attr->length;
+    value_ret->type = ic_attr->type;
+    value_ret->value_length = value_length;
+    value_ret->value = *value_buf;
+
+    *value_buf += value_length;
+}
+
+static void SetFontAttribute (XICAttribute *value_ret,
+                              char *p,
+                              XICAttr *ic_attr,
+                              int value_length,
+                              int need_swap,
+                              void **value_buf)
+{
+    char *base_name;
+    CARD16 base_length;
+    FrameMgr fm;
+    extern XimFrameRec fontset_fr[];
+
+    fm = FrameMgrInit (fontset_fr, (char *) p, need_swap);
+    /* get data */
+    FrameMgrGetToken (fm, base_length);
+    FrameMgrSetSize (fm, base_length);
+
+    /*endif*/
+    FrameMgrGetToken (fm, base_name);
+    FrameMgrFree(fm);
+    strncpy ((char *) (*value_buf), base_name, base_length);
+    ((char *) *value_buf)[base_length] = (char) 0;
+
+    value_ret->attribute_id = ic_attr->attribute_id;
+    value_ret->name = ic_attr->name;
+    value_ret->name_length = ic_attr->length;
+    value_ret->type = ic_attr->type;
+    value_ret->value_length = value_length;
+    value_ret->value = *value_buf;
+
+    *value_buf += (base_length + 1);
+}
+
+static void SetPointAttribute (XICAttribute *value_ret,
+                               char *p,
+                               XICAttr *ic_attr,
+                               int value_length,
+                               int need_swap,
+                               void **value_buf)
+{
+    XPoint *buf;
+    FrameMgr fm;
+    extern XimFrameRec xpoint_fr[];
+
+    buf = (XPoint *) (*value_buf);
+
+    fm = FrameMgrInit (xpoint_fr, (char *) p, need_swap);
+    /* get data */
+    FrameMgrGetToken (fm, buf->x);
+    FrameMgrGetToken (fm, buf->y);
+    FrameMgrFree (fm);
+
+    value_ret->attribute_id = ic_attr->attribute_id;
+    value_ret->name = ic_attr->name;
+    value_ret->name_length = ic_attr->length;
+    value_ret->type = ic_attr->type;
+    value_ret->value_length = value_length;
+    value_ret->value = (char *) buf;
+
+    *value_buf += value_length;
+}
+
+static void SetRectAttribute (XICAttribute *value_ret,
+                              char *p,
+                              XICAttr *ic_attr,
+                              int value_length,
+                              int need_swap,
+                              void **value_buf)
+{
+    XRectangle *buf;
+    FrameMgr fm;
+    extern XimFrameRec xrectangle_fr[];
+
+    buf = (XRectangle *) (*value_buf);
+
+    fm = FrameMgrInit (xrectangle_fr, (char *) p, need_swap);
+    /* get data */
+    FrameMgrGetToken (fm, buf->x);
+    FrameMgrGetToken (fm, buf->y);
+    FrameMgrGetToken (fm, buf->width);
+    FrameMgrGetToken (fm, buf->height);
+    FrameMgrFree (fm);
+
+    value_ret->attribute_id = ic_attr->attribute_id;
+    value_ret->name = ic_attr->name;
+    value_ret->name_length = ic_attr->length;
+    value_ret->type = ic_attr->type;
+    value_ret->value_length = value_length;
+    value_ret->value = (char *) buf;
+
+    *value_buf += value_length;
+}
+
+#if 0
+static void SetHotKeyAttribute (XICAttribute *value_ret,
+                                char *p,
+                                XICAttr *ic_attr,
+                                int value_length,
+                                int need_swap,
+                                void **value_buf)
+{
+    INT32 list_number;
+    XIMTriggerKey *hotkeys;
+
+    memmove (&list_number, p, sizeof(INT32)); p += sizeof(INT32);
+
+    hotkeys = (XIMTriggerKey *) (*value_buf);
+
+    memmove (hotkeys, p, list_number*sizeof (XIMTriggerKey));
+
+    value_ret->attribute_id = ic_attr->attribute_id;
+    value_ret->name = ic_attr->name;
+    value_ret->name_length = ic_attr->length;
+    value_ret->type = ic_attr->type;
+    value_ret->value_length = value_length;
+    value_ret->value = (char *) hotkeys;
+
+    *value_buf += value_length;
+}
+#endif
+
+/* get IC values */
+static void GetAttrHeader (unsigned char *rec,
+                           XICAttribute *list,
+                           int need_swap)
+{
+    FrameMgr fm;
+    extern XimFrameRec attr_head_fr[];
+
+    fm = FrameMgrInit (attr_head_fr, (char *) rec, need_swap);
+    /* put data */
+    FrameMgrPutToken (fm, list->attribute_id);
+    FrameMgrPutToken (fm, list->value_length);
+    FrameMgrFree (fm);
+}
+
+static void GetCardAttribute (char *rec, XICAttribute *list, int need_swap)
+{
+    FrameMgr fm;
+    unsigned char *recp = (unsigned char *) rec;
+
+    GetAttrHeader (recp, list, need_swap);
+    recp += sizeof (CARD16)*2;
+
+    if (list->value_length == sizeof (CARD8))
+    {
+        memmove (recp, list->value, list->value_length);
+    }
+    else if (list->value_length == sizeof (CARD16))
+    {
+        INT16 *value = (INT16 *) list->value;
+        extern XimFrameRec short_fr[];
+
+        fm = FrameMgrInit (short_fr, (char *) recp, need_swap);
+        /* put data */
+        FrameMgrPutToken (fm, *value);
+        FrameMgrFree (fm);
+    }
+    else if (list->value_length == sizeof (CARD32))
+    {
+        INT32 *value = (INT32 *) list->value;
+        extern XimFrameRec long_fr[];
+
+        fm = FrameMgrInit (long_fr, (char *) recp, need_swap);
+        /* put data */
+        FrameMgrPutToken (fm, *value);
+        FrameMgrFree (fm);
+    }
+    /*endif*/
+}
+
+static void GetFontAttribute(char *rec, XICAttribute *list, int need_swap)
+{
+    FrameMgr fm;
+    extern XimFrameRec fontset_fr[];
+    char *base_name = (char *) list->value;
+    unsigned char *recp = (unsigned char *) rec;
+
+    GetAttrHeader (recp, list, need_swap);
+    recp += sizeof (CARD16)*2;
+
+    fm = FrameMgrInit (fontset_fr, (char *)recp, need_swap);
+    /* put data */
+    FrameMgrSetSize (fm, list->value_length);
+    FrameMgrPutToken (fm, list->value_length);
+    FrameMgrPutToken (fm, base_name);
+    FrameMgrFree (fm);
+}
+
+static void GetRectAttribute (char *rec, XICAttribute *list, int need_swap)
+{
+    FrameMgr fm;
+    extern XimFrameRec xrectangle_fr[];
+    XRectangle *rect = (XRectangle *) list->value;
+    unsigned char *recp = (unsigned char *) rec;
+
+    GetAttrHeader (recp, list, need_swap);
+    recp += sizeof(CARD16)*2;
+
+    fm = FrameMgrInit (xrectangle_fr, (char *) recp, need_swap);
+    /* put data */
+    FrameMgrPutToken (fm, rect->x);
+    FrameMgrPutToken (fm, rect->y);
+    FrameMgrPutToken (fm, rect->width);
+    FrameMgrPutToken (fm, rect->height);
+    FrameMgrFree (fm);
+}
+
+static void GetPointAttribute (char *rec, XICAttribute *list, int need_swap)
+{
+    FrameMgr fm;
+    extern XimFrameRec xpoint_fr[];
+    XPoint *rect = (XPoint *) list->value;
+    unsigned char *recp = (unsigned char *) rec;
+
+    GetAttrHeader (recp, list, need_swap);
+    recp += sizeof(CARD16)*2;
+
+    fm = FrameMgrInit (xpoint_fr, (char *) recp, need_swap);
+    /* put data */
+    FrameMgrPutToken (fm, rect->x);
+    FrameMgrPutToken (fm, rect->y);
+    FrameMgrFree (fm);
+}
+
+static int ReadICValue (Xi18n i18n_core,
+                        CARD16 icvalue_id,
+                        int value_length,
+                        void *p,
+                        XICAttribute *value_ret,
+                        CARD16 *number_ret,
+                        int need_swap,
+                        void **value_buf)
+{
+    XICAttr *ic_attr = i18n_core->address.xic_attr;
+    int i;
+
+    *number_ret = (CARD16) 0;
+
+    for (i = 0;  i < i18n_core->address.ic_attr_num;  i++, ic_attr++)
+    {
+        if (ic_attr->attribute_id == icvalue_id)
+            break;
+        /*endif*/
+    }
+    /*endfor*/
+    switch (ic_attr->type)
+    {
+    case XimType_NEST:
+        {
+            int total_length = 0;
+            CARD16 attribute_ID;
+            INT16 attribute_length;
+            unsigned char *p1 = (unsigned char *) p;
+            CARD16 ic_len = 0;
+            CARD16 number;
+            FrameMgr fm;
+            extern XimFrameRec attr_head_fr[];
+
+            while (total_length < value_length)
+            {
+                fm = FrameMgrInit (attr_head_fr, (char *) p1, need_swap);
+                /* get data */
+                FrameMgrGetToken (fm, attribute_ID);
+                FrameMgrGetToken (fm, attribute_length);
+                FrameMgrFree (fm);
+                p1 += sizeof (CARD16)*2;
+                ReadICValue (i18n_core,
+                             attribute_ID,
+                             attribute_length,
+                             p1,
+                             (value_ret + ic_len),
+                             &number,
+                             need_swap,
+                             value_buf);
+                ic_len++;
+                *number_ret += number;
+                p1 += attribute_length;
+                p1 += IMPAD (attribute_length);
+                total_length += (CARD16) sizeof(CARD16)*2
+                                + (INT16) attribute_length
+                                + IMPAD (attribute_length);
+            }
+	    /*endwhile*/
+            return ic_len;
+        }
+
+    case XimType_CARD8:
+    case XimType_CARD16:
+    case XimType_CARD32:
+    case XimType_Window:
+        SetCardAttribute (value_ret, p, ic_attr, value_length, need_swap, value_buf);
+        *number_ret = (CARD16) 1;
+        return *number_ret;
+
+    case XimType_XFontSet:
+        SetFontAttribute (value_ret, p, ic_attr, value_length, need_swap, value_buf);
+        *number_ret = (CARD16) 1;
+        return *number_ret;
+
+    case XimType_XRectangle:
+        SetRectAttribute (value_ret, p, ic_attr, value_length, need_swap, value_buf);
+        *number_ret = (CARD16) 1;
+        return *number_ret;
+
+    case XimType_XPoint:
+        SetPointAttribute(value_ret, p, ic_attr, value_length, need_swap, value_buf);
+        *number_ret = (CARD16) 1;
+        return *number_ret;
+
+#if 0
+    case XimType_XIMHotKeyTriggers:
+        SetHotKeyAttribute (value_ret, p, ic_attr, value_length, need_swap, value_buf);
+	*number_ret = (CARD16) 1;
+	return *number_ret;
+#endif
+    }
+    /*endswitch*/
+    return 0;
+}
+
+static XICAttribute *CreateNestedList (CARD16 attr_id,
+                                       XICAttribute *list,
+                                       int number,
+                                       int need_swap)
+{
+    XICAttribute *nest_list = NULL;
+    register int i;
+    char *values = NULL;
+    char *valuesp;
+    int value_length = 0;
+
+    if (number == 0)
+        return NULL;
+    /*endif*/
+    for (i = 0;  i < number;  i++)
+    {
+        value_length += sizeof (CARD16)*2;
+        value_length += list[i].value_length;
+        value_length += IMPAD (list[i].value_length);
+    }
+    /*endfor*/
+    if ((values = (char *) malloc (value_length)) == NULL)
+        return NULL;
+    /*endif*/
+    memset (values, 0, value_length);
+
+    valuesp = values;
+    for (i = 0;  i < number;  i++)
+    {
+        switch (list[i].type)
+        {
+        case XimType_CARD8:
+        case XimType_CARD16:
+        case XimType_CARD32:
+        case XimType_Window:
+            GetCardAttribute (valuesp, &list[i], need_swap);
+            break;
+
+        case XimType_XFontSet:
+            GetFontAttribute (valuesp, &list[i], need_swap);
+            break;
+
+        case XimType_XRectangle:
+            GetRectAttribute (valuesp, &list[i], need_swap);
+            break;
+
+        case XimType_XPoint:
+            GetPointAttribute (valuesp, &list[i], need_swap);
+            break;
+
+#if 0
+        case XimType_XIMHotKeyTriggers:
+            GetHotKeyAttribute (valuesp, &list[i], need_swap);
+            break;
+#endif
+        }
+        /*endswitch*/
+        valuesp += sizeof (CARD16)*2;
+        valuesp += list[i].value_length;
+        valuesp += IMPAD(list[i].value_length);
+    }
+    /*endfor*/
+
+    nest_list = (XICAttribute *) malloc (sizeof (XICAttribute));
+    if (nest_list == NULL)
+        return NULL;
+    /*endif*/
+    memset (nest_list, 0, sizeof (XICAttribute));
+    nest_list->value = (void *) malloc (value_length);
+    if (nest_list->value == NULL)
+        return NULL;
+    /*endif*/
+    memset (nest_list->value, 0, sizeof (value_length));
+
+    nest_list->attribute_id = attr_id;
+    nest_list->value_length = value_length;
+    memmove (nest_list->value, values, value_length);
+
+    XFree (values);
+    return nest_list;
+}
+
+static Bool IsNestedList (Xi18n i18n_core, CARD16 icvalue_id)
+{
+    XICAttr *ic_attr = i18n_core->address.xic_attr;
+    int i;
+
+    for (i = 0;  i < i18n_core->address.ic_attr_num;  i++, ic_attr++)
+    {
+        if (ic_attr->attribute_id == icvalue_id)
+        {
+            if (ic_attr->type == XimType_NEST)
+                return True;
+            /*endif*/
+            return False;
+        }
+        /*endif*/
+    }
+    /*endfor*/
+    return False;
+}
+
+static Bool IsSeparator (Xi18n i18n_core, CARD16 icvalue_id)
+{
+    return (i18n_core->address.separatorAttr_id == icvalue_id);
+}
+
+static int GetICValue (Xi18n i18n_core,
+                       XICAttribute *attr_ret,
+                       CARD16 *id_list,
+                       int list_num)
+{
+    XICAttr *xic_attr = i18n_core->address.xic_attr;
+    register int i;
+    register int j;
+    register int n;
+
+    i =
+    n = 0;
+    if (IsNestedList (i18n_core, id_list[i]))
+    {
+        i++;
+        while (i < list_num  &&  !IsSeparator (i18n_core, id_list[i]))
+        {
+            for (j = 0;  j < i18n_core->address.ic_attr_num;  j++)
+            {
+                if (xic_attr[j].attribute_id == id_list[i])
+                {
+                    attr_ret[n].attribute_id = xic_attr[j].attribute_id;
+                    attr_ret[n].name_length = xic_attr[j].length;
+                    attr_ret[n].name = malloc (xic_attr[j].length + 1);
+		    strcpy(attr_ret[n].name, xic_attr[j].name);
+                    attr_ret[n].type = xic_attr[j].type;
+                    n++;
+                    i++;
+                    break;
+                }
+                /*endif*/
+            }
+            /*endfor*/
+        }
+        /*endwhile*/
+    }
+    else
+    {
+        for (j = 0;  j < i18n_core->address.ic_attr_num;  j++)
+        {
+            if (xic_attr[j].attribute_id == id_list[i])
+            {
+                attr_ret[n].attribute_id = xic_attr[j].attribute_id;
+                attr_ret[n].name_length = xic_attr[j].length;
+                attr_ret[n].name = malloc (xic_attr[j].length + 1);
+		strcpy(attr_ret[n].name, xic_attr[j].name);
+                attr_ret[n].type = xic_attr[j].type;
+                n++;
+                break;
+            }
+            /*endif*/
+        }
+        /*endfor*/
+    }
+    /*endif*/
+    return n;
+}
+
+static void SwapAttributes (XICAttribute *list,
+			   int number){
+    FrameMgr fm;
+    CARD16 c16;
+    extern XimFrameRec short_fr[];
+    CARD32 c32;
+    extern XimFrameRec long_fr[];
+    XPoint xpoint;
+    extern XimFrameRec xpoint_fr[];
+    XRectangle xrect;
+    extern XimFrameRec xrectangle_fr[];
+    int i;
+
+    for (i = 0; i < number; ++i, ++list) {
+	if (list->value == NULL)
+	    continue;
+	switch (list->type) {
+	case XimType_CARD16:
+	    fm = FrameMgrInit (short_fr, (char *)list->value, 1);
+	    FrameMgrGetToken (fm, c16);
+	    memmove(list->value, &c16, sizeof(CARD16));
+	    FrameMgrFree (fm);
+	    break;
+	case XimType_CARD32:
+	case XimType_Window:
+	    fm = FrameMgrInit (long_fr, (char *)list->value, 1);
+	    FrameMgrGetToken (fm, c32);
+	    memmove(list->value, &c32, sizeof(CARD32));
+	    FrameMgrFree (fm);
+	    break;
+	case XimType_XRectangle:
+	    fm = FrameMgrInit (xrectangle_fr, (char *)list->value, 1);
+	    FrameMgrGetToken (fm, xrect);
+	    memmove(list->value, &xrect, sizeof(XRectangle));
+	    FrameMgrFree (fm);
+	    break;
+	case XimType_XPoint:
+	    fm = FrameMgrInit (xpoint_fr, (char *)list->value, 1);
+	    FrameMgrGetToken (fm, xpoint);
+	    memmove(list->value, &xpoint, sizeof(XPoint));
+	    FrameMgrFree (fm);
+	    break;
+	default:
+	    break;
+	}
+    }
+}
+
+/* called from CreateICMessageProc and SetICValueMessageProc */
+void _Xi18nChangeIC (XIMS ims,
+                     IMProtocol *call_data,
+                     unsigned char *p,
+                     int create_flag)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    FmStatus status;
+    CARD16 byte_length;
+    register int total_size;
+    unsigned char *reply = NULL;
+    register int i;
+    register int attrib_num;
+    XICAttribute *attrib_list;
+    XICAttribute pre_attr[IC_SIZE];
+    XICAttribute sts_attr[IC_SIZE];
+    XICAttribute ic_attr[IC_SIZE];
+    CARD16 preedit_ic_num = 0;
+    CARD16 status_ic_num = 0;
+    CARD16 ic_num = 0;
+    CARD16 connect_id = call_data->any.connect_id;
+    IMChangeICStruct *changeic = (IMChangeICStruct *) &call_data->changeic;
+    extern XimFrameRec create_ic_fr[];
+    extern XimFrameRec create_ic_reply_fr[];
+    extern XimFrameRec set_ic_values_fr[];
+    extern XimFrameRec set_ic_values_reply_fr[];
+    CARD16 input_method_ID;
+
+    void *value_buf = NULL;
+    void *value_buf_ptr;
+
+    register int total_value_length = 0;
+
+    memset (pre_attr, 0, sizeof (XICAttribute)*IC_SIZE);
+    memset (sts_attr, 0, sizeof (XICAttribute)*IC_SIZE);
+    memset (ic_attr, 0, sizeof (XICAttribute)*IC_SIZE);
+
+    if (create_flag == True)
+    {
+        fm = FrameMgrInit (create_ic_fr,
+                           (char *) p,
+                           _Xi18nNeedSwap (i18n_core, connect_id));
+        /* get data */
+        FrameMgrGetToken (fm, input_method_ID);
+        FrameMgrGetToken (fm, byte_length);
+    }
+    else
+    {
+        fm = FrameMgrInit (set_ic_values_fr,
+                           (char *) p,
+                           _Xi18nNeedSwap (i18n_core, connect_id));
+        /* get data */
+        FrameMgrGetToken (fm, input_method_ID);
+        FrameMgrGetToken (fm, changeic->icid);
+        FrameMgrGetToken (fm, byte_length);
+    }
+    /*endif*/
+    attrib_list = (XICAttribute *) malloc (sizeof (XICAttribute)*IC_SIZE);
+    if (!attrib_list)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return;
+    }
+    /*endif*/
+    memset (attrib_list, 0, sizeof(XICAttribute)*IC_SIZE);
+
+    attrib_num = 0;
+    while (FrameMgrIsIterLoopEnd (fm, &status) == False)
+    {
+        void *value;
+        int value_length;
+
+        FrameMgrGetToken (fm, attrib_list[attrib_num].attribute_id);
+        FrameMgrGetToken (fm, value_length);
+        FrameMgrSetSize (fm, value_length);
+        attrib_list[attrib_num].value_length = value_length;
+        FrameMgrGetToken (fm, value);
+        attrib_list[attrib_num].value = (void *) malloc (value_length + 1);
+        memmove (attrib_list[attrib_num].value, value, value_length);
+	((char *)attrib_list[attrib_num].value)[value_length] = '\0';
+        attrib_num++;
+        total_value_length += (value_length + 1);
+    }
+    /*endwhile*/
+
+    value_buf = (void *) malloc (total_value_length);
+    value_buf_ptr = value_buf;
+
+    if (!value_buf)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        for (i = 0;  i < attrib_num;  i++)
+            XFree (attrib_list[i].value);
+        /*endfor*/
+        XFree (attrib_list);
+        return;
+    }
+    /*endif*/
+
+    for (i = 0;  i < attrib_num;  i++)
+    {
+        CARD16 number;
+
+        if (IsNestedList (i18n_core, attrib_list[i].attribute_id))
+        {
+            if (attrib_list[i].attribute_id
+                == i18n_core->address.preeditAttr_id)
+            {
+                ReadICValue (i18n_core,
+                             attrib_list[i].attribute_id,
+                             attrib_list[i].value_length,
+                             attrib_list[i].value,
+                             &pre_attr[preedit_ic_num],
+                             &number,
+                             _Xi18nNeedSwap(i18n_core, connect_id),
+                             &value_buf_ptr);
+                preedit_ic_num += number;
+            }
+            else if (attrib_list[i].attribute_id == i18n_core->address.statusAttr_id)
+            {
+                ReadICValue (i18n_core,
+                             attrib_list[i].attribute_id,
+                             attrib_list[i].value_length,
+                             attrib_list[i].value,
+                             &sts_attr[status_ic_num],
+                             &number,
+                             _Xi18nNeedSwap (i18n_core, connect_id),
+                             &value_buf_ptr);
+                status_ic_num += number;
+            }
+            else
+            {
+                /* another nested list.. possible? */
+            }
+            /*endif*/
+        }
+        else
+        {
+            ReadICValue (i18n_core,
+                         attrib_list[i].attribute_id,
+                         attrib_list[i].value_length,
+                         attrib_list[i].value,
+                         &ic_attr[ic_num],
+                         &number,
+                         _Xi18nNeedSwap (i18n_core, connect_id),
+                         &value_buf_ptr);
+            ic_num += number;
+        }
+        /*endif*/
+    }
+    /*endfor*/
+    for (i = 0;  i < attrib_num;  i++)
+        XFree (attrib_list[i].value);
+    /*endfor*/
+    XFree (attrib_list);
+
+    FrameMgrFree (fm);
+
+    changeic->preedit_attr_num = preedit_ic_num;
+    changeic->status_attr_num = status_ic_num;
+    changeic->ic_attr_num = ic_num;
+    changeic->preedit_attr = pre_attr;
+    changeic->status_attr = sts_attr;
+    changeic->ic_attr = ic_attr;
+
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto(ims, call_data))) {
+            XFree (value_buf);
+            return;
+        }
+        /*endif*/
+    }
+
+    XFree (value_buf);
+
+    /*endif*/
+    if (create_flag == True)
+    {
+        fm = FrameMgrInit (create_ic_reply_fr,
+                           NULL,
+                           _Xi18nNeedSwap (i18n_core, connect_id));
+    }
+    else
+    {
+        fm = FrameMgrInit (set_ic_values_reply_fr,
+                           NULL,
+                           _Xi18nNeedSwap (i18n_core, connect_id));
+    }
+    /*endif*/
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, input_method_ID);
+    FrameMgrPutToken (fm, changeic->icid);
+
+    if (create_flag == True)
+    {
+        _Xi18nSendMessage (ims,
+                           connect_id,
+                           XIM_CREATE_IC_REPLY,
+                           0,
+                           reply,
+                           total_size);
+    }
+    else
+    {
+        _Xi18nSendMessage (ims,
+                           connect_id,
+                           XIM_SET_IC_VALUES_REPLY,
+                           0,
+                           reply,
+                           total_size);
+    }
+    /*endif*/
+    if (create_flag == True)
+    {
+        int on_key_num = i18n_core->address.on_keys.count_keys;
+        int off_key_num = i18n_core->address.off_keys.count_keys;
+
+        if (on_key_num == 0  &&  off_key_num == 0)
+        {
+            long mask;
+
+            if (i18n_core->address.imvalue_mask & I18N_FILTERMASK)
+                mask = i18n_core->address.filterevent_mask;
+            else
+                mask = DEFAULT_FILTER_MASK;
+            /*endif*/
+            /* static event flow is default */
+            _Xi18nSetEventMask (ims,
+                                connect_id,
+                                input_method_ID,
+                                changeic->icid,
+                                mask,
+                                ~mask);
+        }
+        /*endif*/
+    }
+    /*endif*/
+    FrameMgrFree (fm);
+    XFree(reply);
+}
+
+/* called from GetICValueMessageProc */
+void _Xi18nGetIC (XIMS ims, IMProtocol *call_data, unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    FmStatus status;
+    extern XimFrameRec get_ic_values_fr[];
+    extern XimFrameRec get_ic_values_reply_fr[];
+    CARD16 byte_length;
+    register int total_size;
+    unsigned char *reply = NULL;
+    XICAttribute *preedit_ret = NULL;
+    XICAttribute *status_ret = NULL;
+    register int i;
+    register int number;
+    int iter_count;
+    CARD16 *attrID_list;
+    XICAttribute pre_attr[IC_SIZE];
+    XICAttribute sts_attr[IC_SIZE];
+    XICAttribute ic_attr[IC_SIZE];
+    CARD16 pre_count = 0;
+    CARD16 sts_count = 0;
+    CARD16 ic_count = 0;
+    IMChangeICStruct *getic = (IMChangeICStruct *) &call_data->changeic;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+
+    memset (pre_attr, 0, sizeof (XICAttribute)*IC_SIZE);
+    memset (sts_attr, 0, sizeof (XICAttribute)*IC_SIZE);
+    memset (ic_attr, 0, sizeof (XICAttribute)*IC_SIZE);
+
+    fm = FrameMgrInit (get_ic_values_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    /* get data */
+    FrameMgrGetToken (fm, input_method_ID);
+    FrameMgrGetToken (fm, getic->icid);
+    FrameMgrGetToken (fm, byte_length);
+
+    attrID_list = (CARD16 *) malloc (sizeof (CARD16)*IC_SIZE);  /* bogus */
+    memset (attrID_list, 0, sizeof (CARD16)*IC_SIZE);
+
+    number = 0;
+    while (FrameMgrIsIterLoopEnd (fm, &status) == False)
+        FrameMgrGetToken (fm, attrID_list[number++]);
+    /*endwhile*/
+    FrameMgrFree (fm);
+
+    i = 0;
+    while (i < number)
+    {
+        int read_number;
+
+        if (IsNestedList (i18n_core, attrID_list[i]))
+        {
+            if (attrID_list[i] == i18n_core->address.preeditAttr_id)
+            {
+                read_number = GetICValue (i18n_core,
+                                          &pre_attr[pre_count],
+                                          &attrID_list[i],
+                                          number);
+                i += read_number + 1;
+                pre_count += read_number;
+            }
+            else if (attrID_list[i] == i18n_core->address.statusAttr_id)
+            {
+                read_number = GetICValue (i18n_core,
+                                          &sts_attr[sts_count],
+                                          &attrID_list[i],
+                                          number);
+                i += read_number + 1;
+                sts_count += read_number;
+            }
+            else
+            {
+                /* another nested list.. possible? */
+            }
+            /*endif*/
+        }
+        else
+        {
+            read_number = GetICValue (i18n_core,
+                                      &ic_attr[ic_count],
+                                      &attrID_list[i],
+                                      number);
+            i += read_number;
+            ic_count += read_number;
+        }
+        /*endif*/
+    }
+    /*endwhile*/
+    getic->preedit_attr_num = pre_count;
+    getic->status_attr_num = sts_count;
+    getic->ic_attr_num = ic_count;
+    getic->preedit_attr = pre_attr;
+    getic->status_attr = sts_attr;
+    getic->ic_attr = ic_attr;
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto (ims, call_data)))
+            return;
+        /*endif*/
+	if (_Xi18nNeedSwap (i18n_core, connect_id))
+	  SwapAttributes(getic->ic_attr, getic->ic_attr_num);
+    }
+    /*endif*/
+    iter_count = getic->ic_attr_num;
+
+    preedit_ret = CreateNestedList (i18n_core->address.preeditAttr_id,
+                                    getic->preedit_attr,
+                                    getic->preedit_attr_num,
+                                    _Xi18nNeedSwap (i18n_core, connect_id));
+    if (preedit_ret)
+        iter_count++;
+    /*endif*/
+    status_ret = CreateNestedList (i18n_core->address.statusAttr_id,
+                                   getic->status_attr,
+                                   getic->status_attr_num,
+                                   _Xi18nNeedSwap (i18n_core, connect_id));
+    if (status_ret)
+        iter_count++;
+    /*endif*/
+
+    fm = FrameMgrInit (get_ic_values_reply_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    /* set iteration count for list of ic_attribute */
+    FrameMgrSetIterCount (fm, iter_count);
+
+    /* set length of BARRAY item in xicattribute_fr */
+    for (i = 0;  i < (int) getic->ic_attr_num;  i++)
+        FrameMgrSetSize (fm, ic_attr[i].value_length);
+    /*endfor*/
+
+    if (preedit_ret)
+        FrameMgrSetSize (fm, preedit_ret->value_length);
+    /*endif*/
+    if (status_ret)
+        FrameMgrSetSize (fm, status_ret->value_length);
+    /*endif*/
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (reply == NULL)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, input_method_ID);
+    FrameMgrPutToken (fm, getic->icid);
+
+    for (i = 0;  i < (int) getic->ic_attr_num;  i++)
+    {
+        FrameMgrPutToken (fm, ic_attr[i].attribute_id);
+        FrameMgrPutToken (fm, ic_attr[i].value_length);
+        FrameMgrPutToken (fm, ic_attr[i].value);
+    }
+    /*endfor*/
+    if (preedit_ret)
+    {
+        FrameMgrPutToken (fm, preedit_ret->attribute_id);
+        FrameMgrPutToken (fm, preedit_ret->value_length);
+        FrameMgrPutToken (fm, preedit_ret->value);
+    }
+    /*endif*/
+    if (status_ret)
+    {
+        FrameMgrPutToken (fm, status_ret->attribute_id);
+        FrameMgrPutToken (fm, status_ret->value_length);
+        FrameMgrPutToken (fm, status_ret->value);
+    }
+    /*endif*/
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_GET_IC_VALUES_REPLY,
+                       0,
+                       reply,
+                       total_size);
+    XFree (reply);
+    XFree (attrID_list);
+
+    for (i = 0;  i < (int) getic->ic_attr_num;  i++)
+    {
+	if (getic->ic_attr[i].name)
+	    XFree (getic->ic_attr[i].name);
+	/*endif*/
+        if (getic->ic_attr[i].value)
+            XFree (getic->ic_attr[i].value);
+        /*endif*/
+    }
+    /*endfor*/
+    for (i = 0;  i < (int) getic->preedit_attr_num;  i++)
+    {
+	if (getic->preedit_attr[i].name)
+	    XFree (getic->preedit_attr[i].name);
+	/*endif*/
+	if (getic->preedit_attr[i].value)
+	    XFree (getic->preedit_attr[i].value);
+	/*endif*/
+    }
+    /*endfor*/
+    for (i = 0;  i < (int) getic->status_attr_num;  i++)
+    {
+	if (getic->status_attr[i].name)
+	    XFree (getic->status_attr[i].name);
+	/*endif*/
+	if (getic->status_attr[i].value)
+	    XFree (getic->status_attr[i].value);
+	/*endif*/
+    }
+    /*endfor*/
+
+    if (preedit_ret)
+    {
+        XFree (preedit_ret->value);
+        XFree (preedit_ret);
+    }
+    /*endif*/
+    if (status_ret)
+    {
+        XFree (status_ret->value);
+        XFree (status_ret);
+    }
+    /*endif*/
+    FrameMgrFree (fm);
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nMethod.c b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nMethod.c
new file mode 100644
index 0000000..c8b43df
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nMethod.c
@@ -0,0 +1,1150 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#include <X11/Xlib.h>
+#include <X11/Xatom.h>
+#ifndef NEED_EVENTS
+#define NEED_EVENTS
+#endif
+#include <X11/Xproto.h>
+#undef NEED_EVENTS
+#include "FrameMgr.h"
+#include "../include/IMdkit.h"
+#include "../include/Xi18n.h"
+#include "XimFunc.h"
+
+extern Xi18nClient *_Xi18nFindClient (Xi18n, CARD16);
+
+static void *xi18n_setup (Display *, XIMArg *);
+static Status xi18n_openIM (XIMS);
+static Status xi18n_closeIM (XIMS);
+static char *xi18n_setIMValues (XIMS, XIMArg *);
+static char *xi18n_getIMValues (XIMS, XIMArg *);
+static Status xi18n_forwardEvent (XIMS, XPointer);
+static Status xi18n_commit (XIMS, XPointer);
+static int xi18n_callCallback (XIMS, XPointer);
+static int xi18n_preeditStart (XIMS, XPointer);
+static int xi18n_preeditEnd (XIMS, XPointer);
+static int xi18n_syncXlib (XIMS, XPointer);
+
+#ifndef XIM_SERVERS
+#define XIM_SERVERS "XIM_SERVERS"
+#endif
+static Atom XIM_Servers = None;
+
+
+IMMethodsRec Xi18n_im_methods =
+{
+    xi18n_setup,
+    xi18n_openIM,
+    xi18n_closeIM,
+    xi18n_setIMValues,
+    xi18n_getIMValues,
+    xi18n_forwardEvent,
+    xi18n_commit,
+    xi18n_callCallback,
+    xi18n_preeditStart,
+    xi18n_preeditEnd,
+    xi18n_syncXlib,
+};
+
+extern Bool _Xi18nCheckXAddress (Xi18n, TransportSW *, char *);
+extern Bool _Xi18nCheckTransAddress (Xi18n, TransportSW *, char *);
+
+TransportSW _TransR[] =
+{
+    {"X",               1, _Xi18nCheckXAddress},
+#ifdef TCPCONN
+    {"tcp",             3, _Xi18nCheckTransAddress},
+    {"local",           5, _Xi18nCheckTransAddress},
+#endif
+#ifdef DNETCONN
+    {"decnet",          6, _Xi18nCheckTransAddress},
+#endif
+    {(char *) NULL,     0, (Bool (*) ()) NULL}
+};
+
+static Bool GetInputStyles (Xi18n i18n_core, XIMStyles **p_style)
+{
+    Xi18nAddressRec *address = (Xi18nAddressRec *) &i18n_core->address;
+    XIMStyles *p;
+    int	i;
+
+    p = &address->input_styles;
+    if ((*p_style = (XIMStyles *) malloc (sizeof (XIMStyles)
+                                          + p->count_styles*sizeof (XIMStyle)))
+        == NULL)
+    {
+        return False;
+    }
+    /*endif*/
+    (*p_style)->count_styles = p->count_styles;
+    (*p_style)->supported_styles = (XIMStyle *) ((XPointer) *p_style + sizeof (XIMStyles));
+    for (i = 0;  i < (int) p->count_styles;  i++)
+        (*p_style)->supported_styles[i] = p->supported_styles[i];
+    /*endfor*/
+    return True;
+}
+
+static Bool GetOnOffKeys (Xi18n i18n_core, long mask, XIMTriggerKeys **p_key)
+{
+    Xi18nAddressRec *address = (Xi18nAddressRec *) &i18n_core->address;
+    XIMTriggerKeys *p;
+    int	i;
+
+    if (mask & I18N_ON_KEYS)
+        p = &address->on_keys;
+    else
+        p = &address->off_keys;
+    /*endif*/
+    if ((*p_key = (XIMTriggerKeys *) malloc (sizeof(XIMTriggerKeys)
+                                             + p->count_keys*sizeof(XIMTriggerKey)))
+        == NULL)
+    {
+        return False;
+    }
+    /*endif*/
+    (*p_key)->count_keys = p->count_keys;
+    (*p_key)->keylist =
+        (XIMTriggerKey *) ((XPointer) *p_key + sizeof(XIMTriggerKeys));
+    for (i = 0;  i < (int) p->count_keys;  i++)
+    {
+        (*p_key)->keylist[i].keysym = p->keylist[i].keysym;
+        (*p_key)->keylist[i].modifier = p->keylist[i].modifier;
+        (*p_key)->keylist[i].modifier_mask = p->keylist[i].modifier_mask;
+    }
+    /*endfor*/
+    return True;
+}
+
+static Bool GetEncodings(Xi18n i18n_core, XIMEncodings **p_encoding)
+{
+    Xi18nAddressRec *address = (Xi18nAddressRec *) &i18n_core->address;
+    XIMEncodings *p;
+    int	i;
+
+    p = &address->encoding_list;
+
+    if ((*p_encoding = (XIMEncodings *) malloc (sizeof (XIMEncodings)
+                                              + p->count_encodings*sizeof(XIMEncoding))) == NULL)
+    {
+        return False;
+    }
+    /*endif*/
+    (*p_encoding)->count_encodings = p->count_encodings;
+    (*p_encoding)->supported_encodings =
+        (XIMEncoding *) ((XPointer)*p_encoding + sizeof (XIMEncodings));
+    for (i = 0;  i < (int) p->count_encodings;  i++)
+    {
+        (*p_encoding)->supported_encodings[i]
+            = (char *) malloc (strlen (p->supported_encodings[i]) + 1);
+        strcpy ((*p_encoding)->supported_encodings[i],
+                p->supported_encodings[i]);
+    }
+    /*endif*/
+    return True;
+}
+
+static char *ParseArgs (Xi18n i18n_core, int mode, XIMArg *args)
+{
+    Xi18nAddressRec *address = (Xi18nAddressRec *) &i18n_core->address;
+    XIMArg *p;
+
+    if (mode == I18N_OPEN  ||  mode == I18N_SET)
+    {
+        for (p = args;  p->name != NULL;  p++)
+        {
+            if (strcmp (p->name, IMLocale) == 0)
+            {
+                if (address->imvalue_mask & I18N_IM_LOCALE)
+                    return IMLocale;
+                /*endif*/
+                address->im_locale = (char *) malloc (strlen (p->value) + 1);
+                if (!address->im_locale)
+                    return IMLocale;
+                /*endif*/
+                strcpy (address->im_locale, p->value);
+                address->imvalue_mask |= I18N_IM_LOCALE;
+            }
+            else if (strcmp (p->name, IMServerTransport) == 0)
+            {
+                if (address->imvalue_mask & I18N_IM_ADDRESS)
+                    return IMServerTransport;
+                /*endif*/
+                address->im_addr = (char *) malloc (strlen (p->value) + 1);
+                if (!address->im_addr)
+                    return IMServerTransport;
+                /*endif*/
+                strcpy(address->im_addr, p->value);
+                address->imvalue_mask |= I18N_IM_ADDRESS;
+            }
+            else if (strcmp (p->name, IMServerName) == 0)
+            {
+                if (address->imvalue_mask & I18N_IM_NAME)
+                    return IMServerName;
+                /*endif*/
+                address->im_name = (char *) malloc (strlen (p->value) + 1);
+                if (!address->im_name)
+                    return IMServerName;
+                /*endif*/
+                strcpy (address->im_name, p->value);
+                address->imvalue_mask |= I18N_IM_NAME;
+            }
+            else if (strcmp (p->name, IMServerWindow) == 0)
+            {
+                if (address->imvalue_mask & I18N_IMSERVER_WIN)
+                    return IMServerWindow;
+                /*endif*/
+                address->im_window = (Window) p->value;
+                address->imvalue_mask |= I18N_IMSERVER_WIN;
+            }
+            else if (strcmp (p->name, IMInputStyles) == 0)
+            {
+                if (address->imvalue_mask & I18N_INPUT_STYLES)
+                    return IMInputStyles;
+                /*endif*/
+                address->input_styles.count_styles =
+                    ((XIMStyles*)p->value)->count_styles;
+                address->input_styles.supported_styles =
+                    (XIMStyle *) malloc (sizeof (XIMStyle)*address->input_styles.count_styles);
+                if (address->input_styles.supported_styles == (XIMStyle *) NULL)
+                    return IMInputStyles;
+                /*endif*/
+                memmove (address->input_styles.supported_styles,
+                         ((XIMStyles *) p->value)->supported_styles,
+                         sizeof (XIMStyle)*address->input_styles.count_styles);
+                address->imvalue_mask |= I18N_INPUT_STYLES;
+            }
+            else if (strcmp (p->name, IMProtocolHandler) == 0)
+            {
+                address->improto = (IMProtoHandler) p->value;
+                address->imvalue_mask |= I18N_IM_HANDLER;
+            }
+            else if (strcmp (p->name, IMOnKeysList) == 0)
+            {
+                if (address->imvalue_mask & I18N_ON_KEYS)
+                    return IMOnKeysList;
+                /*endif*/
+                address->on_keys.count_keys =
+                    ((XIMTriggerKeys *) p->value)->count_keys;
+                address->on_keys.keylist =
+                    (XIMTriggerKey *) malloc (sizeof (XIMTriggerKey)*address->on_keys.count_keys);
+                if (address->on_keys.keylist == (XIMTriggerKey *) NULL)
+                    return IMOnKeysList;
+                /*endif*/
+                memmove (address->on_keys.keylist,
+                         ((XIMTriggerKeys *) p->value)->keylist,
+                         sizeof (XIMTriggerKey)*address->on_keys.count_keys);
+                address->imvalue_mask |= I18N_ON_KEYS;
+            }
+            else if (strcmp (p->name, IMOffKeysList) == 0)
+            {
+                if (address->imvalue_mask & I18N_OFF_KEYS)
+                    return IMOffKeysList;
+                /*endif*/
+                address->off_keys.count_keys =
+                    ((XIMTriggerKeys *) p->value)->count_keys;
+                address->off_keys.keylist =
+                    (XIMTriggerKey *) malloc (sizeof (XIMTriggerKey)*address->off_keys.count_keys);
+                if (address->off_keys.keylist == (XIMTriggerKey *) NULL)
+                    return IMOffKeysList;
+                /*endif*/
+                memmove (address->off_keys.keylist,
+                         ((XIMTriggerKeys *) p->value)->keylist,
+                         sizeof (XIMTriggerKey)*address->off_keys.count_keys);
+                address->imvalue_mask |= I18N_OFF_KEYS;
+            }
+            else if (strcmp (p->name, IMEncodingList) == 0)
+            {
+                if (address->imvalue_mask & I18N_ENCODINGS)
+                    return IMEncodingList;
+                /*endif*/
+                address->encoding_list.count_encodings =
+                    ((XIMEncodings *) p->value)->count_encodings;
+                address->encoding_list.supported_encodings =
+                    (XIMEncoding *) malloc (sizeof (XIMEncoding)*address->encoding_list.count_encodings);
+                if (address->encoding_list.supported_encodings
+                    == (XIMEncoding *) NULL)
+                {
+                    return IMEncodingList;
+                }
+                /*endif*/
+                memmove (address->encoding_list.supported_encodings,
+                         ((XIMEncodings *) p->value)->supported_encodings,
+                         sizeof (XIMEncoding)*address->encoding_list.count_encodings);
+                address->imvalue_mask |= I18N_ENCODINGS;
+            }
+            else if (strcmp (p->name, IMFilterEventMask) == 0)
+            {
+                if (address->imvalue_mask & I18N_FILTERMASK)
+                    return IMFilterEventMask;
+                /*endif*/
+                address->filterevent_mask = (long) p->value;
+                address->imvalue_mask |= I18N_FILTERMASK;
+            }
+            /*endif*/
+        }
+        /*endfor*/
+        if (mode == I18N_OPEN)
+        {
+            /* check mandatory IM values */
+            if (!(address->imvalue_mask & I18N_IM_LOCALE))
+            {
+                /* locales must be set in IMOpenIM */
+                return IMLocale;
+            }
+            /*endif*/
+            if (!(address->imvalue_mask & I18N_IM_ADDRESS))
+            {
+                /* address must be set in IMOpenIM */
+                return IMServerTransport;
+            }
+            /*endif*/
+        }
+        /*endif*/
+    }
+    else if (mode == I18N_GET)
+    {
+        for (p = args;  p->name != NULL;  p++)
+        {
+            if (strcmp (p->name, IMLocale) == 0)
+            {
+                p->value = (char *) malloc (strlen (address->im_locale) + 1);
+                if (!p->value)
+                    return IMLocale;
+                /*endif*/
+                strcpy (p->value, address->im_locale);
+            }
+            else if (strcmp (p->name, IMServerTransport) == 0)
+            {
+                p->value = (char *) malloc (strlen (address->im_addr) + 1);
+                if (!p->value)
+                    return IMServerTransport;
+                /*endif*/
+                strcpy (p->value, address->im_addr);
+            }
+            else if (strcmp (p->name, IMServerName) == 0)
+            {
+                if (address->imvalue_mask & I18N_IM_NAME)
+                {
+                    p->value = (char *) malloc (strlen (address->im_name) + 1);
+                    if (!p->value)
+                        return IMServerName;
+                    /*endif*/
+                    strcpy (p->value, address->im_name);
+                }
+                else
+                {
+                    return IMServerName;
+                }
+                /*endif*/
+            }
+            else if (strcmp (p->name, IMServerWindow) == 0)
+            {
+                if (address->imvalue_mask & I18N_IMSERVER_WIN)
+                    *((Window *) (p->value)) = address->im_window;
+                else
+                    return IMServerWindow;
+                /*endif*/
+            }
+            else if (strcmp (p->name, IMInputStyles) == 0)
+            {
+                if (GetInputStyles (i18n_core,
+                                    (XIMStyles **) p->value) == False)
+                {
+                    return IMInputStyles;
+                }
+                /*endif*/
+            }
+            else if (strcmp (p->name, IMProtocolHandler) == 0)
+            {
+                if (address->imvalue_mask & I18N_IM_HANDLER)
+                    *((IMProtoHandler *) (p->value)) = address->improto;
+                else
+                    return IMProtocolHandler;
+                /*endif*/
+            }
+            else if (strcmp (p->name, IMOnKeysList) == 0)
+            {
+                if (address->imvalue_mask & I18N_ON_KEYS)
+                {
+                    if (GetOnOffKeys (i18n_core,
+                                      I18N_ON_KEYS,
+                                      (XIMTriggerKeys **) p->value) == False)
+                    {
+                        return IMOnKeysList;
+                    }
+                    /*endif*/
+                }
+                else
+                {
+                    return IMOnKeysList;
+                }
+                /*endif*/
+            }
+            else if (strcmp (p->name, IMOffKeysList) == 0)
+            {
+                if (address->imvalue_mask & I18N_OFF_KEYS)
+                {
+                    if (GetOnOffKeys (i18n_core,
+                                      I18N_OFF_KEYS,
+                                      (XIMTriggerKeys **) p->value) == False)
+                    {
+                        return IMOffKeysList;
+                    }
+                    /*endif*/
+                }
+                else
+                {
+                    return IMOffKeysList;
+                }
+                /*endif*/
+            }
+            else if (strcmp (p->name, IMEncodingList) == 0)
+            {
+                if (address->imvalue_mask & I18N_ENCODINGS)
+                {
+                    if (GetEncodings (i18n_core,
+                                      (XIMEncodings **) p->value) == False)
+                    {
+                        return IMEncodingList;
+                    }
+                    /*endif*/
+                }
+                else
+                {
+                    return IMEncodingList;
+                }
+                /*endif*/
+            }
+            else if (strcmp (p->name, IMFilterEventMask) == 0)
+            {
+                if (address->imvalue_mask & I18N_FILTERMASK)
+                    *((long *) (p->value)) = address->filterevent_mask;
+                else
+                    return IMFilterEventMask;
+                /*endif*/
+            }
+            /*endif*/
+        }
+        /*endfor*/
+    }
+    /*endif*/
+    return NULL;
+}
+
+static int CheckIMName (Xi18n i18n_core)
+{
+    char *address = i18n_core->address.im_addr;
+    int i;
+
+    for (i = 0;  _TransR[i].transportname;  i++)
+    {
+        while (*address == ' '  ||  *address == '\t')
+            address++;
+        /*endwhile*/
+        if (strncmp (address,
+                     _TransR[i].transportname,
+                     _TransR[i].namelen) == 0
+            &&
+            address[_TransR[i].namelen] == '/')
+        {
+            if (_TransR[i].checkAddr (i18n_core,
+                                      &_TransR[i],
+                                      address + _TransR[i].namelen + 1) == True)
+            {
+                return True;
+            }
+            /*endif*/
+            return False;
+        }
+        /*endif*/
+    }
+    /*endfor*/
+    return False;
+}
+
+static int SetXi18nSelectionOwner(Xi18n i18n_core)
+{
+    Display *dpy = i18n_core->address.dpy;
+    Window ims_win = i18n_core->address.im_window;
+    Window root = RootWindow (dpy, DefaultScreen (dpy));
+    Atom realtype;
+    int realformat;
+    unsigned long bytesafter;
+    long *data=NULL;
+    unsigned long length;
+    Atom atom;
+    int i;
+    int found;
+    int forse = False;
+    char buf[256];
+
+    (void)snprintf(buf, 256, "@server=%s", i18n_core->address.im_name);
+    if ((atom = XInternAtom(dpy, buf, False)) == 0)
+        return False;
+    i18n_core->address.selection = atom;
+
+    if (XIM_Servers == None)
+        XIM_Servers = XInternAtom (dpy, XIM_SERVERS, False);
+    /*endif*/
+    XGetWindowProperty (dpy,
+                        root,
+                        XIM_Servers,
+                        0L,
+                        1000000L,
+                        False,
+                        XA_ATOM,
+                        &realtype,
+                        &realformat,
+                        &length,
+                        &bytesafter,
+                        (unsigned char **) (&data));
+    if (realtype != None && (realtype != XA_ATOM || realformat != 32)) {
+        if (data != NULL)
+            XFree ((char *) data);
+        return False;
+    }
+
+    found = False;
+    for (i = 0; i < length; i++) {
+        if (data[i] == atom) {
+            Window owner;
+            found = True;
+            if ((owner = XGetSelectionOwner (dpy, atom)) != ims_win) {
+                if (owner == None  ||  forse == True)
+                    XSetSelectionOwner (dpy, atom, ims_win, CurrentTime);
+                else
+                    return False;
+            }
+            break;
+        }
+    }
+
+    if (found == False) {
+        XSetSelectionOwner (dpy, atom, ims_win, CurrentTime);
+        XChangeProperty (dpy,
+                         root,
+                         XIM_Servers,
+                         XA_ATOM,
+                         32,
+                         PropModePrepend,
+                         (unsigned char *) &atom,
+                         1);
+    }
+    else {
+	/*
+	 * We always need to generate the PropertyNotify to the Root Window
+	 */
+        XChangeProperty (dpy,
+                         root,
+                         XIM_Servers,
+                         XA_ATOM,
+                         32,
+                         PropModePrepend,
+                         (unsigned char *) data,
+                         0);
+    }
+    if (data != NULL)
+        XFree ((char *) data);
+
+    /* Intern "LOCALES" and "TRANSOPORT" Target Atoms */
+    i18n_core->address.Localename = XInternAtom (dpy, LOCALES, False);
+    i18n_core->address.Transportname = XInternAtom (dpy, TRANSPORT, False);
+    return (XGetSelectionOwner (dpy, atom) == ims_win);
+}
+
+static int DeleteXi18nAtom(Xi18n i18n_core)
+{
+    Display *dpy = i18n_core->address.dpy;
+    Window root = RootWindow (dpy, DefaultScreen (dpy));
+    Atom realtype;
+    int realformat;
+    unsigned long bytesafter;
+    long *data=NULL;
+    unsigned long length;
+    Atom atom;
+    int i, ret;
+    int found;
+    char buf[256];
+
+    (void)snprintf(buf, 256, "@server=%s", i18n_core->address.im_name);
+    if ((atom = XInternAtom(dpy, buf, False)) == 0)
+        return False;
+    i18n_core->address.selection = atom;
+
+    if (XIM_Servers == None)
+        XIM_Servers = XInternAtom (dpy, XIM_SERVERS, False);
+    XGetWindowProperty (dpy,
+                        root,
+                        XIM_Servers,
+                        0L,
+                        1000000L,
+                        False,
+                        XA_ATOM,
+                        &realtype,
+                        &realformat,
+                        &length,
+                        &bytesafter,
+                        (unsigned char **) (&data));
+    if (realtype != XA_ATOM || realformat != 32) {
+        if (data != NULL)
+            XFree ((char *) data);
+        return False;
+    }
+
+    found = False;
+    for (i = 0; i < length; i++) {
+        if (data[i] == atom) {
+            found = True;
+            break;
+        }
+    }
+
+    if (found == True) {
+        for (i=i+1; i<length; i++)
+            data[i-1] = data[i];
+        XChangeProperty (dpy,
+                         root,
+                         XIM_Servers,
+                         XA_ATOM,
+                         32,
+                         PropModeReplace,
+                         (unsigned char *)data,
+                         length-1);
+        ret = True;
+    }
+    else {
+        XChangeProperty (dpy,
+                         root,
+                         XIM_Servers,
+                         XA_ATOM,
+                         32,
+                         PropModePrepend,
+                         (unsigned char *)data,
+                         0);
+        ret = False;
+    }
+    if (data != NULL)
+        XFree ((char *) data);
+    return ret;
+}
+
+
+/* XIM protocol methods */
+static void *xi18n_setup (Display *dpy, XIMArg *args)
+{
+    Xi18n i18n_core;
+    CARD16 endian = 1;
+
+    if ((i18n_core = (Xi18n) malloc (sizeof (Xi18nCore))) == (Xi18n) NULL)
+        return NULL;
+    /*endif*/
+
+    memset (i18n_core, 0, sizeof (Xi18nCore));
+
+    i18n_core->address.dpy = dpy;
+
+    if (ParseArgs (i18n_core, I18N_OPEN, args) != NULL)
+    {
+        XFree (i18n_core);
+        return NULL;
+    }
+    /*endif*/
+    if (*(char *) &endian)
+        i18n_core->address.im_byteOrder = 'l';
+    else
+        i18n_core->address.im_byteOrder = 'B';
+    /*endif*/
+
+    /* install IMAttr and ICAttr list in i18n_core */
+    _Xi18nInitAttrList (i18n_core);
+
+    /* install IMExtension list in i18n_core */
+    _Xi18nInitExtension (i18n_core);
+
+    return i18n_core;
+}
+
+static void ReturnSelectionNotify (Xi18n i18n_core, XSelectionRequestEvent *ev)
+{
+    XEvent event;
+    Display *dpy = i18n_core->address.dpy;
+    char buf[4096];
+
+    event.type = SelectionNotify;
+    event.xselection.requestor = ev->requestor;
+    event.xselection.selection = ev->selection;
+    event.xselection.target = ev->target;
+    event.xselection.time = ev->time;
+    event.xselection.property = ev->property;
+    if (ev->target == i18n_core->address.Localename)
+    {
+        snprintf (buf, 4096, "@locale=%s", i18n_core->address.im_locale);
+    }
+    else if (ev->target == i18n_core->address.Transportname)
+    {
+        snprintf (buf, 4096, "@transport=%s", i18n_core->address.im_addr);
+    }
+    /*endif*/
+    XChangeProperty (dpy,
+                     event.xselection.requestor,
+                     ev->target,
+                     ev->target,
+                     8,
+                     PropModeReplace,
+                     (unsigned char *) buf,
+                     strlen (buf));
+    XSendEvent (dpy, event.xselection.requestor, False, NoEventMask, &event);
+    XFlush (i18n_core->address.dpy);
+}
+
+static Bool WaitXSelectionRequest (Display *dpy,
+                                   Window win,
+                                   XEvent *ev,
+                                   XPointer client_data)
+{
+    XIMS ims = (XIMS) client_data;
+    Xi18n i18n_core = ims->protocol;
+
+    if (((XSelectionRequestEvent *) ev)->selection
+        == i18n_core->address.selection)
+    {
+        ReturnSelectionNotify (i18n_core, (XSelectionRequestEvent *) ev);
+        return True;
+    }
+    /*endif*/
+    return False;
+}
+
+static Status xi18n_openIM(XIMS ims)
+{
+    Xi18n i18n_core = ims->protocol;
+    Display *dpy = i18n_core->address.dpy;
+
+    if (!CheckIMName (i18n_core)
+        ||
+        !SetXi18nSelectionOwner (i18n_core)
+        ||
+        !i18n_core->methods.begin (ims))
+    {
+        XFree (i18n_core->address.im_name);
+        XFree (i18n_core->address.im_locale);
+        XFree (i18n_core->address.im_addr);
+        XFree (i18n_core);
+        return False;
+    }
+    /*endif*/
+
+    _XRegisterFilterByType (dpy,
+                            i18n_core->address.im_window,
+                            SelectionRequest,
+                            SelectionRequest,
+                            WaitXSelectionRequest,
+                            (XPointer)ims);
+    XFlush(dpy);
+    return True;
+}
+
+static Status xi18n_closeIM(XIMS ims)
+{
+    Xi18n i18n_core = ims->protocol;
+    Display *dpy = i18n_core->address.dpy;
+
+    DeleteXi18nAtom(i18n_core);
+    if (!i18n_core->methods.end (ims))
+        return False;
+
+    _XUnregisterFilter (dpy,
+                        i18n_core->address.im_window,
+                        WaitXSelectionRequest,
+                        (XPointer)ims);
+    XFree (i18n_core->address.im_name);
+    XFree (i18n_core->address.im_locale);
+    XFree (i18n_core->address.im_addr);
+    XFree (i18n_core);
+    return True;
+}
+
+static char *xi18n_setIMValues (XIMS ims, XIMArg *args)
+{
+    Xi18n i18n_core = ims->protocol;
+    char *ret;
+
+    if ((ret = ParseArgs (i18n_core, I18N_SET, args)) != NULL)
+        return ret;
+    /*endif*/
+    return NULL;
+}
+
+static char *xi18n_getIMValues (XIMS ims, XIMArg *args)
+{
+    Xi18n i18n_core = ims->protocol;
+    char *ret;
+
+    if ((ret = ParseArgs (i18n_core, I18N_GET, args)) != NULL)
+        return ret;
+    /*endif*/
+    return NULL;
+}
+
+static void EventToWireEvent (XEvent *ev, xEvent *event,
+			      CARD16 *serial, Bool byte_swap)
+{
+    FrameMgr fm;
+    extern XimFrameRec wire_keyevent_fr[];
+    extern XimFrameRec short_fr[];
+    BYTE b;
+    CARD16 c16;
+    CARD32 c32;
+
+    *serial = (CARD16)(ev->xany.serial >> 16);
+    switch (ev->type) {
+      case KeyPress:
+      case KeyRelease:
+	{
+	    XKeyEvent *kev = (XKeyEvent*)ev;
+	    /* create FrameMgr */
+	    fm = FrameMgrInit(wire_keyevent_fr, (char *)(&(event->u)), byte_swap);
+
+	    /* set values */
+	    b = (BYTE)kev->type;          FrameMgrPutToken(fm, b);
+	    b = (BYTE)kev->keycode;       FrameMgrPutToken(fm, b);
+	    c16 = (CARD16)(kev->serial & (unsigned long)0xffff);
+					  FrameMgrPutToken(fm, c16);
+	    c32 = (CARD32)kev->time;      FrameMgrPutToken(fm, c32);
+	    c32 = (CARD32)kev->root;      FrameMgrPutToken(fm, c32);
+	    c32 = (CARD32)kev->window;    FrameMgrPutToken(fm, c32);
+	    c32 = (CARD32)kev->subwindow; FrameMgrPutToken(fm, c32);
+	    c16 = (CARD16)kev->x_root;    FrameMgrPutToken(fm, c16);
+	    c16 = (CARD16)kev->y_root;    FrameMgrPutToken(fm, c16);
+	    c16 = (CARD16)kev->x;         FrameMgrPutToken(fm, c16);
+	    c16 = (CARD16)kev->y;         FrameMgrPutToken(fm, c16);
+	    c16 = (CARD16)kev->state;     FrameMgrPutToken(fm, c16);
+	    b = (BYTE)kev->same_screen;   FrameMgrPutToken(fm, b);
+	}
+	break;
+      default:
+	  /* create FrameMgr */
+	  fm = FrameMgrInit(short_fr, (char *)(&(event->u.u.sequenceNumber)),
+			    byte_swap);
+	  c16 = (CARD16)(ev->xany.serial & (unsigned long)0xffff);
+	  FrameMgrPutToken(fm, c16);
+	  break;
+    }
+    /* free FrameMgr */
+    FrameMgrFree(fm);
+}
+
+static Status xi18n_forwardEvent (XIMS ims, XPointer xp)
+{
+    Xi18n i18n_core = ims->protocol;
+    IMForwardEventStruct *call_data = (IMForwardEventStruct *)xp;
+    FrameMgr fm;
+    extern XimFrameRec forward_event_fr[];
+    register int total_size;
+    unsigned char *reply = NULL;
+    unsigned char *replyp;
+    CARD16 serial;
+    int event_size;
+    Xi18nClient *client;
+
+    client = (Xi18nClient *) _Xi18nFindClient (i18n_core, call_data->connect_id);
+
+    /* create FrameMgr */
+    fm = FrameMgrInit (forward_event_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, call_data->connect_id));
+
+    total_size = FrameMgrGetTotalSize (fm);
+    event_size = sizeof (xEvent);
+    reply = (unsigned char *) malloc (total_size + event_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims,
+                           call_data->connect_id,
+                           XIM_ERROR,
+                           0,
+                           0,
+                           0);
+        return False;
+    }
+    /*endif*/
+    memset (reply, 0, total_size + event_size);
+    FrameMgrSetBuffer (fm, reply);
+    replyp = reply;
+
+    call_data->sync_bit = 1; 	/* always sync */
+    client->sync = True;
+
+    FrameMgrPutToken (fm, call_data->connect_id);
+    FrameMgrPutToken (fm, call_data->icid);
+    FrameMgrPutToken (fm, call_data->sync_bit);
+
+    replyp += total_size;
+    EventToWireEvent (&(call_data->event),
+                      (xEvent *) replyp,
+                      &serial,
+                      _Xi18nNeedSwap (i18n_core, call_data->connect_id));
+
+    FrameMgrPutToken (fm, serial);
+
+    _Xi18nSendMessage (ims,
+                       call_data->connect_id,
+                       XIM_FORWARD_EVENT,
+                       0,
+                       reply,
+                       total_size + event_size);
+
+    XFree (reply);
+    FrameMgrFree (fm);
+
+    return True;
+}
+
+static Status xi18n_commit (XIMS ims, XPointer xp)
+{
+    Xi18n i18n_core = ims->protocol;
+    IMCommitStruct *call_data = (IMCommitStruct *)xp;
+    FrameMgr fm;
+    extern XimFrameRec commit_chars_fr[];
+    extern XimFrameRec commit_both_fr[];
+    register int total_size;
+    unsigned char *reply = NULL;
+    CARD16 str_length;
+
+    call_data->flag |= XimSYNCHRONUS;  /* always sync */
+
+    if (!(call_data->flag & XimLookupKeySym)
+        &&
+        (call_data->flag & XimLookupChars))
+    {
+        fm = FrameMgrInit (commit_chars_fr,
+                           NULL,
+                           _Xi18nNeedSwap (i18n_core, call_data->connect_id));
+
+        /* set length of STRING8 */
+        str_length = strlen (call_data->commit_string);
+        FrameMgrSetSize (fm, str_length);
+        total_size = FrameMgrGetTotalSize (fm);
+        reply = (unsigned char *) malloc (total_size);
+        if (!reply)
+        {
+            _Xi18nSendMessage (ims,
+                               call_data->connect_id,
+                               XIM_ERROR,
+                               0,
+                               0,
+                               0);
+            return False;
+        }
+        /*endif*/
+        memset (reply, 0, total_size);
+        FrameMgrSetBuffer (fm, reply);
+
+        str_length = FrameMgrGetSize (fm);
+        FrameMgrPutToken (fm, call_data->connect_id);
+        FrameMgrPutToken (fm, call_data->icid);
+        FrameMgrPutToken (fm, call_data->flag);
+        FrameMgrPutToken (fm, str_length);
+        FrameMgrPutToken (fm, call_data->commit_string);
+    }
+    else
+    {
+        fm = FrameMgrInit (commit_both_fr,
+                           NULL,
+                           _Xi18nNeedSwap (i18n_core, call_data->connect_id));
+        /* set length of STRING8 */
+        str_length = strlen (call_data->commit_string);
+        if (str_length > 0)
+            FrameMgrSetSize (fm, str_length);
+        /*endif*/
+        total_size = FrameMgrGetTotalSize (fm);
+        reply = (unsigned char *) malloc (total_size);
+        if (!reply)
+        {
+            _Xi18nSendMessage (ims,
+                               call_data->connect_id,
+                               XIM_ERROR,
+                               0,
+                               0,
+                               0);
+            return False;
+        }
+        /*endif*/
+        FrameMgrSetBuffer (fm, reply);
+        FrameMgrPutToken (fm, call_data->connect_id);
+        FrameMgrPutToken (fm, call_data->icid);
+        FrameMgrPutToken (fm, call_data->flag);
+        FrameMgrPutToken (fm, call_data->keysym);
+        if (str_length > 0)
+        {
+            str_length = FrameMgrGetSize (fm);
+            FrameMgrPutToken (fm, str_length);
+            FrameMgrPutToken (fm, call_data->commit_string);
+        }
+        /*endif*/
+    }
+    /*endif*/
+    _Xi18nSendMessage (ims,
+                       call_data->connect_id,
+                       XIM_COMMIT,
+                       0,
+                       reply,
+                       total_size);
+    FrameMgrFree (fm);
+    XFree (reply);
+
+    return True;
+}
+
+static int xi18n_callCallback (XIMS ims, XPointer xp)
+{
+    IMProtocol *call_data = (IMProtocol *)xp;
+    switch (call_data->major_code)
+    {
+    case XIM_GEOMETRY:
+        return _Xi18nGeometryCallback (ims, call_data);
+
+    case XIM_PREEDIT_START:
+        return _Xi18nPreeditStartCallback (ims, call_data);
+
+    case XIM_PREEDIT_DRAW:
+        return _Xi18nPreeditDrawCallback (ims, call_data);
+
+    case XIM_PREEDIT_CARET:
+        return _Xi18nPreeditCaretCallback (ims, call_data);
+
+    case XIM_PREEDIT_DONE:
+        return _Xi18nPreeditDoneCallback (ims, call_data);
+
+    case XIM_STATUS_START:
+        return _Xi18nStatusStartCallback (ims, call_data);
+
+    case XIM_STATUS_DRAW:
+        return _Xi18nStatusDrawCallback (ims, call_data);
+
+    case XIM_STATUS_DONE:
+        return _Xi18nStatusDoneCallback (ims, call_data);
+
+    case XIM_STR_CONVERSION:
+        return _Xi18nStringConversionCallback (ims, call_data);
+    }
+    /*endswitch*/
+    return False;
+}
+
+/* preeditStart and preeditEnd are used only for Dynamic Event Flow. */
+static int xi18n_preeditStart (XIMS ims, XPointer xp)
+{
+    IMProtocol *call_data = (IMProtocol *)xp;
+    Xi18n i18n_core = ims->protocol;
+    IMPreeditStateStruct *preedit_state =
+        (IMPreeditStateStruct *) &call_data->preedit_state;
+    long mask;
+    int on_key_num = i18n_core->address.on_keys.count_keys;
+    int off_key_num = i18n_core->address.off_keys.count_keys;
+
+    if (on_key_num == 0  &&  off_key_num == 0)
+        return False;
+    /*endif*/
+    if (i18n_core->address.imvalue_mask & I18N_FILTERMASK)
+        mask = i18n_core->address.filterevent_mask;
+    else
+        mask = DEFAULT_FILTER_MASK;
+    /*endif*/
+    _Xi18nSetEventMask (ims,
+                        preedit_state->connect_id,
+                        preedit_state->connect_id,
+                        preedit_state->icid,
+                        mask,
+                        ~mask);
+    return True;
+}
+
+static int xi18n_preeditEnd (XIMS ims, XPointer xp)
+{
+    IMProtocol *call_data = (IMProtocol *)xp;
+    Xi18n i18n_core = ims->protocol;
+    int on_key_num = i18n_core->address.on_keys.count_keys;
+    int off_key_num = i18n_core->address.off_keys.count_keys;
+    IMPreeditStateStruct *preedit_state;
+
+    preedit_state = (IMPreeditStateStruct *) &call_data->preedit_state;
+
+    if (on_key_num == 0  &&  off_key_num == 0)
+        return False;
+    /*endif*/
+
+    _Xi18nSetEventMask (ims,
+                        preedit_state->connect_id,
+                        preedit_state->connect_id,
+                        preedit_state->icid,
+                        0,
+                        0);
+    return True;
+}
+
+static int xi18n_syncXlib (XIMS ims, XPointer xp)
+{
+    IMProtocol *call_data = (IMProtocol *)xp;
+    Xi18n i18n_core = ims->protocol;
+    IMSyncXlibStruct *sync_xlib;
+
+    extern XimFrameRec sync_fr[];
+    FrameMgr fm;
+    CARD16 connect_id = call_data->any.connect_id;
+    int total_size;
+    unsigned char *reply;
+
+    sync_xlib = (IMSyncXlibStruct *) &call_data->sync_xlib;
+    fm = FrameMgrInit (sync_fr, NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+    total_size = FrameMgrGetTotalSize(fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply) {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return False;
+    }
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    /* input input-method ID */
+    FrameMgrPutToken (fm, connect_id);
+    /* input input-context ID */
+    FrameMgrPutToken (fm, sync_xlib->icid);
+    _Xi18nSendMessage (ims, connect_id, XIM_SYNC, 0, reply, total_size);
+
+    FrameMgrFree (fm);
+    XFree(reply);
+    return True;
+}
+
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nPtHdr.c b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nPtHdr.c
new file mode 100644
index 0000000..17e41b7
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nPtHdr.c
@@ -0,0 +1,1906 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#include <stdlib.h>
+#include <sys/param.h>
+#include <X11/Xlib.h>
+#ifndef NEED_EVENTS
+#define NEED_EVENTS
+#endif
+#include <X11/Xproto.h>
+#undef NEED_EVENTS
+#include "FrameMgr.h"
+#include "../include/IMdkit.h"
+#include "../include/Xi18n.h"
+#include "XimFunc.h"
+
+#ifdef XIM_DEBUG
+#include <stdio.h>
+
+static void	DebugLog(char * msg)
+{
+	fprintf(stderr, msg);
+}
+#endif
+
+extern Xi18nClient *_Xi18nFindClient (Xi18n, CARD16);
+
+static void DiscardQueue (XIMS ims, CARD16 connect_id)
+{
+    Xi18n i18n_core = ims->protocol;
+    Xi18nClient *client = (Xi18nClient *) _Xi18nFindClient (i18n_core,
+                                                            connect_id);
+
+    if (client != NULL) {
+	client->sync = False;
+	while (client->pending != NULL) {
+	    XIMPending* pending = client->pending;
+
+	    client->pending = pending->next;
+
+	    XFree(pending->p);
+	    XFree(pending);
+	}
+    }
+}
+
+static void DiscardAllQueue(XIMS ims)
+{
+    Xi18n i18n_core = ims->protocol;
+    Xi18nClient* client = i18n_core->address.clients;
+
+    while (client != NULL) {
+	if (client->sync) {
+	    DiscardQueue(ims, client->connect_id);
+	}
+	client = client->next;
+    }
+}
+
+static void GetProtocolVersion (CARD16 client_major,
+                                CARD16 client_minor,
+                                CARD16 *server_major,
+                                CARD16 *server_minor)
+{
+    *server_major = client_major;
+    *server_minor = client_minor;
+}
+
+static void ConnectMessageProc (XIMS ims,
+                                IMProtocol *call_data,
+                                unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec connect_fr[], connect_reply_fr[];
+    register int total_size;
+    CARD16 server_major_version, server_minor_version;
+    unsigned char *reply = NULL;
+    IMConnectStruct *imconnect =
+        (IMConnectStruct*) &call_data->imconnect;
+    CARD16 connect_id = call_data->any.connect_id;
+
+    fm = FrameMgrInit (connect_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    /* get data */
+    FrameMgrGetToken (fm, imconnect->byte_order);
+    FrameMgrGetToken (fm, imconnect->major_version);
+    FrameMgrGetToken (fm, imconnect->minor_version);
+
+    FrameMgrFree (fm);
+
+    GetProtocolVersion (imconnect->major_version,
+                        imconnect->minor_version,
+                        &server_major_version,
+                        &server_minor_version);
+#ifdef PROTOCOL_RICH
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto(ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+#endif  /* PROTOCOL_RICH */
+
+    fm = FrameMgrInit (connect_reply_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, server_major_version);
+    FrameMgrPutToken (fm, server_minor_version);
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_CONNECT_REPLY,
+                       0,
+                       reply,
+                       total_size);
+
+    FrameMgrFree (fm);
+    XFree (reply);
+}
+
+static void DisConnectMessageProc (XIMS ims, IMProtocol *call_data)
+{
+    Xi18n i18n_core = ims->protocol;
+    unsigned char *reply = NULL;
+    CARD16 connect_id = call_data->any.connect_id;
+
+#ifdef PROTOCOL_RICH
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto (ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+#endif  /* PROTOCOL_RICH */
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_DISCONNECT_REPLY,
+                       0,
+                       reply,
+                       0);
+
+    i18n_core->methods.disconnect (ims, connect_id);
+}
+
+static void OpenMessageProc(XIMS ims, IMProtocol *call_data, unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec open_fr[];
+    extern XimFrameRec open_reply_fr[];
+    unsigned char *reply = NULL;
+    int str_size;
+    register int i, total_size;
+    CARD16 connect_id = call_data->any.connect_id;
+    int str_length;
+    char *name;
+    IMOpenStruct *imopen = (IMOpenStruct *) &call_data->imopen;
+
+    fm = FrameMgrInit (open_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    /* get data */
+    FrameMgrGetToken (fm, str_length);
+    FrameMgrSetSize (fm, str_length);
+    FrameMgrGetToken (fm, name);
+    imopen->lang.length = str_length;
+    imopen->lang.name = malloc (str_length + 1);
+    strncpy (imopen->lang.name, name, str_length);
+    imopen->lang.name[str_length] = (char) 0;
+
+    FrameMgrFree (fm);
+
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto(ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+    if ((i18n_core->address.imvalue_mask & I18N_ON_KEYS)
+        ||
+        (i18n_core->address.imvalue_mask & I18N_OFF_KEYS))
+    {
+        _Xi18nSendTriggerKey (ims, connect_id);
+    }
+    /*endif*/
+    XFree (imopen->lang.name);
+
+    fm = FrameMgrInit (open_reply_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    /* set iteration count for list of imattr */
+    FrameMgrSetIterCount (fm, i18n_core->address.im_attr_num);
+
+    /* set length of BARRAY item in ximattr_fr */
+    for (i = 0;  i < i18n_core->address.im_attr_num;  i++)
+    {
+        str_size = strlen (i18n_core->address.xim_attr[i].name);
+        FrameMgrSetSize (fm, str_size);
+    }
+    /*endfor*/
+    /* set iteration count for list of icattr */
+    FrameMgrSetIterCount (fm, i18n_core->address.ic_attr_num);
+    /* set length of BARRAY item in xicattr_fr */
+    for (i = 0;  i < i18n_core->address.ic_attr_num;  i++)
+    {
+        str_size = strlen (i18n_core->address.xic_attr[i].name);
+        FrameMgrSetSize (fm, str_size);
+    }
+    /*endfor*/
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    /* input input-method ID */
+    FrameMgrPutToken (fm, connect_id);
+
+    for (i = 0;  i < i18n_core->address.im_attr_num;  i++)
+    {
+        str_size = FrameMgrGetSize (fm);
+        FrameMgrPutToken (fm, i18n_core->address.xim_attr[i].attribute_id);
+        FrameMgrPutToken (fm, i18n_core->address.xim_attr[i].type);
+        FrameMgrPutToken (fm, str_size);
+        FrameMgrPutToken (fm, i18n_core->address.xim_attr[i].name);
+    }
+    /*endfor*/
+    for (i = 0;  i < i18n_core->address.ic_attr_num;  i++)
+    {
+        str_size = FrameMgrGetSize (fm);
+        FrameMgrPutToken (fm, i18n_core->address.xic_attr[i].attribute_id);
+        FrameMgrPutToken (fm, i18n_core->address.xic_attr[i].type);
+        FrameMgrPutToken (fm, str_size);
+        FrameMgrPutToken (fm, i18n_core->address.xic_attr[i].name);
+    }
+    /*endfor*/
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_OPEN_REPLY,
+                       0,
+                       reply,
+                       total_size);
+
+    FrameMgrFree (fm);
+    XFree (reply);
+}
+
+static void CloseMessageProc (XIMS ims,
+                              IMProtocol *call_data,
+                              unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec close_fr[];
+    extern XimFrameRec close_reply_fr[];
+    unsigned char *reply = NULL;
+    register int total_size;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+
+    fm = FrameMgrInit (close_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    FrameMgrGetToken (fm, input_method_ID);
+
+    FrameMgrFree (fm);
+
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto (ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+
+    fm = FrameMgrInit (close_reply_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims,
+                           connect_id,
+                           XIM_ERROR,
+                           0,
+                           0,
+                           0);
+        return;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, input_method_ID);
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_CLOSE_REPLY,
+                       0,
+                       reply,
+                       total_size);
+
+    FrameMgrFree (fm);
+    XFree (reply);
+}
+
+static XIMExt *MakeExtensionList (Xi18n i18n_core,
+                                  XIMStr *lib_extension,
+                                  int number,
+                                  int *reply_number)
+{
+    XIMExt *ext_list;
+    XIMExt *im_ext = (XIMExt *) i18n_core->address.extension;
+    int im_ext_len = i18n_core->address.ext_num;
+    int i;
+    int j;
+
+    *reply_number = 0;
+
+    if (number == 0)
+    {
+        /* query all extensions */
+        *reply_number = im_ext_len;
+    }
+    else
+    {
+        for (i = 0;  i < im_ext_len;  i++)
+        {
+            for (j = 0;  j < (int) number;  j++)
+            {
+                if (strcmp (lib_extension[j].name, im_ext[i].name) == 0)
+                {
+                    (*reply_number)++;
+                    break;
+                }
+                /*endif*/
+            }
+            /*endfor*/
+        }
+        /*endfor*/
+    }
+    /*endif*/
+
+    if (!(*reply_number))
+        return NULL;
+    /*endif*/
+    ext_list = (XIMExt *) malloc (sizeof (XIMExt)*(*reply_number));
+    if (!ext_list)
+        return NULL;
+    /*endif*/
+    memset (ext_list, 0, sizeof (XIMExt)*(*reply_number));
+
+    if (number == 0)
+    {
+        /* query all extensions */
+        for (i = 0;  i < im_ext_len;  i++)
+        {
+            ext_list[i].major_opcode = im_ext[i].major_opcode;
+            ext_list[i].minor_opcode = im_ext[i].minor_opcode;
+            ext_list[i].length = im_ext[i].length;
+            ext_list[i].name = malloc (im_ext[i].length + 1);
+            strcpy (ext_list[i].name, im_ext[i].name);
+        }
+        /*endfor*/
+    }
+    else
+    {
+        int n = 0;
+
+        for (i = 0;  i < im_ext_len;  i++)
+        {
+            for (j = 0;  j < (int)number;  j++)
+            {
+                if (strcmp (lib_extension[j].name, im_ext[i].name) == 0)
+                {
+                    ext_list[n].major_opcode = im_ext[i].major_opcode;
+                    ext_list[n].minor_opcode = im_ext[i].minor_opcode;
+                    ext_list[n].length = im_ext[i].length;
+                    ext_list[n].name = malloc (im_ext[i].length + 1);
+                    strcpy (ext_list[n].name, im_ext[i].name);
+                    n++;
+                    break;
+                }
+                /*endif*/
+            }
+            /*endfor*/
+        }
+        /*endfor*/
+    }
+    /*endif*/
+    return ext_list;
+}
+
+static void QueryExtensionMessageProc (XIMS ims,
+                                       IMProtocol *call_data,
+                                       unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    FmStatus status;
+    extern XimFrameRec query_extension_fr[];
+    extern XimFrameRec query_extension_reply_fr[];
+    unsigned char *reply = NULL;
+    int str_size;
+    register int i;
+    register int number;
+    register int total_size;
+    int byte_length;
+    int reply_number = 0;
+    XIMExt *ext_list;
+    IMQueryExtensionStruct *query_ext =
+        (IMQueryExtensionStruct *) &call_data->queryext;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+
+    fm = FrameMgrInit (query_extension_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    FrameMgrGetToken (fm, input_method_ID);
+    FrameMgrGetToken (fm, byte_length);
+    query_ext->extension = (XIMStr *) malloc (sizeof (XIMStr)*10);
+    memset (query_ext->extension, 0, sizeof (XIMStr)*10);
+    number = 0;
+    while (FrameMgrIsIterLoopEnd (fm, &status) == False)
+    {
+        char *name;
+        int str_length;
+
+        FrameMgrGetToken (fm, str_length);
+        FrameMgrSetSize (fm, str_length);
+        query_ext->extension[number].length = str_length;
+        FrameMgrGetToken (fm, name);
+        query_ext->extension[number].name = malloc (str_length + 1);
+        strncpy (query_ext->extension[number].name, name, str_length);
+        query_ext->extension[number].name[str_length] = (char) 0;
+        number++;
+    }
+    /*endwhile*/
+    query_ext->number = number;
+
+#ifdef PROTOCOL_RICH
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto(ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+#endif  /* PROTOCOL_RICH */
+
+    FrameMgrFree (fm);
+
+    ext_list = MakeExtensionList (i18n_core,
+                                  query_ext->extension,
+                                  number,
+                                  &reply_number);
+
+    for (i = 0;  i < number;  i++)
+        XFree (query_ext->extension[i].name);
+    /*endfor*/
+    XFree (query_ext->extension);
+
+    fm = FrameMgrInit (query_extension_reply_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    /* set iteration count for list of extensions */
+    FrameMgrSetIterCount (fm, reply_number);
+
+    /* set length of BARRAY item in ext_fr */
+    for (i = 0;  i < reply_number;  i++)
+    {
+        str_size = strlen (ext_list[i].name);
+        FrameMgrSetSize (fm, str_size);
+    }
+    /*endfor*/
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims,
+                           connect_id,
+                           XIM_ERROR,
+                           0,
+                           0,
+                           0);
+        return;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, input_method_ID);
+
+    for (i = 0;  i < reply_number;  i++)
+    {
+        str_size = FrameMgrGetSize (fm);
+        FrameMgrPutToken (fm, ext_list[i].major_opcode);
+        FrameMgrPutToken (fm, ext_list[i].minor_opcode);
+        FrameMgrPutToken (fm, str_size);
+        FrameMgrPutToken (fm, ext_list[i].name);
+    }
+    /*endfor*/
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_QUERY_EXTENSION_REPLY,
+                       0,
+                       reply,
+                       total_size);
+    FrameMgrFree (fm);
+    XFree (reply);
+
+    for (i = 0;  i < reply_number;  i++)
+        XFree (ext_list[i].name);
+    /*endfor*/
+    XFree ((char *) ext_list);
+}
+
+static void SyncReplyMessageProc (XIMS ims,
+                                  IMProtocol *call_data,
+                                  unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec sync_reply_fr[];
+    CARD16 connect_id = call_data->any.connect_id;
+    Xi18nClient *client;
+    CARD16 input_method_ID;
+    CARD16 input_context_ID;
+
+    client = (Xi18nClient *)_Xi18nFindClient (i18n_core, connect_id);
+    fm = FrameMgrInit (sync_reply_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+    FrameMgrGetToken (fm, input_method_ID);
+    FrameMgrGetToken (fm, input_context_ID);
+    FrameMgrFree (fm);
+
+    client->sync = False;
+
+    if (ims->sync == True) {
+	ims->sync = False;
+	if (i18n_core->address.improto) {
+	    call_data->sync_xlib.major_code = XIM_SYNC_REPLY;
+	    call_data->sync_xlib.minor_code = 0;
+	    call_data->sync_xlib.connect_id = input_method_ID;
+	    call_data->sync_xlib.icid = input_context_ID;
+	    i18n_core->address.improto(ims, call_data);
+	}
+    }
+}
+
+static void GetIMValueFromName (Xi18n i18n_core,
+                                CARD16 connect_id,
+                                char *buf,
+                                char *name,
+                                int *length)
+{
+    register int i;
+
+    if (strcmp (name, XNQueryInputStyle) == 0)
+    {
+        XIMStyles *styles = (XIMStyles *) &i18n_core->address.input_styles;
+
+        *length = sizeof (CARD16)*2; 	/* count_styles, unused */
+        *length += styles->count_styles*sizeof (CARD32);
+
+        if (buf != NULL)
+        {
+            FrameMgr fm;
+            extern XimFrameRec input_styles_fr[];
+            unsigned char *data = NULL;
+            int total_size;
+
+            fm = FrameMgrInit (input_styles_fr,
+                               NULL,
+                               _Xi18nNeedSwap (i18n_core, connect_id));
+
+            /* set iteration count for list of input_style */
+            FrameMgrSetIterCount (fm, styles->count_styles);
+
+            total_size = FrameMgrGetTotalSize (fm);
+            data = (unsigned char *) malloc (total_size);
+            if (!data)
+                return;
+            /*endif*/
+            memset (data, 0, total_size);
+            FrameMgrSetBuffer (fm, data);
+
+            FrameMgrPutToken (fm, styles->count_styles);
+            for (i = 0;  i < (int) styles->count_styles;  i++)
+                FrameMgrPutToken (fm, styles->supported_styles[i]);
+            /*endfor*/
+            memmove (buf, data, total_size);
+            FrameMgrFree (fm);
+
+            /* ADDED BY SUZHE */
+            free (data);
+            /* ADDED BY SUZHE */
+        }
+        /*endif*/
+    }
+    /*endif*/
+
+    else if (strcmp (name, XNQueryIMValuesList) == 0) {
+    }
+}
+
+static XIMAttribute *MakeIMAttributeList (Xi18n i18n_core,
+                                          CARD16 connect_id,
+                                          CARD16 *list,
+                                          int *number,
+                                          int *length)
+{
+    XIMAttribute *attrib_list;
+    int list_num;
+    XIMAttr *attr = i18n_core->address.xim_attr;
+    int list_len = i18n_core->address.im_attr_num;
+    register int i;
+    register int j;
+    int value_length;
+    int number_ret = 0;
+
+    *length = 0;
+    list_num = 0;
+    for (i = 0;  i < *number;  i++)
+    {
+        for (j = 0;  j < list_len;  j++)
+        {
+            if (attr[j].attribute_id == list[i])
+            {
+                list_num++;
+                break;
+            }
+            /*endif*/
+        }
+        /*endfor*/
+    }
+    /*endfor*/
+    attrib_list = (XIMAttribute *) malloc (sizeof (XIMAttribute)*list_num);
+    if (!attrib_list)
+        return NULL;
+    /*endif*/
+    memset (attrib_list, 0, sizeof (XIMAttribute)*list_num);
+    number_ret = list_num;
+    list_num = 0;
+    for (i = 0;  i < *number;  i++)
+    {
+        for (j = 0;  j < list_len;  j++)
+        {
+            if (attr[j].attribute_id == list[i])
+            {
+                attrib_list[list_num].attribute_id = attr[j].attribute_id;
+                attrib_list[list_num].name_length = attr[j].length;
+                attrib_list[list_num].name = attr[j].name;
+                attrib_list[list_num].type = attr[j].type;
+                GetIMValueFromName (i18n_core,
+                                    connect_id,
+                                    NULL,
+                                    attr[j].name,
+                                    &value_length);
+                attrib_list[list_num].value_length = value_length;
+                attrib_list[list_num].value = (void *) malloc (value_length);
+                memset(attrib_list[list_num].value, 0, value_length);
+                GetIMValueFromName (i18n_core,
+                                    connect_id,
+                                    attrib_list[list_num].value,
+                                    attr[j].name,
+                                    &value_length);
+                *length += sizeof (CARD16)*2;
+                *length += value_length;
+                *length += IMPAD (value_length);
+                list_num++;
+                break;
+            }
+            /*endif*/
+        }
+        /*endfor*/
+    }
+    /*endfor*/
+    *number = number_ret;
+    return attrib_list;
+}
+
+static void GetIMValuesMessageProc (XIMS ims,
+                                    IMProtocol *call_data,
+                                    unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    FmStatus status;
+    extern XimFrameRec get_im_values_fr[];
+    extern XimFrameRec get_im_values_reply_fr[];
+    CARD16 byte_length;
+    int list_len, total_size;
+    unsigned char *reply = NULL;
+    int iter_count;
+    register int i;
+    register int j;
+    int number;
+    CARD16 *im_attrID_list;
+    char **name_list;
+    CARD16 name_number;
+    XIMAttribute *im_attribute_list;
+    IMGetIMValuesStruct *getim = (IMGetIMValuesStruct *)&call_data->getim;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+
+    /* create FrameMgr */
+    fm = FrameMgrInit (get_im_values_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    FrameMgrGetToken (fm, input_method_ID);
+    FrameMgrGetToken (fm, byte_length);
+    im_attrID_list = (CARD16 *) malloc (sizeof (CARD16)*20);
+    memset (im_attrID_list, 0, sizeof (CARD16)*20);
+    name_list = (char **)malloc(sizeof(char *) * 20);
+    memset(name_list, 0, sizeof(char *) * 20);
+    number = 0;
+    while (FrameMgrIsIterLoopEnd (fm, &status) == False)
+    {
+        FrameMgrGetToken (fm, im_attrID_list[number]);
+        number++;
+    }
+    FrameMgrFree (fm);
+
+    name_number = 0;
+    for (i = 0;  i < number;  i++) {
+        for (j = 0;  j < i18n_core->address.im_attr_num;  j++) {
+            if (i18n_core->address.xim_attr[j].attribute_id ==
+                    im_attrID_list[i]) {
+                name_list[name_number++] =
+			i18n_core->address.xim_attr[j].name;
+                break;
+            }
+        }
+    }
+    getim->number = name_number;
+    getim->im_attr_list = name_list;
+    XFree (name_list);
+
+
+#ifdef PROTOCOL_RICH
+    if (i18n_core->address.improto) {
+        if (!(i18n_core->address.improto (ims, call_data)))
+            return;
+    }
+#endif  /* PROTOCOL_RICH */
+
+    im_attribute_list = MakeIMAttributeList (i18n_core,
+                                             connect_id,
+                                             im_attrID_list,
+                                             &number,
+                                             &list_len);
+    if (im_attrID_list)
+        XFree (im_attrID_list);
+    /*endif*/
+
+    fm = FrameMgrInit (get_im_values_reply_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    iter_count = number;
+
+    /* set iteration count for list of im_attribute */
+    FrameMgrSetIterCount (fm, iter_count);
+
+    /* set length of BARRAY item in ximattribute_fr */
+    for (i = 0;  i < iter_count;  i++)
+        FrameMgrSetSize (fm, im_attribute_list[i].value_length);
+    /*endfor*/
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, input_method_ID);
+
+    for (i = 0;  i < iter_count;  i++)
+    {
+        FrameMgrPutToken (fm, im_attribute_list[i].attribute_id);
+        FrameMgrPutToken (fm, im_attribute_list[i].value_length);
+        FrameMgrPutToken (fm, im_attribute_list[i].value);
+    }
+    /*endfor*/
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_GET_IM_VALUES_REPLY,
+                       0,
+                       reply,
+                       total_size);
+    FrameMgrFree (fm);
+    XFree (reply);
+
+    for (i = 0; i < iter_count; i++)
+        XFree(im_attribute_list[i].value);
+    XFree (im_attribute_list);
+}
+
+static void CreateICMessageProc (XIMS ims,
+                                 IMProtocol *call_data,
+                                 unsigned char *p)
+{
+    _Xi18nChangeIC (ims, call_data, p, True);
+}
+
+static void SetICValuesMessageProc (XIMS ims,
+                                    IMProtocol *call_data,
+                                    unsigned char *p)
+{
+    _Xi18nChangeIC (ims, call_data, p, False);
+}
+
+static void GetICValuesMessageProc (XIMS ims,
+                                    IMProtocol *call_data,
+                                    unsigned char *p)
+{
+    _Xi18nGetIC (ims, call_data, p);
+}
+
+static void SetICFocusMessageProc (XIMS ims,
+                                   IMProtocol *call_data,
+                                   unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec set_ic_focus_fr[];
+    IMChangeFocusStruct *setfocus;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+
+    /* some buggy xim clients do not send XIM_SYNC_REPLY for synchronous
+     * events. In such case, xim server is waiting for XIM_SYNC_REPLY
+     * forever. So the xim server is blocked to waiting sync reply.
+     * It prevents further input.
+     * Usually it happens when a client calls XSetICFocus() with another ic
+     * before passing an event to XFilterEvent(), where the event is needed
+     * by the old focused ic to sync its state.
+     * To avoid such problem, remove the whole clients queue and set them
+     * as asynchronous.
+     *
+     * See:
+     * http://bugs.freedesktop.org/show_bug.cgi?id=7869
+     */
+    DiscardAllQueue(ims);
+
+    setfocus = (IMChangeFocusStruct *) &call_data->changefocus;
+
+    fm = FrameMgrInit (set_ic_focus_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    /* get data */
+    FrameMgrGetToken (fm, input_method_ID);
+    FrameMgrGetToken (fm, setfocus->icid);
+
+    FrameMgrFree (fm);
+
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto (ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+}
+
+static void UnsetICFocusMessageProc (XIMS ims,
+                                     IMProtocol *call_data,
+                                     unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec unset_ic_focus_fr[];
+    IMChangeFocusStruct *unsetfocus;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+    Xi18nClient *client = _Xi18nFindClient (i18n_core, connect_id);
+
+    /* some buggy clients unset focus ic before the ic answer the sync reply,
+     * so the xim server may be blocked to waiting sync reply. To avoid
+     * this problem, remove the client queue and set it asynchronous
+     *
+     * See: SetICFocusMessageProc
+     */
+    if (client != NULL && client->sync) {
+	DiscardQueue(ims, client->connect_id);
+    }
+
+    unsetfocus = (IMChangeFocusStruct *) &call_data->changefocus;
+
+    fm = FrameMgrInit (unset_ic_focus_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    /* get data */
+    FrameMgrGetToken (fm, input_method_ID);
+    FrameMgrGetToken (fm, unsetfocus->icid);
+
+    FrameMgrFree (fm);
+
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto (ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+}
+
+static void DestroyICMessageProc (XIMS ims,
+                                  IMProtocol *call_data,
+                                  unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec destroy_ic_fr[];
+    extern XimFrameRec destroy_ic_reply_fr[];
+    register int total_size;
+    unsigned char *reply = NULL;
+    IMDestroyICStruct *destroy =
+        (IMDestroyICStruct *) &call_data->destroyic;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+
+    fm = FrameMgrInit (destroy_ic_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    /* get data */
+    FrameMgrGetToken (fm, input_method_ID);
+    FrameMgrGetToken (fm, destroy->icid);
+
+    FrameMgrFree (fm);
+
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto (ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+
+    fm = FrameMgrInit (destroy_ic_reply_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, input_method_ID);
+    FrameMgrPutToken (fm, destroy->icid);
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_DESTROY_IC_REPLY,
+                       0,
+                       reply,
+                       total_size);
+    XFree(reply);
+    FrameMgrFree (fm);
+}
+
+static void ResetICMessageProc (XIMS ims,
+                                IMProtocol *call_data,
+                                unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec reset_ic_fr[];
+    extern XimFrameRec reset_ic_reply_fr[];
+    register int total_size;
+    unsigned char *reply = NULL;
+    IMResetICStruct *resetic =
+        (IMResetICStruct *) &call_data->resetic;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+
+    fm = FrameMgrInit (reset_ic_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    /* get data */
+    FrameMgrGetToken (fm, input_method_ID);
+    FrameMgrGetToken (fm, resetic->icid);
+
+    FrameMgrFree (fm);
+
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto(ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+
+    /* create FrameMgr */
+    fm = FrameMgrInit (reset_ic_reply_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    /* set length of STRING8 */
+    FrameMgrSetSize (fm, resetic->length);
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, input_method_ID);
+    FrameMgrPutToken (fm, resetic->icid);
+    FrameMgrPutToken(fm, resetic->length);
+    FrameMgrPutToken (fm, resetic->commit_string);
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_RESET_IC_REPLY,
+                       0,
+                       reply,
+                       total_size);
+    FrameMgrFree (fm);
+    XFree(reply);
+}
+
+static int WireEventToEvent (Xi18n i18n_core,
+                             xEvent *event,
+                             CARD16 serial,
+                             XEvent *ev,
+                             Bool byte_swap)
+{
+    FrameMgr fm;
+    extern XimFrameRec wire_keyevent_fr[];
+    BYTE b;
+    CARD16 c16;
+    CARD32 c32;
+    int ret = False;
+
+    /* create FrameMgr */
+    fm = FrameMgrInit(wire_keyevent_fr, (char *)(&(event->u)), byte_swap);
+
+
+    /* get & set type */
+    FrameMgrGetToken(fm, b);
+    ev->type = (unsigned int)b;
+    /* get detail */
+    FrameMgrGetToken(fm, b);
+    /* get & set serial */
+    FrameMgrGetToken(fm, c16);
+    ev->xany.serial = (unsigned long)c16;
+    ev->xany.serial |= serial << 16;
+    ev->xany.send_event = False;
+    ev->xany.display = i18n_core->address.dpy;
+
+    /* Remove SendEvent flag from event type to emulate KeyPress/Release */
+    ev->type &= 0x7F;
+
+    switch (ev->type) {
+      case KeyPress:
+      case KeyRelease:
+      {
+          XKeyEvent *kev = (XKeyEvent*)ev;
+
+          /* set keycode (detail) */
+          kev->keycode = (unsigned int)b;
+
+          /* get & set values */
+          FrameMgrGetToken(fm, c32); kev->time = (Time)c32;
+          FrameMgrGetToken(fm, c32); kev->root = (Window)c32;
+          FrameMgrGetToken(fm, c32); kev->window = (Window)c32;
+          FrameMgrGetToken(fm, c32); kev->subwindow = (Window)c32;
+          FrameMgrGetToken(fm, c16); kev->x_root = (int)c16;
+          FrameMgrGetToken(fm, c16); kev->y_root = (int)c16;
+          FrameMgrGetToken(fm, c16); kev->x = (int)c16;
+          FrameMgrGetToken(fm, c16); kev->y = (int)c16;
+          FrameMgrGetToken(fm, c16); kev->state = (unsigned int)c16;
+          FrameMgrGetToken(fm, b);   kev->same_screen = (Bool)b;
+      }
+      ret = True;
+      break;
+      default:
+      break;
+    }
+    /* free FrameMgr */
+    FrameMgrFree(fm);
+    return ret;
+}
+
+static void ForwardEventMessageProc (XIMS ims,
+                                     IMProtocol *call_data,
+                                     unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec forward_event_fr[];
+    xEvent wire_event;
+    IMForwardEventStruct *forward =
+        (IMForwardEventStruct*) &call_data->forwardevent;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+
+    fm = FrameMgrInit (forward_event_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+    /* get data */
+    FrameMgrGetToken (fm, input_method_ID);
+    FrameMgrGetToken (fm, forward->icid);
+    FrameMgrGetToken (fm, forward->sync_bit);
+    FrameMgrGetToken (fm, forward->serial_number);
+    p += sizeof (CARD16)*4;
+    memmove (&wire_event, p, sizeof (xEvent));
+
+    FrameMgrFree (fm);
+
+    if (WireEventToEvent (i18n_core,
+                          &wire_event,
+                          forward->serial_number,
+                          &forward->event,
+			  _Xi18nNeedSwap (i18n_core, connect_id)) == True)
+    {
+        if (i18n_core->address.improto)
+        {
+            if (!(i18n_core->address.improto(ims, call_data)))
+                return;
+            /*endif*/
+        }
+        /*endif*/
+    }
+    /*endif*/
+}
+
+static void ExtForwardKeyEventMessageProc (XIMS ims,
+                                           IMProtocol *call_data,
+                                           unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec ext_forward_keyevent_fr[];
+    CARD8 type, keycode;
+    CARD16 state;
+    CARD32 ev_time, window;
+    IMForwardEventStruct *forward =
+        (IMForwardEventStruct *) &call_data->forwardevent;
+    XEvent *ev = (XEvent *) &forward->event;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+
+    fm = FrameMgrInit (ext_forward_keyevent_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+    /* get data */
+    FrameMgrGetToken (fm, input_method_ID);
+    FrameMgrGetToken (fm, forward->icid);
+    FrameMgrGetToken (fm, forward->sync_bit);
+    FrameMgrGetToken (fm, forward->serial_number);
+    FrameMgrGetToken (fm, type);
+    FrameMgrGetToken (fm, keycode);
+    FrameMgrGetToken (fm, state);
+    FrameMgrGetToken (fm, ev_time);
+    FrameMgrGetToken (fm, window);
+
+    FrameMgrFree (fm);
+
+    if (type != KeyPress)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return;
+    }
+    /*endif*/
+
+    /* make a faked keypress event */
+    ev->type = (int)type;
+    ev->xany.send_event = True;
+    ev->xany.display = i18n_core->address.dpy;
+    ev->xany.serial = (unsigned long) forward->serial_number;
+    ((XKeyEvent *) ev)->keycode = (unsigned int) keycode;
+    ((XKeyEvent *) ev)->state = (unsigned int) state;
+    ((XKeyEvent *) ev)->time = (Time) ev_time;
+    ((XKeyEvent *) ev)->window = (Window) window;
+    ((XKeyEvent *) ev)->root = DefaultRootWindow (ev->xany.display);
+    ((XKeyEvent *) ev)->x = 0;
+    ((XKeyEvent *) ev)->y = 0;
+    ((XKeyEvent *) ev)->x_root = 0;
+    ((XKeyEvent *) ev)->y_root = 0;
+
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto (ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+}
+
+static void ExtMoveMessageProc (XIMS ims,
+                                IMProtocol *call_data,
+                                unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec ext_move_fr[];
+    IMMoveStruct *extmove =
+        (IMMoveStruct*) & call_data->extmove;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+
+    fm = FrameMgrInit (ext_move_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+    /* get data */
+    FrameMgrGetToken (fm, input_method_ID);
+    FrameMgrGetToken (fm, extmove->icid);
+    FrameMgrGetToken (fm, extmove->x);
+    FrameMgrGetToken (fm, extmove->y);
+
+    FrameMgrFree (fm);
+
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto (ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+}
+
+static void ExtensionMessageProc (XIMS ims,
+                                  IMProtocol *call_data,
+                                  unsigned char *p)
+{
+    switch (call_data->any.minor_code)
+    {
+    case XIM_EXT_FORWARD_KEYEVENT:
+        ExtForwardKeyEventMessageProc (ims, call_data, p);
+        break;
+
+    case XIM_EXT_MOVE:
+        ExtMoveMessageProc (ims, call_data, p);
+        break;
+    }
+    /*endswitch*/
+}
+
+static void TriggerNotifyMessageProc (XIMS ims,
+                                      IMProtocol *call_data,
+                                      unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec trigger_notify_fr[], trigger_notify_reply_fr[];
+    register int total_size;
+    unsigned char *reply = NULL;
+    IMTriggerNotifyStruct *trigger =
+        (IMTriggerNotifyStruct *) &call_data->triggernotify;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+    CARD32 flag;
+
+    fm = FrameMgrInit (trigger_notify_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+    /* get data */
+    FrameMgrGetToken (fm, input_method_ID);
+    FrameMgrGetToken (fm, trigger->icid);
+    FrameMgrGetToken (fm, trigger->flag);
+    FrameMgrGetToken (fm, trigger->key_index);
+    FrameMgrGetToken (fm, trigger->event_mask);
+    /*
+      In order to support Front End Method, this event_mask must be saved
+      per clients so that it should be restored by an XIM_EXT_SET_EVENT_MASK
+      call when preediting mode is reset to off.
+     */
+
+    flag = trigger->flag;
+
+    FrameMgrFree (fm);
+
+    fm = FrameMgrInit (trigger_notify_reply_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, input_method_ID);
+    FrameMgrPutToken (fm, trigger->icid);
+
+    /* NOTE:
+       XIM_TRIGGER_NOTIFY_REPLY should be sent before XIM_SET_EVENT_MASK
+       in case of XIM_TRIGGER_NOTIFY(flag == ON), while it should be
+       sent after XIM_SET_EVENT_MASK in case of
+       XIM_TRIGGER_NOTIFY(flag == OFF).
+       */
+    if (flag == 0)
+    {
+        /* on key */
+        _Xi18nSendMessage (ims,
+                           connect_id,
+                           XIM_TRIGGER_NOTIFY_REPLY,
+                           0,
+                           reply,
+                           total_size);
+        IMPreeditStart (ims, (XPointer)call_data);
+    }
+    /*endif*/
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto(ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+
+    if (flag == 1)
+    {
+        /* off key */
+        IMPreeditEnd (ims, (XPointer) call_data);
+        _Xi18nSendMessage (ims,
+                           connect_id,
+                           XIM_TRIGGER_NOTIFY_REPLY,
+                           0,
+                           reply,
+                           total_size);
+    }
+    /*endif*/
+    FrameMgrFree (fm);
+    XFree (reply);
+}
+
+static INT16 ChooseEncoding (Xi18n i18n_core,
+                             IMEncodingNegotiationStruct *enc_nego)
+{
+    Xi18nAddressRec *address = (Xi18nAddressRec *) & i18n_core->address;
+    XIMEncodings *p;
+    int i, j;
+    int enc_index=0;
+
+    p = (XIMEncodings *) &address->encoding_list;
+    for (i = 0;  i < (int) p->count_encodings;  i++)
+    {
+        for (j = 0;  j < (int) enc_nego->encoding_number;  j++)
+        {
+            if (strcmp (p->supported_encodings[i],
+                        enc_nego->encoding[j].name) == 0)
+            {
+                enc_index = j;
+                break;
+            }
+            /*endif*/
+        }
+        /*endfor*/
+    }
+    /*endfor*/
+
+    return (INT16) enc_index;
+#if 0
+    return (INT16) XIM_Default_Encoding_IDX;
+#endif
+}
+
+static void EncodingNegotiatonMessageProc (XIMS ims,
+                                           IMProtocol *call_data,
+                                           unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    FmStatus status;
+    CARD16 byte_length;
+    extern XimFrameRec encoding_negotiation_fr[];
+    extern XimFrameRec encoding_negotiation_reply_fr[];
+    register int i, total_size;
+    unsigned char *reply = NULL;
+    IMEncodingNegotiationStruct *enc_nego =
+        (IMEncodingNegotiationStruct *) &call_data->encodingnego;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+
+    fm = FrameMgrInit (encoding_negotiation_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    FrameMgrGetToken (fm, input_method_ID);
+
+    /* get ENCODING STR field */
+    FrameMgrGetToken (fm, byte_length);
+    if (byte_length > 0)
+    {
+        enc_nego->encoding = (XIMStr *) malloc (sizeof (XIMStr)*10);
+        memset (enc_nego->encoding, 0, sizeof (XIMStr)*10);
+        i = 0;
+        while (FrameMgrIsIterLoopEnd (fm, &status) == False)
+        {
+            char *name;
+            int str_length;
+
+            FrameMgrGetToken (fm, str_length);
+            FrameMgrSetSize (fm, str_length);
+            enc_nego->encoding[i].length = str_length;
+            FrameMgrGetToken (fm, name);
+            enc_nego->encoding[i].name = malloc (str_length + 1);
+            strncpy (enc_nego->encoding[i].name, name, str_length);
+            enc_nego->encoding[i].name[str_length] = '\0';
+            i++;
+        }
+        /*endwhile*/
+        enc_nego->encoding_number = i;
+    }
+    /*endif*/
+    /* get ENCODING INFO field */
+    FrameMgrGetToken (fm, byte_length);
+    if (byte_length > 0)
+    {
+        enc_nego->encodinginfo = (XIMStr *) malloc (sizeof (XIMStr)*10);
+        memset (enc_nego->encoding, 0, sizeof (XIMStr)*10);
+        i = 0;
+        while (FrameMgrIsIterLoopEnd (fm, &status) == False)
+        {
+            char *name;
+            int str_length;
+
+            FrameMgrGetToken (fm, str_length);
+            FrameMgrSetSize (fm, str_length);
+            enc_nego->encodinginfo[i].length = str_length;
+            FrameMgrGetToken (fm, name);
+            enc_nego->encodinginfo[i].name = malloc (str_length + 1);
+            strncpy (enc_nego->encodinginfo[i].name, name, str_length);
+            enc_nego->encodinginfo[i].name[str_length] = '\0';
+            i++;
+        }
+        /*endwhile*/
+        enc_nego->encoding_info_number = i;
+    }
+    /*endif*/
+
+    enc_nego->enc_index = ChooseEncoding (i18n_core, enc_nego);
+    enc_nego->category = 0;
+
+#ifdef PROTOCOL_RICH
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto(ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+#endif  /* PROTOCOL_RICH */
+
+    FrameMgrFree (fm);
+
+    fm = FrameMgrInit (encoding_negotiation_reply_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return;
+    }
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, input_method_ID);
+    FrameMgrPutToken (fm, enc_nego->category);
+    FrameMgrPutToken (fm, enc_nego->enc_index);
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_ENCODING_NEGOTIATION_REPLY,
+                       0,
+                       reply,
+                       total_size);
+    XFree (reply);
+
+    /* free data for encoding list */
+    if (enc_nego->encoding)
+    {
+        for (i = 0;  i < (int) enc_nego->encoding_number;  i++)
+            XFree (enc_nego->encoding[i].name);
+        /*endfor*/
+        XFree (enc_nego->encoding);
+    }
+    /*endif*/
+    if (enc_nego->encodinginfo)
+    {
+        for (i = 0;  i < (int) enc_nego->encoding_info_number;  i++)
+            XFree (enc_nego->encodinginfo[i].name);
+        /*endfor*/
+        XFree (enc_nego->encodinginfo);
+    }
+    /*endif*/
+    FrameMgrFree (fm);
+}
+
+void PreeditStartReplyMessageProc (XIMS ims,
+                                   IMProtocol *call_data,
+                                   unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec preedit_start_reply_fr[];
+    IMPreeditCBStruct *preedit_CB =
+        (IMPreeditCBStruct *) &call_data->preedit_callback;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+
+    fm = FrameMgrInit (preedit_start_reply_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+    /* get data */
+    FrameMgrGetToken (fm, input_method_ID);
+    FrameMgrGetToken (fm, preedit_CB->icid);
+    FrameMgrGetToken (fm, preedit_CB->todo.return_value);
+
+    FrameMgrFree (fm);
+
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto (ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+}
+
+void PreeditCaretReplyMessageProc (XIMS ims,
+                                   IMProtocol *call_data,
+                                   unsigned char *p)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec preedit_caret_reply_fr[];
+    IMPreeditCBStruct *preedit_CB =
+        (IMPreeditCBStruct *) &call_data->preedit_callback;
+    XIMPreeditCaretCallbackStruct *caret =
+        (XIMPreeditCaretCallbackStruct *) & preedit_CB->todo.caret;
+    CARD16 connect_id = call_data->any.connect_id;
+    CARD16 input_method_ID;
+
+    fm = FrameMgrInit (preedit_caret_reply_fr,
+                       (char *) p,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+    /* get data */
+    FrameMgrGetToken (fm, input_method_ID);
+    FrameMgrGetToken (fm, preedit_CB->icid);
+    FrameMgrGetToken (fm, caret->position);
+
+    FrameMgrFree (fm);
+
+    if (i18n_core->address.improto)
+    {
+        if (!(i18n_core->address.improto(ims, call_data)))
+            return;
+        /*endif*/
+    }
+    /*endif*/
+}
+
+void StrConvReplyMessageProc (XIMS ims,
+                              IMProtocol *call_data,
+                              unsigned char *p)
+{
+    return;
+}
+
+static void AddQueue (Xi18nClient *client, unsigned char *p)
+{
+    XIMPending *new;
+    XIMPending *last;
+
+    if ((new = (XIMPending *) malloc (sizeof (XIMPending))) == NULL)
+        return;
+    /*endif*/
+    new->p = p;
+    new->next = (XIMPending *) NULL;
+    if (!client->pending)
+    {
+        client->pending = new;
+    }
+    else
+    {
+        for (last = client->pending;  last->next;  last = last->next)
+            ;
+        /*endfor*/
+        last->next = new;
+    }
+    /*endif*/
+    return;
+}
+
+static void ProcessQueue (XIMS ims, CARD16 connect_id)
+{
+    Xi18n i18n_core = ims->protocol;
+    Xi18nClient *client = (Xi18nClient *) _Xi18nFindClient (i18n_core,
+                                                            connect_id);
+
+    while (client->sync == False  &&  client->pending)
+    {
+        XimProtoHdr *hdr = (XimProtoHdr *) client->pending->p;
+        unsigned char *p1 = (unsigned char *) (hdr + 1);
+        IMProtocol call_data;
+
+        call_data.major_code = hdr->major_opcode;
+        call_data.any.minor_code = hdr->minor_opcode;
+        call_data.any.connect_id = connect_id;
+
+        switch (hdr->major_opcode)
+        {
+        case XIM_FORWARD_EVENT:
+            ForwardEventMessageProc(ims, &call_data, p1);
+            break;
+        }
+        /*endswitch*/
+        XFree (hdr);
+        {
+            XIMPending *old = client->pending;
+
+            client->pending = old->next;
+            XFree (old);
+        }
+    }
+    /*endwhile*/
+    return;
+}
+
+
+void _Xi18nMessageHandler (XIMS ims,
+                           CARD16 connect_id,
+                           unsigned char *p,
+                           Bool *delete)
+{
+    XimProtoHdr	*hdr = (XimProtoHdr *)p;
+    unsigned char *p1 = (unsigned char *)(hdr + 1);
+    IMProtocol call_data;
+    Xi18n i18n_core = ims->protocol;
+    Xi18nClient *client;
+
+    client = (Xi18nClient *) _Xi18nFindClient (i18n_core, connect_id);
+    if (hdr == (XimProtoHdr *) NULL)
+        return;
+    /*endif*/
+
+    memset (&call_data, 0, sizeof(IMProtocol));
+
+    call_data.major_code = hdr->major_opcode;
+    call_data.any.minor_code = hdr->minor_opcode;
+    call_data.any.connect_id = connect_id;
+
+    switch (call_data.major_code)
+    {
+    case XIM_CONNECT:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_CONNECT\n");
+#endif
+        ConnectMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_DISCONNECT:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_DISCONNECT\n");
+#endif
+        DisConnectMessageProc (ims, &call_data);
+        break;
+
+    case XIM_OPEN:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_OPEN\n");
+#endif
+        OpenMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_CLOSE:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_CLOSE\n");
+#endif
+        CloseMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_QUERY_EXTENSION:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_QUERY_EXTENSION\n");
+#endif
+        QueryExtensionMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_GET_IM_VALUES:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_GET_IM_VALUES\n");
+#endif
+        GetIMValuesMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_CREATE_IC:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_CREATE_IC\n");
+#endif
+        CreateICMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_SET_IC_VALUES:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_SET_IC_VALUES\n");
+#endif
+        SetICValuesMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_GET_IC_VALUES:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_GET_IC_VALUES\n");
+#endif
+        GetICValuesMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_SET_IC_FOCUS:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_SET_IC_FOCUS\n");
+#endif
+        SetICFocusMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_UNSET_IC_FOCUS:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_UNSET_IC_FOCUS\n");
+#endif
+        UnsetICFocusMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_DESTROY_IC:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_DESTROY_IC\n");
+#endif
+        DestroyICMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_RESET_IC:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_RESET_IC\n");
+#endif
+        ResetICMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_FORWARD_EVENT:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_FORWARD_EVENT\n");
+#endif
+        if (client->sync == True)
+        {
+            AddQueue (client, p);
+            *delete = False;
+        }
+        else
+        {
+            ForwardEventMessageProc (ims, &call_data, p1);
+        }
+        break;
+
+    case XIM_EXTENSION:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_EXTENSION\n");
+#endif
+        ExtensionMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_SYNC:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_SYNC\n");
+#endif
+        break;
+
+    case XIM_SYNC_REPLY:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_SYNC_REPLY\n");
+#endif
+        SyncReplyMessageProc (ims, &call_data, p1);
+        ProcessQueue (ims, connect_id);
+        break;
+
+    case XIM_TRIGGER_NOTIFY:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_TRIGGER_NOTIFY\n");
+#endif
+        TriggerNotifyMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_ENCODING_NEGOTIATION:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_ENCODING_NEGOTIATION\n");
+#endif
+        EncodingNegotiatonMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_PREEDIT_START_REPLY:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_PREEDIT_START_REPLY\n");
+#endif
+        PreeditStartReplyMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_PREEDIT_CARET_REPLY:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_PREEDIT_CARET_REPLY\n");
+#endif
+        PreeditCaretReplyMessageProc (ims, &call_data, p1);
+        break;
+
+    case XIM_STR_CONVERSION_REPLY:
+#ifdef XIM_DEBUG
+	DebugLog("-- XIM_STR_CONVERSION_REPLY\n");
+#endif
+        StrConvReplyMessageProc (ims, &call_data, p1);
+        break;
+    }
+    /*endswitch*/
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nUtil.c b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nUtil.c
new file mode 100644
index 0000000..ff8970e
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nUtil.c
@@ -0,0 +1,276 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#include <X11/Xlib.h>
+#include "../include/IMdkit.h"
+#include "../include/Xi18n.h"
+#include "FrameMgr.h"
+#include "XimFunc.h"
+
+Xi18nClient *_Xi18nFindClient (Xi18n, CARD16);
+
+int
+_Xi18nNeedSwap (Xi18n i18n_core, CARD16 connect_id)
+{
+    CARD8 im_byteOrder = i18n_core->address.im_byteOrder;
+    Xi18nClient *client = _Xi18nFindClient (i18n_core, connect_id);
+
+    return (client->byte_order != im_byteOrder);
+}
+
+Xi18nClient *_Xi18nNewClient(Xi18n i18n_core)
+{
+    static CARD16 connect_id = 0;
+    int new_connect_id;
+    Xi18nClient *client;
+
+    if (i18n_core->address.free_clients)
+    {
+        client = i18n_core->address.free_clients;
+        i18n_core->address.free_clients = client->next;
+	new_connect_id = client->connect_id;
+    }
+    else
+    {
+        client = (Xi18nClient *) malloc (sizeof (Xi18nClient));
+	new_connect_id = ++connect_id;
+    }
+    /*endif*/
+    memset (client, 0, sizeof (Xi18nClient));
+    client->connect_id = new_connect_id;
+    client->pending = (XIMPending *) NULL;
+    client->sync = False;
+    client->byte_order = '?'; 	/* initial value */
+    memset (&client->pending, 0, sizeof (XIMPending *));
+    client->next = i18n_core->address.clients;
+    i18n_core->address.clients = client;
+
+    return (Xi18nClient *) client;
+}
+
+Xi18nClient *_Xi18nFindClient (Xi18n i18n_core, CARD16 connect_id)
+{
+    Xi18nClient *client = i18n_core->address.clients;
+
+    while (client)
+    {
+        if (client->connect_id == connect_id)
+            return client;
+        /*endif*/
+        client = client->next;
+    }
+    /*endwhile*/
+    return NULL;
+}
+
+void _Xi18nDeleteClient (Xi18n i18n_core, CARD16 connect_id)
+{
+    Xi18nClient *target = _Xi18nFindClient (i18n_core, connect_id);
+    Xi18nClient *ccp;
+    Xi18nClient *ccp0;
+
+    for (ccp = i18n_core->address.clients, ccp0 = NULL;
+         ccp != NULL;
+         ccp0 = ccp, ccp = ccp->next)
+    {
+        if (ccp == target)
+        {
+            if (ccp0 == NULL)
+                i18n_core->address.clients = ccp->next;
+            else
+                ccp0->next = ccp->next;
+            /*endif*/
+            /* put it back to free list */
+            target->next = i18n_core->address.free_clients;
+            i18n_core->address.free_clients = target;
+            return;
+        }
+        /*endif*/
+    }
+    /*endfor*/
+}
+
+void _Xi18nSendMessage (XIMS ims,
+                        CARD16 connect_id,
+                        CARD8 major_opcode,
+                        CARD8 minor_opcode,
+                        unsigned char *data,
+                        long length)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec packet_header_fr[];
+    unsigned char *reply_hdr = NULL;
+    int header_size;
+    unsigned char *reply = NULL;
+    unsigned char *replyp;
+    int reply_length;
+    long p_len = length/4;
+
+    fm = FrameMgrInit (packet_header_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    header_size = FrameMgrGetTotalSize (fm);
+    reply_hdr = (unsigned char *) malloc (header_size);
+    if (reply_hdr == NULL)
+    {
+        _Xi18nSendMessage (ims, connect_id, XIM_ERROR, 0, 0, 0);
+        return;
+    }
+    /*endif*/
+    FrameMgrSetBuffer (fm, reply_hdr);
+
+    /* put data */
+    FrameMgrPutToken (fm, major_opcode);
+    FrameMgrPutToken (fm, minor_opcode);
+    FrameMgrPutToken (fm, p_len);
+
+    reply_length = header_size + length;
+    reply = (unsigned char *) malloc (reply_length);
+    replyp = reply;
+    memmove (reply, reply_hdr, header_size);
+    replyp += header_size;
+    memmove (replyp, data, length);
+
+    i18n_core->methods.send (ims, connect_id, reply, reply_length);
+
+    XFree (reply);
+    XFree (reply_hdr);
+    FrameMgrFree (fm);
+}
+
+void _Xi18nSendTriggerKey (XIMS ims, CARD16 connect_id)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec register_triggerkeys_fr[];
+    XIMTriggerKey *on_keys = i18n_core->address.on_keys.keylist;
+    XIMTriggerKey *off_keys = i18n_core->address.off_keys.keylist;
+    int on_key_num = i18n_core->address.on_keys.count_keys;
+    int off_key_num = i18n_core->address.off_keys.count_keys;
+    unsigned char *reply = NULL;
+    register int i, total_size;
+    CARD16 im_id;
+
+    if (on_key_num == 0  &&  off_key_num == 0)
+        return;
+    /*endif*/
+
+    fm = FrameMgrInit (register_triggerkeys_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    /* set iteration count for on-keys list */
+    FrameMgrSetIterCount (fm, on_key_num);
+    /* set iteration count for off-keys list */
+    FrameMgrSetIterCount (fm, off_key_num);
+
+    /* get total_size */
+    total_size = FrameMgrGetTotalSize (fm);
+
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+        return;
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    /* Right now XIM_OPEN_REPLY hasn't been sent to this new client, so
+       the input-method-id is still invalid, and should be set to zero...
+       Reter to $(XC)/lib/X11/imDefLkup.c:_XimRegisterTriggerKeysCallback
+     */
+    im_id = 0;
+    FrameMgrPutToken (fm, im_id);  /* input-method-id */
+    for (i = 0;  i < on_key_num;  i++)
+    {
+        FrameMgrPutToken (fm, on_keys[i].keysym);
+        FrameMgrPutToken (fm, on_keys[i].modifier);
+        FrameMgrPutToken (fm, on_keys[i].modifier_mask);
+    }
+    /*endfor*/
+    for (i = 0;  i < off_key_num;  i++)
+    {
+        FrameMgrPutToken (fm, off_keys[i].keysym);
+        FrameMgrPutToken (fm, off_keys[i].modifier);
+        FrameMgrPutToken (fm, off_keys[i].modifier_mask);
+    }
+    /*endfor*/
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_REGISTER_TRIGGERKEYS,
+                       0,
+                       reply,
+                       total_size);
+    FrameMgrFree (fm);
+    XFree(reply);
+}
+
+void _Xi18nSetEventMask (XIMS ims,
+                         CARD16 connect_id,
+                         CARD16 im_id,
+                         CARD16 ic_id,
+                         CARD32 forward_mask,
+                         CARD32 sync_mask)
+{
+    Xi18n i18n_core = ims->protocol;
+    FrameMgr fm;
+    extern XimFrameRec set_event_mask_fr[];
+    unsigned char *reply = NULL;
+    register int total_size;
+
+    fm = FrameMgrInit (set_event_mask_fr,
+                       NULL,
+                       _Xi18nNeedSwap (i18n_core, connect_id));
+
+    total_size = FrameMgrGetTotalSize (fm);
+    reply = (unsigned char *) malloc (total_size);
+    if (!reply)
+        return;
+    /*endif*/
+    memset (reply, 0, total_size);
+    FrameMgrSetBuffer (fm, reply);
+
+    FrameMgrPutToken (fm, im_id); 	/* input-method-id */
+    FrameMgrPutToken (fm, ic_id); 	/* input-context-id */
+    FrameMgrPutToken (fm, forward_mask);
+    FrameMgrPutToken (fm, sync_mask);
+
+    _Xi18nSendMessage (ims,
+                       connect_id,
+                       XIM_SET_EVENT_MASK,
+                       0,
+                       reply,
+                       total_size);
+
+    FrameMgrFree (fm);
+    XFree(reply);
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nX.c b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nX.c
new file mode 100644
index 0000000..87df6b4
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/IMdkit/lib/i18nX.c
@@ -0,0 +1,497 @@
+/******************************************************************
+
+         Copyright 1994, 1995 by Sun Microsystems, Inc.
+         Copyright 1993, 1994 by Hewlett-Packard Company
+
+Permission to use, copy, modify, distribute, and sell this software
+and its documentation for any purpose is hereby granted without fee,
+provided that the above copyright notice appear in all copies and
+that both that copyright notice and this permission notice appear
+in supporting documentation, and that the name of Sun Microsystems, Inc.
+and Hewlett-Packard not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+Sun Microsystems, Inc. and Hewlett-Packard make no representations about
+the suitability of this software for any purpose.  It is provided "as is"
+without express or implied warranty.
+
+SUN MICROSYSTEMS INC. AND HEWLETT-PACKARD COMPANY DISCLAIMS ALL
+WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+SUN MICROSYSTEMS, INC. AND HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
+RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
+CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
+IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+  Author: Hidetoshi Tajima(tajima@Eng.Sun.COM) Sun Microsystems, Inc.
+
+    This version tidied and debugged by Steve Underwood May 1999
+
+******************************************************************/
+
+#include <X11/Xlib.h>
+#include <X11/Xatom.h>
+#include "FrameMgr.h"
+#include "../include/IMdkit.h"
+#include "../include/Xi18n.h"
+#include "Xi18nX.h"
+#include "XimFunc.h"
+
+extern Xi18nClient *_Xi18nFindClient(Xi18n, CARD16);
+extern Xi18nClient *_Xi18nNewClient(Xi18n);
+extern void _Xi18nDeleteClient(Xi18n, CARD16);
+static Bool WaitXConnectMessage(Display*, Window,
+                                XEvent*, XPointer);
+static Bool WaitXIMProtocol(Display*, Window, XEvent*, XPointer);
+
+static XClient *NewXClient (Xi18n i18n_core, Window new_client)
+{
+    Display *dpy = i18n_core->address.dpy;
+    Xi18nClient *client = _Xi18nNewClient (i18n_core);
+    XClient *x_client;
+
+    x_client = (XClient *) malloc (sizeof (XClient));
+    x_client->client_win = new_client;
+    x_client->accept_win = XCreateSimpleWindow (dpy,
+                                                DefaultRootWindow(dpy),
+                                                0,
+                                                0,
+                                                1,
+                                                1,
+                                                1,
+                                                0,
+                                                0);
+    client->trans_rec = x_client;
+    return ((XClient *) x_client);
+}
+
+static unsigned char *ReadXIMMessage (XIMS ims,
+                                      XClientMessageEvent *ev,
+                                      int *connect_id)
+{
+    Xi18n i18n_core = ims->protocol;
+    Xi18nClient *client = i18n_core->address.clients;
+    XClient *x_client = NULL;
+    FrameMgr fm;
+    extern XimFrameRec packet_header_fr[];
+    unsigned char *p = NULL;
+    unsigned char *p1;
+
+    while (client != NULL) {
+        x_client = (XClient *) client->trans_rec;
+        if (x_client->accept_win == ev->window) {
+            *connect_id = client->connect_id;
+            break;
+        }
+        client = client->next;
+    }
+
+    if (ev->format == 8) {
+        /* ClientMessage only */
+        XimProtoHdr *hdr = (XimProtoHdr *) ev->data.b;
+        unsigned char *rec = (unsigned char *) (hdr + 1);
+        register int total_size;
+        CARD8 major_opcode;
+        CARD8 minor_opcode;
+        CARD16 length;
+        extern int _Xi18nNeedSwap (Xi18n, CARD16);
+
+        if (client->byte_order == '?')
+        {
+            if (hdr->major_opcode != XIM_CONNECT)
+                return (unsigned char *) NULL; 	/* can do nothing */
+            client->byte_order = (CARD8) rec[0];
+        }
+
+        fm = FrameMgrInit (packet_header_fr,
+                           (char *) hdr,
+                           _Xi18nNeedSwap (i18n_core, *connect_id));
+        total_size = FrameMgrGetTotalSize (fm);
+        /* get data */
+        FrameMgrGetToken (fm, major_opcode);
+        FrameMgrGetToken (fm, minor_opcode);
+        FrameMgrGetToken (fm, length);
+        FrameMgrFree (fm);
+
+        if ((p = (unsigned char *) malloc (total_size + length * 4)) == NULL)
+            return (unsigned char *) NULL;
+
+        p1 = p;
+        memmove (p1, &major_opcode, sizeof (CARD8));
+        p1 += sizeof (CARD8);
+        memmove (p1, &minor_opcode, sizeof (CARD8));
+        p1 += sizeof (CARD8);
+        memmove (p1, &length, sizeof (CARD16));
+        p1 += sizeof (CARD16);
+        memmove (p1, rec, length * 4);
+    }
+    else if (ev->format == 32) {
+        /* ClientMessage and WindowProperty */
+        unsigned long length = (unsigned long) ev->data.l[0];
+        Atom atom = (Atom) ev->data.l[1];
+        int	return_code;
+        Atom	actual_type_ret;
+        int	actual_format_ret;
+        unsigned long bytes_after_ret;
+        unsigned char *prop;
+        unsigned long nitems;
+
+        return_code = XGetWindowProperty (i18n_core->address.dpy,
+                                          x_client->accept_win,
+                                          atom,
+                                          0L,
+                                          length,
+                                          True,
+                                          AnyPropertyType,
+                                          &actual_type_ret,
+                                          &actual_format_ret,
+                                          &nitems,
+                                          &bytes_after_ret,
+                                          &prop);
+        if (return_code != Success || actual_format_ret == 0 || nitems == 0) {
+            if (return_code == Success)
+                XFree (prop);
+            return (unsigned char *) NULL;
+        }
+        if (length != nitems)
+            length = nitems;
+	if (actual_format_ret == 16)
+	    length *= 2;
+	else if (actual_format_ret == 32)
+	    length *= 4;
+
+        /* if hit, it might be an error */
+        if ((p = (unsigned char *) malloc (length)) == NULL)
+            return (unsigned char *) NULL;
+
+        memmove (p, prop, length);
+        XFree (prop);
+    }
+    return (unsigned char *) p;
+}
+
+static void ReadXConnectMessage (XIMS ims, XClientMessageEvent *ev)
+{
+    Xi18n i18n_core = ims->protocol;
+    XSpecRec *spec = (XSpecRec *) i18n_core->address.connect_addr;
+    XEvent event;
+    Display *dpy = i18n_core->address.dpy;
+    Window new_client = ev->data.l[0];
+    CARD32 major_version = ev->data.l[1];
+    CARD32 minor_version = ev->data.l[2];
+    XClient *x_client = NewXClient (i18n_core, new_client);
+
+    if (ev->window != i18n_core->address.im_window)
+        return; 			/* incorrect connection request */
+    /*endif*/
+    if (major_version != 0  ||  minor_version != 0)
+    {
+        major_version =
+        minor_version = 0;
+        /* Only supporting only-CM & Property-with-CM method */
+    }
+    /*endif*/
+    _XRegisterFilterByType (dpy,
+                            x_client->accept_win,
+                            ClientMessage,
+                            ClientMessage,
+                            WaitXIMProtocol,
+                            (XPointer)ims);
+    event.xclient.type = ClientMessage;
+    event.xclient.display = dpy;
+    event.xclient.window = new_client;
+    event.xclient.message_type = spec->connect_request;
+    event.xclient.format = 32;
+    event.xclient.data.l[0] = x_client->accept_win;
+    event.xclient.data.l[1] = major_version;
+    event.xclient.data.l[2] = minor_version;
+    event.xclient.data.l[3] = XCM_DATA_LIMIT;
+
+    XSendEvent (dpy,
+                new_client,
+                False,
+                NoEventMask,
+                &event);
+    XFlush (dpy);
+}
+
+static Bool Xi18nXBegin (XIMS ims)
+{
+    Xi18n i18n_core = ims->protocol;
+    Display *dpy = i18n_core->address.dpy;
+    XSpecRec *spec = (XSpecRec *) i18n_core->address.connect_addr;
+
+    spec->xim_request = XInternAtom (i18n_core->address.dpy,
+                                     _XIM_PROTOCOL,
+                                     False);
+    spec->connect_request = XInternAtom (i18n_core->address.dpy,
+                                         _XIM_XCONNECT,
+                                         False);
+
+    _XRegisterFilterByType (dpy,
+                            i18n_core->address.im_window,
+                            ClientMessage,
+                            ClientMessage,
+                            WaitXConnectMessage,
+                            (XPointer)ims);
+    return True;
+}
+
+static Bool Xi18nXEnd(XIMS ims)
+{
+    Xi18n i18n_core = ims->protocol;
+    Display *dpy = i18n_core->address.dpy;
+
+    _XUnregisterFilter (dpy,
+                        i18n_core->address.im_window,
+                        WaitXConnectMessage,
+                        (XPointer)ims);
+    return True;
+}
+
+static char *MakeNewAtom (CARD16 connect_id, char *atomName)
+{
+    static int sequence = 0;
+
+    sprintf (atomName,
+             "_server%d_%d",
+             connect_id,
+             ((sequence > 20)  ?  (sequence = 0)  :  sequence++));
+    return atomName;
+}
+
+static Bool Xi18nXSend (XIMS ims,
+                        CARD16 connect_id,
+                        unsigned char *reply,
+                        long length)
+{
+    Xi18n i18n_core = ims->protocol;
+    Xi18nClient *client = _Xi18nFindClient (i18n_core, connect_id);
+    XSpecRec *spec = (XSpecRec *) i18n_core->address.connect_addr;
+    XClient *x_client = (XClient *) client->trans_rec;
+    XEvent event;
+
+    event.type = ClientMessage;
+    event.xclient.window = x_client->client_win;
+    event.xclient.message_type = spec->xim_request;
+
+    if (length > XCM_DATA_LIMIT)
+    {
+        Atom atom;
+        char atomName[16];
+        Atom actual_type_ret;
+        int actual_format_ret;
+        int return_code;
+        unsigned long nitems_ret;
+        unsigned long bytes_after_ret;
+        unsigned char *win_data;
+
+        event.xclient.format = 32;
+        atom = XInternAtom (i18n_core->address.dpy,
+                            MakeNewAtom (connect_id, atomName),
+                            False);
+        return_code = XGetWindowProperty (i18n_core->address.dpy,
+                                          x_client->client_win,
+                                          atom,
+                                          0L,
+                                          10000L,
+                                          False,
+                                          XA_STRING,
+                                          &actual_type_ret,
+                                          &actual_format_ret,
+                                          &nitems_ret,
+                                          &bytes_after_ret,
+                                          &win_data);
+        if (return_code != Success)
+            return False;
+        /*endif*/
+        if (win_data)
+            XFree ((char *) win_data);
+        /*endif*/
+        XChangeProperty (i18n_core->address.dpy,
+                         x_client->client_win,
+                         atom,
+                         XA_STRING,
+                         8,
+                         PropModeAppend,
+                         (unsigned char *) reply,
+                         length);
+        event.xclient.data.l[0] = length;
+        event.xclient.data.l[1] = atom;
+    }
+    else
+    {
+        unsigned char buffer[XCM_DATA_LIMIT];
+        int i;
+
+        event.xclient.format = 8;
+
+        /* Clear unused field with NULL */
+        memmove(buffer, reply, length);
+        for (i = length; i < XCM_DATA_LIMIT; i++)
+            buffer[i] = (char) 0;
+        /*endfor*/
+        length = XCM_DATA_LIMIT;
+        memmove (event.xclient.data.b, buffer, length);
+    }
+    XSendEvent (i18n_core->address.dpy,
+                x_client->client_win,
+                False,
+                NoEventMask,
+                &event);
+    XFlush (i18n_core->address.dpy);
+    return True;
+}
+
+static Bool CheckCMEvent (Display *display, XEvent *event, XPointer xi18n_core)
+{
+    Xi18n i18n_core = (Xi18n) ((void *) xi18n_core);
+    XSpecRec *spec = (XSpecRec *) i18n_core->address.connect_addr;
+
+    if ((event->type == ClientMessage)
+        &&
+        (event->xclient.message_type == spec->xim_request))
+    {
+        return  True;
+    }
+    /*endif*/
+    return  False;
+}
+
+static Bool Xi18nXWait (XIMS ims,
+                        CARD16 connect_id,
+                        CARD8 major_opcode,
+                        CARD8 minor_opcode)
+{
+    Xi18n i18n_core = ims->protocol;
+    XEvent event;
+    Xi18nClient *client = _Xi18nFindClient (i18n_core, connect_id);
+    XClient *x_client = (XClient *) client->trans_rec;
+
+    for (;;)
+    {
+        unsigned char *packet;
+        XimProtoHdr *hdr;
+        int connect_id_ret;
+
+        XIfEvent (i18n_core->address.dpy,
+                  &event,
+                  CheckCMEvent,
+                  (XPointer) i18n_core);
+        if (event.xclient.window == x_client->accept_win)
+        {
+            if ((packet = ReadXIMMessage (ims,
+                                          (XClientMessageEvent *) & event,
+                                          &connect_id_ret))
+                == (unsigned char*) NULL)
+            {
+                return False;
+            }
+            /*endif*/
+            hdr = (XimProtoHdr *)packet;
+
+            if ((hdr->major_opcode == major_opcode)
+                &&
+                (hdr->minor_opcode == minor_opcode))
+            {
+                return True;
+            }
+            else if (hdr->major_opcode == XIM_ERROR)
+            {
+                return False;
+            }
+            /*endif*/
+        }
+        /*endif*/
+    }
+    /*endfor*/
+}
+
+static Bool Xi18nXDisconnect (XIMS ims, CARD16 connect_id)
+{
+    Xi18n i18n_core = ims->protocol;
+    Display *dpy = i18n_core->address.dpy;
+    Xi18nClient *client = _Xi18nFindClient (i18n_core, connect_id);
+    XClient *x_client = (XClient *) client->trans_rec;
+
+    XDestroyWindow (dpy, x_client->accept_win);
+    _XUnregisterFilter (dpy,
+		        x_client->accept_win,
+                        WaitXIMProtocol,
+		        (XPointer)ims);
+    XFree (x_client);
+    _Xi18nDeleteClient (i18n_core, connect_id);
+    return True;
+}
+
+Bool _Xi18nCheckXAddress (Xi18n i18n_core,
+                          TransportSW *transSW,
+                          char *address)
+{
+    XSpecRec *spec;
+
+    if (!(spec = (XSpecRec *) malloc (sizeof (XSpecRec))))
+        return False;
+    /*endif*/
+
+    i18n_core->address.connect_addr = (XSpecRec *) spec;
+    i18n_core->methods.begin = Xi18nXBegin;
+    i18n_core->methods.end = Xi18nXEnd;
+    i18n_core->methods.send = Xi18nXSend;
+    i18n_core->methods.wait = Xi18nXWait;
+    i18n_core->methods.disconnect = Xi18nXDisconnect;
+    return True;
+}
+
+static Bool WaitXConnectMessage (Display *dpy,
+                                 Window win,
+                                 XEvent *ev,
+                                 XPointer client_data)
+{
+    XIMS ims = (XIMS)client_data;
+    Xi18n i18n_core = ims->protocol;
+    XSpecRec *spec = (XSpecRec *) i18n_core->address.connect_addr;
+
+    if (((XClientMessageEvent *) ev)->message_type
+        == spec->connect_request)
+    {
+        ReadXConnectMessage (ims, (XClientMessageEvent *) ev);
+        return True;
+    }
+    /*endif*/
+    return False;
+}
+
+static Bool WaitXIMProtocol (Display *dpy,
+                             Window win,
+                             XEvent *ev,
+                             XPointer client_data)
+{
+    extern void _Xi18nMessageHandler (XIMS, CARD16, unsigned char *, Bool *);
+    XIMS ims = (XIMS) client_data;
+    Xi18n i18n_core = ims->protocol;
+    XSpecRec *spec = (XSpecRec *) i18n_core->address.connect_addr;
+    Bool delete = True;
+    unsigned char *packet;
+    int connect_id;
+
+    if (((XClientMessageEvent *) ev)->message_type
+        == spec->xim_request)
+    {
+        if ((packet = ReadXIMMessage (ims,
+                                      (XClientMessageEvent *) ev,
+                                      &connect_id))
+            == (unsigned char *)  NULL)
+        {
+            return False;
+        }
+        /*endif*/
+        _Xi18nMessageHandler (ims, connect_id, packet, &delete);
+        if (delete == True)
+            XFree (packet);
+        /*endif*/
+        return True;
+    }
+    /*endif*/
+    return False;
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/config.h b/src/plugins/platforminputcontexts/hime/include/config.h
new file mode 100644
index 0000000..2e9289e
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/config.h
@@ -0,0 +1 @@
+#define GETTEXT_PACKAGE "hime"
diff --git a/src/plugins/platforminputcontexts/hime/include/gst.h b/src/plugins/platforminputcontexts/hime/include/gst.h
new file mode 100644
index 0000000..3fecd34
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/gst.h
@@ -0,0 +1,63 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+typedef struct {
+  struct CHPHO *chpho;
+  int c_idx, c_len;
+  int ph_sta;  // phrase start
+  int sel_pho;
+//  int save_frm, save_to;
+  int current_page;
+  int startf;
+  gboolean full_match;
+  gboolean tsin_half_full;
+  gboolean tsin_buffer_editing;
+  gboolean ctrl_pre_sel;
+  struct PRE_SEL *pre_sel;
+  int pre_selN;
+  int last_cursor_idx;
+  int pho_menu_idx;
+//  int pho_sel_menu_idx;
+} TSIN_ST;
+extern TSIN_ST tss;
+
+typedef enum {
+  SAME_PHO_QUERY_none = 0,
+  SAME_PHO_QUERY_gtab_input = 1,
+  SAME_PHO_QUERY_pho_select = 2,
+} SAME_PHO_QUERY;
+
+typedef struct {
+  int ityp3_pho;
+  int cpg, maxi;
+  int start_idx, stop_idx;
+  char typ_pho[4];
+  char inph[8];
+  SAME_PHO_QUERY same_pho_query_state;
+} PHO_ST;
+extern PHO_ST poo;
+
+#define MAX_TAB_KEY_NUM64_6 (10)
+
+typedef struct {
+  int S1, E1, last_idx, wild_page, pg_idx, total_matchN, sel1st_i;
+  u_int64_t kval;
+  gboolean last_full, wild_mode, spc_pressed, invalid_spc, more_pg, gtab_buf_select;
+  short defselN, exa_match, ci, gbufN, gbuf_cursor;
+  KeySym inch[MAX_TAB_KEY_NUM64_6];
+} GTAB_ST;
+extern GTAB_ST ggg;
diff --git a/src/plugins/platforminputcontexts/hime/include/gtab-buf.c b/src/plugins/platforminputcontexts/hime/include/gtab-buf.c
new file mode 100644
index 0000000..462931e
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/gtab-buf.c
@@ -0,0 +1,1146 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "hime.h"
+#include "gtab.h"
+#include "hime-conf.h"
+#include "hime-endian.h"
+#include "pho.h"
+#include "tsin.h"
+#include "tsin-parse.h"
+#include "win-save-phrase.h"
+#include "gtab-buf.h"
+#include "gst.h"
+
+void disp_gbuf(), ClrIn(), clear_after_put();
+gboolean gtab_phrase_on();
+int page_len();
+void show_win_gtab();
+void disp_selection0(gboolean phrase_selected, gboolean force_disp);
+void disp_gtab_sel(char *s);
+void add_cache(int start, int usecount, TSIN_PARSE *out, short match_phr_N, short no_match_ch_N, int tc_len);
+int ch_pos_find(char *ch, int pos);
+void inc_gtab_usecount(char *str), ClrSelArea();
+void lookup_gtabn(char *ch, char *out);
+char *htmlspecialchars(char *s, char out[]);
+void hide_gtab_pre_sel();
+gboolean gtab_vertical_select_on();
+
+extern gboolean key_press_alt, key_press_ctrl;
+
+extern gboolean test_mode;
+
+GEDIT *gbuf;
+extern char **seltab;
+extern int ph_key_sz;
+
+void extract_gtab_key(int start, int len, void *out)
+{
+  int i;
+
+  char *p=(char *)out;
+  if (ph_key_sz==4) {
+    for(i=0; i < len; i++) {
+      u_int k = gbuf[i+start].keys[0];
+      memcpy(p, &k, sizeof(k));
+      p+=sizeof(k);
+    }
+  } else {
+    for(i=0; i < len; i++) {
+      memcpy(p, &gbuf[i+start].keys[0], sizeof(u_int64_t));
+      p+=sizeof(u_int64_t);
+    }
+  }
+}
+
+void extract_gbuf_str(int start, int len, char *out)
+{
+  int i;
+  out[0]=0;
+  for(i=0;i<len;i++)
+    strcat(out, gbuf[i+start].ch);
+}
+
+
+gboolean gtab_cursor_end()
+{
+  return ggg.gbuf_cursor==ggg.gbufN;
+}
+
+void dump_gbuf()
+{
+  int i;
+
+  for(i=0; i<ggg.gbufN; i++) {
+    int j;
+    for(j=0;j < gbuf[i].selN; j++)
+      printf("%d:%s ", j, gbuf[i].sel[j]);
+    puts("");
+  }
+}
+
+static unich_t latin_chars[]=
+""
+""
+"";
+
+int en_word_len(char *bf)
+{
+  char *s;
+
+  for(s=bf;*s;) {
+    int sz = utf8_sz(s);
+    if (sz==1) {
+      if (!((*s >= 'A' && *s<='Z') || (*s >= 'a' && *s<='z') || strchr("-_'", *s)))
+        break;
+    } else
+    if (sz==2) {
+      char *p;
+      for (p=latin_chars; *p; p+=2)
+        if (!memcmp(p, s, 2))
+          break;
+      if (!(*p))
+        break;
+    } else
+    if (sz>=3)
+      break;
+    s+=sz;
+  }
+
+  if (*s)
+    return 0;
+  return strlen(bf);
+}
+
+static char *gen_buf_str(int start, gboolean add_spc)
+{
+  int i;
+  char *out = tmalloc(char, 1);
+  int outN=0;
+
+  gboolean last_en_word = FALSE;
+  for(i=start;i<ggg.gbufN;i++) {
+    char *t = gbuf[i].ch;
+    int len = strlen(t);
+
+    if (add_spc && en_word_len(t) && !(gbuf[i].flag & FLAG_CHPHO_GTAB_BUF_EN_NO_SPC)) {
+      if (last_en_word) {
+        out = trealloc(out, char, outN+1);
+        out[outN++]=' ';
+      }
+      last_en_word = TRUE;
+    } else
+      last_en_word = FALSE;
+
+    out = trealloc(out, char, outN+len+1);
+    memcpy(out + outN, t, len);
+    outN+=len;
+  }
+
+  out[outN] = 0;
+  return out;
+}
+
+extern gboolean last_cursor_off;
+
+static char *gen_buf_str_disp()
+{
+  if (!ggg.gbufN) {
+    return strdup("");
+  }
+
+  int i;
+  char *out = tmalloc(char, 1);
+  int outN=0;
+
+  out[0]=0;
+  gbuf[ggg.gbufN].ch = " ";
+
+  gboolean last_is_en_word = FALSE;
+
+  int N = last_cursor_off ? ggg.gbufN-1:ggg.gbufN;
+  for(i=0;i<=N;i++) {
+    char addspc[MAX_CIN_PHR * 2 + 2];
+    char spec[MAX_CIN_PHR * 2 + 2];
+    int len = en_word_len(gbuf[i].ch);
+//    dbg("i %d N:%d bufN:%d\n",i,N,ggg.gbufN);
+    if (gbuf[i].flag & FLAG_CHPHO_GTAB_BUF_EN_NO_SPC)
+      len = 0;
+//    dbg("%d %d is_en:%d\n",i, len, last_is_en_word);
+
+    if (len) {
+      if (last_is_en_word) {
+        strcpy(addspc, " ");
+        strcat(addspc, gbuf[i].ch);
+      } else
+        strcpy(addspc, gbuf[i].ch);
+      last_is_en_word = TRUE;
+    } else {
+      last_is_en_word = FALSE;
+      strcpy(addspc, gbuf[i].ch);
+    }
+
+    htmlspecialchars(addspc, spec);
+//    dbg("addspc '%s'  spec:%s out:%s\n", addspc, spec, out);
+
+    char www[MAX_CIN_PHR * 2 + 2];
+    char *t = spec;
+
+    if (i==ggg.gbuf_cursor) {
+      if (hime_win_color_use)
+        sprintf(www, "<span foreground=\"white\" background=\"%s\">%s</span>", tsin_cursor_color, spec);
+      else
+        sprintf(www, "<span foreground=\"white\" background=\""TSIN_CURSOR_COLOR_DEFAULT"\">%s</span>", spec);
+      t = www;
+    }
+
+    len = strlen(t);
+    out = trealloc(out, char, outN+len+1);
+    memcpy(out + outN, t, len);
+    outN+=len;
+    out[outN] = 0;
+  }
+
+  return out;
+}
+
+
+void disp_label_edit(char *str);
+
+static void free_pgbuf(GEDIT *p)
+{
+  int i;
+  for(i=0; i < p->selN; i++)
+    free(p->sel[i]);
+  free(p->sel);
+  p->ch = NULL;
+  p->sel=NULL;
+  p->flag = 0;
+}
+
+
+static void free_gbuf(int idx)
+{
+  free_pgbuf(&gbuf[idx]);
+}
+
+
+static void clear_gtab_buf_all()
+{
+  int i;
+  for(i=0;i<ggg.gbufN;i++)
+    free_gbuf(i);
+  ggg.gbuf_cursor = ggg.gbufN=0;
+  ggg.gtab_buf_select = 0;
+  disp_gbuf();
+}
+
+
+void disp_gbuf()
+{
+  char *bf=gen_buf_str_disp();
+  disp_label_edit(bf);
+
+  if (ggg.gbufN && gtab_disp_key_codes)
+    lookup_gtabn(gbuf[ggg.gbufN-1].ch, NULL);
+
+  free(bf);
+}
+
+void clear_gbuf_sel()
+{
+  ggg.gtab_buf_select = 0;
+  ggg.total_matchN = 0;
+  ClrSelArea();
+}
+
+int gbuf_cursor_left()
+{
+  hide_gtab_pre_sel();
+  if (!ggg.gbuf_cursor)
+    return ggg.gbufN;
+  if (ggg.gtab_buf_select)
+    clear_gbuf_sel();
+  ClrIn();
+  ggg.gbuf_cursor--;
+  disp_gbuf();
+  return 1;
+}
+
+
+int gbuf_cursor_right()
+{
+  hide_gtab_pre_sel();
+  if (ggg.gbuf_cursor==ggg.gbufN)
+    return ggg.gbufN;
+  if (ggg.gtab_buf_select)
+    clear_gbuf_sel();
+  ggg.gbuf_cursor++;
+  disp_gbuf();
+  return 1;
+}
+
+int gbuf_cursor_home()
+{
+  hide_gtab_pre_sel();
+  if (!ggg.gbufN)
+    return 0;
+  if (ggg.gtab_buf_select)
+    clear_gbuf_sel();
+
+  ggg.gbuf_cursor = 0;
+  disp_gbuf();
+  return 1;
+}
+
+
+int gbuf_cursor_end()
+{
+  hide_gtab_pre_sel();
+  if (!ggg.gbufN)
+    return 0;
+  if (ggg.gtab_buf_select)
+    clear_gbuf_sel();
+
+  ggg.gbuf_cursor = ggg.gbufN;
+  disp_gbuf();
+  return 1;
+}
+
+void inc_gtab_use_count(char *s);
+void inc_dec_tsin_use_count(void *pho, char *ch, int N);
+
+gboolean output_gbuf()
+{
+  hide_gtab_pre_sel();
+
+  if (!ggg.gbufN)
+    return FALSE;
+  char *bf=gen_buf_str(0, TRUE);
+#if 0
+  printf("out %s\n", bf);
+#endif
+
+#if 0
+  // single character
+  char *p;
+  for(p=bf; *p; p+=utf8_sz(p))
+    inc_gtab_use_count(p);
+#endif
+
+  send_text(bf);
+  free(bf);
+
+  int i;
+  for(i=0; i < ggg.gbufN;) {
+    char t[MAX_CIN_PHR+1];
+    t[0]=0;
+    inc_gtab_use_count(gbuf[i].ch);
+
+    int j;
+    for(j=i; j < i+gbuf[i].plen; j++)
+      strcat(t, gbuf[j].ch);
+
+    if (!gbuf[i].plen)
+      i++;
+    else {
+      u_int64_t kk[MAX_PHRASE_LEN];
+	  extract_gtab_key(i, gbuf[i].plen, kk);
+	  inc_dec_tsin_use_count(kk, t, gbuf[i].plen);
+      i+=gbuf[i].plen;
+    }
+  }
+
+
+  clear_gtab_buf_all();
+  ClrIn();
+  return TRUE;
+}
+
+
+gboolean check_gtab_fixed_mismatch(int idx, char *mtch, int plen)
+{
+  int j;
+  char *p = mtch;
+
+  for(j=0; j < plen; j++) {
+    int u8sz = utf8_sz(p);
+    if (!(gbuf[idx+j].flag & FLAG_CHPHO_FIXED))
+      continue;
+
+    if (memcmp(gbuf[idx+j].ch, p, u8sz))
+      break;
+
+    p+= u8sz;
+  }
+
+  if (j < plen)
+    return TRUE;
+
+  return FALSE;
+}
+
+void set_gtab_user_head()
+{
+  gbuf[ggg.gbuf_cursor].flag |= FLAG_CHPHO_PHRASE_USER_HEAD;
+}
+
+#define DBG 0
+
+void free_cache();
+void init_tsin_table();
+void set_tsin_parse_len(int);
+
+void gtab_parse()
+{
+  int i;
+  TSIN_PARSE out[MAX_PH_BF_EXT+1];
+  bzero(out, sizeof(out));
+
+  if (test_mode)
+    return;
+
+  if (ggg.gbufN <= 1)
+    return;
+
+  init_tsin_table();
+
+  init_cache(ggg.gbufN);
+
+  set_tsin_parse_len(ggg.gbufN);
+
+  short smatch_phr_N, sno_match_ch_N;
+  tsin_parse_recur(0, out, &smatch_phr_N, &sno_match_ch_N);
+#if 0
+  puts("vvvvvvvvvvvvvvvv");
+  for(i=0;  i < out[i].len; i++) {
+    printf("%x %d:", out[i].str, out[i].len);
+    utf8_putcharn(out[i].str, out[i].len);
+  }
+  dbg("\n");
+#endif
+
+  for(i=0; i < ggg.gbufN; i++)
+    gbuf[i].flag &= ~(FLAG_CHPHO_PHRASE_HEAD|FLAG_CHPHO_PHRASE_BODY);
+
+  int ofsi;
+  for(ofsi=i=0; out[i].len; i++) {
+    int j, ofsj;
+
+    if (out[i].flag & FLAG_TSIN_PARSE_PHRASE) {
+      gbuf[ofsi].flag |= FLAG_CHPHO_PHRASE_HEAD;
+      gbuf[ofsi].plen = out[i].len;
+    }
+
+    for(ofsj=j=0; j < out[i].len; j++) {
+      char *w = (char *)&out[i].str[ofsj];
+      int wsz = utf8_sz(w);
+      ofsj += wsz;
+
+      int k;
+      for(k=0;k<gbuf[ofsi].selN; k++) {
+        int sz = utf8_sz(gbuf[ofsi].sel[k]);
+        if (wsz == sz && !memcmp(gbuf[ofsi].sel[k], w, sz))
+          break;
+      }
+      if (k==gbuf[ofsi].selN) {
+#if 0
+        dbg("qq ");
+        utf8_putchar(w);
+        p_err(" err 1 selN:%d ofsi:%d", gbuf[ofsi].selN, ofsi);
+#endif
+        k=0;
+      }
+
+      if (!(gbuf[ofsi].flag & FLAG_CHPHO_FIXED)) {
+        gbuf[ofsi].ch = gbuf[ofsi].sel[k];
+        gbuf[ofsi].c_sel = k;
+      }
+      gbuf[ofsi].flag |= FLAG_CHPHO_PHRASE_BODY;
+
+      ofsi++;
+    }
+  }
+
+#if 0
+  puts("-----------------------------");
+  for(i=0;i<ggg.gbufN;i++)
+    puts(gbuf[i].ch);
+#endif
+  free_cache();
+}
+
+static GEDIT *cursor_gbuf()
+{
+  return ggg.gbuf_cursor == ggg.gbufN ? &gbuf[ggg.gbuf_cursor-1] : &gbuf[ggg.gbuf_cursor];
+}
+
+typedef struct {
+  char *s;
+  int usecount;
+  int org_seq;
+} GITEM;
+
+int get_gtab_use_count(char *s);
+
+int qcmp_gitem(const void *aa, const void *bb)
+{
+  int d = ((GITEM *)bb)->usecount - ((GITEM *)aa)->usecount;
+  if (d)
+    return d;
+
+  return ((GITEM *)aa)->org_seq - ((GITEM *)bb)->org_seq;
+}
+
+void hide_row2_if_necessary();
+
+unich_t auto_end_punch[] = ", . ? : ; ! [ ]            ";
+GEDIT *insert_gbuf_cursor(char **sel, int selN, u_int64_t key, gboolean b_gtab_en_no_spc)
+{
+  hide_row2_if_necessary();
+
+  if (!sel || !selN)
+    return NULL;
+//  dbg("insert_gbuf_cursor %x\n", key);
+
+  gbuf=trealloc(gbuf, GEDIT, ggg.gbufN+2);
+
+  GEDIT *pbuf = &gbuf[ggg.gbuf_cursor];
+
+  if (ggg.gbuf_cursor < ggg.gbufN)
+    memmove(&gbuf[ggg.gbuf_cursor+1], &gbuf[ggg.gbuf_cursor], sizeof(GEDIT) * (ggg.gbufN - ggg.gbuf_cursor));
+
+  ggg.gbuf_cursor++;
+  ggg.gbufN++;
+
+  bzero(pbuf, sizeof(GEDIT));
+  bzero(gbuf+ggg.gbufN, sizeof(GEDIT));
+
+  GITEM *items = tmalloc(GITEM, selN);
+
+  int i;
+  for(i=0; i < selN; i++) {
+    items[i].s = sel[i];
+    items[i].org_seq = i;
+    items[i].usecount = get_gtab_use_count(sel[i]);
+  }
+  qsort(items, selN, sizeof(GITEM), qcmp_gitem);
+
+  for(i=0; i < selN; i++)
+    sel[i] = items[i].s;
+
+  pbuf->ch = sel[0];
+  pbuf->sel = sel;
+  pbuf->selN = selN;
+  pbuf->c_sel = 0;
+  pbuf->keys[0] = key;
+  pbuf->keysN=1;
+  pbuf->flag = b_gtab_en_no_spc ? FLAG_CHPHO_GTAB_BUF_EN_NO_SPC:0;
+
+  if (hime_punc_auto_send && ggg.gbufN==ggg.gbuf_cursor && selN==1 && strstr(_(auto_end_punch), sel[0])) {
+    char_play(pbuf->ch);
+    output_gbuf();
+  } else {
+    gtab_parse();
+    disp_gbuf();
+    char_play(pbuf->ch);
+  }
+
+  free(items);
+  return pbuf;
+}
+
+
+void set_gbuf_c_sel(int v)
+{
+  GEDIT *pbuf = cursor_gbuf();
+
+  pbuf->c_sel = v + ggg.pg_idx;
+  pbuf->ch = pbuf->sel[pbuf->c_sel];
+//  dbg("zzzsel v:%d %d %s\n",v, pbuf->c_sel,pbuf->ch);
+  pbuf->flag |= FLAG_CHPHO_FIXED;
+  ggg.gtab_buf_select = 0;
+  ggg.more_pg = 0;
+  disp_gtab_sel("");
+  gtab_parse();
+  disp_gbuf();
+//  dbg("zzzsel v:%d\n", pbuf->c_sel);
+}
+
+GEDIT *insert_gbuf_cursor1(char *s, u_int64_t key, gboolean b_gtab_en_no_spc)
+{
+   if (!gtab_phrase_on())
+     return NULL;
+
+//   dbg("insert_gbuf_cursor1 %s %x\n", s, key);
+   char **sel = tmalloc(char *, 1);
+   sel[0] = strdup(s);
+   GEDIT *e = insert_gbuf_cursor(sel, 1, key, b_gtab_en_no_spc);
+   clear_after_put();
+   return e;
+}
+
+void insert_gbuf_cursor_phrase(char *s, void *key, int N)
+{
+  u_int *key32 = (u_int *)key;
+  u_int64_t *key64 = (u_int64_t *)key;
+
+  int i;
+  for(i=0; i < N; i++) {
+    char ch[CH_SZ+1];
+    int n = utf8cpy(ch, s);
+    u_int64_t v = ph_key_sz==4?key32[i]:key64[i];
+    GEDIT *e = insert_gbuf_cursor1(ch, v, TRUE);
+    e->flag |= FLAG_CHPHO_FIXED;
+    s+=n;
+  }
+}
+
+static int key_N(u_int64_t k)
+{
+  int n=0;
+  int mask = (1 << KeyBits) - 1;
+
+  while (k) {
+    k>>=mask;
+    n++;
+  }
+
+  return n;
+}
+
+static int qcmp_key_N(const void *aa, const void *bb)
+{
+  u_int64_t a = *((u_int64_t *)aa);
+  u_int64_t b = *((u_int64_t *)bb);
+
+  return key_N(a) - key_N(b);
+}
+
+
+void insert_gbuf_nokey(char *s)
+{
+   if (!gtab_phrase_on())
+     return;
+
+//   dbg("insert_gbuf_nokey\n");
+
+   int i;
+   u_int64_t keys[32];
+   int keysN=0;
+   int sz = utf8_sz(s);
+
+   keys[0]=0;
+   if (cur_inmd->tbl64) {
+     for(i=0; i < cur_inmd->DefChars; i++) {
+       if (!memcmp(cur_inmd->tbl64[i].ch, s, sz)) {
+         u_int64_t t;
+         memcpy(&t, cur_inmd->tbl64[i].key, sizeof(u_int64_t));
+         keys[keysN++] = t;
+       }
+     }
+   } else
+   if (cur_inmd->tbl) {
+     for(i=0; i < cur_inmd->DefChars; i++) {
+       if (!memcmp(cur_inmd->tbl[i].ch, s, sz)) {
+         u_int t;
+         memcpy(&t, cur_inmd->tbl[i].key, sizeof(u_int));
+         keys[keysN++] = t;
+       }
+     }
+   }
+
+   qsort(keys, keysN, sizeof(u_int64_t), qcmp_key_N);
+
+   GEDIT *e = insert_gbuf_cursor1(s, keys[0], TRUE);
+   if (keysN > 8)
+     keysN = 8;
+
+   memcpy(e->keys, keys, sizeof(u_int64_t) * keysN);
+   e->keysN = keysN;
+}
+
+void insert_gbuf_cursor1_cond(char *s, u_int64_t key, gboolean valid_key)
+{
+  if (valid_key)
+    insert_gbuf_cursor1(s, key, FALSE);
+  else
+    insert_gbuf_nokey(s);
+}
+
+void insert_gbuf_cursor_char(char ch)
+{
+  char t[2];
+  t[0]=ch;
+  t[1]=0;
+  insert_gbuf_cursor1(t, 0, TRUE);
+}
+
+gboolean gtab_has_input();
+void hide_win_gtab();
+
+int gtab_buf_delete_ex(gboolean auto_hide)
+{
+  if (ggg.gbuf_cursor==ggg.gbufN)
+    return 0;
+
+  if (test_mode)
+    return 1;
+
+  if (ggg.gtab_buf_select)
+    clear_gbuf_sel();
+
+  free_gbuf(ggg.gbuf_cursor);
+  memmove(&gbuf[ggg.gbuf_cursor], &gbuf[ggg.gbuf_cursor+1], sizeof(GEDIT) * (ggg.gbufN - ggg.gbuf_cursor -1));
+  ggg.gbufN--;
+  disp_gbuf();
+
+  if (hime_pop_up_win && !gtab_has_input() && auto_hide)
+    hide_win_gtab();
+
+  return 1;
+}
+
+int gtab_buf_delete()
+{
+  return gtab_buf_delete_ex(TRUE);
+}
+
+
+gboolean gtab_has_input();
+void hide_win_gtab();
+
+int gtab_buf_backspace_ex(gboolean auto_hide)
+{
+  if (!ggg.gbuf_cursor) {
+    return ggg.gbufN>0;
+  }
+  ggg.gbuf_cursor--;
+  gtab_buf_delete_ex(auto_hide);
+
+  if (hime_pop_up_win && !gtab_has_input() && auto_hide)
+    hide_win_gtab();
+
+  return 1;
+}
+
+int gtab_buf_backspace()
+{
+  return gtab_buf_backspace_ex(TRUE);
+}
+
+
+void gtab_buf_backspaceN(int n)
+{
+  int i;
+  for(i=0; i < n; i++)
+    gtab_buf_backspace_ex(FALSE);
+}
+
+extern int more_pg;
+
+void gtab_disp_sel()
+{
+  int idx = ggg.gbuf_cursor==ggg.gbufN ? ggg.gbuf_cursor-1:ggg.gbuf_cursor;
+  GEDIT *pbuf=&gbuf[idx];
+
+  int i;
+  for(i=0; i < cur_inmd->M_DUP_SEL; i++) {
+    int v = i + ggg.pg_idx;
+    if (v >= pbuf->selN)
+      seltab[i][0]=0;
+    else
+      strcpy(seltab[i], pbuf->sel[v]);
+  }
+
+  if (pbuf->selN > page_len())
+    ggg.more_pg = 1;
+  disp_selection0(FALSE, TRUE);
+  show_win_gtab();
+}
+
+
+int show_buf_select()
+{
+  if (!ggg.gbufN)
+    return 0;
+
+  int idx = ggg.gbuf_cursor==ggg.gbufN ? ggg.gbuf_cursor-1:ggg.gbuf_cursor;
+  GEDIT *pbuf=&gbuf[idx];
+  ggg.gtab_buf_select = 1;
+  ggg.total_matchN = pbuf->selN;
+  ggg.pg_idx = 0;
+
+  gtab_disp_sel();
+  hide_gtab_pre_sel();
+
+  return 1;
+}
+
+void gbuf_prev_pg()
+{
+  ggg.pg_idx -= page_len();
+  if (ggg.pg_idx < 0)
+    ggg.pg_idx = 0;
+
+  gtab_disp_sel();
+}
+
+void gbuf_next_pg()
+{
+  ggg.pg_idx += page_len();
+  if (ggg.pg_idx >= ggg.total_matchN)
+    ggg.pg_idx = 0;
+
+  gtab_disp_sel();
+}
+
+#include "im-client/hime-im-client-attr.h"
+
+int get_DispInArea_str(char *out);
+
+int gtab_get_preedit(char *str, HIME_PREEDIT_ATTR attr[], int *pcursor, int *sub_comp_len)
+{
+  int i=0;
+  int strN=0;
+  int attrN=0;
+  int ch_N=0;
+
+//  dbg("gtab_get_preedit\n");
+  str[0]=0;
+  *pcursor=0;
+
+  *sub_comp_len = ggg.ci > 0;
+#if 1
+  if (ggg.gbufN && !hime_edit_display_ap_only())
+	*sub_comp_len|=4;
+#endif
+  gboolean ap_only = hime_edit_display_ap_only();
+
+  if (gtab_phrase_on()) {
+    attr[0].flag=HIME_PREEDIT_ATTR_FLAG_UNDERLINE;
+    attr[0].ofs0=0;
+
+    if (ggg.gbufN)
+      attrN=1;
+
+    gboolean last_is_en_word = FALSE;
+    for(i=0; i < ggg.gbufN; i++) {
+      char *s = gbuf[i].ch;
+      char tt[MAX_CIN_PHR+2];
+
+      if (en_word_len(s) && !(gbuf[i].flag & FLAG_CHPHO_GTAB_BUF_EN_NO_SPC)) {
+        if (last_is_en_word) {
+          strcpy(tt, " ");
+          strcat(tt, s);
+          s = tt;
+        }
+        last_is_en_word = TRUE;
+      } else {
+        last_is_en_word = FALSE;
+      }
+
+      int len = strlen(s);
+      int N = utf8_str_N(s);
+      ch_N+=N;
+      if (i < ggg.gbuf_cursor)
+        *pcursor+=N;
+      if (ap_only && i==ggg.gbuf_cursor) {
+        attr[1].ofs0=*pcursor;
+        attr[1].ofs1=*pcursor+N;
+        attr[1].flag=HIME_PREEDIT_ATTR_FLAG_REVERSE;
+        attrN++;
+      }
+
+      if (hime_display_on_the_spot_key() && i==ggg.gbuf_cursor)
+        strN += get_DispInArea_str(str+strN);
+
+      memcpy(str+strN, s, len);
+      strN+=len;
+    }
+  }
+
+
+  if (hime_display_on_the_spot_key() && i==ggg.gbuf_cursor)
+    strN += get_DispInArea_str(str+strN);
+
+  str[strN]=0;
+
+  attr[0].ofs1 = ch_N;
+  return attrN;
+}
+
+extern GtkWidget *gwin_gtab;
+void gtab_reset()
+{
+  if (!gwin_gtab)
+    return;
+  clear_gtab_buf_all();
+  clear_gbuf_sel();
+  ClrIn();
+  return;
+}
+
+int ch_to_gtab_keys(INMD *tinmd, char *ch, u_int64_t keys[]);
+
+void save_gtab_buf_phrase_idx(int idx0, int len)
+{
+  WSP_S wsp[MAX_PHRASE_LEN];
+
+  bzero(wsp, sizeof(wsp));
+  int i;
+  for(i=0; i < len; i++) {
+    u8cpy(wsp[i].ch, gbuf[idx0 + i].ch);
+    u_int64_t key = gbuf[idx0 + i].keys[0];
+
+    if (!key) {
+      u_int64_t keys[64];
+      int keysN = ch_to_gtab_keys(cur_inmd, wsp[i].ch, keys);
+      if (keysN)
+        key = keys[0];
+    }
+
+    wsp[i].key = key;
+  }
+
+  create_win_save_phrase(wsp, len);
+}
+
+void save_gtab_buf_phrase(KeySym key)
+{
+  int len = key - '0';
+  int idx0 = ggg.gbuf_cursor - len;
+  int idx1 = ggg.gbuf_cursor - 1;
+
+  if (idx0 < 0 || idx0 > idx1)
+    return;
+
+  save_gtab_buf_phrase_idx(idx0, len);
+}
+
+gboolean save_gtab_buf_shift_enter()
+{
+  if (!ggg.gbufN)
+    return 0;
+  int idx0 = 0;
+  if (ggg.gbufN != ggg.gbuf_cursor)
+    idx0 = ggg.gbuf_cursor;
+  int len = ggg.gbufN - idx0;
+  if (len > MAX_PHRASE_LEN)
+    return 0;
+
+  save_gtab_buf_phrase_idx(idx0, len);
+  gbuf_cursor_end();
+  return 1;
+}
+
+
+void load_tsin_db0(char *infname, gboolean is_gtab_i);
+gboolean init_tsin_table_fname(INMD *p, char *fname);
+
+void init_tsin_table()
+{
+  char fname[256];
+  if (!current_CS)
+    return;
+
+  init_tsin_table_fname(&inmd[current_CS->in_method], fname);
+  load_tsin_db0(fname, TRUE);
+}
+
+extern u_char scanphr_e(int chpho_idx, int plen, gboolean pho_incr, int *rselN);
+void init_pre_sel();
+void clear_sele();
+void set_sele_text(int tN, int i, char *text, int len);
+void get_win_gtab_geom();
+void disp_selections(int x, int y);
+
+gboolean use_tsin_sel_win();
+void init_tsin_selection_win();
+
+static int gtab_pre_select_phrase_len;
+
+void disp_gtab_pre_sel(char *s);
+extern GtkWidget *gwin1;
+
+void gtab_scan_pre_select(gboolean b_incr)
+{
+  if (!gtab_phrase_pre_select)
+    return;
+//  dbg("gtab_scan_pre_select\n");
+
+  tss.pre_selN = 0;
+
+  hide_gtab_pre_sel();
+
+  if (!gtab_cursor_end() || !ggg.gbufN)
+    return;
+
+  init_tsin_table();
+  init_pre_sel();
+
+  int Maxlen = ggg.gbufN;
+  if (Maxlen > MAX_PHRASE_LEN)
+    Maxlen = MAX_PHRASE_LEN;
+
+  int len, selN, max_len=-1, max_selN;
+  for(len=1; len <= Maxlen; len++) {
+    int idx = ggg.gbufN - len;
+    if (gbuf[idx].flag & FLAG_CHPHO_PHRASE_TAIL)
+      break;
+    int mlen = scanphr_e(ggg.gbufN - len, len, b_incr, &selN);
+    if (mlen) {
+      max_len = len;
+      max_selN = selN;
+    }
+  }
+
+//  dbg("max_len:%d  max_selN:%d\n", max_len, max_selN);
+
+  if (max_len < 0 || max_selN >= strlen(cur_inmd->selkey) * 2) {
+    tss.pre_selN = 0;
+    return;
+  }
+
+  gtab_pre_select_phrase_len = max_len;
+
+  scanphr_e(ggg.gbufN - max_len, max_len, b_incr, &selN);
+
+//  dbg("selN:%d %d\n", selN, tss.pre_selN);
+
+  if (selN==1 && tss.pre_sel[0].len==max_len) {
+    char out[MAX_PHRASE_LEN * CH_SZ + 1];
+    extract_gbuf_str(ggg.gbufN - max_len, max_len, out);
+    if (!strcmp(out, tss.pre_sel[0].str))
+      return;
+  }
+
+//  dbg("selN %d %d\n",selN, tss.pre_selN);
+
+  if (use_tsin_sel_win()) {
+	if (gwin1)
+      clear_sele();
+	else
+      init_tsin_selection_win();
+
+    int i;
+    for(i=0;i<tss.pre_selN; i++)
+       set_sele_text(tss.pre_selN,i,tss.pre_sel[i].str, -1);
+    get_win_gtab_geom();
+    disp_selections(-1, -1);
+    return;
+  }
+
+  char tt[4096];
+  tt[0]=0;
+  int i;
+
+  for(i=0;i<tss.pre_selN; i++) {
+    char ts[(MAX_PHRASE_LEN+3) * CH_SZ + 1];
+    char *br= (i < tss.pre_selN-1 && gtab_vertical_select_on())?"\n":"";
+    if (hime_win_color_use)
+      sprintf(ts, "<span foreground=\"%s\">%c</span>%s%s", hime_sel_key_color, cur_inmd->selkey[i], tss.pre_sel[i].str, br);
+    else
+      sprintf(ts, "<span foreground=\""HIME_SEL_KEY_COLOR_DEFAULT"\">%c</span>%s%s", cur_inmd->selkey[i], tss.pre_sel[i].str, br);
+    strcat(tt, ts);
+    if (!gtab_vertical_select_on() && i < tss.pre_selN-1)
+      strcat(tt, " ");
+  }
+
+//  dbg("tt %s\n", tt);
+  disp_gtab_pre_sel(tt);
+}
+
+
+int shift_key_idx(char *s, KeySym xkey);
+
+gboolean gtab_pre_select_idx(int c)
+{
+  if (c < 0)
+    return FALSE;
+  if (c >= tss.pre_selN)
+    return TRUE;
+
+#if 0
+  dbg("c %d %s  ggg.gbuf_cursor:%d,%d\n", c, tss.pre_sel[c].str,
+    ggg.gbuf_cursor, ggg.gbufN);
+#endif
+
+  gtab_buf_backspaceN(gtab_pre_select_phrase_len);
+  int len = tss.pre_sel[c].len;
+  insert_gbuf_cursor_phrase(tss.pre_sel[c].str, tss.pre_sel[c].phkey, len);
+  gbuf[ggg.gbufN-1].flag |= FLAG_CHPHO_PHRASE_TAIL;
+
+  hide_gtab_pre_sel();
+  if (hime_pop_up_win)
+    hide_win_gtab();
+
+  return TRUE;
+}
+
+gboolean gtab_pre_select_shift(KeySym key, int kbstate)
+{
+//  dbg("gtab_pre_select_shift %c\n", key);
+  if (!gtab_phrase_pre_select || !tss.pre_selN)
+    return FALSE;
+
+  int c = shift_key_idx(cur_inmd->selkey, key);
+  return gtab_pre_select_idx(c);
+}
+
+void tsin_toggle_eng_ch();
+
+int feedkey_gtab_release(KeySym xkey, int kbstate)
+{
+  switch (xkey) {
+     case XK_Control_L:
+     case XK_Control_R:
+       if (key_press_ctrl && tss.pre_selN) {
+         if (!test_mode) {
+           tss.ctrl_pre_sel = TRUE;
+         }
+	 key_press_ctrl = FALSE;
+         return 1;
+       } else
+         return 0;
+#if 1
+     case XK_Shift_L:
+     case XK_Shift_R:
+// dbg("release xkey %x\n", xkey);
+        if (((tsin_chinese_english_toggle_key == TSIN_CHINESE_ENGLISH_TOGGLE_KEY_Shift) ||
+             (tsin_chinese_english_toggle_key == TSIN_CHINESE_ENGLISH_TOGGLE_KEY_ShiftL && xkey == XK_Shift_L) ||
+             (tsin_chinese_english_toggle_key == TSIN_CHINESE_ENGLISH_TOGGLE_KEY_ShiftR && xkey == XK_Shift_R)) &&
+	     key_press_alt) {
+          if (!test_mode) {
+            tsin_toggle_eng_ch();
+          }
+	  key_press_alt = FALSE;
+          return 1;
+        } else
+          return 0;
+#endif
+     default:
+        return 0;
+  }
+}
+
+#include "win1.h"
+
+void gtab_set_win1_cb()
+{
+  set_win1_cb((cb_selec_by_idx_t)gtab_pre_select_idx, NULL, NULL);
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/gtab-buf.h b/src/plugins/platforminputcontexts/hime/include/gtab-buf.h
new file mode 100644
index 0000000..6ee7803
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/gtab-buf.h
@@ -0,0 +1,33 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+typedef struct {
+  char *ch;
+  char **sel;
+  int selN;
+  u_short flag;
+  u_char c_sel;
+  char plen, keysN;
+  u_int64_t keys[8];
+} GEDIT;
+
+extern GEDIT *gbuf;
+extern short gbufN;
+
+void insert_gbuf_nokey(char *s);
+void insert_gbuf_cursor1_cond(char *s, u_int64_t key, gboolean valid_key);
+GEDIT *insert_gbuf_cursor(char **sel, int selN, u_int64_t key, gboolean b_gtab_en_no_spc);
diff --git a/src/plugins/platforminputcontexts/hime/include/gtab.c b/src/plugins/platforminputcontexts/hime/include/gtab.c
new file mode 100644
index 0000000..708fa06
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/gtab.c
@@ -0,0 +1,1832 @@
+/* Copyright (C) 2004-2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <sys/stat.h>
+#include <regex.h>
+#include "hime.h"
+#include "gtab.h"
+#include "pho.h"
+#include "hime-conf.h"
+#include "hime-endian.h"
+#include "gtab-buf.h"
+#include "tsin.h"
+#include "gst.h"
+
+extern gboolean test_mode;
+gboolean gtab_phrase_on();
+gboolean gtab_disp_partial_match_on(), gtab_vertical_select_on(), gtab_pre_select_on(), gtab_unique_auto_send_on(), gtab_press_full_auto_send_on();
+void init_seltab(char ***p);
+
+extern gboolean key_press_alt, key_press_ctrl;
+
+extern GtkWidget *gwin_gtab;
+void hide_gtab_pre_sel();
+void gtab_scan_pre_select(gboolean);
+
+extern GTAB_space_pressed_E _gtab_space_auto_first;
+extern char *TableDir;
+
+extern INMD *cur_inmd;
+extern char **seltab;
+
+extern char str_key_codes[128];
+void disp_pho_sel(char *s);
+
+#define gtab_full_space_auto_first (_gtab_space_auto_first & (GTAB_space_auto_first_any|GTAB_space_auto_first_full))
+#define AUTO_SELECT_BY_PHRASE (gtab_phrase_on())
+
+gboolean use_tsin_sel_win()
+{
+  return  gtab_vertical_select_on() && gtab_phrase_pre_select;
+}
+
+
+static gboolean gtab_pre_select_or_partial_on()
+{
+  return gtab_pre_select_on() || (cur_inmd->flag&FLAG_GTAB_DISP_PARTIAL_MATCH)!=0;
+}
+
+gboolean same_query_show_pho_win()
+{
+  return poo.same_pho_query_state != SAME_PHO_QUERY_none;
+}
+
+gboolean hime_edit_display_ap_only();
+gboolean gtab_has_input()
+{
+  int i;
+
+  for(i=0; i < MAX_TAB_KEY_NUM64_6; i++)
+    if (ggg.inch[i])
+      return TRUE;
+
+  if (same_query_show_pho_win())
+    return TRUE;
+
+  if (ggg.gtab_buf_select)
+    return TRUE;
+
+  if (ggg.gbufN && !hime_edit_display_ap_only())
+    return TRUE;
+
+  return FALSE;
+}
+
+#define tblch(i) tblch2(cur_inmd, i)
+
+int load_phr_ch(INMD *inm, u_char *ch, char *tt)
+{
+  int phrno =((int)(ch[0])<<16)|((int)ch[1]<<8)|ch[2];
+  int ofs = inm->phridx[phrno], ofs1 = inm->phridx[phrno+1];
+
+//  dbg("load_phr   j:%d %d %d %d\n", j, phrno, ofs, ofs1);
+  int len = ofs1 - ofs;
+
+  if (len > MAX_CIN_PHR || len <= 0) {
+    dbg("phrae error %d\n", len);
+    strcpy(tt,"err");
+    return 0;
+  }
+
+  memcpy(tt, inm->phrbuf + ofs, len);
+  tt[len]=0;
+  return len;
+}
+
+static void load_phr(int j, char *tt)
+{
+  u_char *ch = tblch(j);
+
+  load_phr_ch(cur_inmd, ch, tt);
+}
+
+static int qcmp_strlen(const void *aa, const void *bb)
+{
+  char *a = *((char **)aa), *b = *((char **)bb);
+
+  return strlen(a) - strlen(b);
+}
+
+void set_key_codes_label(char *s, int better);
+void set_page_label(char *s);
+
+static void clear_page_label()
+{
+  set_page_label("");
+}
+
+int gtab_key2name(INMD *tinmd, u_int64_t key, char *t, int *rtlen);
+
+
+int ch_to_gtab_keys(INMD *tinmd, char *ch, u_int64_t keys[])
+{
+  int n = utf8_str_N(ch);
+  gboolean phrase = n > 1 || !(ch[0] & 0x80);
+  int i, keysN=0;
+  for(i=0; i < tinmd->DefChars; i++) {
+    char *chi = (char *)tblch2(tinmd, i);
+
+    if (phrase) {
+      if ((chi[0] & 0x80))
+        continue;
+      char tstr[512];
+      load_phr_ch(tinmd, (u_char *)chi, tstr);
+      if (strcmp(tstr, ch))
+        continue;
+    } else {
+      if (!(chi[0] & 0x80))
+        continue;
+      if (!utf8_eq(chi, ch))
+        continue;
+    }
+
+    u_int64_t key = CONVT2(tinmd, i);
+    keys[keysN++] = key;
+  }
+  return keysN;
+}
+
+void lookup_gtabn(char *ch, char *out)
+{
+  char outbuf[512];
+  char *tbuf[128];
+  int tbufN=0;
+  INMD *tinmd = &inmd[default_input_method];
+
+  if (!tinmd->DefChars)
+    tinmd = cur_inmd;
+
+  if (!tinmd)
+    return;
+
+  gboolean need_disp = FALSE;
+
+  if (!out) {
+    out = outbuf;
+    need_disp = TRUE;
+  }
+
+  out[0]=0;
+
+
+  int min_klen = 100;
+  u_int64_t keys[64];
+  int keysN = ch_to_gtab_keys(tinmd, ch, keys);
+
+  int i;
+  for(i=0; i < keysN; i++) {
+    int tlen, klen;
+    char t[CH_SZ * 10 + 1];
+
+    klen = gtab_key2name(tinmd, keys[i], t, &tlen);
+
+    if (klen < min_klen)
+      min_klen = klen;
+
+    t[tlen]=0;
+
+    tbuf[tbufN] = strdup(t);
+    tbufN++;
+  }
+
+
+  qsort(tbuf, tbufN, sizeof(char *), qcmp_strlen);
+  out[0]=0;
+
+  for(i=0; i < tbufN; i++) {
+#define MAX_DISP_MATCH 40
+    if (strlen(out) < MAX_DISP_MATCH) {
+      strcat(out, tbuf[i]);
+      if (i < tbufN-1)
+        strcat(out, " |");
+    }
+
+    free(tbuf[i]);
+  }
+
+  if (!out[0] || !need_disp)
+    return;
+
+
+  set_key_codes_label(out, ggg.ci > min_klen);
+  void set_key_codes_label_pho(char *s);
+  set_key_codes_label_pho(out);
+}
+
+void lookup_gtab(char *ch)
+{
+  char tt[CH_SZ+1];
+  utf8cpy(tt, ch);
+  lookup_gtabn(tt, NULL);
+}
+
+
+void lookup_gtab_out(char *ch, char *out)
+{
+  char tt[CH_SZ+1];
+  utf8cpy(tt, ch);
+  lookup_gtabn(tt, out);
+}
+
+void free_gtab()
+{
+  int i;
+
+  for(i=0; i < inmdN; i++) {
+    INMD *inp = &inmd[i];
+    free(inp->tbl); inp->tbl = NULL;
+    free(inp->tbl64); inp->tbl64 = NULL;
+    free(inp->phridx); inp->phridx = NULL;
+    free(inp->phrbuf); inp->phrbuf = NULL;
+    free(inp->keyname_lookup); inp->keyname_lookup = NULL;
+  }
+
+  free(inmd);
+}
+
+
+char *b1_cat(char *s, char c)
+{
+  char t[2];
+  t[0]=c;
+  t[1]=0;
+
+  return strcat(s, t);
+}
+
+
+char *bch_cat(char *s, char *ch)
+{
+  char t[CH_SZ + 1];
+  int len = u8cpy(t, ch);
+  t[len]=0;
+
+  return strcat(s, t);
+}
+
+
+void disp_gtab_sel(char *s);
+
+void ClrSelArea()
+{
+  disp_gtab_sel("");
+//  hide_gtab_pre_sel();
+}
+
+
+void disp_gtab(char *);
+void clear_gtab_input_error_color();
+
+static void clr_seltab()
+{
+  int i;
+  if (!seltab)
+    return;
+
+  for(i=0; i < MAX_SELKEY; i++)
+     seltab[i][0]=0;
+}
+
+void clear_gtab_in_area(), hide_win_gtab();
+void ClrIn()
+{
+  bzero(ggg.inch,sizeof(ggg.inch));
+  clr_seltab();
+  ggg.total_matchN=ggg.pg_idx=ggg.more_pg=ggg.wild_mode=ggg.wild_page=ggg.last_idx=ggg.defselN=ggg.exa_match=
+  ggg.spc_pressed=ggg.ci=ggg.invalid_spc=0;
+
+  ggg.sel1st_i=MAX_SELKEY-1;
+
+  clear_gtab_in_area();
+  ggg.last_idx = 0;
+
+  if (hime_pop_up_win && !gtab_has_input() && !tss.pre_selN)
+    hide_win_gtab();
+
+  clear_gtab_input_error_color();
+  clear_page_label();
+//  hide_gtab_pre_sel();
+}
+
+
+void hide_win_pho();
+
+void close_gtab_pho_win()
+{
+  if (test_mode)
+    return;
+  if (same_query_show_pho_win()) {
+    poo.same_pho_query_state = SAME_PHO_QUERY_none;
+    hide_win_pho();
+    if (hime_pop_up_win && (str_key_codes[0]!='\0'))
+      hide_win_gtab();
+  }
+}
+
+void gtab_disp_empty(char *tt, int N);
+extern int win_gtab_max_key_press;
+
+static void DispInArea()
+{
+  int i;
+
+//  hide_gtab_pre_sel();
+
+//  dbg("sel1st:%d\n", ggg.sel1st_i);
+  if (hime_display_on_the_spot_key()) {
+    if (hime_pop_up_win && gwin_gtab && GTK_WIDGET_VISIBLE(gwin_gtab) && poo.same_pho_query_state == SAME_PHO_QUERY_none)
+      hide_win_gtab();
+    return;
+  }
+
+  char tt[128];
+  int ttN=0;
+
+  if (win_gtab_max_key_press < ggg.ci)
+    win_gtab_max_key_press = ggg.ci;
+
+  for(i=0;i<ggg.ci;i++) {
+    char *p=(char *)&cur_inmd->keyname[ggg.inch[i] * CH_SZ];
+    int len;
+    if (*p & 0x80)
+      len=utf8cpy(tt+ttN, p);
+    else {
+      len = strlen(p);
+      strcpy(tt+ttN, p);
+    }
+
+    ttN+=len;
+  }
+
+  tt[ttN]=0;
+
+  gtab_disp_empty(tt, win_gtab_max_key_press - i);
+
+  disp_gtab(tt);
+}
+
+int get_DispInArea_str(char *out)
+{
+  int outN=0, i;
+  for(i=0;i<ggg.ci;i++) {
+    char *p = (char *)&cur_inmd->keyname[ggg.inch[i] * CH_SZ];
+    if (*p & 0x80)
+      outN+=u8cpy(out+outN, p);
+    else {
+      int len = strlen(p);
+      memcpy(out+outN, p, len);
+      outN+=len;
+    }
+  }
+
+#if 0
+  if (outN) {
+    hide_gtab_pre_sel();
+  }
+#endif
+
+  out[outN]=0;
+//  dbg("get_DispInArea_str\n", out);
+  return outN;
+}
+
+
+void set_gtab_input_method_name(char *s);
+void case_inverse(KeySym *xkey, int shift_m);
+
+extern unich_t *fullchar[];
+
+void start_gtab_pho_query(char *utf8);
+
+void clear_after_put()
+{
+  ClrIn();
+  ClrSelArea();
+}
+
+void add_to_tsin_buf_str(char *str);
+gboolean init_in_method(int in_no);
+void hide_win_kbm();
+
+void hide_row2_if_necessary()
+{
+  if ((!ggg.wild_mode && gtab_hide_row2) || !gtab_disp_key_codes) {
+    set_key_codes_label(NULL, 0);
+  }
+}
+
+static void putstr_inp(char *p)
+{
+  clear_page_label();
+
+//  dbg("gtab_hide_row2 %d\n", gtab_hide_row2);
+  hide_row2_if_necessary();
+
+  char_play(p);
+
+  int to_tsin = (cur_inmd->flag & FLAG_GTAB_SYM_KBM) && inmd[default_input_method].method_type==method_type_TSIN && tss.c_len;
+
+  if (utf8_str_N(p) > 1  || !(p[0]&128)) {
+    if ((gtab_disp_key_codes && !gtab_hide_row2) || ggg.wild_mode)
+      lookup_gtabn(p, NULL);
+    if (to_tsin) {
+      add_to_tsin_buf_str(p);
+    }
+    else
+      send_text(p);
+  }
+  else {
+    if (poo.same_pho_query_state == SAME_PHO_QUERY_gtab_input) {
+      poo.same_pho_query_state = SAME_PHO_QUERY_pho_select;
+      start_gtab_pho_query(p);
+
+      ClrIn();
+      ClrSelArea();
+      return;
+    }
+
+    if ((gtab_disp_key_codes && !gtab_hide_row2) || ggg.wild_mode)
+      lookup_gtab(p);
+
+    if (to_tsin)
+      add_to_tsin_buf_str(p);
+    else
+      send_utf8_ch(p);
+  }
+
+  clear_after_put();
+
+  if ((cur_inmd->flag & FLAG_GTAB_SYM_KBM)) {
+    extern int win_kbm_inited, hime_show_win_kbm;
+    init_in_method(default_input_method);
+    if (win_kbm_inited && !hime_show_win_kbm)
+      hide_win_kbm();
+  }
+}
+
+
+#define swap(a,b) { tt=a; a=b; b=tt; }
+
+static u_int vmask[]=
+{ 0,
+ (0x3f<<24),
+ (0x3f<<24)|(0x3f<<18),
+ (0x3f<<24)|(0x3f<<18)|(0x3f<<12),
+ (0x3f<<24)|(0x3f<<18)|(0x3f<<12)|(0x3f<<6),
+ (0x3f<<24)|(0x3f<<18)|(0x3f<<12)|(0x3f<<6)|0x3f
+};
+
+
+static u_int vmask_7[]=
+{ 0,
+ (0x7f<<21),
+ (0x7f<<21)|(0x7f<<14),
+ (0x7f<<21)|(0x7f<<14)|(0x7f<<7),
+ (0x7f<<21)|(0x7f<<14)|(0x7f<<7)|0x7f,
+};
+
+#define KKK ((u_int64_t)0x3f)
+
+
+static u_int64_t vmask64[]=
+{ 0,
+  (KKK<<54),
+  (KKK<<54)|(KKK<<48),
+  (KKK<<54)|(KKK<<48)|(KKK<<42),
+  (KKK<<54)|(KKK<<48)|(KKK<<42)|(KKK<<36),
+  (KKK<<54)|(KKK<<48)|(KKK<<42)|(KKK<<36)|(KKK<<30),
+  (KKK<<54)|(KKK<<48)|(KKK<<42)|(KKK<<36)|(KKK<<30)|(KKK<<24),
+  (KKK<<54)|(KKK<<48)|(KKK<<42)|(KKK<<36)|(KKK<<30)|(KKK<<24)|(KKK<<18),
+  (KKK<<54)|(KKK<<48)|(KKK<<42)|(KKK<<36)|(KKK<<30)|(KKK<<24)|(KKK<<18)|(KKK<<12),
+  (KKK<<54)|(KKK<<48)|(KKK<<42)|(KKK<<36)|(KKK<<30)|(KKK<<24)|(KKK<<18)|(KKK<<12)|(KKK<<6),
+  (KKK<<54)|(KKK<<48)|(KKK<<42)|(KKK<<36)|(KKK<<30)|(KKK<<24)|(KKK<<18)|(KKK<<12)|(KKK<<6)|KKK
+};
+
+
+#define KKK7 ((u_int64_t)0x7f)
+
+static u_int64_t vmask64_7[]=
+{ 0,
+ (KKK7<<56),
+ (KKK7<<56)|(KKK7<<49),
+ (KKK7<<56)|(KKK7<<49)|(KKK7<<42),
+ (KKK7<<56)|(KKK7<<49)|(KKK7<<42)|(KKK7<<35),
+ (KKK7<<56)|(KKK7<<49)|(KKK7<<42)|(KKK7<<35)|(KKK7<<28),
+ (KKK7<<56)|(KKK7<<49)|(KKK7<<42)|(KKK7<<35)|(KKK7<<28)|(KKK7<<21),
+ (KKK7<<56)|(KKK7<<49)|(KKK7<<42)|(KKK7<<35)|(KKK7<<28)|(KKK7<<21)|(KKK7<<14),
+ (KKK7<<56)|(KKK7<<49)|(KKK7<<42)|(KKK7<<35)|(KKK7<<28)|(KKK7<<21)|(KKK7<<14)|(KKK7<<7),
+ (KKK7<<56)|(KKK7<<49)|(KKK7<<42)|(KKK7<<35)|(KKK7<<28)|(KKK7<<21)|(KKK7<<14)|(KKK7<<7)|KKK7,
+};
+
+
+#define KEY_N (cur_inmd->max_keyN)
+
+static gboolean load_seltab(int tblidx, int seltabidx)
+{
+  u_char *tbl_ch = tblch(tblidx);
+  if (tbl_ch[0] < 0x80) {
+    load_phr(tblidx, seltab[seltabidx]);
+    return TRUE;
+  }
+
+  int len = u8cpy(seltab[seltabidx], (char *)tbl_ch);
+  seltab[seltabidx][len] = 0;
+
+  return FALSE;
+}
+
+
+static char* load_tblidx(int tblidx)
+{
+  char tt[MAX_CIN_PHR];
+  u_char *tbl_ch = tblch(tblidx);
+  if (tbl_ch[0] < 0x80) {
+    load_phr(tblidx, tt);
+  } else {
+    int len = u8cpy(tt, (char *)tbl_ch);
+    tt[len] = 0;
+  }
+
+  return strdup(tt);
+}
+
+
+void set_gtab_input_error_color();
+static void bell_err()
+{
+  if (test_mode)
+    return;
+
+  bell();
+  set_gtab_input_error_color();
+}
+
+gboolean cmp_inmd_idx(regex_t *reg, int idx)
+{
+  u_int64_t kk=CONVT2(cur_inmd, idx);
+  char ts[32];
+  int tsN=0;
+
+  ts[tsN++]= ' ';
+
+  int i;
+  for(i=0; i < KEY_N; i++) {
+    char c = (kk >> (LAST_K_bitN - i*cur_inmd->keybits)) & cur_inmd->kmask;
+    if (!c)
+      break;
+    ts[tsN++] = c + '0';
+  }
+
+  ts[tsN++]= ' ';
+  ts[tsN]=0;
+
+  return regexec(reg, ts, 0, 0, 0);
+}
+
+int page_len()
+{
+  return (_gtab_space_auto_first & GTAB_space_auto_first_any) ?
+  cur_inmd->M_DUP_SEL+1:cur_inmd->M_DUP_SEL;
+}
+
+static void page_no_str(char tstr[])
+{
+  if (ggg.wild_mode || ggg.gtab_buf_select) {
+    int pgN = (ggg.total_matchN + cur_inmd->M_DUP_SEL - 1) / cur_inmd->M_DUP_SEL;
+    if (pgN < 2)
+      return;
+
+    int pg = ggg.gtab_buf_select ? ggg.pg_idx : ggg.wild_page;
+    sprintf(tstr, "%d/%d", pg /cur_inmd->M_DUP_SEL + 1, pgN);
+  } else {
+    int pgN = (ggg.E1 - ggg.S1 + page_len() - 1) /page_len();
+
+    if (pgN < 2)
+      return;
+
+    sprintf(tstr, "%d/%d", (ggg.pg_idx - ggg.S1)/page_len()+1, pgN);
+  }
+}
+
+char *htmlspecialchars(char *s, char out[])
+{
+  struct {
+    char c;
+    char *str;
+  } chs[]= {{'>',"gt"}, {'<',"lt"}, {'&',"amp"}
+#if 0
+  , {' ',"nbsp"}
+#endif
+  };
+  int chsN=sizeof(chs)/sizeof(chs[0]);
+
+  int outn=0;
+  while (*s) {
+    int sz = utf8_sz(s);
+    int i;
+    for(i=0; i<chsN; i++)
+      if (chs[i].c==*s)
+        break;
+    if (i==chsN) {
+      memcpy(&out[outn],s, sz);
+      outn+=sz;
+      s+=sz;
+    }
+    else {
+      out[outn++]='&';
+      int len=strlen(chs[i].str);
+      memcpy(&out[outn], chs[i].str, len);
+      outn+=len;
+      out[outn++]=';';
+      s++;
+    }
+  }
+
+  out[outn]=0;
+  return out;
+}
+
+
+void disp_selection0(gboolean phrase_selected, gboolean force_disp)
+{
+  char pgstr[32];
+  pgstr[0]=0;
+  page_no_str(pgstr);
+
+  if (!gtab_vertical_select_on()) {
+    if (ggg.more_pg)
+      set_page_label(pgstr);
+    else
+      clear_page_label();
+  }
+
+  char tt[1024];
+  tt[0]=0;
+  char uu[MAX_CIN_PHR];
+
+  int ofs;
+  if (!ggg.wild_mode && ggg.exa_match && (_gtab_space_auto_first & GTAB_space_auto_first_any)) {
+    strcat(tt, htmlspecialchars(seltab[0], uu));
+    if (gtab_vertical_select_on())
+      strcat(tt, "\n");
+    else
+      strcat(tt, " ");
+    ofs = 1;
+  } else {
+    ofs = 0;
+  }
+
+
+  int i,max_i;
+  for(max_i = cur_inmd->M_DUP_SEL + ofs-1; max_i>=0; max_i--)
+    if (seltab[max_i][0])
+      break;
+
+  for(i=ofs; i<= max_i; i++) {
+    if (seltab[i][0]) {
+      char selback[MAX_CIN_PHR+16];
+      htmlspecialchars(seltab[i], selback);
+
+      utf8cpy(uu, &cur_inmd->selkey[i - ofs]);
+      char vvv[16];
+      char www[1024];
+      if (hime_win_color_use)
+        sprintf(www, "<span foreground=\"%s\">%s</span>", hime_sel_key_color, htmlspecialchars(uu, vvv));
+      else
+        sprintf(www, "<span foreground=\""HIME_SEL_KEY_COLOR_DEFAULT"\">%s</span>", htmlspecialchars(uu, vvv));
+      strcat(tt, www);
+
+      if (gtab_vertical_select_on())
+        strcat(tt, " ");
+
+      if (phrase_selected && i==ggg.sel1st_i) {
+        strcat(tt, "<span foreground=\"red\">");
+        strcat(strcat(tt, selback), " ");
+        strcat(tt, "</span>");
+      } else {
+        char uu[MAX_CIN_PHR];
+
+        if (gtab_vertical_select_on()) {
+          utf8cpy_bytes(uu, selback, 120);
+          strcat(tt, uu);
+        } else {
+          char *p = selback;
+
+          static char *skip[]={"http://", "ftp://", "https://", NULL};
+
+          int j;
+          for(j=0; skip[j]; j++)
+            if (!strncmp(seltab[i], skip[j], strlen(skip[j]))) {
+              p+=strlen(skip[j]);
+              break;
+            }
+
+          utf8cpy_bytes(uu, p, 6 * 3);
+          strcat(strcat(tt, uu), " ");
+        }
+      }
+
+      if (gtab_vertical_select_on())
+        strcat(tt, "\n");
+    } else {
+      extern gboolean b_use_full_space;
+
+      if (!gtab_vertical_select_on() && gtab_disp_partial_match_on()) {
+         if (b_use_full_space)
+           strcat(tt, "  ");
+         else {
+           strcat(tt, "   ");
+         }
+      }
+    }
+  }
+
+  if (gtab_vertical_select_on() && pgstr[0]) {
+    char tstr2[16];
+    sprintf(tstr2, "(%s)", pgstr);
+    strcat(tt, tstr2);
+  }
+
+  int len = strlen(tt);
+  if (len && tt[len-1] == '\n')
+    tt[len-1] = 0;
+
+  if (gtab_pre_select_or_partial_on() || ggg.wild_mode || ggg.spc_pressed || ggg.last_full || force_disp) {
+    disp_gtab_sel(tt);
+  }
+}
+
+
+void disp_selection(gboolean phrase_selected)
+{
+  disp_selection0(phrase_selected, FALSE);
+}
+
+void wildcard()
+{
+  int i,t, wild_ofs=0;
+  int found=0;
+  regex_t reg;
+
+  ClrSelArea();
+  clr_seltab();
+  /* printf("wild %d %d %d %d\n", ggg.inch[0], ggg.inch[1], ggg.inch[2], ggg.inch[3]); */
+  ggg.defselN=0;
+  char regstr[32];
+  int regstrN=0;
+
+  regstr[regstrN++]=' ';
+
+  for(i=0; i < KEY_N; i++) {
+    if (!ggg.inch[i])
+      break;
+    if (ggg.inch[i] == cur_inmd->WILD_STAR) {
+      regstr[regstrN++]='.';
+      regstr[regstrN++]='*';
+    } else
+    if (ggg.inch[i] == cur_inmd->WILD_QUES) {
+      regstr[regstrN++]='.';
+    } else {
+      char c = ggg.inch[i] + '0';         // start from '0'
+      if (strchr("*.\\()[]", c))
+      regstr[regstrN++] = '\\';
+      regstr[regstrN++]=c;
+    }
+  }
+
+  regstr[regstrN++]=' ';
+  regstr[regstrN]=0;
+
+//  dbg("regstr %s\n", regstr);
+
+  if (regcomp(&reg, regstr, 0)) {
+    dbg("regcomp failed\n");
+    return;
+  }
+
+  for(t=0; t< cur_inmd->DefChars && ggg.defselN < cur_inmd->M_DUP_SEL; t++) {
+    if (cmp_inmd_idx(&reg, t))
+      continue;
+
+    if (wild_ofs >= ggg.wild_page) {
+      load_seltab(t, ggg.defselN);
+      ggg.defselN++;
+    } else
+      wild_ofs++;
+
+    found=1;
+  } /* for t */
+
+
+  if (!found) {
+    bell_err();
+  } else
+  if (!ggg.wild_page) {
+    ggg.total_matchN = 0;
+
+    for(t=0; t< cur_inmd->DefChars; t++)
+      if (!cmp_inmd_idx(&reg, t))
+        ggg.total_matchN++;
+
+  }
+
+  if (ggg.total_matchN > cur_inmd->M_DUP_SEL)
+    ggg.more_pg = 1;
+
+  regfree(&reg);
+  disp_selection(FALSE);
+}
+
+static char *ptr_selkey(KeySym key)
+{
+  if (key>= XK_KP_0 && key<= XK_KP_9)
+    key-= XK_KP_0 - '0';
+  return strchr(cur_inmd->selkey, key);
+}
+
+
+void init_gtab_pho_query_win();
+int feedkey_pho(KeySym xkey, int state);
+
+void set_gtab_target_displayed()
+{
+  close_gtab_pho_win();
+}
+
+gboolean is_gtab_query_mode()
+{
+  return poo.same_pho_query_state == SAME_PHO_QUERY_pho_select;
+}
+
+void reset_gtab_all()
+{
+  if (!cur_inmd)
+    return;
+
+  ClrIn();
+  ClrSelArea();
+}
+
+
+static gboolean has_wild_card()
+{
+  int i;
+
+  for(i=0; i < cur_inmd->MaxPress; i++)
+    if (ggg.inch[i]>= cur_inmd->WILD_QUES) {
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+static void proc_wild_disp()
+{
+   DispInArea();
+   ggg.wild_page = 0;
+   wildcard();
+   disp_selection(0);
+}
+
+gboolean full_char_proc(KeySym keysym);
+void insert_gbuf_cursor_char(char ch);
+gboolean gtab_pre_select_shift(KeySym key, int kbstate);
+
+gboolean shift_char_proc(KeySym key, int kbstate)
+{
+    if (key >= 127)
+      return FALSE;
+
+#if 0
+    if (kbstate & LockMask) {
+      if (key >= 'a' && key <= 'z')
+        key-=0x20;
+    } else {
+      if (key >= 'A' && key <= 'Z')
+        key+=0x20;
+    }
+#endif
+
+    if (gtab_pre_select_shift(key, kbstate))
+      return TRUE;
+
+    if (current_CS->b_half_full_char)
+      return full_char_proc(key);
+
+    if (ggg.gbufN)
+      insert_gbuf_cursor_char(key);
+    else
+      send_ascii(key);
+
+    return TRUE;
+}
+
+extern GtkWidget *gwin_pho;
+gboolean feed_phrase(KeySym ksym, int state);
+int gtab_buf_backspace();
+gboolean output_gbuf();
+int show_buf_select();
+void gbuf_next_pg(), gbuf_prev_pg();
+void show_win_gtab();
+int gbuf_cursor_left();
+int gbuf_cursor_right();
+int gbuf_cursor_home();
+int gbuf_cursor_end();
+int gtab_buf_delete();
+void set_gbuf_c_sel(int v);
+void set_gtab_user_head();
+KeySym keypad_proc(KeySym xkey);
+void save_gtab_buf_phrase(KeySym key);
+gboolean save_gtab_buf_shift_enter();
+gboolean win_sym_page_up(), win_sym_page_down();
+u_int64_t vmaskci;
+gboolean gtab_pre_select_idx(int c);
+void save_CS_current_to_temp();
+void tsin_set_eng_ch(int nmod);
+
+gboolean feedkey_gtab(KeySym key, int kbstate)
+{
+  int i,j=0;
+  int inkey=0;
+  char *pselkey= NULL;
+  gboolean phrase_selected = FALSE;
+  char seltab_phrase[MAX_SELKEY];
+  gboolean is_keypad = FALSE;
+  gboolean shift_m = (kbstate & ShiftMask) > 0;
+//  gboolean ctrl_m = (kbstate & ControlMask) > 0;
+  gboolean capslock_on = (kbstate & LockMask);
+
+  bzero(seltab_phrase, sizeof(seltab_phrase));
+
+//  dbg("uuuuu %x %x   shift,ctrl:%d,%d\n", key, kbstate, shift_m, ctrl_m);
+
+  if (!cur_inmd)
+    return 0;
+
+  gboolean is_dayi = !strncmp(cur_inmd->filename, "dayi", 4);
+
+  if ((tsin_chinese_english_toggle_key == TSIN_CHINESE_ENGLISH_TOGGLE_KEY_CapsLock) &&
+      (key == XK_Caps_Lock)){
+    // The CapLock status may be incorrect when XK_Caps_Lock is pressed.
+    gboolean new_tsin_pho_mode = ! gdk_keymap_get_caps_lock_state(gdk_keymap_get_default());
+    if (current_CS->tsin_pho_mode != new_tsin_pho_mode) {
+      current_CS->tsin_pho_mode = new_tsin_pho_mode;
+      save_CS_current_to_temp();
+      tsin_set_eng_ch(new_tsin_pho_mode);
+    }
+  }
+
+  if ((kbstate & (Mod1Mask|Mod4Mask|Mod5Mask|ControlMask))==ControlMask
+     && key>='1' && key<='9' && ggg.gbufN) {
+    save_gtab_buf_phrase(key);
+    return 1;
+  }
+
+  if (ggg.gbufN && key==XK_Tab)
+    return 1;
+
+  if ((key==XK_Shift_L||key==XK_Shift_R) && !key_press_alt) {
+    key_press_alt = TRUE;
+    key_press_ctrl = FALSE;
+  } else if ((key==XK_Control_L||key==XK_Control_R) && !key_press_ctrl && tss.pre_selN) {
+    key_press_alt = FALSE;
+    key_press_ctrl = TRUE;
+    return TRUE;
+  } else {
+    key_press_alt = FALSE;
+    key_press_ctrl = FALSE;
+  }
+
+  if (kbstate & (Mod1Mask|Mod4Mask|Mod5Mask|ControlMask)) {
+    return 0;
+  }
+
+  if (poo.same_pho_query_state == SAME_PHO_QUERY_pho_select)
+    return feedkey_pho(key, 0);
+
+  if (poo.same_pho_query_state == SAME_PHO_QUERY_none && gwin_pho &&
+    GTK_WIDGET_VISIBLE(gwin_pho))
+     hide_win_pho();
+
+  if (!tsin_pho_mode()) {
+    if (key < 0x20 || key>=0x7f)
+      goto shift_proc;
+
+    if (capslock_on && hime_capslock_lower)
+      case_inverse((KeySym *)&key, shift_m);
+
+    if (ggg.gbufN)
+      insert_gbuf_cursor_char(key);
+    else
+      send_ascii(key);
+
+    return 1;
+  }
+
+
+  int lcase;
+  lcase = tolower(key);
+  int ucase;
+  ucase = toupper(key);
+  if (key < 127 && cur_inmd->keymap[key]) {
+    if (key < 'A' || key > 'z' || (key > 'Z'  && key < 'a') )
+      goto shift_proc;
+    if (cur_inmd->keymap[lcase] != cur_inmd->keymap[ucase])
+      goto next;
+  }
+
+
+shift_proc:
+  if (shift_m && !strchr(cur_inmd->selkey, key) && !ggg.more_pg && key>=' ' && key < 0x7e &&
+      key!='*' && (key!='?' || (gtab_shift_phrase_key && !ggg.ci))) {
+    if (gtab_shift_phrase_key) {
+      if (tss.pre_selN && shift_char_proc(key, kbstate))
+        return TRUE;
+      if (feed_phrase(key, kbstate))
+        return TRUE;
+    } else {
+      if (!cur_inmd->keymap[key] || (lcase != ucase &&
+           cur_inmd->keymap[lcase]==cur_inmd->keymap[ucase]))
+        return shift_char_proc(key, kbstate);
+    }
+  }
+
+  gboolean has_wild;
+  has_wild = FALSE;
+
+  switch (key) {
+    case XK_BackSpace:
+      ggg.last_idx=0;
+      ggg.spc_pressed=0;
+      ggg.sel1st_i=MAX_SELKEY-1;
+      clear_gtab_input_error_color();
+      hide_gtab_pre_sel();
+
+      if (ggg.ci==0) {
+        if (AUTO_SELECT_BY_PHRASE)
+          return gtab_buf_backspace();
+        else
+          return 0;
+      }
+
+      if (ggg.ci>0)
+        ggg.inch[--ggg.ci]=0;
+
+      if (has_wild_card()) {
+        proc_wild_disp();
+        return 1;
+      }
+
+
+      ggg.wild_mode=0;
+      ggg.invalid_spc = FALSE;
+      if (ggg.ci==1 && cur_inmd->use_quick) {
+        int i;
+        clr_seltab();
+        for(i=0;i<cur_inmd->M_DUP_SEL;i++)
+          utf8cpy(seltab[i], (char *)cur_inmd->qkeys->quick1[ggg.inch[0]-1][i]);
+
+        ggg.defselN=cur_inmd->M_DUP_SEL;
+        DispInArea();
+        goto Disp_opt;
+      } else
+      if (ggg.ci==2 && cur_inmd->use_quick) {
+        int i;
+        clr_seltab();
+        for(i=0;i<cur_inmd->M_DUP_SEL;i++)
+          utf8cpy(seltab[i], (char *)cur_inmd->qkeys->quick2[ggg.inch[0]-1][ggg.inch[1]-1][i]);
+
+        ggg.defselN=cur_inmd->M_DUP_SEL;
+        DispInArea();
+        goto Disp_opt;
+      }
+
+      break;
+    case XK_KP_Enter:
+    case XK_Return:
+      if (AUTO_SELECT_BY_PHRASE) {
+        hide_gtab_pre_sel();
+        if (shift_m) {
+          return save_gtab_buf_shift_enter();
+        } else
+          return output_gbuf();
+      }
+      else
+        return 0;
+    case XK_Up:
+      if (gtab_has_input())
+        return TRUE;
+      return FALSE;
+    case XK_Down:
+    case XK_KP_Down:
+      if (AUTO_SELECT_BY_PHRASE)
+        return show_buf_select();
+      else
+        return 0;
+    case XK_Escape:
+      hide_gtab_pre_sel();
+      if (ggg.gtab_buf_select) {
+        ggg.gtab_buf_select = 0;
+        reset_gtab_all();
+        ClrSelArea();
+        if (hime_pop_up_win && !gtab_has_input())
+          hide_win_gtab();
+        return 1;
+      }
+      ClrSelArea();
+      close_gtab_pho_win();
+      if (ggg.ci) {
+        reset_gtab_all();
+        return 1;
+      } else {
+        if (ggg.gbufN) {
+          set_gtab_user_head();
+          return 1;
+        }
+        ClrIn();
+        return 0;
+      }
+    case XK_Prior:
+    case XK_KP_Prior:
+    case XK_KP_Subtract:
+      if (ggg.wild_mode) {
+        if (ggg.wild_page >= cur_inmd->M_DUP_SEL) ggg.wild_page-=cur_inmd->M_DUP_SEL;
+        wildcard();
+        return 1;
+      } else
+      if (ggg.more_pg) {
+        if (ggg.gtab_buf_select) {
+          gbuf_prev_pg();
+          return 1;
+        }
+
+        ggg.pg_idx -= page_len();
+        if (ggg.pg_idx < ggg.S1)
+          ggg.pg_idx = ggg.S1;
+
+        goto next_pg;
+      }
+
+      if (key==XK_KP_Subtract)
+        goto keypad_proc;
+
+      return win_sym_page_up();
+    case XK_Next:
+    case XK_KP_Next:
+    case XK_KP_Add:
+      if (ggg.more_pg) {
+        if (ggg.gtab_buf_select) {
+          gbuf_next_pg();
+          return 1;
+        }
+next_page:
+//        dbg("more...\n");
+        ggg.pg_idx += page_len();
+        if (ggg.pg_idx >=ggg.E1)
+          ggg.pg_idx = ggg.S1;
+        goto next_pg;
+      } else {
+        if (key==XK_KP_Add)
+          goto keypad_proc;
+        if (win_sym_page_down())
+          return TRUE;
+        if (!ggg.gtab_buf_select && ggg.gbufN && AUTO_SELECT_BY_PHRASE)
+          return show_buf_select();
+        return FALSE;
+      }
+    case ' ':
+      hide_gtab_pre_sel();
+
+      if (ggg.invalid_spc && gtab_invalid_key_in)
+        ClrIn();
+
+      if (!gtab_invalid_key_in && ggg.spc_pressed && ggg.invalid_spc) {
+        ClrIn();
+        return 1;
+      }
+
+      has_wild = has_wild_card();
+
+//      dbg("ggg.wild_mode:%d ggg.more_pg:%d ggg.ci:%d  has_wild:%d\n", ggg.wild_mode, ggg.more_pg, ggg.ci, has_wild);
+
+      if (ggg.wild_mode) {
+        // request from tetralet
+        if (!ggg.wild_page && ggg.total_matchN < cur_inmd->M_DUP_SEL) {
+          ggg.sel1st_i = 0;
+          goto direct_select;
+        }
+
+        ggg.wild_page += cur_inmd->M_DUP_SEL;
+        if (ggg.wild_page >= ggg.total_matchN)
+          ggg.wild_page=0;
+
+        wildcard();
+        ggg.spc_pressed = TRUE;
+        return 1;
+      } else
+      if (ggg.more_pg && !(_gtab_space_auto_first & GTAB_space_auto_first_any)) {
+        if (ggg.gtab_buf_select) {
+          gbuf_next_pg();
+          return 1;
+        }
+        else
+          goto next_page;
+      } else
+      if (ggg.ci==0) {
+        if (current_CS->b_half_full_char)
+          return full_char_proc(key);
+
+        if (ggg.gbufN) {
+          output_gbuf();
+        } else
+          return 0;
+      } else
+      if (!has_wild) {
+//        dbg("iii %d  ggg.defselN:%d   %d\n", ggg.sel1st_i, ggg.defselN, cur_inmd->M_DUP_SEL);
+        if (_gtab_space_auto_first == GTAB_space_auto_first_any && seltab[0][0] &&
+            ggg.sel1st_i==MAX_SELKEY-1) {
+          ggg.sel1st_i = 0;
+        }
+
+        if (_gtab_space_auto_first == GTAB_space_auto_first_nofull && ggg.exa_match > 1
+            && !AUTO_SELECT_BY_PHRASE && gtab_dup_select_bell)
+          bell();
+
+        if (seltab[ggg.sel1st_i][0]) {
+//          dbg("ggg.last_full %d %d\n", ggg.last_full,ggg.spc_pressed);
+          if (gtab_full_space_auto_first || ggg.spc_pressed) {
+direct_select:
+            if (AUTO_SELECT_BY_PHRASE && poo.same_pho_query_state != SAME_PHO_QUERY_gtab_input) {
+//              dbg("ins ggg.kval %x\n", ggg.kval);
+              insert_gbuf_cursor1_cond(seltab[ggg.sel1st_i], ggg.kval, ggg.exa_match);
+            }
+            else
+              putstr_inp(seltab[ggg.sel1st_i]);  /* select 1st */
+            return 1;
+          }
+        }
+      }
+
+      ggg.last_full=0;
+      ggg.spc_pressed=1;
+//      dbg("spc_pressed=1\n");
+
+      if (has_wild) {
+        ggg.wild_page=0;
+        ggg.wild_mode=1;
+        wildcard();
+        return 1;
+      }
+
+      break;
+    case '?':
+    case '*':
+      if ((!gtab_que_wild_card && key == '?') || (!gtab_que_wild_card_asterisk && key == '*')) {
+        inkey=cur_inmd->keymap[key];
+        if ((inkey && (inkey!=cur_inmd->WILD_QUES && inkey!=cur_inmd->WILD_STAR)) || ptr_selkey(key))
+          goto next;
+        if (AUTO_SELECT_BY_PHRASE && ggg.gbufN) {
+          insert_gbuf_cursor_char(key);
+          return 1;
+        } else {
+          if (current_CS->b_half_full_char)
+            return full_char_proc(key);
+	  else
+            return 0;
+	}
+      }
+      if (tss.pre_selN && shift_char_proc(key, kbstate))
+        return TRUE;
+
+      // if (current_CS->b_half_full_char)
+      //  return full_char_proc(key);
+
+      inkey=cur_inmd->keymap[key];
+      if ((inkey && (inkey!=cur_inmd->WILD_STAR && inkey!=cur_inmd->WILD_QUES)) || ptr_selkey(key)) {
+//        dbg("%d %d\n", inkey, cur_inmd->WILD_STAR);
+        goto next;
+      }
+      if (ggg.ci< cur_inmd->MaxPress) {
+        ggg.inch[ggg.ci++]=inkey;
+        DispInArea();
+
+        if (hime_pop_up_win)
+          show_win_gtab();
+
+        ggg.total_matchN = 0;
+        ggg.wild_page=0;
+        ggg.wild_mode=1;
+        wildcard();
+        return 1;
+      }
+      return 0;
+    case XK_Left:
+    case XK_KP_Left:
+      return gbuf_cursor_left();
+    case XK_Right:
+    case XK_KP_Right:
+      return gbuf_cursor_right();
+    case XK_Home:
+    case XK_KP_Home:
+      return gbuf_cursor_home();
+    case XK_End:
+    case XK_KP_End:
+      return gbuf_cursor_end();
+    case XK_Delete:
+    case XK_KP_Delete:
+      return gtab_buf_delete();
+    case XK_Shift_L:
+    case XK_Shift_R:
+    case XK_Control_R:
+    case XK_Control_L:
+    case XK_Alt_L:
+    case XK_Alt_R:
+    case XK_Caps_Lock:
+      return 0;
+    case '`':
+      if (gtab_pho_query && !cur_inmd->keymap[key]) {
+        poo.same_pho_query_state = SAME_PHO_QUERY_gtab_input;
+        reset_gtab_all();
+        disp_gtab_sel(_(""));
+        if (hime_pop_up_win)
+          show_win_gtab();
+        disp_pho_sel("");
+        init_gtab_pho_query_win();
+        return 1;
+      }
+    default:
+next:
+
+      if (key < 0x7f)
+        inkey= cur_inmd->keymap[key];
+      else
+        inkey = 0;
+
+      if (shift_m && !inkey && !tss.ctrl_pre_sel &&
+        tss.pre_selN && shift_char_proc(key, kbstate))
+        return TRUE;
+
+      clear_gtab_input_error_color();
+
+      if (ggg.invalid_spc && gtab_invalid_key_in) {
+        ClrIn();
+      }
+      if (key>=XK_KP_0 && key<=XK_KP_9) {
+        if (!ggg.ci) {
+          if (ggg.gbufN) {
+            insert_gbuf_cursor_char(key - XK_KP_0 + '0');
+            return 1;
+          } else
+            return 0;
+        }
+        if (is_dayi) {
+          key = key - XK_KP_0 + '0';
+          is_keypad = TRUE;
+        }
+      }
+
+      int keypad;
+keypad_proc:
+      keypad = keypad_proc(key);
+      if (keypad) {
+        if (!ggg.ci) {
+          if (ggg.gbufN) {
+            insert_gbuf_cursor_char(keypad);
+            return 1;
+          } else
+            return 0;
+        }
+      }
+      char *pendkey = strchr(cur_inmd->endkey, key);
+
+      pselkey=ptr_selkey(key);
+
+      if (!pselkey && (key < 32 || key > 0x7e) && (gtab_full_space_auto_first || ggg.spc_pressed)) {
+//        dbg("%x %x ggg.sel1st_i:%d  '%c'\n", pselkey, key, ggg.sel1st_i, seltab[ggg.sel1st_i][0]);
+        if (seltab[ggg.sel1st_i][0]) {
+          if (AUTO_SELECT_BY_PHRASE && poo.same_pho_query_state != SAME_PHO_QUERY_gtab_input)
+            insert_gbuf_cursor1_cond(seltab[ggg.sel1st_i], ggg.kval, ggg.exa_match);
+          else
+            putstr_inp(seltab[ggg.sel1st_i]);  /* select 1st */
+        }
+
+        return 0;
+      }
+
+
+
+//        dbg("ggg.spc_pressed %d %d %d is_keypad:%d\n", ggg.spc_pressed, ggg.last_full, cur_inmd->MaxPress, is_keypad);
+
+#if 1 // for dayi, testcase :  6 space keypad6
+      int vv = pselkey - cur_inmd->selkey;
+      if (pselkey && tss.pre_selN && !ggg.gtab_buf_select && (tss.ctrl_pre_sel||
+          ((!inkey||ggg.spc_pressed||is_keypad)&&! gtab_disp_partial_match_on() && !gtab_pre_select_on()))) {
+        if (gtab_pre_select_idx(vv))
+          return TRUE;
+      } else
+      if (( (ggg.spc_pressed||ggg.last_full||is_keypad) ||(ggg.wild_mode && (!inkey ||pendkey)) || ggg.gtab_buf_select) && pselkey) {
+        if ((_gtab_space_auto_first & GTAB_space_auto_first_any) && !ggg.wild_mode)
+          vv++;
+
+        if (vv<0)
+          vv=9;
+
+        if (seltab[vv][0]) {
+          if (AUTO_SELECT_BY_PHRASE && !same_query_show_pho_win()) {
+            if (ggg.gtab_buf_select && poo.same_pho_query_state != SAME_PHO_QUERY_gtab_input)
+              set_gbuf_c_sel(vv);
+            else
+              insert_gbuf_cursor1_cond(seltab[vv], ggg.kval, ggg.exa_match);
+          }
+          else {
+            putstr_inp(seltab[vv]);
+          }
+
+          if (hime_pop_up_win && !gtab_has_input())
+            hide_win_gtab();
+
+          return 1;
+        }
+      }
+#endif
+
+//      dbg("iii %x sel1st_i:%d auto:%d\n", pselkey, ggg.sel1st_i, AUTO_SELECT_BY_PHRASE);
+      if (seltab[ggg.sel1st_i][0] && !ggg.wild_mode &&
+           (gtab_full_space_auto_first||ggg.spc_pressed||ggg.last_full) ) {
+        if (AUTO_SELECT_BY_PHRASE && poo.same_pho_query_state != SAME_PHO_QUERY_gtab_input)
+          insert_gbuf_cursor1_cond(seltab[ggg.sel1st_i], ggg.kval, ggg.exa_match);
+        else
+          putstr_inp(seltab[ggg.sel1st_i]);  /* select 1st */
+      }
+#if 0
+      if (key > 0x7f) {
+        return 0;
+      }
+#endif
+
+      ggg.spc_pressed=0;
+
+      // for cj & boshiamy to input digits
+      if (!ggg.ci && !inkey) {
+        if (current_CS->b_half_full_char)
+          return full_char_proc(key);
+        else {
+          if (ggg.gbufN && poo.same_pho_query_state != SAME_PHO_QUERY_gtab_input) {
+            insert_gbuf_cursor_char(key);
+            return 1;
+          }
+          else
+            return 0;
+        }
+      }
+
+      if (ggg.wild_mode && inkey>=1 && ggg.ci< cur_inmd->MaxPress) {
+        ggg.inch[ggg.ci++]=inkey;
+        if (hime_pop_up_win)
+          show_win_gtab();
+        proc_wild_disp();
+        return 1;
+      }
+
+      if (inkey>=1 && ggg.ci< cur_inmd->MaxPress) {
+        ggg.inch[ggg.ci++]=inkey;
+        hide_gtab_pre_sel();
+
+        if (hime_pop_up_win)
+          show_win_gtab();
+        ggg.last_full=0;
+
+        if (cur_inmd->use_quick && !pendkey) {
+          if (ggg.ci==1) {
+            int i;
+            for(i=0;i < cur_inmd->M_DUP_SEL; i++) {
+              utf8cpy(seltab[i], (char *)&cur_inmd->qkeys->quick1[inkey-1][i]);
+            }
+
+            ggg.defselN=cur_inmd->M_DUP_SEL;
+            DispInArea();
+            goto Disp_opt;
+          } else
+          if (ggg.ci==2 && !pselkey) {
+            int i;
+            for(i=0;i < cur_inmd->M_DUP_SEL; i++) {
+              utf8cpy(seltab[i], (char *)&cur_inmd->qkeys->quick2[ggg.inch[0]-1][inkey-1][i]);
+            }
+
+            ggg.defselN=cur_inmd->M_DUP_SEL;
+            DispInArea();
+            goto Disp_opt;
+          }
+        }
+      } else
+      if (ggg.ci == cur_inmd->MaxPress && !pselkey) {
+        bell();
+        return 1;
+      }
+
+
+      if (inkey) {
+        for(i=0; i < MAX_TAB_KEY_NUM64_6; i++)
+          if (ggg.inch[i]>=cur_inmd->WILD_QUES) {
+            DispInArea();
+            if (ggg.ci==cur_inmd->MaxPress) {
+              ggg.wild_mode=1;
+              ggg.wild_page=0;
+              wildcard();
+            }
+
+            return 1;
+          }
+      } else {
+        if (!pselkey) {
+          if (current_CS->b_half_full_char)
+            return full_char_proc(key);
+          else {
+            if (key>=' ' && key<0x7f && AUTO_SELECT_BY_PHRASE && ggg.gbufN)
+              insert_gbuf_cursor_char(key);
+            else
+              return 0;
+          }
+        }
+
+        if (ggg.defselN) {
+          goto YYYY;
+        }
+     }
+  } /* switch */
+
+
+  if (ggg.ci==0) {
+    ClrSelArea();
+    ClrIn();
+    return 1;
+  }
+
+  ggg.invalid_spc = FALSE;
+  char *pendkey = NULL;
+  pendkey = strchr(cur_inmd->endkey, key);
+
+  DispInArea();
+
+  ggg.kval=0;
+
+  for(i=0; i < Max_tab_key_num; i++) {
+    ggg.kval|= (u_int64_t)ggg.inch[i] << (KeyBits * (Max_tab_key_num - 1 - i));
+  }
+
+#if 1
+  if (ggg.last_idx)
+    ggg.S1=ggg.last_idx;
+  else
+#endif
+    ggg.S1=cur_inmd->idx1[ggg.inch[0]];
+
+//  dbg("--------- ch:%d %d val %llx  ggg.S1:%d\n", ggg.inch[0], Max_tab_key_num, ggg.kval, ggg.S1);
+
+  int oE1;
+  oE1=cur_inmd->idx1[ggg.inch[0]+1];
+  if (cur_inmd->keybits==6)
+    vmaskci = cur_inmd->key64 ? vmask64[ggg.ci]:vmask[ggg.ci];
+  else
+    vmaskci = cur_inmd->key64 ? vmask64_7[ggg.ci]:vmask_7[ggg.ci];
+
+  gtab_scan_pre_select(TRUE);
+
+  while ((CONVT2(cur_inmd, ggg.S1) & vmaskci) != ggg.kval &&
+          CONVT2(cur_inmd, ggg.S1) < ggg.kval &&  ggg.S1<oE1)
+    ggg.S1++;
+
+  ggg.pg_idx=ggg.last_idx=ggg.S1;
+
+
+#if 0
+  dbg("MaxPress:%d vmaskci:%llx kval:%llx ggg.ci:%d  !=%d  S1:%d  kval:%x\n", cur_inmd->MaxPress,
+  vmaskci, ggg.kval, ggg.ci,
+  ((CONVT2(cur_inmd, ggg.S1) & vmaskci)!=ggg.kval), ggg.S1);
+#endif
+
+  if ((CONVT2(cur_inmd, ggg.S1) & vmaskci)!=ggg.kval || (ggg.wild_mode && ggg.defselN) ||
+                  ((/* ggg.ci==cur_inmd->MaxPress|| */ ggg.spc_pressed) && ggg.defselN &&
+      (pselkey && ( pendkey || ggg.spc_pressed)) ) ) {
+YYYY:
+
+    if ((pselkey || ggg.wild_mode) && ggg.defselN) {
+      int vv = pselkey - cur_inmd->selkey;
+
+      if ((_gtab_space_auto_first & GTAB_space_auto_first_any) && !ggg.wild_mode
+          && ggg.exa_match && (!cur_inmd->use_quick || ggg.ci!=2))
+        vv++;
+
+      if (vv<0)
+        vv=9;
+
+      if (seltab[vv][0]) {
+        if (AUTO_SELECT_BY_PHRASE && poo.same_pho_query_state != SAME_PHO_QUERY_gtab_input)
+          insert_gbuf_cursor1_cond(seltab[vv], ggg.kval, ggg.exa_match);
+        else
+          putstr_inp(seltab[vv]);
+        return 1;
+      }
+    }
+
+    if (pselkey && !ggg.defselN)
+      return 0;
+
+    if (gtab_invalid_key_in) {
+      if (ggg.spc_pressed) {
+        bell_err();
+        ggg.invalid_spc = TRUE;
+//        dbg("ggg.invalid_spc\n");
+      } else {
+        seltab[0][0]=0;
+        ClrSelArea();
+      }
+    } else {
+      if (gtab_dup_select_bell)
+        bell();
+
+      if (ggg.ci>0)
+        ggg.inch[--ggg.ci]=0;
+    }
+
+    ggg.last_idx=0;
+    DispInArea();
+    return 1;
+  }
+
+//refill:
+
+  j=ggg.S1;
+  while(CONVT2(cur_inmd, j)==ggg.kval && j<oE1)
+    j++;
+
+  ggg.E1 = j;
+  ggg.total_matchN = ggg.E1 - ggg.S1;
+  ggg.pg_idx = ggg.S1;
+
+  ggg.more_pg = 0;
+  if (ggg.total_matchN > page_len()) {
+    if ((_gtab_space_auto_first & GTAB_space_auto_first_any) || ggg.spc_pressed || pendkey ||
+      (ggg.ci==cur_inmd->MaxPress && (_gtab_space_auto_first & GTAB_space_auto_first_full)))
+      ggg.more_pg = 1;
+  }
+
+  if (ggg.ci < cur_inmd->MaxPress && !ggg.spc_pressed && !pendkey && !ggg.more_pg) {
+    j = ggg.S1;
+    ggg.exa_match=0;
+    clr_seltab();
+    int match_cnt=0;
+
+    while (CONVT2(cur_inmd, j)==ggg.kval && ggg.exa_match <= page_len()) {
+      seltab_phrase[ggg.exa_match] = load_seltab(j, ggg.exa_match);
+      match_cnt++;
+      ggg.exa_match++;
+      j++;
+    }
+
+    ggg.defselN=ggg.exa_match;
+//    dbg("--- ggg.exa_match %d\n", ggg.exa_match);
+
+    if (ggg.defselN > page_len())
+      ggg.defselN--;
+
+    int shiftb=(KEY_N - 1 -ggg.ci) * KeyBits;
+
+//    if (gtab_disp_partial_match_on)
+    while((CONVT2(cur_inmd, j) & vmaskci)==ggg.kval && j<oE1) {
+      int fff=cur_inmd->keycol[(CONVT2(cur_inmd, j)>>shiftb) & cur_inmd->kmask];
+      u_char *tbl_ch = tblch(j);
+
+      if (gtab_disp_partial_match_on() && (!seltab[fff][0] || seltab_phrase[fff] ||
+           (bchcmp(seltab[fff], tbl_ch)>0 && fff > ggg.exa_match))) {
+        seltab_phrase[fff] = load_seltab(j, fff);
+        ggg.defselN++;
+      }
+
+      match_cnt++;
+#if 0
+      dbg("jj %d", fff); utf8_putchar(seltab[fff]); dbg("\n");
+#endif
+      j++;
+    }
+
+    if (gtab_unique_auto_send_on()) {
+      char *first_str=NULL;
+      for(i=0; i < page_len(); i++) {
+        if (!seltab[i][0])
+          continue;
+        if (!first_str)
+          first_str = seltab[i];
+      }
+
+      if (match_cnt==1 && first_str) {
+        if (AUTO_SELECT_BY_PHRASE && poo.same_pho_query_state != SAME_PHO_QUERY_gtab_input)
+          insert_gbuf_nokey(first_str);
+        else
+          putstr_inp(first_str);
+        return 1;
+      }
+    }
+  } else {
+//    dbg("more %d %d  skip_end:%d\n", ggg.more_pg,  ggg.total_matchN, cur_inmd->flag&FLAG_PHRASE_AUTO_SKIP_ENDKEY);
+next_pg:
+    ggg.defselN=0;
+    clr_seltab();
+    if (pendkey && (!(cur_inmd->flag&FLAG_PHRASE_AUTO_SKIP_ENDKEY) || !AUTO_SELECT_BY_PHRASE || ggg.ci==1)) {
+//      dbg("spc_pressed = 1\n");
+      ggg.spc_pressed = 1;
+    }
+
+    if (ggg.ci==cur_inmd->MaxPress)
+      ggg.last_full=1;
+    int full_send = gtab_press_full_auto_send_on() && ggg.last_full;
+
+//    dbg("flag %d\n",!(pendkey && (cur_inmd->flag&FLAG_PHRASE_AUTO_SKIP_ENDKEY)));
+    if (AUTO_SELECT_BY_PHRASE && !(pendkey && (cur_inmd->flag&FLAG_PHRASE_AUTO_SKIP_ENDKEY))
+        && poo.same_pho_query_state != SAME_PHO_QUERY_gtab_input &&
+        (ggg.spc_pressed||full_send)) {
+      j = ggg.S1;
+      int selN=0;
+      char **sel = NULL;
+
+//     puts("kkkkkkkkkkk");
+      while(j<ggg.E1 && CONVT2(cur_inmd, j)==ggg.kval && selN < 255) {
+        sel = trealloc(sel, char *, selN+1);
+        sel[selN++] = load_tblidx(j);
+        j++;
+      }
+      insert_gbuf_cursor(sel, selN, ggg.kval, FALSE);
+      gtab_scan_pre_select(FALSE);
+      clear_after_put();
+      return 1;
+    } else {
+      j = ggg.pg_idx;
+
+//      dbg("jjjjjjjjjjjjjjjjjj");
+      while(j<ggg.E1 && CONVT2(cur_inmd, j)==ggg.kval && ggg.defselN < page_len()) {
+        load_seltab(j, ggg.defselN);
+
+        j++; ggg.defselN++;
+
+        if (ggg.ci == cur_inmd->MaxPress || ggg.spc_pressed) {
+          ggg.sel1st_i=0;
+//          dbg("ggg.sel1st_i %d %d %d\n", ggg.ci, cur_inmd->MaxPress, ggg.spc_pressed);
+        }
+      }
+    }
+
+    ggg.exa_match = ggg.defselN;
+//    dbg("ggg.defselN %d\n", ggg.defselN);
+
+
+    if (ggg.defselN==1 && !ggg.more_pg) {
+      if (ggg.spc_pressed || full_send || gtab_unique_auto_send_on()) {
+        if (AUTO_SELECT_BY_PHRASE && poo.same_pho_query_state != SAME_PHO_QUERY_gtab_input)
+          insert_gbuf_cursor1_cond(seltab[0], ggg.kval, ggg.exa_match);
+        else
+          putstr_inp(seltab[0]);
+        return 1;
+      }
+    } else
+    if (!ggg.defselN) {
+      bell_err();
+//      ggg.spc_pressed=0;
+//      if (gtab_invalid_key_in)
+      {
+        ggg.invalid_spc = TRUE;
+        return TRUE;
+      }
+
+      return TRUE;
+    } else
+    if (!ggg.more_pg) {
+      if (gtab_dup_select_bell && (gtab_disp_partial_match_on() || gtab_pre_select_or_partial_on())) {
+        if (ggg.spc_pressed || gtab_full_space_auto_first || (ggg.last_full && gtab_press_full_auto_send_on()))
+          bell();
+      }
+    }
+  }
+
+Disp_opt:
+  if (gtab_disp_partial_match_on() || gtab_pre_select_or_partial_on() || ((ggg.exa_match > 1 || ggg.more_pg) &&
+    (ggg.spc_pressed || gtab_press_full_auto_send_on() ||
+    (ggg.ci==cur_inmd->MaxPress && (_gtab_space_auto_first & GTAB_space_auto_first_full))) ) ) {
+       disp_selection(phrase_selected);
+  }
+
+  return 1;
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/gtab.h b/src/plugins/platforminputcontexts/hime/include/gtab.h
new file mode 100644
index 0000000..a30b937
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/gtab.h
@@ -0,0 +1,167 @@
+/* Copyright (C) 2004-2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+typedef enum {
+  GTAB_space_auto_first_none=0,   // use the value set by .cin
+  GTAB_space_auto_first_any=1,    // boshiamy, dayi
+  GTAB_space_auto_first_full=2,   // simplex
+  GTAB_space_auto_first_nofull=4,  // windows ar30 cj
+  GTAB_space_auto_first_dayi=8    // dayi: input:2   select:1
+} GTAB_space_pressed_E;
+
+typedef struct {
+  u_char key[4];   /* If I use u_long key, the struc size will be 8 */
+  u_char ch[CH_SZ];
+} ITEM;
+
+typedef struct {
+  u_char key[8];   /* If I use u_long key, the struc size will be 8 */
+  u_char ch[CH_SZ];
+} ITEM64;
+
+typedef struct {
+  char quick1[46][10][CH_SZ];
+  char quick2[46][46][10][CH_SZ];
+} QUICK_KEYS;
+
+
+enum {
+  FLAG_KEEP_KEY_CASE=1,
+  FLAG_GTAB_SYM_KBM=2, // auto close, auto switch to default input method
+  FLAG_PHRASE_AUTO_SKIP_ENDKEY=4,
+  FLAG_AUTO_SELECT_BY_PHRASE=8,
+  FLAG_GTAB_DISP_PARTIAL_MATCH=0x10,
+  FLAG_GTAB_DISP_FULL_MATCH=0x20,
+  FLAG_GTAB_VERTICAL_SELECTION=0x40,
+  FLAG_GTAB_PRESS_FULL_AUTO_SEND=0x80,
+  FLAG_GTAB_UNIQUE_AUTO_SEND=0x100,
+};
+
+enum {
+  GTAB_OPTION_AUTO=0,
+  GTAB_OPTION_YES=1,
+  GTAB_OPTION_NO=2,
+};
+
+
+#define MAX_SELKEY 16
+
+struct TableHead {
+  int version;
+  u_int flag;
+  char cname[32];         /* prompt */
+  char selkey[12];        /* select keys */
+  GTAB_space_pressed_E space_style;
+  int KeyS;               /* number of keys needed */
+  int MaxPress;           /* Max len of keystroke  ar30:4  changjei:5 */
+  int M_DUP_SEL;          /* how many keys used to select */
+  int DefC;               /* Defined characters */
+  QUICK_KEYS qkeys;
+
+  union {
+    struct {
+      char endkey[99];
+      char keybits;
+      char selkey2[10];
+    };
+
+    char dummy[128];  // for future use
+  };
+};
+
+
+#define KeyBits1(inm) (inm->keybits)
+#define KeyBits (cur_inmd->keybits)
+#define MAX_GTAB_KEYS (1<<KeyBits)
+
+#define MAX_TAB_KEY_NUM (32/KeyBits)
+#define MAX_TAB_KEY_NUM1(inm) (32/KeyBits1(inm))
+#define MAX_TAB_KEY_NUM64 (64/KeyBits)
+#define MAX_TAB_KEY_NUM641(inm) (64/KeyBits1(inm))
+
+struct _HIME_module_callback_functions;
+typedef u_int gtab_idx1_t;
+
+typedef struct {
+  ITEM *tbl;
+  ITEM64 *tbl64;
+  QUICK_KEYS *qkeys;
+  int use_quick;
+  u_int flag;
+#define MAX_CNAME (4*CH_SZ+1)
+  char *cname;
+  char *keycol;
+  int KeyS;               /* number of keys needed */
+  int MaxPress;           /* Max len of keystrike  ar30:5  changjei:5 */
+  int DefChars;           /* defined chars */
+  char *keyname; // including ?*
+  char *keyname_lookup; // used by boshiamy only
+  gtab_idx1_t *idx1;
+  char *keymap;
+  char *selkey;
+  u_char *sel1st;
+  int M_DUP_SEL;
+  int phrnum;
+  int *phridx;
+  char *phrbuf;
+  char *filename, *filename_append;
+  time_t file_modify_time;
+  gboolean key64; // db is 64 bit-long key
+  gboolean disabled; // will not be display in the selection menu
+  int max_keyN;
+  char *endkey;       // only pinin/ar30 use it
+  GTAB_space_pressed_E space_style;
+  char *icon;
+  u_char kmask, keybits, last_k_bitn, method_type;
+  char WILD_QUES, WILD_STAR;
+  struct _HIME_module_callback_functions *mod_cb_funcs;
+  char key_ch, in_cycle;
+} INMD;
+
+enum {
+  method_type_GTAB=1,
+  method_type_PHO=3,
+  method_type_TSIN=6,
+  method_type_MODULE=12,
+  method_type_SYMBOL_TABLE=13,
+  method_type_EN=14,
+};
+
+extern INMD *inmd;
+extern int inmdN;
+
+u_int64_t CONVT2(INMD *inmd, int i);
+extern INMD *cur_inmd;
+void load_gtab_list(gboolean);
+char current_method_type();
+
+#define LAST_K_bitN (cur_inmd->last_k_bitn)
+
+#define KEY_MASK ((1<<cur_inmd->keybits)-1);
+
+
+#define GTAB_LIST "gtab.list"
+
+#if 1
+#define NEED_SWAP (__BYTE_ORDER == __BIG_ENDIAN && 0)
+#else
+#define NEED_SWAP (1)
+#endif
+
+#define tblch2(inm, i) (inm->key64 ? inm->tbl64[i].ch:inm->tbl[i].ch)
+#define Max_tab_key_num1(inm) (inm->key64 ? MAX_TAB_KEY_NUM641(inm) : MAX_TAB_KEY_NUM1(inm))
+#define Max_tab_key_num Max_tab_key_num1(cur_inmd)
diff --git a/src/plugins/platforminputcontexts/hime/include/hime-conf.c b/src/plugins/platforminputcontexts/hime/include/hime-conf.c
new file mode 100644
index 0000000..527ed91
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/hime-conf.c
@@ -0,0 +1,246 @@
+/* Copyright (C) 2010 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "hime.h"
+#include <dirent.h>
+#include <X11/Xatom.h>
+#include <glib.h>
+
+#if !CLIENT_LIB
+char *TableDir=HIME_TABLE_DIR;
+GKeyFile *hime_omni_config = NULL;
+#define HIME_CONF "/hime.conf"
+
+void init_TableDir()
+{
+  char *dname;
+  if ((dname=getenv("HIME_TABLE_DIR"))) {
+    TableDir = dname;
+    return;
+  }
+}
+
+
+void get_hime_dir(char *tt)
+{
+    char *home = getenv("HOME");
+    if (!home)
+      home = "";
+    strcpy(tt,home);
+    strcat(tt,"/.config/hime");
+}
+
+void init_omni_config(void)
+{
+  char omni_config_fname[256];
+  int len;
+  GError *error = NULL;
+
+  if (hime_omni_config)
+    return;
+
+  memset(omni_config_fname, 0, 256);
+  get_hime_dir(omni_config_fname);
+  len = strlen(omni_config_fname);
+  snprintf(omni_config_fname + len, 256 - len, HIME_CONF);
+
+  hime_omni_config = g_key_file_new();
+  /* Ignore error */
+  g_key_file_load_from_file(hime_omni_config, omni_config_fname, 0, &error);
+}
+
+void free_omni_config(void)
+{
+  if (hime_omni_config) {
+    g_key_file_free(hime_omni_config);
+    hime_omni_config = NULL;
+  }
+}
+
+void save_omni_config(void)
+{
+  char omni_config_fname[256];
+  int len;
+  FILE *f;
+  gchar *buff;
+  gsize bufflen;
+  GError *error = NULL;
+
+  if (NULL == hime_omni_config)
+    return;
+
+  memset(omni_config_fname, 0, 256);
+  get_hime_dir(omni_config_fname);
+  len = strlen(omni_config_fname);
+  snprintf(omni_config_fname + len, 256 - len, HIME_CONF);
+  f = fopen(omni_config_fname, "w");
+  if (f) {
+    buff = g_key_file_to_data(hime_omni_config, &bufflen, &error);
+    if (NULL == buff)
+      return;
+    fwrite(buff, 1, bufflen, f);
+    fclose(f);
+    g_free(buff);
+  }
+}
+
+gboolean get_hime_user_fname(char *name, char fname[])
+{
+  get_hime_dir(fname);
+  strcat(strcat(fname,"/"),name);
+  return !access(fname, R_OK);
+//  dbg("get_hime_user_fname %s %s\n", name, fname);
+}
+
+void get_hime_conf_fname(char *name, char fname[])
+{
+  get_hime_dir(fname);
+  strcat(strcat(fname,"/config/"),name);
+}
+
+void get_hime_user_or_sys_fname(char *name, char fname[])
+{
+  if (!getenv("HIME_TABLE_DIR")) {
+    if (get_hime_user_fname(name, fname))
+      return;
+  }
+
+  get_sys_table_file_name(name, fname);
+}
+
+void get_hime_conf_str(char *name, char **rstr, char *default_str)
+{
+  char fname[MAX_HIME_STR];
+  char out[256];
+
+  if (*rstr)
+    free(*rstr);
+
+  *rstr = g_key_file_get_string(hime_omni_config, "HIME", name, NULL);
+  if (NULL != *rstr) {
+    return;
+  }
+
+  /* Compatible for previous configuration */
+  get_hime_conf_fname(name, fname);
+
+  FILE *fp;
+
+  if ((fp=fopen(fname, "rb")) == NULL) {
+    *rstr = strdup(default_str);
+    return;
+  }
+
+  myfgets(out, sizeof(out), fp);
+  int len = strlen(out);
+  if (len && out[len-1]=='\n')
+    out[len-1] = 0;
+
+  fclose(fp);
+
+  *rstr = strdup(out);
+}
+
+void get_hime_conf_fstr(char *name, char rstr[], char *default_str)
+{
+  char *tt = NULL;
+  get_hime_conf_str(name, &tt, default_str);
+  strcpy(rstr, tt);
+  free(tt);
+}
+
+int get_hime_conf_int(char *name, int default_value)
+{
+  char tt[32];
+  char default_value_str[MAX_HIME_STR];
+
+  sprintf(default_value_str, "%d", default_value);
+  get_hime_conf_fstr(name, tt, default_value_str);
+
+  return atoi(tt);
+}
+
+
+void save_hime_conf_str(char *name, char *str)
+{
+  FILE *fp;
+  char fname[256];
+
+  g_key_file_set_value(hime_omni_config, "HIME", name, str);
+
+  /* Compatible for previous configuration */
+  get_hime_conf_fname(name, fname);
+
+  if ((fp=fopen(fname,"wb"))==NULL) {
+    p_err("cannot create %s", fname);
+  }
+
+  fprintf(fp, "%s", str);
+  fclose(fp);
+}
+
+
+void save_hime_conf_int(char *name, int val)
+{
+  char tt[16];
+
+  sprintf(tt, "%d", val);
+  save_hime_conf_str(name, tt);
+}
+
+void get_sys_table_file_name(char *name, char *fname)
+{
+  sprintf(fname, "%s/%s", TableDir, name);
+}
+#endif /* !CLIENT_LIB */
+
+char *get_hime_xim_name()
+{
+  char *xim_name;
+
+  if ((xim_name=getenv("XMODIFIERS"))) {
+    static char find[] = "@im=";
+    static char sstr[32];
+    char *p = strstr(xim_name, find);
+
+    if (p==NULL) return "hime";
+
+    p += strlen(find);
+    strncpy(sstr, p, sizeof(sstr));
+    sstr[sizeof(sstr) - 1]=0;
+
+    if ((p=strchr(sstr, '.')))
+      *p=0;
+
+//    dbg("Try to use name from XMODIFIERS=@im=%s\n", sstr);
+    return sstr;
+  }
+
+  return "hime";
+}
+
+Atom get_hime_atom(Display *dpy)
+{
+  char *xim_name = get_hime_xim_name();
+  char tt[128];
+
+  snprintf(tt, sizeof(tt), "HIME_ATOM_%s", xim_name);
+
+  Atom atom = XInternAtom(dpy, tt, False);
+
+  return atom;
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/hime-conf.h b/src/plugins/platforminputcontexts/hime/include/hime-conf.h
new file mode 100644
index 0000000..4ef79f1
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/hime-conf.h
@@ -0,0 +1,159 @@
+#define CHANGE_FONT_SIZE "change font size"
+#define GB_OUTPUT_TOGGLE "gb output toggle"
+#define SIM_OUTPUT_TOGGLE "gb output sim"
+#define TRAD_OUTPUT_TOGGLE "gb output trad"
+#define KBM_TOGGLE "kbm toggle"
+#define UPDATE_TRAY "update tray"
+#define RELOAD_TSIN_DB "reload tsin db"
+#define HIME_EXIT_MESSAGE "hime exit"
+
+
+#define HIME_SETUP_WINDOW_TYPE_UTILITY "hime-setup-window-type-utility"
+#define HIME_FONT_SIZE "hime-font-size"
+#define HIME_FONT_NAME "hime-font-name"
+#define HIME_FONT_SIZE_TSIN_PRESEL "hime-font-size-tsin-presel"
+#define HIME_FONT_SIZE_SYMBOL "hime-font-size-symbol"
+#define HIME_FONT_SIZE_TSIN_PHO_IN "hime-font-size-tsin-pho-in"
+#define HIME_FONT_SIZE_GTAB_IN "hime-font-size-gtab-in"
+#define HIME_FONT_SIZE_PHO_NEAR "hime-font-size-pho-near"
+#define HIME_FONT_SIZE_WIN_KBM "hime-font-size-win-kbm"
+#define HIME_FONT_SIZE_WIN_KBM_EN "hime-font-size-win-kbm-en"
+#define HIME_INPUT_STYLE "hime-input-style"
+#define HIME_ROOT_X      "hime-root-x"
+#define HIME_ROOT_Y      "hime-root-y"
+#define HIME_POP_UP_WIN "hime-pop-up-win"
+#define HIME_ICON_DIR "hime-icon-dir"
+#define HIME_INNER_FRAME "hime-inner-frame"
+#define HIME_INIT_IM_ENABLED "hime-init-im-enabled"
+#define HIME_INIT_FULL_MODE "hime-init-full-mode"
+#define HIME_BELL_VOLUME "hime-bell-volume"
+#define HIME_SOUND_PLAY_OVERLAP "hime-sound-play-overlap"
+#define HIME_ENABLE_CTRL_ALT_SWITCH "hime-enable-ctrl-alt-switch"
+#define HIME_EDIT_DISPLAY "hime-edit-display"
+#define HIME_BELL_OFF "hime-bell-off"
+#define HIME_ON_THE_SPOT_KEY "hime-on-the-spot-key"
+#define HIME_TRAY_HF_WIN_KBM "hime-tray-hf-win-kbm"
+#define HIME_SINGLE_STATE "hime-single-state"
+#define HIME_PUNC_AUTO_SEND "hime-punc-auto-send"
+
+#define HIME_IM_TOGGLE_KEYS "hime-im-toggle-keys"
+#define DEFAULT_INPUT_METHOD "default-input-method"
+// #define LEFT_RIGHT_BUTTON_TIPS "left-right-button-tips"
+#define HIME_STR_IM_CYCLE "hime-str-im-cycle"
+#define HIME_REMOTE_CLIENT "hime-remote-client"
+#define HIME_SHIFT_SPACE_ENG_FULL "hime-shift-space-eng-full"
+#define HIME_STATUS_TRAY "hime-status-tray"
+#define HIME_WIN_COLOR_FG "hime-win-color-fg"
+#define HIME_WIN_COLOR_BG "hime-win-color-bg"
+#define HIME_WIN_COLOR_USE "hime-win-color-use"
+#define HIME_CAPSLOCK_LOWER "hime-capslock-lower"
+#define HIME_ENG_PHRASE_ENABLED "hime-eng-phrase-enabled"
+#define HIME_WIN_SYM_CLICK_CLOSE "hime-win-sym-click-close"
+#define HIME_SEL_KEY_COLOR "hime-sel-key-color"
+#define HIME_TRAY_DISPLAY "hime-tray-display"
+
+#define GTAB_DUP_SELECT_BELL "gtab-dup-select-bell"
+#define GTAB_SPACE_AUTO_FIRST "gtab-space-auto-first"
+#define GTAB_AUTO_SELECT_BY_PHRASE "gtab-auto-select-by_phrase"
+#define GTAB_PRE_SELECT "gtab-pre-select"
+#define GTAB_PHRASE_PRE_SELECT "gtab-phrase-pre-select"
+#define GTAB_PRESS_FULL_AUTO_SEND "gtab-press-full-auto-send"
+#define GTAB_DISP_PARTIAL_MATCH "gtab-disp-partial-match"
+#define GTAB_DISP_KEY_CODES "gtab-disp-key-codes"
+#define GTAB_DISP_IM_NAME "gtab-disp-im-name"
+#define GTAB_INVALID_KEY_IN "gtab-invalid-key-in"
+#define GTAB_SHIFT_PHRASE_KEY "gtab-shift-phrase-key"
+#define GTAB_HIDE_ROW2 "gtab-hide-row2"
+#define GTAB_IN_ROW1 "gtab-in-row1"
+#define GTAB_VERTICAL_SELECT "gtab-vertical-select"
+#define GTAB_UNIQUE_AUTO_SEND "gtab-unique-auto-send"
+#define GTAB_QUE_WILD_CARD "gtab-que-wild-card"
+#define GTAB_QUE_WILD_CARD_ASTERISK "gtab-que-wild-card-asterisk"
+#define GTAB_PHO_QUERY "gtab-pho-query"
+#define GTAB_PHRASE_PRE_SELECT "gtab-phrase-pre-select"
+#define GTAB_IN_AREA_BUTTON "gtab-in-area-button"
+
+
+#define TSIN_PHRASE_PRE_SELECT "tsin-phrase-pre-select"
+#define TSIN_CHINESE_ENGLISH_TOGGLE_KEY "tsin-chinese-english-toggle_key"
+#define TSIN_SPACE_OPT "tsin-space-opt"
+#define TSIN_BUFFER_SIZE "tsin-buffer-size"
+#define TSIN_PHRASE_LINE_COLOR "tsin-phrase-line-color"
+#define TSIN_CURSOR_COLOR "tsin-cursor-color"
+#define TSIN_TONE_CHAR_INPUT "tsin-tone-char-input"
+#define TSIN_TAB_PHRASE_END "tsin-tab-phrase-end"
+#define TSIN_TAIL_SELECT_KEY "tsin-tail-select-key"
+#define TSIN_BUFFER_EDITING_MODE "tsin-buffer-editing-mode"
+#define TSIN_USE_PHO_NEAR "tsin-use-pho-near"
+
+#define PHO_HIDE_ROW2 "pho-hide-row2"
+#define PHO_IN_ROW1 "pho-in-row1"
+
+
+#define PHONETIC_KEYBOARD "phonetic-keyboard2"
+#define PHONETIC_KEYBOARD_BAK "phonetic-keyboard-bak"
+
+#define PHONETIC_CHAR_DYNAMIC_SEQUENCE "phonetic-char-dynamic-sequence"
+#define PHONETIC_HUGE_TAB "phonetic-huge-tab"
+#define PHONETIC_SPEAK "phonetic-speak"
+#define PHONETIC_SPEAK_SEL "phonetic-speak-sel"
+
+extern int hime_setup_window_type_utility,
+           hime_font_size, hime_font_size_tsin_presel, hime_font_size_symbol,
+           hime_font_size_tsin_pho_in, hime_font_size_pho_near,
+           hime_font_size_gtab_in, hime_font_size_win_kbm, hime_font_size_win_kbm_en,
+           hime_inner_frame, hime_single_state,
+           hime_remote_client,
+           gtab_disp_key_codes, gtab_disp_im_name, hime_shift_space_eng_full,
+           gtab_invalid_key_in, gtab_hide_row2, gtab_in_row1,
+           hime_capslock_lower, pho_hide_row2, pho_in_row1,
+           hime_eng_phrase_enabled, hime_win_sym_click_close,
+           gtab_que_wild_card, gtab_que_wild_card_asterisk, gtab_pho_query,
+           hime_bell_volume, hime_sound_play_overlap, hime_enable_ctrl_alt_switch, hime_on_the_spot_key;
+
+extern int default_input_method;
+// extern int left_right_button_tips;
+extern int gtab_dup_select_bell;
+extern int gtab_space_auto_first;
+extern int gtab_auto_select_by_phrase;
+extern int hime_im_toggle_keys;
+extern int gtab_pre_select, gtab_phrase_pre_select;
+extern int gtab_press_full_auto_send;
+extern int gtab_disp_partial_match;
+extern int gtab_shift_phrase_key, gtab_in_area_button;
+extern int gtab_vertical_select, gtab_unique_auto_send;
+extern int tsin_buffer_size;
+extern int hime_input_style, hime_root_x, hime_root_y, hime_pop_up_win;
+extern int hime_status_tray, hime_show_win_kbm, hime_tray_hf_win_kbm;
+extern int hime_punc_auto_send;
+
+extern int tsin_phrase_pre_select;
+extern int tsin_chinese_english_toggle_key;
+extern int tsin_tab_phrase_end, tsin_tail_select_key;
+extern int tsin_buffer_editing_mode;
+extern int tsin_use_pho_near;
+
+extern int phonetic_char_dynamic_sequence;
+extern int phonetic_huge_tab, phonetic_speak;
+extern char *phonetic_speak_sel;
+extern int tsin_space_opt, tsin_tone_char_input;
+
+extern char *tsin_phrase_line_color, *tsin_cursor_color, *hime_font_name, *hime_sel_key_color, *hime_icon_dir;
+extern unich_t eng_full_str[], eng_half_str[], cht_full_str[];
+extern char *eng_color_full_str, *eng_color_half_str, *cht_color_full_str;
+extern char *hime_win_color_fg, *hime_win_color_bg;
+extern int hime_win_color_use, hime_bell_off;
+extern int hime_init_im_enabled, hime_init_full_mode;
+extern int hime_edit_display, hime_tray_display;
+extern char *pho_kbm_name, *pho_selkey, *hime_str_im_cycle;
+extern int pho_candicate_col_N, pho_candicate_R2L;
+
+gboolean get_hime_user_fname(char *name, char fname[]);
+void get_hime_conf_str(char *name, char **rstr, char *default_str);
+void get_hime_conf_fstr(char *name, char rstr[], char *default_str);
+void save_hime_conf_str(char *name, char *str);
+void save_hime_conf_int(char *name, int val);
+void load_settings();
+void save_omni_config(void);
+void free_omni_config(void);
+
diff --git a/src/plugins/platforminputcontexts/hime/include/hime-crypt.c b/src/plugins/platforminputcontexts/hime/include/hime-crypt.c
new file mode 100644
index 0000000..f35b4f4
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/hime-crypt.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2009 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "im-client/hime-protocol.h"
+
+static int __hime_rand__(u_int *next)
+{
+  *next = *next * 1103515245 + 12345;
+  return((unsigned)(*next/65536) % 32768);
+}
+
+void __hime_enc_mem(u_char *p, int n,
+                    HIME_PASSWD *passwd, u_int *seed)
+{
+  int i;
+
+  for(i=0; i < n; i++) {
+    int v = __hime_rand__(seed) % __HIME_PASSWD_N_;
+    p[i]^=passwd->passwd[v];
+  }
+}
+
diff --git a/src/plugins/platforminputcontexts/hime/include/hime-endian.h b/src/plugins/platforminputcontexts/hime/include/hime-endian.h
new file mode 100644
index 0000000..fe5970e
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/hime-endian.h
@@ -0,0 +1,33 @@
+/* Copyright (C) 2009 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#define swap_ch(a, b) do { char t; t = *(a); *(a) = *(b); *(b) = t; } while (0)
+
+#define swap_byte_2(pp) do { char *p=(char *)pp;  swap_ch(p, p+1); } while (0)
+#define swap_byte_4(pp) do { char *p=(char *)pp;  swap_ch(p, p+3); swap_ch(p+1, p+2); } while (0)
+#define swap_byte_8(pp) do { char *p=(char *)pp;  swap_ch(p, p+7); swap_ch(p+1, p+6); swap_ch(p+2, p+5); swap_ch(p+3, p+4);} while (0)
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+//#warning "big endian"
+#define to_hime_endian_2(pp) swap_byte_2(pp)
+#define to_hime_endian_4(pp) swap_byte_4(pp)
+#define to_hime_endian_8(pp) swap_byte_8(pp)
+#else
+#define to_hime_endian_2(pp) do { } while (0)
+#define to_hime_endian_4(pp) do { } while (0)
+#define to_hime_endian_8(pp) do { } while (0)
+#endif
diff --git a/src/plugins/platforminputcontexts/hime/include/hime-gtk-compatible.h b/src/plugins/platforminputcontexts/hime/include/hime-gtk-compatible.h
new file mode 100644
index 0000000..cc4ea9c
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/hime-gtk-compatible.h
@@ -0,0 +1,139 @@
+#if !GTK_CHECK_VERSION(2,13,4)
+#define gtk_widget_get_window(x) (x)->window
+#define gtk_color_selection_dialog_get_color_selection(x) (x)->colorsel
+#endif
+
+#if !GTK_CHECK_VERSION(2,15,0)
+#define gtk_status_icon_set_tooltip_text gtk_status_icon_set_tooltip
+#endif
+
+#if !GTK_CHECK_VERSION(2,16,0)
+#include <X11/XKBlib.h>
+#include <gdk/gdkx.h>
+#define gdk_keymap_get_caps_lock_state(x) get_caps_lock_state()
+#endif
+
+#if GTK_CHECK_VERSION(2,17,5)
+#undef GTK_WIDGET_NO_WINDOW
+#define GTK_WIDGET_NO_WINDOW !gtk_widget_get_has_window
+#undef GTK_WIDGET_SET_FLAGS
+#define GTK_WIDGET_SET_FLAGS(x,y) gtk_widget_set_can_default(x,1)
+#endif
+
+#if GTK_CHECK_VERSION(2,17,7)
+#undef GTK_WIDGET_VISIBLE
+#define GTK_WIDGET_VISIBLE gtk_widget_get_visible
+#endif
+
+#if GTK_CHECK_VERSION(2,17,10)
+#undef GTK_WIDGET_DRAWABLE
+#define GTK_WIDGET_DRAWABLE gtk_widget_is_drawable
+#endif
+
+#if GTK_CHECK_VERSION(2,19,5)
+#undef GTK_WIDGET_REALIZED
+#define GTK_WIDGET_REALIZED gtk_widget_get_realized
+#endif
+
+#if GTK_CHECK_VERSION(2,21,8)
+#undef GDK_DISPLAY
+#define GDK_DISPLAY() GDK_DISPLAY_XDISPLAY(gdk_display_get_default())
+#endif
+
+#if GTK_CHECK_VERSION(2,24,0)
+#define gdk_window_lookup_for_display gdk_x11_window_lookup_for_display
+#define gtk_combo_box_new_text gtk_combo_box_text_new
+#define gtk_combo_box_append_text gtk_combo_box_text_append_text
+#define gtk_widget_hide_all gtk_widget_hide
+#endif
+
+#if GTK_CHECK_VERSION(2,90,0)
+#undef GTK_CHECK_CAST
+#define GTK_CHECK_CAST G_TYPE_CHECK_INSTANCE_CAST
+#undef GDK_DRAWABLE_XID
+#define GDK_DRAWABLE_XID GDK_WINDOW_XID
+#undef GDK_DRAWABLE_XDISPLAY
+#define GDK_DRAWABLE_XDISPLAY GDK_WINDOW_XDISPLAY
+#define gtk_hseparator_new() gtk_separator_new(GTK_ORIENTATION_HORIZONTAL)
+#define gtk_vseparator_new() gtk_separator_new(GTK_ORIENTATION_VERTICAL)
+#endif
+
+#if !GTK_CHECK_VERSION(2,91,0)
+#define gdk_error_trap_pop_ignored gdk_error_trap_pop
+#define gtk_widget_get_preferred_size(x,y,z) gtk_widget_size_request(x,z)
+#define gtk_widget_set_halign(x,y);
+#endif
+
+#if GTK_CHECK_VERSION(2,91,0)
+#define GTK_OBJECT
+#define gdk_drawable_get_screen gdk_window_get_screen
+#endif
+
+#if !GTK_CHECK_VERSION(2,91,1)
+#define gtk_window_set_has_resize_grip(x,y);
+#define gtk_widget_set_hexpand(x,y);
+#define gtk_widget_set_vexpand(x,y);
+#endif
+
+#if !GTK_CHECK_VERSION(2,91,2)
+#define gtk_grid_set_column_homogeneous(x,y);
+#define gtk_grid_set_row_homogeneous(x,y);
+#define gtk_orientable_set_orientation(x,y);
+#endif
+
+#if GTK_CHECK_VERSION(2,91,2)
+#undef GTK_BOX
+#define GTK_BOX GTK_GRID
+#define gtk_hbox_new(x,y) gtk_grid_new()
+#define gtk_vbox_new(x,y) gtk_grid_new()
+#define gtk_box_pack_end(v,w,x,y,z) gtk_container_add(GTK_CONTAINER(v),w)
+#define gtk_box_pack_start(v,w,x,y,z) gtk_container_add(GTK_CONTAINER(v),w)
+#endif
+
+#ifndef GTK_COMBO_BOX_TEXT
+#define GTK_COMBO_BOX_TEXT GTK_COMBO_BOX
+#endif
+
+#if !GTK_CHECK_VERSION(2,91,6)
+#define gtk_widget_override_font gtk_widget_modify_font
+#endif
+
+#if GTK_CHECK_VERSION(2,91,6)
+#define GDK_WINDOW_XWINDOW GDK_WINDOW_XID
+#endif
+
+#if GTK_CHECK_VERSION(3,3,2)
+#undef      GTK_TABLE
+#define     GTK_TABLE GTK_GRID
+#define     gtk_table_attach_defaults(u,v,w,x,y,z) gtk_grid_attach(u,v,w,y,1,1)
+#define     gtk_table_new(x,y,z) gtk_grid_new()
+#endif
+
+#if GTK_CHECK_VERSION(3,3,18)
+#define GTK_COLOR_SELECTION_DIALOG GTK_COLOR_CHOOSER_DIALOG
+#define GTK_COLOR_SELECTION GTK_COLOR_CHOOSER
+#endif
+
+#if GTK_CHECK_VERSION(3,9,8)
+#define gtk_image_menu_item_set_image(a,b) NULL
+#endif
+
+#if GTK_CHECK_VERSION(3,9,10)
+#define gtk_button_new_from_stock(x) gtk_button_new_from_icon_name(x,GTK_ICON_SIZE_BUTTON)
+#define GTK_STOCK_CANCEL "gtk-cancel"
+#define GTK_STOCK_OK "gtk-ok"
+#define GTK_STOCK_QUIT "gtk-quit"
+#define GTK_STOCK_SAVE "gtk-save"
+#define GTK_STOCK_OPEN "gtk-open"
+#define GTK_STOCK_CLOSE "gtk-close"
+#define GTK_STOCK_DELETE "gtk-delete"
+#define GTK_STOCK_FIND "gtk-find"
+#endif
+
+#if GTK_CHECK_VERSION(3,13,4)
+#define gtk_window_set_has_resize_grip(x,y);
+#endif
+
+#ifndef PANGO_VERSION_CHECK
+#define PANGO_VERSION_CHECK(x,y,z) FALSE
+#endif
diff --git a/src/plugins/platforminputcontexts/hime/include/hime.c b/src/plugins/platforminputcontexts/hime/include/hime.c
new file mode 100644
index 0000000..1c17c59
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/hime.c
@@ -0,0 +1,702 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "hime.h"
+#include "config.h"
+#include "gtab.h"
+#include <signal.h>
+#if HIME_i18n_message
+#include <libintl.h>
+#endif
+
+Window root;
+Display *dpy;
+
+int win_xl, win_yl;
+int win_x, win_y;   // actual win x/y
+int dpy_xl, dpy_yl;
+Window xim_xwin;
+
+extern unich_t *fullchar[];
+gboolean win_kbm_inited;
+char *get_hime_xim_name();
+
+char *half_char_to_full_char(KeySym xkey)
+{
+  if (xkey < ' ' || xkey > 127)
+    return NULL;
+  return _(fullchar[xkey-' ']);
+}
+
+static void start_inmd_window()
+{
+  GtkWidget *win = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+  gtk_widget_realize (win);
+  xim_xwin = GDK_WINDOW_XWINDOW(gtk_widget_get_window(win));
+  dbg("xim_xwin %x\n", xim_xwin);
+}
+
+#if USE_XIM
+char *lc;
+
+static XIMStyle Styles[] = {
+#if 1
+        XIMPreeditCallbacks|XIMStatusCallbacks,         //OnTheSpot
+        XIMPreeditCallbacks|XIMStatusArea,              //OnTheSpot
+        XIMPreeditCallbacks|XIMStatusNothing,           //OnTheSpot
+#endif
+        XIMPreeditPosition|XIMStatusArea,               //OverTheSpot
+        XIMPreeditPosition|XIMStatusNothing,            //OverTheSpot
+        XIMPreeditPosition|XIMStatusNone,               //OverTheSpot
+#if 1
+        XIMPreeditArea|XIMStatusArea,                   //OffTheSpot
+        XIMPreeditArea|XIMStatusNothing,                //OffTheSpot
+        XIMPreeditArea|XIMStatusNone,                   //OffTheSpot
+#endif
+        XIMPreeditNothing|XIMStatusNothing,             //Root
+        XIMPreeditNothing|XIMStatusNone,                //Root
+};
+static XIMStyles im_styles;
+
+#if 1
+static XIMTriggerKey trigger_keys[] = {
+        {XK_space, ControlMask, ControlMask},
+        {XK_space, ShiftMask, ShiftMask},
+        {XK_space, Mod1Mask, Mod1Mask},   // Alt
+        {XK_space, Mod4Mask, Mod4Mask},   // Windows
+};
+#endif
+
+/* Supported Encodings */
+static XIMEncoding chEncodings[] = {
+        "COMPOUND_TEXT",
+        0
+};
+static XIMEncodings encodings;
+
+int xim_ForwardEventHandler(IMForwardEventStruct *call_data);
+
+XIMS current_ims;
+extern void toggle_im_enabled();
+
+
+int MyTriggerNotifyHandler(IMTriggerNotifyStruct *call_data)
+{
+//    dbg("MyTriggerNotifyHandler %d %x\n", call_data->key_index, call_data->event_mask);
+
+    if (call_data->flag == 0) { /* on key */
+//        db(g("trigger %d\n", call_data->key_index);
+        if ((call_data->key_index == 0 && hime_im_toggle_keys==Control_Space) ||
+            (call_data->key_index == 3 && hime_im_toggle_keys==Shift_Space) ||
+            (call_data->key_index == 6 && hime_im_toggle_keys==Alt_Space) ||
+            (call_data->key_index == 9 && hime_im_toggle_keys==Windows_Space)
+            ) {
+            toggle_im_enabled();
+        }
+        return True;
+    } else {
+        /* never happens */
+        return False;
+    }
+}
+
+#if 0
+void switch_IC_index(int index);
+#endif
+void CreateIC(IMChangeICStruct *call_data);
+void DeleteIC(CARD16 icid);
+void SetIC(IMChangeICStruct * call_data);
+void GetIC(IMChangeICStruct *call_data);
+int xim_hime_FocusIn(IMChangeFocusStruct *call_data);
+int xim_hime_FocusOut(IMChangeFocusStruct *call_data);
+
+int hime_ProtoHandler(XIMS ims, IMProtocol *call_data)
+{
+//  dbg("hime_ProtoHandler %x ims\n", ims);
+
+  current_ims = ims;
+
+  switch (call_data->major_code) {
+  case XIM_OPEN:
+#define MAX_CONNECT 20000
+    {
+      IMOpenStruct *pimopen=(IMOpenStruct *)call_data;
+
+      if (pimopen->connect_id > MAX_CONNECT - 1)
+        return True;
+
+#if DEBUG && 0
+    dbg("open lang %s  connectid:%d\n", pimopen->lang.name, pimopen->connect_id);
+#endif
+      return True;
+    }
+  case XIM_CLOSE:
+#if DEBUG && 0
+    dbg("XIM_CLOSE\n");
+#endif
+    return True;
+  case XIM_CREATE_IC:
+#if DEBUG && 0
+     dbg("CREATE_IC\n");
+#endif
+     CreateIC((IMChangeICStruct *)call_data);
+     return True;
+  case XIM_DESTROY_IC:
+     {
+       IMChangeICStruct *pimcha=(IMChangeICStruct *)call_data;
+#if DEBUG && 0
+       dbg("DESTROY_IC %d\n", pimcha->icid);
+#endif
+       DeleteIC(pimcha->icid);
+     }
+     return True;
+  case XIM_SET_IC_VALUES:
+#if DEBUG && 0
+     dbg("SET_IC\n");
+#endif
+     SetIC((IMChangeICStruct *)call_data);
+     return True;
+  case XIM_GET_IC_VALUES:
+#if DEBUG && 0
+     dbg("GET_IC\n");
+#endif
+     GetIC((IMChangeICStruct *)call_data);
+     return True;
+  case XIM_FORWARD_EVENT:
+#if DEBUG && 0
+     dbg("XIM_FORWARD_EVENT\n");
+#endif
+     return xim_ForwardEventHandler((IMForwardEventStruct *)call_data);
+  case XIM_SET_IC_FOCUS:
+#if DEBUG && 0
+     dbg("XIM_SET_IC_FOCUS\n");
+#endif
+     return xim_hime_FocusIn((IMChangeFocusStruct *)call_data);
+  case XIM_UNSET_IC_FOCUS:
+#if DEBUG && 0
+     dbg("XIM_UNSET_IC_FOCUS\n");
+#endif
+     return xim_hime_FocusOut((IMChangeFocusStruct *)call_data);
+  case XIM_RESET_IC:
+#if DEBUG && 0
+     dbg("XIM_UNSET_IC_FOCUS\n");
+#endif
+     return True;
+  case XIM_TRIGGER_NOTIFY:
+#if DEBUG && 0
+     dbg("XIM_TRIGGER_NOTIFY\n");
+#endif
+     MyTriggerNotifyHandler((IMTriggerNotifyStruct *)call_data);
+     return True;
+  case XIM_PREEDIT_START_REPLY:
+#if DEBUG && 1
+     dbg("XIM_PREEDIT_START_REPLY\n");
+#endif
+     return True;
+  case XIM_PREEDIT_CARET_REPLY:
+#if DEBUG && 1
+     dbg("XIM_PREEDIT_CARET_REPLY\n");
+#endif
+     return True;
+  case XIM_STR_CONVERSION_REPLY:
+#if DEBUG && 1
+     dbg("XIM_STR_CONVERSION_REPLY\n");
+#endif
+     return True;
+  default:
+     printf("Unknown major code.\n");
+     break;
+  }
+
+  return True;
+}
+
+
+void open_xim()
+{
+  XIMTriggerKeys triggerKeys;
+
+  im_styles.supported_styles = Styles;
+  im_styles.count_styles = sizeof(Styles)/sizeof(Styles[0]);
+
+  triggerKeys.count_keys = sizeof(trigger_keys)/sizeof(trigger_keys[0]);
+  triggerKeys.keylist = trigger_keys;
+
+  encodings.count_encodings = sizeof(chEncodings)/sizeof(XIMEncoding) - 1;
+  encodings.supported_encodings = chEncodings;
+
+  char *xim_name = get_hime_xim_name();
+
+  XIMS xims = IMOpenIM(dpy,
+          IMServerWindow,         xim_xwin,        //input window
+          IMModifiers,            "Xi18n",        //X11R6 protocol
+          IMServerName,           xim_name, //XIM server name
+          IMLocale,               lc,
+          IMServerTransport,      "X/",      //Comm. protocol
+          IMInputStyles,          &im_styles,   //faked styles
+          IMEncodingList,         &encodings,
+          IMProtocolHandler,      hime_ProtoHandler,
+          IMFilterEventMask,      KeyPressMask|KeyReleaseMask,
+          IMOnKeysList, &triggerKeys,
+          NULL);
+
+  if (xims == NULL) {
+          p_err("IMOpenIM '%s' failed. Maybe another XIM server is running.\n",
+          xim_name);
+  }
+}
+
+#endif // if USE_XIM
+
+void load_tsin_db();
+void load_tsin_conf(), load_settings(), load_tab_pho_file();
+
+void disp_hide_tsin_status_row(), update_win_kbm_inited();
+void change_tsin_line_color(), change_win0_style(), change_tsin_color();
+void change_win_gtab_style();
+#if TRAY_ENABLED
+void update_item_active_all();
+#endif
+void destroy_inmd_menu();
+void load_gtab_list(gboolean);
+void change_win1_font();
+void set_wselkey(char *s);
+void create_win_gtab();
+
+#if TRAY_ENABLED
+void disp_tray_icon();
+#endif
+gboolean init_in_method(int in_no);
+#include "im-client/hime-protocol.h"
+#include "im-srv.h"
+
+static int get_in_method_by_filename(char filename[])
+{
+    int i, in_method = 0;
+    gboolean found = FALSE;
+    for(i=0; i < inmdN; i++) {
+      if (strcmp(filename, inmd[i].filename))
+        continue;
+      found = TRUE;
+      in_method = i;
+      break;
+    }
+    if (!found)
+      in_method = default_input_method;
+    return in_method;
+}
+
+static void reload_data()
+{
+  dbg("reload_data\n");
+//  Save input method state before reload
+  char temp_inmd_filenames[hime_clientsN][128];
+  HIME_STATE_E temp_CS_im_states[hime_clientsN];
+  char temp_current_CS_inmd_filename[128] = "";
+  HIME_STATE_E temp_current_CS_im_state = 0;
+  if (current_CS) {
+    temp_current_CS_im_state = current_CS->im_state;
+    strcpy(temp_current_CS_inmd_filename, inmd[current_CS->in_method].filename);
+  }
+  int c;
+  for(c=0;c<hime_clientsN;c++) {
+    strcpy(temp_inmd_filenames[c], "");
+    temp_CS_im_states[c] = HIME_STATE_DISABLED;
+    if (!hime_clients[c].cs)
+      continue;
+    ClientState *cs = hime_clients[c].cs;
+    temp_CS_im_states[c] = cs->im_state;
+    strcpy(temp_inmd_filenames[c], inmd[cs->in_method].filename);
+  }
+  free_omni_config();
+  load_settings();
+  if (current_method_type()==method_type_TSIN)
+    set_wselkey(pho_selkey);
+
+//  load_tsin_db();
+  change_win0_style();
+  change_win1_font();
+  create_win_gtab();
+  change_win_gtab_style();
+//  change_win_pho_style();
+  load_tab_pho_file();
+  change_tsin_color();
+  update_win_kbm_inited();
+
+  destroy_inmd_menu();
+  load_gtab_list(TRUE);
+
+#if TRAY_ENABLED
+  update_item_active_all();
+#endif
+
+//  Load input method state after reload, which may change inmd
+  // load clientstate properties back
+  for(c=0;c<hime_clientsN;c++) {
+    if (!hime_clients[c].cs)
+      continue;
+    hime_clients[c].cs->im_state = HIME_STATE_CHINESE;
+    hime_clients[c].cs->in_method = get_in_method_by_filename(temp_inmd_filenames[c]);
+    init_in_method(hime_clients[c].cs->in_method);
+    if (temp_CS_im_states[c] == HIME_STATE_DISABLED)
+      toggle_im_enabled();
+    hime_clients[c].cs->im_state = temp_CS_im_states[c];
+  }
+  current_CS->im_state = HIME_STATE_CHINESE;
+  init_in_method(get_in_method_by_filename(temp_current_CS_inmd_filename));
+  if (temp_current_CS_im_state == HIME_STATE_DISABLED)
+    toggle_im_enabled();
+  current_CS->im_state = temp_current_CS_im_state;
+}
+
+void change_tsin_font_size();
+void change_gtab_font_size();
+void change_pho_font_size();
+void change_win_sym_font_size();
+void change_win_gtab_style();
+extern gboolean win_kbm_on;
+extern void change_module_font_size();
+
+static void change_font_size()
+{
+  load_settings();
+  change_tsin_font_size();
+  change_gtab_font_size();
+  change_pho_font_size();
+  change_win_sym_font_size();
+  change_win0_style();
+  change_win_gtab_style();
+  update_win_kbm_inited();
+  change_win1_font();
+//  change_win_pho_style();
+  change_module_font_size();
+}
+
+static int xerror_handler(Display *d, XErrorEvent *eve)
+{
+  return 0;
+}
+
+Atom hime_atom;
+
+void toggle_gb_output();
+
+void cb_trad_sim_toggle()
+{
+  toggle_gb_output();
+#if TRAY_ENABLED
+  disp_tray_icon();
+#endif
+}
+void execute_message(char *message), show_win_kbm(), hide_win_kbm();
+void disp_win_kbm_capslock_init();
+
+extern int hime_show_win_kbm;
+void kbm_open_close(GtkButton *checkmenuitem, gboolean b_show)
+{
+  hime_show_win_kbm=b_show;
+
+  if (hime_show_win_kbm) {
+    show_win_kbm();
+    disp_win_kbm_capslock_init();
+  } else
+    hide_win_kbm();
+}
+
+void kbm_toggle()
+{
+  win_kbm_inited = 1;
+  kbm_open_close(NULL, ! hime_show_win_kbm);
+}
+
+
+void reload_tsin_db();
+void do_exit();
+
+void message_cb(char *message)
+{
+   void sim_output();  // FIXME
+   void trad_output(); // FIXME
+//   dbg("message '%s'\n", message);
+
+   /* TODO: rewrite the mess with case() ? */
+   if (!strcmp(message, CHANGE_FONT_SIZE)) {
+     change_font_size();
+   } else
+   if (!strcmp(message, GB_OUTPUT_TOGGLE)) {
+     cb_trad_sim_toggle();
+#if TRAY_ENABLED
+     update_item_active_all();
+#endif
+   } else
+   if (!strcmp(message, SIM_OUTPUT_TOGGLE)) {
+     sim_output();
+#if TRAY_ENABLED
+     disp_tray_icon();
+     update_item_active_all();
+#endif
+   } else
+   if (!strcmp(message, TRAD_OUTPUT_TOGGLE)) {
+     trad_output();
+#if TRAY_ENABLED
+     disp_tray_icon();
+     update_item_active_all();
+#endif
+   } else
+   if (!strcmp(message, KBM_TOGGLE)) {
+     kbm_toggle();
+   } else
+   if (strstr(message, "#hime_message")) {
+     execute_message(message);
+   } else
+#if TRAY_ENABLED
+   if (!strcmp(message, UPDATE_TRAY)) {
+     disp_tray_icon();
+   } else
+#endif
+   if (!strcmp(message, RELOAD_TSIN_DB)) {
+     reload_tsin_db();
+   } else
+   if (!strcmp(message, HIME_EXIT_MESSAGE)) {
+     do_exit();
+   } else
+     reload_data();
+}
+
+static GdkFilterReturn my_gdk_filter(GdkXEvent *xevent,
+                                     GdkEvent *event,
+                                     gpointer data)
+{
+   XEvent *xeve = (XEvent *)xevent;
+#if 0
+   dbg("a zzz %d\n", xeve->type);
+#endif
+
+   // only very old WM will enter this
+   if (xeve->type == FocusIn || xeve->type == FocusOut) {
+#if 0
+     dbg("focus %s\n", xeve->type == FocusIn ? "in":"out");
+#endif
+     return GDK_FILTER_REMOVE;
+   }
+
+#if USE_XIM
+   if (XFilterEvent(xeve, None) == True)
+     return GDK_FILTER_REMOVE;
+#endif
+
+   return GDK_FILTER_CONTINUE;
+}
+
+void init_atom_property()
+{
+  hime_atom = get_hime_atom(dpy);
+  XSetSelectionOwner(dpy, hime_atom, xim_xwin, CurrentTime);
+}
+
+void hide_win0();
+void destroy_win0();
+void destroy_win1();
+void destroy_win_gtab();
+void free_pho_mem(),free_tsin(),free_all_IC(), free_gtab(), free_phrase();
+#if TRAY_ENABLED
+void destroy_tray();
+#endif
+
+void do_exit()
+{
+  dbg("----------------- do_ exit ----------------\n");
+
+  free_pho_mem();
+  free_tsin();
+#if USE_XIM
+  free_all_IC();
+#endif
+  free_gtab();
+  free_phrase();
+
+#if 1
+  destroy_win0();
+  destroy_win1();
+  destroy_win_gtab();
+#endif
+
+#if TRAY_ENABLED
+  destroy_tray();
+#endif
+
+  free_omni_config();
+  gtk_main_quit();
+}
+
+void sig_do_exit(int sig)
+{
+  do_exit();
+}
+
+void load_phrase(), init_TableDir();
+void init_tray(), exec_setup_scripts();
+void init_hime_im_serv(Window win);
+void init_tray_double();
+
+#if TRAY_UNITY
+void init_tray_appindicator();
+#endif
+
+gboolean delayed_start_cb(gpointer data)
+{
+#if TRAY_ENABLED
+  if (hime_status_tray) {
+    if (hime_tray_display == HIME_TRAY_DISPLAY_SINGLE)
+      init_tray();
+    else if (hime_tray_display == HIME_TRAY_DISPLAY_DOUBLE)
+      init_tray_double();
+#if TRAY_UNITY
+    else if (hime_tray_display == HIME_TRAY_DISPLAY_APPINDICATOR)
+      init_tray_appindicator();
+#endif
+  }
+#endif
+
+  dbg("after init_tray\n");
+
+  return FALSE;
+}
+
+void get_dpy_xyl()
+{
+	dpy_xl = gdk_screen_width(), dpy_yl = gdk_screen_height();
+}
+
+void screen_size_changed(GdkScreen *screen, gpointer user_data)
+{
+	get_dpy_xyl();
+}
+
+#include "lang.h"
+
+extern int destroy_window;
+
+int main(int argc, char **argv)
+{
+  char *destroy = getenv("HIME_DESTROY_WINDOW");
+  if (destroy)
+    destroy_window = atoi(destroy);
+//  printf("HIME_DESTROY_WINDOW=%d\n",destroy_window);
+
+  gtk_init (&argc, &argv);
+
+  signal(SIGCHLD, SIG_IGN);
+  signal(SIGPIPE, SIG_IGN);
+
+  if (getenv("HIME_DAEMON")) {
+    daemon(1,1);
+#if FREEBSD
+    setpgid(0, getpid());
+#else
+    setpgrp();
+#endif
+  }
+
+  set_is_chs();
+
+  char *lc_ctype = getenv("LC_CTYPE");
+  char *lc_all = getenv("LC_ALL");
+  char *lang = getenv("LANG");
+  if (!lc_ctype && lang)
+    lc_ctype = lang;
+
+  if (lc_all)
+    lc_ctype = lc_all;
+
+  if (!lc_ctype)
+    lc_ctype = "zh_TW.Big5";
+  dbg("hime get env LC_CTYPE=%s  LC_ALL=%s  LANG=%s\n", lc_ctype, lc_all, lang);
+
+#if USE_XIM
+  char *t = strchr(lc_ctype, '.');
+  if (t) {
+    int len = t - lc_ctype;
+#if MAC_OS || FREEBSD
+    lc = strdup(lc_ctype);
+    lc[len] = 0;
+#else
+    lc = g_strndup(lc_ctype, len);
+#endif
+  }
+  else
+    lc = lc_ctype;
+
+  dbg("hime XIM will use %s as the default encoding\n", lc_ctype);
+#endif
+
+  if (argc == 2 && (!strcmp(argv[1], "-v") || !strcmp(argv[1], "--version") || !strcmp(argv[1], "-h")) ) {
+#if GIT_HAVE
+    p_err(" version %s (git %s)\n", HIME_VERSION, GIT_HASH);
+#else
+    p_err(" version %s\n", HIME_VERSION);
+#endif
+  }
+
+  init_TableDir();
+  load_settings();
+  load_gtab_list(TRUE);
+
+
+#if HIME_i18n_message
+  bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8");
+  textdomain(GETTEXT_PACKAGE);
+#endif
+
+  dbg("after gtk_init\n");
+
+  dpy = GDK_DISPLAY();
+  root=DefaultRootWindow(dpy);
+  get_dpy_xyl();
+  g_signal_connect(gdk_screen_get_default(),"size-changed", G_CALLBACK(screen_size_changed), NULL);
+
+  dbg("display width:%d height:%d\n", dpy_xl, dpy_yl);
+
+  start_inmd_window();
+
+#if USE_XIM
+  open_xim();
+#endif
+
+  gdk_window_add_filter(NULL, my_gdk_filter, NULL);
+
+  init_atom_property();
+  signal(SIGINT, sig_do_exit);
+  signal(SIGHUP, sig_do_exit);
+  // disable the io handler abort
+  // void *olderr =
+    XSetErrorHandler((XErrorHandler)xerror_handler);
+
+  init_hime_im_serv(xim_xwin);
+
+  exec_setup_scripts();
+
+  g_timeout_add(200, delayed_start_cb, NULL); // Old setting is 5000 here.
+
+  dbg("before gtk_main\n");
+
+  disp_win_kbm_capslock_init();
+
+  gtk_main();
+
+  return 0;
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/hime.h b/src/plugins/platforminputcontexts/hime/include/hime.h
new file mode 100644
index 0000000..047cc12
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/hime.h
@@ -0,0 +1,181 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include "os-dep.h"
+#include <gtk/gtk.h>
+#include <string.h>
+#include "IMdkit/include/IMdkit.h"
+#include "IMdkit/include/Xi18n.h"
+#if HIME_i18n_message
+#include <libintl.h>
+#define _(STRING) gettext(STRING)
+#else
+#define _(STRING) (STRING)
+#endif
+
+#define N_(STRING) (STRING)
+
+#include "hime-gtk-compatible.h"
+
+typedef enum {
+  HIME_STATE_DISABLED = 0,
+  HIME_STATE_ENG_FULL = 1,
+  HIME_STATE_CHINESE = 2
+} HIME_STATE_E;
+
+/* change 3 to 4 if you want to use 4-byte UTF-8 characters, but you must
+   regenerate *.gtab tsin
+*/
+#define CH_SZ (4)
+
+
+#include "IC.h"
+
+#if CLIENT_LIB
+#define p_err __hime_p_err
+#define zmalloc __hime_zmalloc
+#endif
+
+#include "util.h"
+
+#define tmalloc(type,n)  (type*)malloc(sizeof(type) * (n))
+void *zmalloc(int n);
+void *memdup(void *p, int n);
+#define tzmalloc(type,n)  (type*)zmalloc(sizeof(type) * (n))
+#define trealloc(p,type,n)  (type*)realloc(p, sizeof(type) * (n+1))
+#define tmemdup(p,type,n) (type*)memdup(p, sizeof(type) * n)
+extern Display *dpy;
+
+extern char *TableDir;
+extern GtkWidget *gwin0;
+extern GdkWindow *gdkwin0;
+extern Window xwin0;
+extern Window root;
+void loadIC();
+IC *FindIC(CARD16 icid);
+extern ClientState *current_CS;
+
+enum {
+  InputStyleOverSpot = 1,
+  InputStyleRoot = 2,
+  InputStyleOnSpot = 4
+};
+
+typedef enum {
+  Control_Space=0,
+  Shift_Space=1,
+  Alt_Space=2,
+  Windows_Space=3,
+} IM_TOGGLE_KEYS;
+
+enum {
+  TSIN_CHINESE_ENGLISH_TOGGLE_KEY_None=0,
+  TSIN_CHINESE_ENGLISH_TOGGLE_KEY_CapsLock=1,
+  TSIN_CHINESE_ENGLISH_TOGGLE_KEY_Tab=2,
+  TSIN_CHINESE_ENGLISH_TOGGLE_KEY_Shift=4,
+  TSIN_CHINESE_ENGLISH_TOGGLE_KEY_ShiftL=8,
+  TSIN_CHINESE_ENGLISH_TOGGLE_KEY_ShiftR=16,
+};
+
+typedef enum {
+  TSIN_SPACE_OPT_SELECT_CHAR = 1,
+  TSIN_SPACE_OPT_INPUT = 2,
+} TSIN_SPACE_OPT;
+
+enum {
+  HIME_EDIT_DISPLAY_OVER_THE_SPOT=1,
+  HIME_EDIT_DISPLAY_ON_THE_SPOT=2,
+  HIME_EDIT_DISPLAY_BOTH=4,
+};
+
+#if TRAY_ENABLED
+enum {
+  HIME_TRAY_DISPLAY_SINGLE=1,
+  HIME_TRAY_DISPLAY_DOUBLE=2,
+  HIME_TRAY_DISPLAY_APPINDICATOR=3,
+};
+#endif
+
+#define HIME_SEL_KEY_COLOR_DEFAULT "blue"
+#define TSIN_CURSOR_COLOR_DEFAULT "blue"
+
+#define ROW_ROW_SPACING (2)
+
+
+#define MAX_HIME_STR (256)
+
+#define PHO_KBM "phokbm"
+
+extern int win_xl, win_yl;
+extern int win_x, win_y;   // actual win x/y
+extern int  current_in_win_x,  current_in_win_y;  // request x/y
+extern int dpy_xl, dpy_yl;
+
+extern int hime_font_size;
+
+void big5_utf8(char *s, char out[]);
+void utf8_big5(char *s, char out[]);
+gint inmd_switch_popup_handler (GtkWidget *widget, GdkEvent *event);
+
+#include "hime-conf.h"
+
+#define bchcpy(a,b) memcpy(a,b, CH_SZ)
+#define bchcmp(a,b) memcmp(a,b, CH_SZ)
+
+int utf8_sz(char *s);
+int utf8cpy(char *t, char *s);
+int u8cpy(char *t, char *s);
+int utf8_tlen(char *s, int N);
+void utf8_putchar(char *s);
+void utf8_putcharn(char *s, int n);
+gboolean utf8_eq(char *a, char *b);
+gboolean utf8_str_eq(char *a, char *b, int len);
+void utf8cpyN(char *t, char *s, int N);
+int utf8_str_N(char *str);
+void utf8cpyn(char *t, char *s, int n);
+void utf8cpy_bytes(char *t, char *s, int n);
+char *myfgets(char *buf, int bufN, FILE *fp);
+void get_hime_dir(char *tt);
+Atom get_hime_atom(Display *dpy);
+void get_sys_table_file_name(char *name, char *fname);
+char *half_char_to_full_char(KeySym xkey);
+void send_text(char *text);
+void send_utf8_ch(char *bchar);
+void send_ascii(char key);
+void bell();
+void set_label_font_size(GtkWidget *label, int size);
+void send_hime_message(Display *dpy, char *s);
+void check_CS();
+gint64 current_time();
+void get_win_size(GtkWidget *win, int *width, int *height);
+void change_win_fg_bg(GtkWidget *win, GtkWidget *label);
+void set_no_focus(GtkWidget *win);
+void change_win_bg(GtkWidget *win);
+gboolean hime_edit_display_ap_only();
+gboolean hime_display_on_the_spot_key();
+void char_play(char *utf8);
+void skip_utf8_sigature(FILE *fp);
+
+#define BITON(flag, bit) ((flag) & (bit))
+
+typedef int usecount_t;
+
+#define MAX_CIN_PHR (100*CH_SZ + 1)
diff --git a/src/plugins/platforminputcontexts/hime/include/im-addr.c b/src/plugins/platforminputcontexts/hime/include/im-addr.c
new file mode 100644
index 0000000..642b34a
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/im-addr.c
@@ -0,0 +1,95 @@
+/* Copyright (C) 2009 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <pwd.h>
+#include <string.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include "hime.h"
+
+char *get_hime_xim_name();
+
+void get_hime_im_srv_sock_path(char *outstr, int outstrN)
+{
+  char *disp = getenv("DISPLAY");
+  int my_uid = getuid();
+
+  if (!disp || !strcmp(disp, ":0"))
+    disp = ":0.0";
+
+  char tdisp[64];
+  strcpy(tdisp, disp);
+
+  if (!strchr(disp, ':'))
+      strcat(tdisp, ":0");
+  if (!strchr(disp, '.'))
+      strcat(tdisp, ".0");
+
+  char my_dir[128];
+
+  struct passwd *pw = getpwuid(my_uid);
+  snprintf(my_dir, sizeof(my_dir), "%s/.hime-%s", g_get_tmp_dir(), pw->pw_name);
+  struct stat st;
+
+  if (stat(my_dir, &st) < 0)
+    mkdir(my_dir, 0700);
+  else {
+    if (st.st_uid != my_uid) {
+      fprintf(stderr, "please check the permission of dir %s\n", my_dir);
+      return;
+    }
+  }
+
+  snprintf(outstr,outstrN, "%s/socket-%s-%s", my_dir, tdisp, get_hime_xim_name());
+}
+
+
+Atom get_hime_addr_atom(Display *dpy)
+{
+  if (!dpy) {
+    dbg("dpy is null\n");
+    return 0;
+  }
+
+  char *xim_name = get_hime_xim_name();
+  char tt[128];
+
+  snprintf(tt, sizeof(tt), "HIME_ADDR_ATOM_%s", xim_name);
+
+  Atom atom = XInternAtom(dpy, tt, False);
+
+  return atom;
+}
+
+
+
+Atom get_hime_sockpath_atom(Display *dpy)
+{
+  if (!dpy) {
+    dbg("dpy is null\n");
+    return 0;
+  }
+
+  char *xim_name = get_hime_xim_name();
+  char tt[128];
+
+  snprintf(tt, sizeof(tt), "HIME_SOCKPATH_ATOM_%s", xim_name);
+
+  Atom atom = XInternAtom(dpy, tt, False);
+
+  return atom;
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/im-client/hime-im-client-attr.h b/src/plugins/platforminputcontexts/hime/include/im-client/hime-im-client-attr.h
new file mode 100644
index 0000000..ea7369c
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/im-client/hime-im-client-attr.h
@@ -0,0 +1,9 @@
+#define HIME_PREEDIT_ATTR_FLAG_UNDERLINE 1
+#define HIME_PREEDIT_ATTR_FLAG_REVERSE 2
+#define HIME_PREEDIT_ATTR_MAX_N 64
+#define HIME_PREEDIT_MAX_STR 512
+
+typedef struct {
+  int flag;
+  short ofs0, ofs1;   // ofs : bytes offset
+} HIME_PREEDIT_ATTR;
diff --git a/src/plugins/platforminputcontexts/hime/include/im-client/hime-im-client.c b/src/plugins/platforminputcontexts/hime/include/im-client/hime-im-client.c
new file mode 100644
index 0000000..fa67248
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/im-client/hime-im-client.c
@@ -0,0 +1,815 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <signal.h>
+#include <errno.h>
+#include "../hime.h"
+#include "hime-protocol.h"
+#include "hime-im-client.h"
+#define DBG 0
+static int flags_backup;
+
+Atom get_hime_sockpath_atom(Display *dpy);
+static void save_old_sigaction_single(int signo, struct sigaction *act)
+{
+  sigaction(signo, NULL, act);
+
+  if (act->sa_handler != SIG_IGN) {
+    signal(signo, SIG_IGN);
+  }
+}
+
+static void restore_old_sigaction_single(int signo, struct sigaction *act)
+{
+  if (act->sa_handler != SIG_IGN)
+    signal(signo, act->sa_handler);
+}
+char *get_hime_im_srv_sock_path();
+Atom get_hime_addr_atom(Display *dpy);
+
+Window find_hime_window(Display *dpy)
+{
+  Atom hime_addr_atom = get_hime_addr_atom(dpy);
+  if (!hime_addr_atom)
+    return FALSE;
+  return XGetSelectionOwner(dpy, hime_addr_atom);
+}
+
+int is_special_user;
+
+static HIME_client_handle *hime_im_client_reopen(HIME_client_handle *hime_ch, Display *dpy)
+{
+//  dbg("hime_im_client_reopen\n");
+  int dbg_msg = getenv("HIME_CONNECT_MSG_ON") != NULL;
+  int sockfd=0;
+  int servlen;
+//  char *addr;
+  Server_IP_port srv_ip_port;
+#if DEBUG
+  u_char *pp;
+#endif
+
+  int uid = getuid();
+  if (uid > 0 && uid < 500) {
+    is_special_user = TRUE;
+  }
+
+  int tcp = FALSE;
+  HIME_client_handle *handle;
+  int rstatus;
+
+//  dbg("hime_im_client_reopen\n");
+  if (!dpy) {
+    dbg("null disp %d\n", hime_ch->fd);
+    goto next;
+  }
+
+  Atom hime_addr_atom = get_hime_addr_atom(dpy);
+  Window hime_win = None;
+
+
+#define MAX_TRY 3
+  int loop;
+
+  if (!is_special_user)
+  for(loop=0; loop < MAX_TRY; loop++) {
+    if ((hime_win=find_hime_window(dpy))!=None || getenv("HIME_IM_CLIENT_NO_AUTO_EXEC"))
+      break;
+    static time_t exec_time;
+
+    if (time(NULL) - exec_time > 1 /* && count < 5 */) {
+      time(&exec_time);
+      dbg("XGetSelectionOwner: old version of hime or hime is not running ??\n");
+      static char execbin[]=HIME_BIN_DIR"/hime";
+      dbg("... try to start a new hime server %s\n", execbin);
+
+      int pid;
+
+      if ((pid=fork())==0) {
+        setenv("HIME_DAEMON", "", TRUE);
+        execl(execbin, "hime", NULL);
+      } else {
+        int status;
+        // hime will daemon()
+        waitpid(pid, &status, 0);
+      }
+    }
+  }
+
+  if (loop == MAX_TRY || hime_win == None) {
+    goto next;
+  }
+
+  Atom actual_type;
+  int actual_format;
+  u_long nitems,bytes_after;
+  char *message_sock = NULL;
+  Atom hime_sockpath_atom = get_hime_sockpath_atom(dpy);
+
+//  printf("hime_sockpath_atom %d\n", hime_sockpath_atom);
+
+  if (!hime_sockpath_atom || XGetWindowProperty(dpy, hime_win, hime_sockpath_atom, 0, 64,
+     False, AnyPropertyType, &actual_type, &actual_format,
+     &nitems,&bytes_after,(u_char **)&message_sock) != Success) {
+#if DBG || 1
+    dbg("XGetWindowProperty 2: old version of hime or hime is not running ??\n");
+#endif
+    goto next;
+  }
+
+  Server_sock_path srv_sock_path;
+  srv_sock_path.sock_path[0] = 0;
+  if (message_sock) {
+    memcpy(&srv_sock_path, message_sock, sizeof(srv_sock_path));
+    XFree(message_sock);
+  } else
+    goto next;
+
+  struct sockaddr_un serv_addr;
+  bzero((char *) &serv_addr,sizeof(serv_addr));
+  serv_addr.sun_family = AF_UNIX;
+  char sock_path[UNIX_PATH_MAX];
+
+  if (srv_sock_path.sock_path[0]) {
+    strcpy(sock_path, srv_sock_path.sock_path);
+  }
+  else {
+    get_hime_im_srv_sock_path(sock_path, sizeof(sock_path));
+  }
+
+//  addr = sock_path;
+  strcpy(serv_addr.sun_path, sock_path);
+#ifdef SUN_LEN
+  servlen = SUN_LEN(&serv_addr);
+#else
+  servlen = strlen(serv_addr.sun_path) + sizeof(serv_addr.sun_family);
+#endif
+
+  if ((sockfd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
+    perror("cannot open socket");
+    goto tcp;
+  }
+
+  if (connect(sockfd, (struct sockaddr *)&serv_addr, servlen) < 0) {
+    close(sockfd);
+    sockfd = 0;
+    goto tcp;
+  }
+
+  if (dbg_msg)
+    dbg("connected to unix socket addr %s\n", sock_path);
+  goto next;
+
+  char *message;
+
+tcp:
+  message = NULL;
+
+  if (!hime_addr_atom || XGetWindowProperty(dpy, hime_win, hime_addr_atom, 0, 64,
+     False, AnyPropertyType, &actual_type, &actual_format,
+     &nitems,&bytes_after,(u_char **)&message) != Success) {
+#if DBG || 1
+    dbg("XGetWindowProperty: old version of hime or hime is not running ??\n");
+#endif
+    goto next;
+  }
+
+  if (message) {
+    memcpy(&srv_ip_port, message, sizeof(srv_ip_port));
+    XFree(message);
+  } else
+    goto next;
+
+
+//  dbg("im server tcp port %d\n", ntohs(srv_ip_port.port));
+
+  struct sockaddr_in in_serv_addr;
+  bzero((char *) &in_serv_addr, sizeof(in_serv_addr));
+
+  in_serv_addr.sin_family = AF_INET;
+  in_serv_addr.sin_addr.s_addr = srv_ip_port.ip;
+  in_serv_addr.sin_port = srv_ip_port.port;
+  servlen = sizeof(in_serv_addr);
+
+
+  if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+      perror("cannot open socket");
+      goto next;
+  }
+
+  dbg("sock %d\n", sockfd);
+
+  if (connect(sockfd, (struct sockaddr *)&in_serv_addr, servlen) < 0) {
+    dbg("hime_im_client_open cannot open: ") ;
+    perror("");
+    close(sockfd);
+    sockfd = 0;
+    goto next;
+  }
+
+#if DEBUG
+  pp = (u_char *)&srv_ip_port.ip;
+  if (dbg_msg)
+    dbg("hime client connected to server %d.%d.%d.%d:%d\n",
+        pp[0], pp[1], pp[2], pp[3], ntohs(srv_ip_port.port));
+#endif
+
+  tcp = TRUE;
+
+next:
+  if (!hime_ch)
+    handle = tzmalloc(HIME_client_handle, 1);
+  else {
+    handle = hime_ch;
+  }
+
+  if (sockfd < 0)
+    sockfd = 0;
+
+  if (sockfd > 0) {
+    handle->fd = sockfd;
+    if (tcp) {
+      if (!handle->passwd)
+        handle->passwd = malloc(sizeof(HIME_PASSWD));
+      memcpy(handle->passwd, &srv_ip_port.passwd, sizeof(srv_ip_port.passwd));
+    } else {
+      if (handle->passwd) {
+        free(handle->passwd); handle->passwd = NULL;
+      }
+    }
+  }
+
+  if (handle->fd)  {
+    if (BITON(handle->flag, FLAG_HIME_client_handle_has_focus))
+      hime_im_client_focus_in(handle);
+
+    hime_im_client_set_flags(handle, flags_backup, &rstatus);
+  }
+
+  return handle;
+}
+
+
+static void validate_handle(HIME_client_handle *hime_ch)
+{
+  if (hime_ch->fd > 0)
+    return;
+  if (is_special_user)
+    return;
+
+  hime_im_client_reopen(hime_ch, hime_ch->disp);
+}
+
+
+HIME_client_handle *hime_im_client_open(Display *disp)
+{
+//  dbg("hime_im_client_open\n");
+  HIME_client_handle *handle = hime_im_client_reopen(NULL,  disp);
+  handle->disp = disp;
+  return handle;
+}
+
+void hime_im_client_close(HIME_client_handle *handle)
+{
+  if (!handle)
+	  return;
+  if (handle->fd > 0)
+    close(handle->fd);
+  free(handle->passwd);
+  free(handle);
+}
+
+static int gen_req(HIME_client_handle *handle, u_int req_no, HIME_req *req)
+{
+  validate_handle(handle);
+
+  if (!handle->fd)
+    return 0;
+
+  handle->seq++;
+
+  bzero(req, sizeof(HIME_req));
+
+  req->req_no = req_no;
+  to_hime_endian_4(&req->req_no);
+
+  req->client_win = handle->client_win;
+  to_hime_endian_4(&req->client_win);
+
+  req->input_style = handle->input_style;
+  to_hime_endian_4(&req->input_style);
+
+  req->spot_location.x = handle->spot_location.x;
+  req->spot_location.y = handle->spot_location.y;
+  to_hime_endian_2(&req->spot_location.x);
+  to_hime_endian_2(&req->spot_location.y);
+
+  return 1;
+}
+
+static void error_proc(HIME_client_handle *handle, char *msg)
+{
+  if (!handle->fd)
+    return;
+
+  perror(msg);
+  close(handle->fd);
+  handle->fd = 0;
+  usleep(100000);
+}
+
+typedef struct {
+  struct sigaction apipe;
+} SAVE_ACT;
+static void save_old_sigaction(SAVE_ACT *save_act)
+{
+  save_old_sigaction_single(SIGPIPE, &save_act->apipe);
+}
+static void restore_old_sigaction(SAVE_ACT *save_act)
+{
+  restore_old_sigaction_single(SIGPIPE, &save_act->apipe);
+}
+static int handle_read(HIME_client_handle *handle, void *ptr, int n)
+{
+  int fd = handle->fd;
+
+  if (!fd)
+    return 0;
+
+  SAVE_ACT save_act;
+  save_old_sigaction(&save_act);
+  int r = read(fd, ptr, n);
+
+#if (DBG || 1)
+  if (r < 0)
+    perror("handle_read");
+#endif
+
+  restore_old_sigaction(&save_act);
+
+  if (r<=0)
+    return r;
+  if (handle->passwd)
+    __hime_enc_mem((u_char *)ptr, n, handle->passwd, &handle->passwd->seed);
+  return r;
+}
+
+static int handle_write(HIME_client_handle *handle, void *ptr, int n)
+{
+  int fd = handle->fd;
+
+  if (!fd)
+    return 0;
+
+  u_char *tmp = malloc(n);
+  memcpy(tmp, ptr, n);
+
+  if (handle->passwd)
+    __hime_enc_mem(tmp, n, handle->passwd, &handle->passwd->seed);
+
+  SAVE_ACT save_act;
+#if 1
+  save_old_sigaction(&save_act);
+#endif
+  int r =  write(fd, tmp, n);
+#if 1
+  restore_old_sigaction(&save_act);
+#endif
+  free(tmp);
+
+  return r;
+}
+
+void hime_im_client_focus_in(HIME_client_handle *handle)
+{
+  if (!handle)
+    return;
+  if (is_special_user)
+    return;
+
+  HIME_req req;
+//  dbg("hime_im_client_focus_in\n");
+  handle->flag |= FLAG_HIME_client_handle_has_focus;
+
+  if (!gen_req(handle, HIME_req_focus_in, &req))
+    return;
+
+  if (handle_write(handle, &req, sizeof(req)) <=0) {
+    error_proc(handle,"hime_im_client_focus_in error");
+  }
+
+  hime_im_client_set_cursor_location(handle, handle->spot_location.x,
+     handle->spot_location.y);
+}
+
+
+void hime_im_client_focus_out(HIME_client_handle *handle)
+{
+  if (!handle)
+    return;
+  if (is_special_user)
+    return;
+
+  HIME_req req;
+//  dbg("hime_im_client_focus_out\n");
+  handle->flag &= ~FLAG_HIME_client_handle_has_focus;
+
+  if (!gen_req(handle, HIME_req_focus_out, &req))
+    return;
+
+  if (handle_write(handle, &req, sizeof(req)) <=0) {
+    error_proc(handle,"hime_im_client_focus_out error");
+  }
+}
+
+void hime_im_client_focus_out2(HIME_client_handle *handle, char **rstr)
+{
+  HIME_req req;
+  HIME_reply reply;
+
+  if (rstr)
+    *rstr = NULL;
+
+  if (!handle)
+    return;
+
+  if (is_special_user)
+    return;
+
+#if DBG
+  dbg("hime_im_client_focus_out2\n");
+#endif
+  handle->flag &= ~FLAG_HIME_client_handle_has_focus;
+
+  if (!gen_req(handle, HIME_req_focus_out2, &req))
+    return;
+
+  if (handle_write(handle, &req, sizeof(req)) <=0) {
+    error_proc(handle,"hime_im_client_focus_out error");
+  }
+
+  bzero(&reply, sizeof(reply));
+  if (handle_read(handle, &reply, sizeof(reply)) <=0) {
+    error_proc(handle, "cannot read reply from hime server");
+    return;
+  }
+
+  to_hime_endian_4(&reply.datalen);
+  to_hime_endian_4(&reply.flag);
+
+  if (reply.datalen > 0) {
+    *rstr = (char *)malloc(reply.datalen);
+    if (handle_read(handle, *rstr, reply.datalen) <= 0) {
+      free(*rstr); *rstr = NULL;
+      error_proc(handle, "cannot read reply str from hime server");
+      return;
+    }
+  }
+
+//  dbg("hime_im_client_forward_key_event %x\n", reply.flag);
+
+  return;
+}
+
+static int hime_im_client_forward_key_event(HIME_client_handle *handle,
+                                          HIME_req_t event_type,
+                                          KeySym key, u_int state,
+                                          char **rstr)
+{
+  HIME_reply reply;
+  HIME_req req;
+
+  *rstr = NULL;
+
+  if (is_special_user) {
+      return 0;
+  }
+
+  if (!gen_req(handle, event_type, &req))
+    return 0;
+
+  req.keyeve.key = key;
+  to_hime_endian_4(&req.keyeve.key);
+  req.keyeve.state = state;
+  to_hime_endian_4(&req.keyeve.state);
+
+
+  if (handle_write(handle, &req, sizeof(req)) <= 0) {
+    error_proc(handle, "cannot write to hime server");
+    return FALSE;
+  }
+
+  bzero(&reply, sizeof(reply));
+  if (handle_read(handle, &reply, sizeof(reply)) <=0) {
+    error_proc(handle, "cannot read reply from hime server");
+    return FALSE;
+  }
+
+  to_hime_endian_4(&reply.datalen);
+  to_hime_endian_4(&reply.flag);
+
+  if (reply.datalen > 0) {
+    *rstr = (char *)malloc(reply.datalen);
+    if (handle_read(handle, *rstr, reply.datalen) <= 0) {
+      free(*rstr); *rstr = NULL;
+      error_proc(handle, "cannot read reply str from hime server");
+      return FALSE;
+    }
+  }
+
+//  dbg("hime_im_client_forward_key_event %x\n", reply.flag);
+
+  return reply.flag;
+}
+
+
+// return TRUE if the key is accepted
+int hime_im_client_forward_key_press(HIME_client_handle *handle,
+                                          KeySym key, u_int state,
+                                          char **rstr)
+{
+  int flag;
+  if (!handle)
+    return 0;
+  // in case client didn't send focus in event
+  if (!BITON(handle->flag, FLAG_HIME_client_handle_has_focus)) {
+    hime_im_client_focus_in(handle);
+    handle->flag |= FLAG_HIME_client_handle_has_focus;
+    hime_im_client_set_cursor_location(handle, handle->spot_location.x,
+       handle->spot_location.y);
+  }
+
+//  dbg("hime_im_client_forward_key_press\n");
+  flag = hime_im_client_forward_key_event(
+             handle, HIME_req_key_press, key, state, rstr);
+
+  return ((flag & HIME_reply_key_processed) !=0);
+}
+
+
+// return TRUE if the key is accepted
+int hime_im_client_forward_key_release(HIME_client_handle *handle,
+                                          KeySym key, u_int state,
+                                          char **rstr)
+{
+  int flag;
+  if (!handle)
+    return 0;
+  handle->flag |= FLAG_HIME_client_handle_has_focus;
+//  dbg("hime_im_client_forward_key_release\n");
+  flag = hime_im_client_forward_key_event(
+             handle, HIME_req_key_release, key, state, rstr);
+  return ((flag & HIME_reply_key_processed) !=0);
+}
+
+
+void hime_im_client_set_cursor_location(HIME_client_handle *handle, int x, int y)
+{
+  if (!handle)
+    return;
+  if (is_special_user)
+    return;
+
+//  dbg("hime_im_client_set_cursor_location %d   %d,%d\n", handle->flag, x, y);
+
+  HIME_req req;
+  handle->spot_location.x = x;
+  handle->spot_location.y = y;
+
+  if (!BITON(handle->flag, FLAG_HIME_client_handle_has_focus))
+    return;
+
+  if (!gen_req(handle, HIME_req_set_cursor_location, &req))
+    return;
+
+  if (handle_write(handle, &req, sizeof(req)) <=0) {
+    error_proc(handle,"hime_im_client_set_cursor_location error");
+  }
+}
+
+// in win32, if win is NULL, this means hime_im_client_set_cursor_location(x,y) is screen position
+void hime_im_client_set_window(HIME_client_handle *handle, Window win)
+{
+  if (!handle)
+    return;
+//  dbg("hime_im_client_set_window %x\n", win);
+
+  if (is_special_user)
+    return;
+  if (!win)
+    return;
+  handle->client_win = win;
+
+// For chrome
+//  hime_im_client_set_cursor_location(handle, handle->spot_location.x, handle->spot_location.y);
+}
+
+void hime_im_client_set_flags(HIME_client_handle *handle, int flags, int *ret_flag)
+{
+  HIME_req req;
+
+#if DBG
+  dbg("hime_im_client_set_flags\n");
+#endif
+
+  if (!handle)
+    return;
+
+  if (is_special_user)
+    return;
+
+  if (!gen_req(handle, HIME_req_set_flags, &req))
+    return;
+
+  req.flag |= flags;
+
+  flags_backup = req.flag;
+
+#if DBG
+  dbg("hime_im_client_set_flags b\n");
+#endif
+
+  if (handle_write(handle, &req, sizeof(req)) <=0) {
+    error_proc(handle,"hime_im_client_set_flags error");
+  }
+
+#if DBG
+  dbg("hime_im_client_set_flags c\n");
+#endif
+
+  if (handle_read(handle, ret_flag, sizeof(int)) <= 0) {
+    error_proc(handle, "cannot read reply str from hime server");
+  }
+}
+
+
+void hime_im_client_clear_flags(HIME_client_handle *handle, int flags, int *ret_flag)
+{
+  HIME_req req;
+
+  if (!handle)
+    return;
+
+  if (is_special_user)
+    return;
+
+  if (!gen_req(handle, HIME_req_set_flags, &req))
+    return;
+
+  req.flag &= ~flags;
+
+  flags_backup = req.flag;
+
+  if (handle_write(handle, &req, sizeof(req)) <=0) {
+    error_proc(handle,"hime_im_client_set_flags error");
+  }
+
+  if (handle_read(handle, ret_flag, sizeof(int)) <= 0) {
+    error_proc(handle, "cannot read reply str from hime server");
+  }
+}
+
+
+int hime_im_client_get_preedit(HIME_client_handle *handle, char **str, HIME_PREEDIT_ATTR att[], int *cursor ,int *sub_comp_len)
+{
+  *str=NULL;
+  if (!handle)
+    return 0;
+
+  if (is_special_user)
+    return 0;
+
+  int attN, tcursor, str_len;
+#if DBG
+  dbg("hime_im_client_get_preedit\n");
+#endif
+  HIME_req req;
+  if (!gen_req(handle, HIME_req_get_preedit, &req)) {
+err_ret:
+#if DBG
+    dbg("aaaaaaaaaaaaa %x\n", str);
+#endif
+    if (cursor)
+      *cursor=0;
+    *str=strdup("");
+    return 0;
+  }
+
+  if (handle_write(handle, &req, sizeof(req)) <=0) {
+    error_proc(handle,"hime_im_client_get_preedit error");
+    goto err_ret;
+  }
+
+  str_len=-1; // str_len includes \0
+  if (handle_read(handle, &str_len, sizeof(str_len))<=0)
+    goto err_ret; // including \0
+
+  *str = (char *)malloc(str_len);
+
+  if (handle_read(handle, *str, str_len)<=0)
+    goto err_ret;
+#if DBG
+  dbg("hime_im_client_get_preedit len:%d '%s' \n", str_len, *str);
+#endif
+  attN = -1;
+  if (handle_read(handle, &attN, sizeof(attN))<=0) {
+    goto err_ret;
+  }
+
+//  dbg("attrN:%d\n", attN);
+
+  if (attN>0 && handle_read(handle, att, sizeof(HIME_PREEDIT_ATTR)*attN)<=0) {
+    goto err_ret;
+  }
+
+
+  tcursor=0;
+  if (handle_read(handle, &tcursor, sizeof(tcursor))<=0) {
+    goto err_ret;
+  }
+
+  if (cursor)
+    *cursor = tcursor;
+
+  int tsub_comp_len;
+  tsub_comp_len=0;
+  if (handle_read(handle, &tsub_comp_len, sizeof(tsub_comp_len))<=0) {
+    goto err_ret;
+  }
+  if (sub_comp_len)
+	*sub_comp_len = tsub_comp_len;
+
+#if DBG
+  dbg("jjjjjjjjj %d tcursor:%d\n", attN, tcursor);
+#endif
+  return attN;
+}
+
+
+
+void hime_im_client_reset(HIME_client_handle *handle)
+{
+  if (!handle)
+    return;
+
+  if (is_special_user)
+    return;
+
+  HIME_req req;
+#if DBG
+  dbg("hime_im_client_reset\n");
+#endif
+  if (!gen_req(handle, HIME_req_reset, &req))
+    return;
+
+  if (handle_write(handle, &req, sizeof(req)) <=0) {
+    error_proc(handle,"hime_im_client_reset error");
+  }
+}
+
+
+void hime_im_client_message(HIME_client_handle *handle, char *message)
+{
+  HIME_req req;
+  short len;
+#if DBG
+  dbg("hime_im_client_message\n");
+#endif
+  if (!gen_req(handle, HIME_req_message, &req))
+    return;
+
+  if (handle_write(handle, &req, sizeof(req)) <=0) {
+    error_proc(handle,"hime_im_client_message error 1");
+  }
+
+  len = strlen(message)+1;
+  if (handle_write(handle, &len, sizeof(len)) <=0) {
+    error_proc(handle,"hime_im_client_message error 2");
+  }
+
+  if (handle_write(handle, message, len) <=0) {
+    error_proc(handle,"hime_im_client_message error 2");
+  }
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/im-client/hime-im-client.h b/src/plugins/platforminputcontexts/hime/include/im-client/hime-im-client.h
new file mode 100644
index 0000000..54d8f44
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/im-client/hime-im-client.h
@@ -0,0 +1,96 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef HIME_IM_CLIENT_H
+#define HIME_IM_CLIENT_H
+
+#ifndef _XSERVER64
+#define _XSERVER64
+#endif
+
+struct HIME_PASSWD;
+
+typedef struct HIME_client_handle_S {
+  int fd;
+  Window client_win;	/* client window */
+  u_int	input_style;	/* input style */
+  XPoint spot_location; /* spot location */
+// below is private data, don't modify them.
+  u_int flag;
+  Display *disp;
+  struct HIME_PASSWD *passwd;
+  u_int seq;
+} HIME_client_handle;
+
+enum {
+  FLAG_HIME_client_handle_has_focus = 1,
+  FLAG_HIME_client_handle_use_preedit = 2,
+  FLAG_HIME_client_handle_raise_window = 0x1000  // for mozilla, dirty fix
+};
+
+enum {
+  FLAG_HIME_srv_ret_status_use_pop_up = 1    // If this is used, we don't need the dirty fix
+};
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+HIME_client_handle *hime_im_client_open(Display *disp);
+void hime_im_client_close(HIME_client_handle *handle);
+void hime_im_client_focus_in(HIME_client_handle *handle);
+void hime_im_client_focus_out(HIME_client_handle *handle);
+void hime_im_client_focus_out2(HIME_client_handle *handle, char **rstr);
+void hime_im_client_set_window(HIME_client_handle *handle, Window win);
+void hime_im_client_set_cursor_location(HIME_client_handle *handle,
+                                        int x, int y);
+/*  rstr returns UTF-8 encoded string, you should use 'free()' to free the
+    memory.
+
+    return boolean:
+      FALSE : the key is rejected, should use client's own result(ASCII key).
+      TRUE : the key is accepted, translated result is in rstr.
+ */
+int hime_im_client_forward_key_press(HIME_client_handle *handle,
+                                          KeySym key, u_int state,
+                                          char **rstr);
+// return some state bits instead of TRUE/FALSE
+int hime_im_client_forward_key_press2(HIME_client_handle *handle,
+                                          KeySym key, u_int state,
+                                          char **rstr);
+int hime_im_client_forward_key_release(HIME_client_handle *handle,
+                                          KeySym key, u_int state,
+                                          char **rstr);
+
+void hime_im_client_set_flags(HIME_client_handle *handle, int flags, int *ret_flags);
+void hime_im_client_clear_flags(HIME_client_handle *handle, int flags, int *ret_flags);
+
+void hime_im_client_reset(HIME_client_handle *handle);
+void hime_im_client_message(HIME_client_handle *handle, char *message);
+
+#include "hime-im-client-attr.h"
+int hime_im_client_get_preedit(HIME_client_handle *handle, char **str, HIME_PREEDIT_ATTR att[], int *cursor, int *sub_comp_len);
+
+Window find_hime_window(Display *dpy);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
diff --git a/src/plugins/platforminputcontexts/hime/include/im-client/hime-protocol.h b/src/plugins/platforminputcontexts/hime/include/im-client/hime-protocol.h
new file mode 100644
index 0000000..b7b4ee3
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/im-client/hime-protocol.h
@@ -0,0 +1,95 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <X11/Xlib.h>
+#include "../hime-endian.h"
+
+#define UNIX_PATH_MAX 108
+
+typedef enum {
+  HIME_req_key_press = 1,
+  HIME_req_key_release = 2,
+  HIME_req_focus_in = 4,
+  HIME_req_focus_out = 8,
+  HIME_req_set_cursor_location = 0x10,
+  HIME_req_set_flags = 0x20,
+  HIME_req_get_preedit = 0x40,
+  HIME_req_reset = 0x80,
+  HIME_req_focus_out2 = 0x100,
+  HIME_req_message = 0x200,
+  HIME_req_test_key_press = 0x400,
+  HIME_req_test_key_release = 0x800,
+} HIME_req_t;
+
+
+typedef struct {
+#if 0
+    KeySym key;
+#else
+    u_int key;
+#endif
+    u_int state;
+} KeyEvent;
+
+typedef struct {
+    short x, y;
+} HIMEpoint;
+
+
+typedef struct {
+  u_int req_no;  // to make the im server stateless, more is better
+  u_int client_win;
+  u_int flag;
+  u_int input_style;
+  HIMEpoint spot_location;
+
+  union {
+    KeyEvent keyeve;
+    char dummy[32];   // for future expansion
+  };
+} HIME_req;
+
+
+enum {
+  HIME_reply_key_processed = 1,
+  HIME_reply_key_state_disabled = 2,
+};
+
+
+typedef struct {
+  u_int flag;
+  u_int datalen;    // '\0' shoule be counted if data is string
+} HIME_reply;
+
+
+#define __HIME_PASSWD_N_ (31)
+
+typedef struct HIME_PASSWD {
+  u_int seed;
+  u_char passwd[__HIME_PASSWD_N_];
+} HIME_PASSWD;
+
+typedef struct {
+  u_int ip;
+  u_short port;
+  HIME_PASSWD passwd;
+} Server_IP_port;
+
+typedef struct {
+  char sock_path[UNIX_PATH_MAX];
+} Server_sock_path;
+void __hime_enc_mem(u_char *p, int n, HIME_PASSWD *passwd, u_int *seed);
diff --git a/src/plugins/platforminputcontexts/hime/include/im-client/hime-send.c b/src/plugins/platforminputcontexts/hime/include/im-client/hime-send.c
new file mode 100644
index 0000000..0b22fba
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/im-client/hime-send.c
@@ -0,0 +1,26 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "../hime.h"
+#include "hime-im-client.h"
+
+void send_hime_message(Display *dpy, char *s)
+{
+  HIME_client_handle *handle = hime_im_client_open(dpy);
+  hime_im_client_message(handle, s);
+  hime_im_client_close(handle);
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/im-srv.c b/src/plugins/platforminputcontexts/hime/include/im-srv.c
new file mode 100644
index 0000000..ac50497
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/im-srv.c
@@ -0,0 +1,293 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <string.h>
+#include <netdb.h>
+#include <X11/Xatom.h>
+#include <sys/stat.h>
+#include <arpa/inet.h>
+#include <ifaddrs.h>
+
+#include "hime.h"
+#include "im-client/hime-protocol.h"
+#include "im-srv.h"
+#include <gdk/gdk.h>
+
+int im_sockfd, im_tcp_sockfd;
+Atom get_hime_sockpath_atom(Display *dpy);
+Server_IP_port srv_ip_port;
+static Window prop_win;
+static Atom addr_atom;
+
+void gdk_input_remove	  (gint		     tag);
+
+
+void get_hime_im_srv_sock_path(char *outstr, int outstrN);
+void process_client_req(int fd);
+
+static gboolean cb_read_hime_client_data(GIOChannel *source, GIOCondition condition, gpointer data)
+{
+  int fd=GPOINTER_TO_INT(data);
+
+  process_client_req(fd);
+  return TRUE;
+}
+
+Atom get_hime_addr_atom(Display *dpy);
+
+static void gen_passwd_idx()
+{
+  srv_ip_port.passwd.seed = (rand() >> 1) % __HIME_PASSWD_N_;
+
+  Server_IP_port tsrv_ip_port = srv_ip_port;
+
+  to_hime_endian_4(&srv_ip_port.passwd.seed);
+  XChangeProperty(dpy, prop_win , addr_atom, XA_STRING, 8,
+     PropModeReplace, (unsigned char *)&tsrv_ip_port, sizeof(srv_ip_port));
+
+  XSync(GDK_DISPLAY(), FALSE);
+}
+
+
+
+static gboolean cb_new_hime_client(GIOChannel *source, GIOCondition condition, gpointer data)
+{
+  Connection_type type=(Connection_type) GPOINTER_TO_INT(data);
+#if 0
+  dbg("im-srv: cb_new_hime_client %s\n", type==Connection_type_unix ? "unix":"tcp");
+#endif
+  int newsockfd;
+  socklen_t clilen;
+
+  if (type==Connection_type_unix) {
+    struct sockaddr_un cli_addr;
+
+    bzero(&cli_addr, sizeof(cli_addr));
+    clilen=0;
+    newsockfd = accept(im_sockfd,(struct sockaddr *) & cli_addr, &clilen);
+  } else
+  {
+    struct sockaddr_in cli_addr;
+
+    bzero(&cli_addr, sizeof(cli_addr));
+    clilen=sizeof(cli_addr);
+    newsockfd = accept(im_tcp_sockfd,(struct sockaddr *) & cli_addr, &clilen);
+  }
+
+  if (newsockfd < 0) {
+    perror("accept");
+    return FALSE;
+  }
+
+//  dbg("newsockfd %d\n", newsockfd);
+
+  if (newsockfd >= hime_clientsN - 1) {
+    int prev_hime_clientsN = hime_clientsN, c;
+    hime_clientsN = newsockfd + 1;
+    hime_clients = trealloc(hime_clients, HIME_ENT, hime_clientsN);
+    // Initialize clientstate in useless hime_clients for recognition
+    for(c=prev_hime_clientsN;c<hime_clientsN;c++)
+      hime_clients[c].cs = NULL;
+  }
+
+  bzero(&hime_clients[newsockfd], sizeof(hime_clients[0]));
+
+  hime_clients[newsockfd].tag = g_io_add_watch(g_io_channel_unix_new(newsockfd), G_IO_IN, cb_read_hime_client_data,
+              GINT_TO_POINTER(newsockfd));
+
+  if (type==Connection_type_tcp) {
+    hime_clients[newsockfd].seed = srv_ip_port.passwd.seed;
+    gen_passwd_idx();
+  }
+  hime_clients[newsockfd].type = type;
+  return TRUE;
+}
+
+
+static int get_ip_address(u_int *ip)
+{
+
+#if 0
+  char hostname[64];
+
+  if (gethostname(hostname, sizeof(hostname)) < 0) {
+    perror("cannot get hostname\n");
+    return -1;
+  }
+  dbg("hostname %s\n", hostname);
+  struct hostent *hent;
+
+  if (!(hent=gethostbyname(hostname))) {
+    dbg("cannot call gethostbyname to get IP address");
+    return -1;
+  }
+
+  memcpy(ip, hent->h_addr_list[0], hent->h_length);
+#else
+  struct ifaddrs *ifaddr = NULL, *ifa;
+  int family;
+
+  if (getifaddrs(&ifaddr) == -1) {
+    perror("getifaddrs");
+    exit(EXIT_FAILURE);
+  }
+
+  for (ifa = ifaddr; ifa; ifa = ifa->ifa_next) {
+      if (!ifa->ifa_addr)
+        continue;
+
+      family = ifa->ifa_addr->sa_family;
+      if (family == AF_INET) {
+        struct sockaddr_in *padd=(struct sockaddr_in *)ifa->ifa_addr;
+        char *ipaddr = inet_ntoa(padd->sin_addr);
+        if (!strcmp(ipaddr, "127.0.0.1"))
+          continue;
+        dbg("ip addr %s\n", ipaddr);
+        memcpy(ip, &padd->sin_addr.s_addr, INET_ADDRSTRLEN);
+        break;
+      }
+  }
+
+  freeifaddrs(ifaddr);
+#endif
+  return 0;
+}
+
+
+
+void start_pipe_svr();
+
+void init_hime_im_serv(Window win)
+{
+  dbg("init_hime_im_serv\n");
+
+  int servlen;
+  prop_win = win;
+  struct sockadd_un;
+  struct sockaddr_un serv_addr;
+
+  // unix socket
+  bzero(&serv_addr,sizeof(serv_addr));
+  serv_addr.sun_family = AF_UNIX;
+  char sock_path[UNIX_PATH_MAX];
+  get_hime_im_srv_sock_path(sock_path, sizeof(sock_path));
+  strcpy(serv_addr.sun_path, sock_path);
+
+#ifdef SUN_LEN
+  servlen = SUN_LEN (&serv_addr);
+#else
+  servlen = strlen(serv_addr.sun_path) + sizeof(serv_addr.sun_family);
+#endif
+
+  dbg("-- %s\n",serv_addr.sun_path);
+  struct stat st;
+
+  if (!stat(serv_addr.sun_path, &st)) {
+    if (unlink(serv_addr.sun_path) < 0) {
+      char tt[512];
+      snprintf(tt, sizeof(tt), "unlink error %s", serv_addr.sun_path);
+      perror(tt);
+    }
+  }
+
+
+  if ((im_sockfd = socket(AF_UNIX,SOCK_STREAM,0)) < 0) {
+    perror("cannot open unix socket");
+    exit(-1);
+  }
+
+  if (bind(im_sockfd, (struct sockaddr *) &serv_addr, servlen) < 0) {
+    perror("cannot bind");
+    exit(-1);
+  }
+
+  listen(im_sockfd,2);
+
+  dbg("im_sockfd:%d\n", im_sockfd);
+
+  g_io_add_watch(g_io_channel_unix_new(im_sockfd), G_IO_IN, cb_new_hime_client,
+                GINT_TO_POINTER(Connection_type_unix));
+
+  Display *dpy = GDK_DISPLAY();
+
+  Server_sock_path srv_sockpath;
+  strcpy(srv_sockpath.sock_path, sock_path);
+  Atom sockpath_atom = get_hime_sockpath_atom(dpy);
+  XChangeProperty(dpy, prop_win , sockpath_atom, XA_STRING, 8,
+     PropModeReplace, (unsigned char *)&srv_sockpath, sizeof(srv_sockpath));
+
+  addr_atom = get_hime_addr_atom(dpy);
+  XSetSelectionOwner(dpy, addr_atom, win, CurrentTime);
+
+  if (!hime_remote_client) {
+    dbg("connection via TCP is disabled\n");
+    return;
+  }
+
+  // tcp socket
+  if (get_ip_address(&srv_ip_port.ip) < 0)
+    return;
+
+  if ((im_tcp_sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+    perror("cannot open tcp socket");
+    exit(-1);
+  }
+
+//  dbg("socket succ\n");
+
+  struct sockaddr_in serv_addr_tcp;
+  u_short port;
+
+  for(port=9999; port < 20000; port++)
+  {
+    // tcp socket
+    bzero(&serv_addr_tcp, sizeof(serv_addr_tcp));
+    serv_addr_tcp.sin_family = AF_INET;
+
+    serv_addr_tcp.sin_addr.s_addr = htonl(INADDR_ANY);
+    serv_addr_tcp.sin_port = htons(port);
+    if (bind(im_tcp_sockfd, (struct sockaddr *) &serv_addr_tcp, sizeof(serv_addr_tcp)) == 0)
+      break;
+  }
+
+  srv_ip_port.port = serv_addr_tcp.sin_port;
+  dbg("server port bind to %s:%d\n", inet_ntoa(serv_addr_tcp.sin_addr), port);
+  time_t t;
+  srand(time(&t));
+
+  int i;
+  for(i=0; i < __HIME_PASSWD_N_; i++) {
+    srv_ip_port.passwd.passwd[i] = (rand()>>2) & 0xff;
+  }
+
+  if (listen(im_tcp_sockfd, 5) < 0) {
+    perror("cannot listen: ");
+    exit(1);
+  }
+
+  dbg("after listen\n");
+
+
+  gen_passwd_idx();
+
+  g_io_add_watch(g_io_channel_unix_new(im_tcp_sockfd), G_IO_IN, cb_new_hime_client,
+                GINT_TO_POINTER(Connection_type_tcp));
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/im-srv.h b/src/plugins/platforminputcontexts/hime/include/im-srv.h
new file mode 100644
index 0000000..4bd9657
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/im-srv.h
@@ -0,0 +1,33 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+typedef enum {
+  Connection_type_unix = 1,
+  Connection_type_tcp = 2
+} Connection_type;
+
+typedef struct {
+  ClientState *cs;
+  int tag;
+  u_int seed;
+  Connection_type type;
+  int fd;
+} HIME_ENT;
+
+extern HIME_ENT *hime_clients;
+extern int hime_clientsN;
+extern Server_IP_port srv_ip_port;
diff --git a/src/plugins/platforminputcontexts/hime/include/lang.c b/src/plugins/platforminputcontexts/hime/include/lang.c
new file mode 100644
index 0000000..d7035e8
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/lang.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "hime.h"
+#include "lang.h"
+
+gboolean is_chs;
+char *tsin32_f="tsin32";
+
+void set_is_chs()
+{
+  char *lc_ctype = getenv("LC_CTYPE");
+  char *lc_all = getenv("LC_ALL");
+  char *lang = getenv("LANG");
+  if (!lc_ctype && lang)
+    lc_ctype = lang;
+
+  if (lc_all)
+    lc_ctype = lc_all;
+
+  if (!lc_ctype)
+    lc_ctype = "zh_TW.Big5";
+  dbg("hime get env LC_CTYPE=%s  LC_ALL=%s  LANG=%s\n", lc_ctype, lc_all, lang);
+
+  if (strstr(lc_ctype, "zh_CN") || 0) {
+    is_chs = TRUE;
+  }
+
+  if (is_chs) {
+    tsin32_f = "s-tsin32";
+    dbg("is simplified chinese\n");
+  }
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/lang.h b/src/plugins/platforminputcontexts/hime/include/lang.h
new file mode 100644
index 0000000..c54a2b6
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/lang.h
@@ -0,0 +1,3 @@
+extern gboolean is_chs;
+extern char *tsin32_f;
+void set_is_chs();
diff --git a/src/plugins/platforminputcontexts/hime/include/os-dep.h b/src/plugins/platforminputcontexts/hime/include/os-dep.h
new file mode 100644
index 0000000..1b2fb01
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/os-dep.h
@@ -0,0 +1,18 @@
+#ifndef OS_DEP_H
+#define OS_DEP_H
+
+typedef char unich_t;
+void unix_exec(char *fmt,...);
+
+#include <X11/Xlib.h>
+#include <X11/Xlocale.h>
+#include <X11/keysym.h>
+
+#include <glib.h>
+#if GLIB_CHECK_VERSION(2,29,8)
+#define G_CONST_RETURN const
+#endif
+
+#include <gdk/gdkx.h>
+
+#endif
diff --git a/src/plugins/platforminputcontexts/hime/include/pho-status.h b/src/plugins/platforminputcontexts/hime/include/pho-status.h
new file mode 100644
index 0000000..f31f8a4
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/pho-status.h
@@ -0,0 +1,7 @@
+enum {
+  PHO_STATUS_REJECT=1,
+  PHO_STATUS_OK=2,
+  PHO_STATUS_OK_NEW=4,
+  PHO_STATUS_PINYIN_LEFT=8,
+  PHO_STATUS_TONE=16,
+};
diff --git a/src/plugins/platforminputcontexts/hime/include/pho.c b/src/plugins/platforminputcontexts/hime/include/pho.c
new file mode 100644
index 0000000..bcefa8c
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/pho.c
@@ -0,0 +1,869 @@
+/* Copyright (C) 1994-2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "hime.h"
+#include "pho.h"
+#include <sys/stat.h>
+#include <stdlib.h>
+#include "gtab.h"
+#include "gst.h"
+#include "pho-status.h"
+
+PHO_ST poo;
+
+extern PHO_ITEM *ch_pho;
+
+PHOKBM phkbm;
+extern int text_pho_N;
+gboolean b_hsu_kbm;
+extern PIN_JUYIN *pin_juyin;
+int pin_juyinN;
+
+gboolean full_char_proc(KeySym keysym);
+void hide_win_pho();
+void ClrSelArea();
+
+#define MAX_HASH_PHO 27
+u_short hash_pho[MAX_HASH_PHO+1];
+
+static char typ_pho_len[]={5, 2, 4, 3};
+
+gboolean same_query_show_pho_win();
+
+gboolean typ_pho_empty()
+{
+  return !poo.typ_pho[0] &&!poo.typ_pho[1] &&!poo.typ_pho[2] &&!poo.typ_pho[3];
+}
+
+gboolean pho_has_input()
+{
+  return !typ_pho_empty() || same_query_show_pho_win();
+}
+
+phokey_t pho2key(char typ_pho[])
+{
+  phokey_t key=typ_pho[0];
+  int i;
+
+  if (key==BACK_QUOTE_NO)
+    return (BACK_QUOTE_NO<<9) | typ_pho[1];
+
+  for(i=1; i < 4; i++) {
+    key =  typ_pho[i] | (key << typ_pho_len[i]) ;
+  }
+
+  return key;
+}
+
+void key_typ_pho(phokey_t phokey, u_char rtyp_pho[])
+{
+  rtyp_pho[3] = phokey & 7;
+  phokey >>= 3;
+  rtyp_pho[2] = phokey & 0xf;
+  phokey >>=4;
+  rtyp_pho[1] = phokey & 0x3;
+  phokey >>=2;
+  rtyp_pho[0] = phokey;
+}
+
+
+void mask_key_typ_pho(phokey_t *key)
+{
+  if (poo.typ_pho[0] == BACK_QUOTE_NO)
+    return;
+  if (!poo.typ_pho[0]) *key &= ~(31<<9);
+  if (!poo.typ_pho[1]) *key &= ~(3<<7);
+  if (!poo.typ_pho[2]) *key &= ~(15<<3);
+  if (!poo.typ_pho[3]) *key &= ~(7);
+}
+
+#define TKBM 0
+#define MIN_M_PHO 5
+
+static void find_match_phos(u_char mtyp_pho[4], int *mcount, int newkey)
+{
+      int vv;
+      phokey_t key = pho2key(poo.typ_pho);
+
+      mask_key_typ_pho(&key);
+#if TKBM
+      dbg("-------------------- %d --", poo.typ_pho[3]);
+      prph(key);
+      dbg("\n");
+#endif
+      for (vv = hash_pho[(int)poo.typ_pho[0]]; vv < hash_pho[(int)poo.typ_pho[0]+1]; vv++) {
+        phokey_t ttt=idx_pho[vv].key;
+
+        if (newkey!=' ' && !poo.typ_pho[3])
+          mask_key_typ_pho(&ttt);
+
+        if (ttt > key)
+          break;
+
+        int count = 0;
+
+        int i;
+        for(i=idx_pho[vv].start; i < idx_pho[vv+1].start; i++) {
+          if (utf8_sz(pho_idx_str(i)) > 1) {
+#if 0
+            utf8_putchar(ch_pho[i].ch);
+            dbg(" ");
+#endif
+            count++;
+          }
+        }
+
+        if (*mcount < count) {
+          *mcount = count;
+          memcpy(mtyp_pho, poo.typ_pho, sizeof(poo.typ_pho));
+#if TKBM
+          dbg("count %d\n", count);
+#endif
+          if (*mcount > MIN_M_PHO)
+            break;
+        }
+      }
+}
+
+gboolean inph_typ_pho_pinyin(int newkey);
+
+static int typ_pho_status()
+{
+  return poo.typ_pho[3] ? PHO_STATUS_OK_NEW:PHO_STATUS_OK;
+}
+
+int inph_typ_pho(KeySym newkey)
+{
+  int i;
+  int insert = -1;
+
+  if (pin_juyin) {
+    return inph_typ_pho_pinyin(newkey);
+  }
+
+  if (poo.typ_pho[0]==BACK_QUOTE_NO) {
+    poo.typ_pho[1]=(char)newkey;
+    poo.inph[1]=newkey;
+    return PHO_STATUS_OK;
+  }
+
+  int max_in_idx;
+  for(max_in_idx=3; max_in_idx>=0 && !poo.typ_pho[max_in_idx]; max_in_idx--);
+
+  // try insert mode first
+  if (insert < 0)
+  for(i=0; i < 3; i++) {
+    char num = phkbm.phokbm[(int)newkey][i].num;
+    int typ = phkbm.phokbm[(int)newkey][i].typ;
+
+    if (num && !poo.inph[typ] && typ>max_in_idx) {
+      poo.inph[typ] = newkey;
+      poo.typ_pho[typ] = num;
+#if TKBM
+      dbg("insert typ %d\n", typ);
+#endif
+      insert = typ;
+      break;
+    }
+  }
+
+  if (insert < 0) {
+    // then overwrite mode
+    for(i=0; i < 3; i++) {
+      char num = phkbm.phokbm[newkey][i].num;
+      int typ = phkbm.phokbm[newkey][i].typ;
+
+      if (num) {
+        poo.inph[typ] = newkey;
+        poo.typ_pho[typ] = num;
+        insert = typ;
+        break;
+      }
+    }
+  }
+
+//  dbg("newkey %c\n", newkey);
+
+  int mcount = 0;
+  u_char mtyp_pho[4];
+
+  int a;
+
+  for(a=0; a < 3; a++) {
+    char num = phkbm.phokbm[(int)poo.inph[0]][a].num;
+    char typ = phkbm.phokbm[(int)poo.inph[0]][a].typ;
+
+    if (typ == 3)
+      continue;
+
+    if (num) {
+      if (typ==2 && poo.typ_pho[0] && !poo.typ_pho[2])
+        poo.typ_pho[0] = 0;
+      poo.typ_pho[(int)typ] = num;
+#if TKBM
+      dbg("%d num %d\n",a, num);
+#endif
+      find_match_phos(mtyp_pho, &mcount, newkey);
+    }
+
+    for(i=0; i < 3; i++) {
+      char num = phkbm.phokbm[(int)poo.inph[2]][i].num;
+      char typ = phkbm.phokbm[(int)poo.inph[2]][i].typ;
+
+      if (!num)
+        break;
+
+      if (typ!=2)
+        continue;
+
+      poo.typ_pho[(int)typ] = num;
+
+      find_match_phos(mtyp_pho, &mcount, newkey);
+
+      if (mcount > MIN_M_PHO) {
+        return typ_pho_status();
+      }
+    }
+
+
+    find_match_phos(mtyp_pho, &mcount, newkey);
+
+    if (mcount > MIN_M_PHO) {
+      return typ_pho_status();
+    }
+  }
+
+  if (mcount) {
+    memcpy(poo.typ_pho, mtyp_pho, sizeof(poo.typ_pho));
+    return typ_pho_status();
+  }
+
+  return PHO_STATUS_REJECT;
+}
+
+
+void clrin_pho()
+{
+  bzero(poo.typ_pho,sizeof(poo.typ_pho));
+  bzero(poo.inph,sizeof(poo.inph));
+  poo.maxi=poo.ityp3_pho=0;
+  poo.cpg=0;
+
+  if (hime_pop_up_win && !same_query_show_pho_win())
+    hide_win_pho();
+}
+
+void disp_pho(int index, char *phochar);
+void clr_in_area_pho()
+{
+  int i;
+
+  clrin_pho();
+  for(i=0; i < text_pho_N; i++)
+    disp_pho(i, "  ");
+}
+
+
+static void disp_in_area_pho()
+{
+  int i;
+
+  text_pho_N = pin_juyin?7:4;
+  if (pin_juyin) {
+    for(i=0;i<text_pho_N;i++) {
+      disp_pho(i, &poo.inph[i]);
+    }
+  } else {
+    for(i=0;i<4;i++) {
+      if (i==1 && poo.typ_pho[0]==BACK_QUOTE_NO) {
+        disp_pho(i, &poo.inph[1]);
+      }
+      else
+        disp_pho(i, &pho_chars[i][poo.typ_pho[i]*3]);
+    }
+  }
+}
+
+static int qcmp_count(const void *aa, const void *bb)
+{
+  PHO_ITEM *a = (PHO_ITEM *)aa;
+  PHO_ITEM *b = (PHO_ITEM *)bb;
+
+  return b->count - a->count;
+}
+
+void disp_pho_sel(char *s);
+
+static void ClrPhoSelArea()
+{
+  disp_pho_sel("");
+}
+
+
+extern char *TableDir;
+extern char phofname[128];
+
+gboolean get_start_stop_idx(phokey_t key, int *start_i, int *stop_i)
+{
+  int typ_pho0 = key >> 9;
+  int vv=hash_pho[typ_pho0];
+
+  while (vv<idxnum_pho) {
+    if (idx_pho[vv].key>=key) break;
+    else
+      vv++;
+  }
+
+  if (vv >= idxnum_pho || idx_pho[vv].key != key)
+    return FALSE;
+
+  *start_i=idx_pho[vv].start;
+  *stop_i=idx_pho[vv+1].start;
+
+  return TRUE;
+}
+
+// given the pho key & the utf8 char, return the idx in ch_pho
+int ch_key_to_ch_pho_idx(phokey_t phkey, char *utf8)
+{
+  int start_i, stop_i;
+
+  get_start_stop_idx(phkey, &start_i, &stop_i);
+
+  int i;
+  for(i=start_i; i<stop_i; i++) {
+    char *ch = pho_idx_str(i);
+    int u8len = utf8_sz(ch);
+    if (!memcmp(ch, utf8, u8len)) {
+      return i;
+    }
+  }
+
+//  prph(phkey);
+//  dbg("error found   %c%c", *big5, *(big5+1));
+  return -1;
+}
+
+
+void inc_pho_count(phokey_t key, int ch_idx)
+{
+  int start_i, stop_i;
+
+  if (!phonetic_char_dynamic_sequence)
+    return;
+
+  get_start_stop_idx(key, &start_i, &stop_i);
+
+//  dbg("start_i %d %d    %d %d\n", start_i, stop_i, poo.start_idx, poo.stop_idx);
+
+  ch_pho[ch_idx].count++;
+//  dbg("count %d\n", ch_pho[ch_idx].count);
+
+  qsort(&ch_pho[start_i], stop_i - start_i, sizeof(PHO_ITEM), qcmp_count);
+#if 0
+  int i;
+  for(i=start_i; i < stop_i; i++) {
+    dbg("uuuu %c%c%c %d\n", ch_pho[i].ch[0], ch_pho[i].ch[1],
+      ch_pho[i].ch[2], ch_pho[i].count);
+  }
+#endif
+
+  FILE *fw;
+
+//  dbg("phofname %s\n", phofname);
+  if ((fw=fopen(phofname,"rb+"))==NULL) {
+    p_err("err %s\n", phofname);
+  }
+
+  if (fseek(fw, ch_pho_ofs + sizeof(PHO_ITEM) * start_i, SEEK_SET) < 0)
+    p_err("fseek err");
+#if 1
+  if (fwrite(&ch_pho[start_i], sizeof(PHO_ITEM), stop_i - start_i, fw) <= 0)
+    p_err("fwrite err");
+#endif
+  fclose(fw);
+}
+
+
+void lookup_gtab(char *ch);
+gboolean is_gtab_query_mode();
+void set_gtab_target_displayed();
+
+#include "gtab-buf.h"
+
+void putkey_pho(u_short key, int idx)
+{
+  char *pho_str = pho_idx_str(idx);
+
+  if (poo.same_pho_query_state==SAME_PHO_QUERY_pho_select && ggg.gbufN)
+    insert_gbuf_nokey(pho_str);
+  else
+    send_text(pho_str);
+
+  lookup_gtab(pho_str);
+
+  inc_pho_count(key, idx);
+
+  clr_in_area_pho();
+  ClrSelArea();
+
+  if (is_gtab_query_mode())
+    set_gtab_target_displayed();
+}
+
+void load_pin_juyin();
+void recreate_win1_if_nessary();
+
+void load_tab_pho_file()
+{
+  pho_load();
+
+  bzero(poo.typ_pho,sizeof(poo.typ_pho));
+
+  u_int ttt=0;
+  int i;
+  for(i=0; i<MAX_HASH_PHO; i++) {
+    if (idx_pho[ttt].key >> 9 == i)
+      hash_pho[i]=ttt;
+    else {
+      continue;
+    }
+
+    while (ttt < idxnum_pho && idx_pho[ttt].key >> 9 == i)
+      ttt++;
+  }
+
+  for(i=MAX_HASH_PHO; !hash_pho[i];  i--)
+    hash_pho[i]=idxnum_pho;
+
+  char kbmfname[MAX_HIME_STR];
+  FILE *fr;
+
+  free(pin_juyin);
+  pin_juyin = NULL;
+
+  if (!strstr(pho_kbm_name, "pinyin")) {
+    text_pho_N = 4;
+  } else {
+    load_pin_juyin();
+  }
+
+  if (strcmp(pho_kbm_name, "hsu"))
+    b_hsu_kbm = FALSE;
+  else
+    b_hsu_kbm = TRUE;
+
+  char pho_kbm_name_kbm[128];
+
+  strcat(strcpy(pho_kbm_name_kbm, pho_kbm_name), ".kbm");
+  dbg("phokbm_name: %s\n", pho_kbm_name_kbm);
+
+  get_sys_table_file_name(pho_kbm_name_kbm, kbmfname);
+
+  if ((fr=fopen(kbmfname,"rb"))==NULL)
+     p_err("Cannot open %s", kbmfname);
+
+  dbg("kbmfname %s\n", kbmfname);
+
+  fread(&phkbm,sizeof(phkbm),1,fr);
+  fclose (fr);
+  phkbm.selkeyN = strlen(pho_selkey);
+
+  dbg("pho_selkey %s\n", pho_selkey);
+
+  recreate_win1_if_nessary();
+#if 0
+  for(i='A'; i <= 'z'; i++)
+    dbg("%c %d %d\n", i, phkbm.phokbm[i][0].num, phkbm.phokbm[i][0].typ);
+#endif
+}
+
+
+void show_win_pho();
+
+void init_tab_pho()
+{
+  if (!ch_pho) {
+    load_tab_pho_file();
+  }
+
+  show_win_pho();
+  clr_in_area_pho();
+}
+
+static char *pho_idx_str_markup(int ii)
+{
+  char *pho_str = pho_idx_str(ii);
+  if (!strcmp(pho_str, "<"))
+    pho_str = "&lt;";
+  else
+  if (!strcmp(pho_str, ">"))
+    pho_str = "&gt;";
+  return pho_str;
+}
+
+
+gboolean shift_char_proc(KeySym key, int kbstate);
+gboolean pre_punctuation(KeySym xkey);
+void pho_play(phokey_t key);
+void close_gtab_pho_win();
+gboolean pre_punctuation_hsu(KeySym xkey);
+void case_inverse(KeySym *xkey, int shift_m);
+
+int feedkey_pho(KeySym xkey, int kbstate)
+{
+  int ctyp = 0;
+  static unsigned int vv, ii;
+  static phokey_t key;
+  char *pp=NULL;
+  char kno;
+  int i,j,jj=0,kk=0;
+  char out_buffer[512];
+  int out_bufferN;
+  int shift_m=kbstate&ShiftMask;
+  int ctrl_m=kbstate&ControlMask;
+
+  if (ctrl_m)
+    return 0;
+
+
+  if (kbstate&LockMask) {
+    if (xkey >= 0x7e || xkey < ' ')
+      return FALSE;
+    if (hime_capslock_lower)
+      case_inverse(&xkey, shift_m);
+    send_ascii(xkey);
+    return 1;
+  }
+
+  if (xkey >= 'A' && xkey <='Z' && poo.typ_pho[0]!=BACK_QUOTE_NO)
+    xkey+=0x20;
+
+  switch (xkey) {
+    case XK_Escape:
+      if (typ_pho_empty())
+        return 0;
+      ClrPhoSelArea();
+      clr_in_area_pho();
+      if (is_gtab_query_mode())
+        close_gtab_pho_win();
+      return 1;
+    case XK_BackSpace:
+      poo.ityp3_pho=0;
+      for(j=3;j>=0;j--) if (poo.typ_pho[j]) {
+        poo.typ_pho[j]=0;
+        if (typ_pho_empty()) {
+          ClrSelArea();
+          clr_in_area_pho();
+          return 1;
+        }
+        break;
+      }
+
+      if (j<0)
+        return 0;
+
+      goto llll3;
+    case '<':
+       if (!poo.ityp3_pho) {
+         return pre_punctuation(xkey);
+       }
+       if (poo.cpg >= phkbm.selkeyN)
+         poo.cpg -= phkbm.selkeyN;
+       goto proc_state;
+    case ' ':
+      if (!poo.typ_pho[0] && !poo.typ_pho[1] && !poo.typ_pho[2]) {
+        if (current_CS->b_half_full_char)
+          return full_char_proc(xkey);
+        return 0;
+      }
+
+//      dbg("poo.ityp3_pho %d\n", poo.ityp3_pho);
+      if (!poo.ityp3_pho) {
+        poo.ityp3_pho = TRUE;
+        goto lll1;
+      }
+
+      ii = poo.start_idx+ poo.cpg + phkbm.selkeyN;
+
+      if (ii < poo.stop_idx) {
+        poo.cpg += phkbm.selkeyN;
+        dbg("spc pool.cpg %d\n", poo.cpg);
+      } else {
+        if (poo.cpg) {
+          poo.cpg=0;
+          ii=poo.start_idx;
+        } else {
+          putkey_pho(key, poo.start_idx);
+          return 1;
+        }
+      }
+
+      goto disp;
+   default:
+      if (xkey >= 127 || xkey < ' ')
+        return 0;
+
+      if (shift_m) {
+//        return shift_char_proc(xkey, kbstate);
+        if (pre_punctuation(xkey))
+          return 1;
+        return 0;
+      }
+
+//    dbg("poo.maxi:%d  %d\n", poo.maxi, poo.cpg);
+
+      if ((pp=strchr(pho_selkey, xkey)) && poo.maxi && poo.ityp3_pho) {
+        int c=pp-pho_selkey;
+
+        if (c<poo.maxi) {
+          putkey_pho(key, poo.start_idx + poo.cpg + c);
+        }
+        return 1;
+      }
+
+      if (poo.ityp3_pho && !poo.cpg) {
+//        dbg("poo.start_idx: %d\n", poo.start_idx);
+        putkey_pho(key, poo.start_idx);
+      }
+
+//      poo.cpg=0;
+  }
+
+lll1:
+  inph_typ_pho(xkey);
+//  dbg("typ_pho %x %x\n", poo.typ_pho[0], poo.typ_pho[1]);
+
+  if (hime_pop_up_win)
+    show_win_pho();
+
+  if (poo.typ_pho[3])
+    ctyp = 3;
+
+  jj=0;
+  kk=1;
+llll2:
+  if (ctyp == 3) {
+       poo.ityp3_pho=1;  /* last key is entered */
+  }
+llll3:
+
+  key = pho2key(poo.typ_pho);
+
+#if    0
+  dbg("poo.typ_pho %d %d %d %d\n", poo.typ_pho[0], poo.typ_pho[1], poo.typ_pho[2], poo.typ_pho[3]);
+#endif
+  if (!key) {
+    return pre_punctuation_hsu(xkey);
+  }
+
+  pho_play(key);
+
+  vv=hash_pho[(int)poo.typ_pho[0]];
+  phokey_t ttt;
+  ttt=0xffff;
+
+  while (vv < idxnum_pho) {
+    ttt=idx_pho[vv].key;
+    mask_key_typ_pho(&ttt);
+
+    if (ttt>=key)
+      break;
+    else
+      vv++;
+  }
+
+//  dbg("vv %d %d\n", vv, idxnum_pho);
+
+  if (ttt > key || (poo.ityp3_pho && idx_pho[vv].key != key) ) {
+//    dbg("not found\n");
+    while (jj<4) {
+      while(kk<3)
+        if (phkbm.phokbm[(int)poo.inph[jj]][kk].num ) {
+
+          if (kk) {
+            ctyp=phkbm.phokbm[(int)poo.inph[jj]][kk-1].typ;
+            poo.typ_pho[ctyp]=0;
+          }
+
+          kno=phkbm.phokbm[(int)poo.inph[jj]][kk].num;
+          ctyp=phkbm.phokbm[(int)poo.inph[jj]][kk].typ;
+          poo.typ_pho[ctyp]=kno;
+          kk++;
+          goto llll2;
+        }
+        else
+          kk++;
+      jj++;
+      kk=1;
+    }
+
+    bell();
+    poo.ityp3_pho=poo.typ_pho[3]=0;
+    disp_in_area_pho();
+    return 1;
+  }
+
+proc_state:
+  disp_in_area_pho();
+  poo.start_idx = ii = idx_pho[vv].start;
+  poo.stop_idx = idx_pho[vv+1].start;
+
+//  dbg("poo.start_idx: %d %d\n", poo.start_idx, poo.stop_idx);
+
+  if (poo.typ_pho[0]==L_BRACKET_NO||poo.typ_pho[0]==R_BRACKET_NO || (poo.typ_pho[0]==BACK_QUOTE_NO && poo.typ_pho[1]))
+     poo.ityp3_pho = 1;
+
+  ii+=poo.cpg;
+
+  if (poo.ityp3_pho && poo.stop_idx - poo.start_idx==1) {
+    putkey_pho(key, ii);
+    poo.maxi=poo.ityp3_pho=0;
+    return 1;
+  }
+
+disp:
+  i=0;
+  out_bufferN=0;
+  out_buffer[0]=0;
+
+  if (poo.ityp3_pho) {
+//    dbg("poo.cpg %d\n", poo.cpg);
+
+    while(i< phkbm.selkeyN  && ii < poo.stop_idx) {
+      char tt[512];
+      sprintf(tt, "<span foreground=\"%s\">%c</span>",
+         hime_sel_key_color, pho_selkey[i]);
+      int ttlen = strlen(tt);
+      memcpy(out_buffer+out_bufferN, tt, ttlen);
+      out_bufferN+=ttlen;
+//      strcat(out_buffer, tt);
+      char *pho_str = pho_idx_str_markup(ii);
+      int len = strlen(pho_str);
+      memcpy(&out_buffer[out_bufferN], pho_str, len);
+      out_bufferN+=len;
+      out_buffer[out_bufferN++] = ' ';
+
+      ii++;
+      i++;
+    }
+
+    char *tt = poo.cpg ? "&lt;" : " ";
+    int ttlen = strlen(tt);
+    memcpy(out_buffer+out_bufferN, tt, ttlen);
+    out_bufferN+=ttlen;
+
+    if (ii < poo.stop_idx) {
+      out_buffer[out_bufferN++] = poo.cpg ? '\\' : ' ';
+      tt = "&gt;";
+      ttlen = strlen(tt);
+      memcpy(out_buffer+out_bufferN, tt, ttlen);
+      out_bufferN+=strlen(tt);
+    }
+
+    poo.maxi=i;
+  } else {
+    while(i<phkbm.selkeyN  && ii < poo.stop_idx) {
+      char *pho_str = pho_idx_str_markup(ii);
+      int len = strlen(pho_str);
+      memcpy(&out_buffer[out_bufferN], pho_str, len);
+      out_bufferN+=len;
+
+      ii++;
+      i++;
+    }
+    poo.maxi=i;
+  }
+
+  out_buffer[out_bufferN]=0;
+  disp_pho_sel(out_buffer);
+
+  return 1;
+}
+
+static char typ_pho_no_to_xkey(int typ, u_char num)
+{
+  int i, j;
+
+  for(i=' '; i < 127; i++)
+    for(j=0; j < 3; j++)
+      if (phkbm.phokbm[i][j].typ == typ && phkbm.phokbm[i][j].num == num)
+        return i;
+
+  return 0;
+}
+
+
+void start_gtab_pho_query(char *utf8)
+{
+  phokey_t phokeys[32];
+  int phokeysN, i;
+
+  phokeysN = utf8_pho_keys(utf8, phokeys);
+  if (phokeysN <= 0)
+    return;
+
+  u_char rtyp_pho[4];
+  bzero(rtyp_pho, sizeof(rtyp_pho));
+  key_typ_pho(phokeys[0], rtyp_pho);
+
+  char xkeys[4];
+  bzero(xkeys, sizeof(xkeys));
+
+  for(i=0; i < 4; i++) {
+    if (!rtyp_pho[i])
+      continue;
+
+    xkeys[i] = typ_pho_no_to_xkey(i, rtyp_pho[i]);
+  }
+
+  if (!xkeys[3])
+    xkeys[3] = ' ';
+
+  for(i=0; i < 4; i++) {
+    feedkey_pho(xkeys[i], 0);
+  }
+}
+
+
+void pho_reset()
+{
+}
+
+#include "im-client/hime-im-client-attr.h"
+extern GtkWidget *gwin_pho;
+
+int pho_get_preedit(char *str, HIME_PREEDIT_ATTR attr[], int *cursor, int *sub_comp_len)
+{
+  *sub_comp_len = !typ_pho_empty();;
+  if (gwin_pho && GTK_WIDGET_VISIBLE(gwin_pho))
+    *sub_comp_len|=2;
+  *cursor = 0;
+  str[0]=0;
+  return 0;
+}
+
+static PHO_ST temp_pho_st;
+void pho_save_gst()
+{
+  temp_pho_st = poo;
+}
+
+void pho_restore_gst()
+{
+  poo = temp_pho_st;
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/pho.h b/src/plugins/platforminputcontexts/hime/include/pho.h
new file mode 100644
index 0000000..da76a80
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/pho.h
@@ -0,0 +1,92 @@
+/* Copyright (C) 1995-2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+typedef u_short phokey_t;
+
+typedef struct {
+  char selkeyN;
+  struct {
+    char num, typ;
+  } phokbm[128][3];  // for 26 keys pho, it may have up-to 3 pho char for a key
+} PHOKBM;
+
+extern PHOKBM phkbm;
+
+typedef struct {
+  char ch[CH_SZ];
+  int count;
+} PHO_ITEM;
+
+typedef struct {
+  phokey_t key;
+  u_short start;
+} PHO_IDX;
+
+
+typedef struct {
+  char pinyin[7];
+  phokey_t key;
+} PIN_JUYIN;
+
+#define MAX_PHRASE_LEN (32)
+#define MAX_PHRASE_STR_LEN (MAX_PHRASE_LEN * CH_SZ + 1)
+
+#define Min(a,b) ((a) < (b) ? (a):(b))
+
+#define TSIN_HASH_N (256)
+
+extern char phofname[128];
+extern u_short idxnum_pho;
+extern PHO_IDX *idx_pho;
+extern int ch_pho_ofs;
+extern PHO_ITEM *ch_pho;
+extern int ch_phoN;
+extern PIN_JUYIN *pin_juyin;
+extern int pin_juyinN;
+
+void pho_load();
+extern char *pho_chars[];
+char *phokey_to_str(phokey_t kk);
+int utf8_pho_keys(char *big5, phokey_t *phkeys);
+void prph(phokey_t kk);
+void prphs(phokey_t *ks, int ksN);
+phokey_t pho2key(char typ_pho[]);
+gboolean save_phrase_to_db(void *phkeys, char *utf8str, int len, usecount_t usecount);
+int lookup(u_char *s);
+int find_match(char *str, int *eq_N, usecount_t *usecount);
+char *phokey_to_str2(phokey_t kk, int last_number);
+char *pho_idx_str(int idx);
+char *pho_idx_str2(int idx, int *is_phrase);
+
+
+#define MAX_PH_BF (90)
+
+#define MAX_PH_BF_EXT (MAX_PH_BF + MAX_PHRASE_LEN + 1)
+
+
+#define TSIN_HASH_SHIFT 6
+#define TSIN_HASH_SHIFT_32 24
+#define TSIN_HASH_SHIFT_64 56
+
+#define PHO_CHAR_LEN 3
+
+#define L_BRACKET_NO 22
+#define R_BRACKET_NO 23
+#define BACK_QUOTE_NO 24
+
+#define PHO_PHRASE_ESCAPE 0x1b
+#define PHO_PINYIN_TONE1 -1
diff --git a/src/plugins/platforminputcontexts/hime/include/tsin-parse.c b/src/plugins/platforminputcontexts/hime/include/tsin-parse.c
new file mode 100644
index 0000000..9df67f1
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/tsin-parse.c
@@ -0,0 +1,353 @@
+/* Copyright (C) 2010 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <string.h>
+#include "hime.h"
+#include "pho.h"
+#include "tsin.h"
+#include "hime-conf.h"
+#include <math.h>
+#include "tsin-parse.h"
+#include "gtab-buf.h"
+#include "gst.h"
+
+#define DBG (0)
+extern gboolean tsin_is_gtab;
+extern int ph_key_sz;
+void add_cache(int start, int usecount, TSIN_PARSE *out, short match_phr_N, short no_match_ch_N, int tc_len);
+void extract_gtab_key(int start, int len, void *out);
+gboolean check_gtab_fixed_mismatch(int idx, char *mtch, int plen);
+void mask_tone(phokey_t *pho, int plen, char *tone_mask);
+
+static int tsin_parse_len;
+
+void set_tsin_parse_len(int len)
+{
+  tsin_parse_len = len;
+}
+
+static char *c_pinyin_set;
+
+int tsin_parse_recur(int start, TSIN_PARSE *out,
+                     short *r_match_phr_N, short *r_no_match_ch_N)
+{
+  int plen;
+  double bestscore = -1;
+  int bestusecount = 0;
+  *r_match_phr_N = 0;
+  *r_no_match_ch_N = tsin_parse_len - start;
+
+
+  for(plen=1; start + plen <= tsin_parse_len && plen <= MAX_PHRASE_LEN; plen++) {
+#if DBG
+    dbg("---- aa st:%d hh plen:%d ", start, plen);utf8_putchar(tss.chpho[start].ch); dbg("\n");
+#endif
+    if (plen > 1) {
+      if (tsin_is_gtab) {
+        if (gbuf[start+plen-1].flag & FLAG_CHPHO_PHRASE_USER_HEAD)
+          break;
+      } else
+        if (tss.chpho[start+plen-1].flag & FLAG_CHPHO_PHRASE_USER_HEAD)
+          break;
+    }
+
+    phokey_t pp[MAX_PHRASE_LEN + 1];
+    u_int pp32[MAX_PHRASE_LEN + 1];
+    u_int64_t pp64[MAX_PHRASE_LEN + 1];
+    int sti, edi;
+    TSIN_PARSE pbest[MAX_PH_BF_EXT+1];
+#define MAXV 1000
+    int maxusecount = 5-MAXV;
+    int remlen;
+    short match_phr_N=0, no_match_ch_N = plen;
+    void *ppp;
+
+    if (ph_key_sz==2)
+      ppp=pp;
+    else if (ph_key_sz==4)
+      ppp=pp32;
+    else
+      ppp=pp64;
+
+    bzero(pbest, sizeof(TSIN_PARSE) * tsin_parse_len);
+
+    pbest[0].len = plen;
+    pbest[0].start = start;
+    int i, ofs;
+
+    if (tsin_is_gtab)
+      for(ofs=i=0; i < plen; i++)
+        ofs += utf8cpy((char *)pbest[0].str + ofs, gbuf[start + i].ch);
+    else
+      for(ofs=i=0; i < plen; i++)
+        ofs += utf8cpy((char *)pbest[0].str + ofs, tss.chpho[start + i].ch);
+
+#if DBG
+    dbg("st:%d hh plen:%d ", start, plen);utf8_putchar(tss.chpho[start].ch); dbg("\n");
+#endif
+
+    if (tsin_is_gtab)
+      extract_gtab_key(start, plen, ppp);
+    else {
+      extract_pho(start, plen, (phokey_t *)ppp);
+      if (c_pinyin_set)
+        mask_tone(pp, plen, c_pinyin_set + start);
+    }
+
+#if DBG
+    for(i=0; i < plen; i++) {
+      prph(pp[i]); dbg("%d", c_pinyin_set[i+start]);
+    }
+    dbg("\n");
+#endif
+
+    char *pinyin_set = c_pinyin_set ? c_pinyin_set+start:NULL;
+    if (!tsin_seek(ppp, plen, &sti, &edi, pinyin_set)) {
+//      dbg("tsin_seek not found...\n");
+      if (plen > 1)
+        break;
+      goto next;
+    }
+
+    phokey_t mtk[MAX_PHRASE_LEN];
+    u_int mtk32[MAX_PHRASE_LEN];
+    u_int64_t mtk64[MAX_PHRASE_LEN];
+    void *pho;
+
+    if (ph_key_sz==2)
+      pho=mtk;
+    else if (ph_key_sz==4)
+      pho=mtk32;
+    else
+      pho=mtk64;
+
+    for (;sti < edi; sti++) {
+      char mtch[MAX_PHRASE_LEN*CH_SZ+1];
+      char match_len;
+      usecount_t usecount;
+
+      load_tsin_entry(sti, &match_len, &usecount, pho, (u_char *)mtch);
+
+      if (match_len < plen)
+        continue;
+
+      if (tsin_is_gtab) {
+        if (check_gtab_fixed_mismatch(start, mtch, plen))
+          continue;
+      } else
+      if (check_fixed_mismatch(start, mtch, plen))
+        continue;
+
+      if (usecount < 0)
+        usecount = 0;
+
+      int i;
+      if (ph_key_sz==2) {
+        if (c_pinyin_set) {
+//          mask_tone(pp, plen, c_pinyin_set + start);
+          mask_tone(mtk, plen, c_pinyin_set + start);
+        }
+        for(i=0;i < plen;i++)
+          if (mtk[i]!=pp[i])
+            break;
+      } else if (ph_key_sz==4) {
+        for(i=0;i < plen;i++)
+          if (mtk32[i]!=pp32[i])
+            break;
+      } else {
+        for(i=0;i < plen;i++)
+          if (mtk64[i]!=pp64[i])
+            break;
+      }
+
+      if (i < plen)
+        continue;
+
+      if (match_len > plen) {
+        continue;
+      }
+
+      if (usecount <= maxusecount)
+        continue;
+
+      pbest[0].len = plen;
+      maxusecount = usecount;
+      utf8cpyN((char *)pbest[0].str, mtch, plen);
+      pbest[0].flag |= FLAG_TSIN_PARSE_PHRASE;
+
+      match_phr_N = 1;
+      no_match_ch_N = 0;
+#if DBG
+      utf8_putcharn(mtch, plen);
+      dbg("   plen %d usecount:%d  ", plen, usecount);
+        utf8_putcharn(mtch, plen);
+      dbg("\n");
+#endif
+    }
+
+
+next:
+
+#if 0
+    if (!match_phr_N) {
+      if (tsin_is_gtab) {
+        if (!(gbuf[start].ch[0] & 0x80))
+          no_match_ch_N = 0;
+      } else
+      if (!(tss.chpho[start].ch[0] & 0x80))
+        no_match_ch_N = 0;
+    }
+#else
+//	dbg("no_match_ch_N %d\n", no_match_ch_N);
+#endif
+
+    remlen = tsin_parse_len - (start + plen);
+
+
+    if (remlen) {
+      int next = start + plen;
+      CACHE *pca;
+
+      short smatch_phr_N, sno_match_ch_N;
+      int uc;
+
+      if ((pca = cache_lookup(next))) {
+        uc = pca->usecount;
+        smatch_phr_N = pca->match_phr_N;
+        sno_match_ch_N = pca->no_match_ch_N;
+        memcpy(&pbest[1], pca->best, (tsin_parse_len - next) * sizeof(TSIN_PARSE));
+      } else {
+        uc = tsin_parse_recur(next, &pbest[1], &smatch_phr_N, &sno_match_ch_N);
+//        dbg("   gg %d\n", smatch_phr_N);
+        add_cache(next, uc, &pbest[1], smatch_phr_N, sno_match_ch_N, tsin_parse_len);
+      }
+
+      match_phr_N += smatch_phr_N;
+      no_match_ch_N += sno_match_ch_N;
+      maxusecount += uc;
+    }
+
+
+    double score = log((double)maxusecount + MAXV) /
+      (pow((double)match_phr_N, 10)+ 1.0E-6) / (pow((double)no_match_ch_N, 20) + 1.0E-6);
+
+#if DBG
+    dbg("st:%d plen:%d zz muse:%d ma:%d noma:%d  score:%.4e %.4e\n", start, plen,
+        maxusecount, match_phr_N, no_match_ch_N, score, bestscore);
+#endif
+    if (score > bestscore) {
+#if DBG
+      dbg("is best org %.4e\n", bestscore);
+#endif
+      bestscore = score;
+      memcpy(out, pbest, sizeof(TSIN_PARSE) * (tsin_parse_len - start));
+
+#if DBG
+      dbg("    str:%d  ", start);
+      int i;
+      for(i=0;  i < tsin_parse_len - start; i++) {
+        utf8_putcharn((char *)out[i].str, out[i].len);
+      }
+      dbg("\n");
+#endif
+
+      bestusecount = maxusecount;
+      *r_match_phr_N = match_phr_N;
+      *r_no_match_ch_N = no_match_ch_N;
+    }
+  }
+
+  if (bestusecount < 0)
+    bestusecount = 0;
+
+  return bestusecount;
+}
+
+void disp_ph_sta_idx(int idx);
+
+void free_cache(), load_tsin_db();
+void tsin_parse()
+{
+  TSIN_PARSE out[MAX_PH_BF_EXT+1];
+  bzero(out, sizeof(out));
+
+  int i, ofsi;
+
+  if (tss.c_len <= 1)
+    return;
+
+  load_tsin_db();
+
+  set_tsin_parse_len(tss.c_len);
+
+  init_cache(tss.c_len);
+
+  char pinyin_set[MAX_PH_BF_EXT];
+  c_pinyin_set = pin_juyin?pinyin_set:NULL;
+  get_chpho_pinyin_set(pinyin_set);
+
+  short smatch_phr_N, sno_match_ch_N;
+  tsin_parse_recur(0, out, &smatch_phr_N, &sno_match_ch_N);
+
+#if 0
+  puts("vvvvvvvvvvvvvvvv");
+  for(i=0;  i < tss.c_len; i++) {
+    printf("%d:", out[i].len);
+    utf8_putcharn(out[i].str, out[i].len);
+  }
+  dbg("\n");
+#endif
+
+  for(i=0; i < tss.c_len; i++)
+    tss.chpho[i].flag &= ~(FLAG_CHPHO_PHRASE_HEAD|FLAG_CHPHO_PHRASE_BODY);
+
+  for(ofsi=i=0; out[i].len; i++) {
+    int j, ofsj;
+    int psta = ofsi;
+
+    if (out[i].flag & FLAG_TSIN_PARSE_PHRASE)
+        tss.chpho[ofsi].flag |= FLAG_CHPHO_PHRASE_HEAD;
+
+    for(ofsj=j=0; j < out[i].len; j++) {
+      ofsj += utf8cpy(tss.chpho[ofsi].cha, (char *)&out[i].str[ofsj]);
+//      tss.chpho[ofsi].ch = tss.chpho[ofsi].cha;
+
+      tss.chpho[ofsi].flag |= FLAG_CHPHO_PHRASE_BODY;
+      if (out[i].flag & FLAG_TSIN_PARSE_PHRASE)
+        tss.chpho[ofsi].psta = psta;
+
+      ofsi++;
+    }
+  }
+
+  int ph_sta_idx = tss.ph_sta;
+  if (tss.chpho[tss.c_len-1].psta>=0 && tss.c_len - tss.chpho[tss.c_len-1].psta > 1) {
+    ph_sta_idx = tss.chpho[tss.c_len-1].psta;
+  }
+
+#if 1
+  disp_ph_sta_idx(ph_sta_idx);
+#endif
+
+#if 0
+  for(i=0;i<tss.c_len;i++)
+    utf8_putchar(tss.chpho[i].ch);
+  puts("");
+#endif
+
+  free_cache();
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/tsin-parse.h b/src/plugins/platforminputcontexts/hime/include/tsin-parse.h
new file mode 100644
index 0000000..7f3771b
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/tsin-parse.h
@@ -0,0 +1,40 @@
+/* Copyright (C) 2010 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+typedef struct {
+  char len, flag;
+  u_char start;
+  unsigned char str[MAX_PHRASE_LEN*CH_SZ+1];  // use malloc
+} TSIN_PARSE;
+
+enum {
+  FLAG_TSIN_PARSE_PHRASE = 1,
+  FLAG_TSIN_PARSE_PARTIAL = 2, //partial phrase
+};
+
+typedef struct {
+  int start;
+  int usecount;
+  short match_phr_N, no_match_ch_N;
+  TSIN_PARSE best[MAX_PH_BF_EXT+1];
+} CACHE;
+
+void tsin_parse();
+void init_cache(int tc_len);
+CACHE *cache_lookup(int start);
+int tsin_parse_recur(int start, TSIN_PARSE *out,
+                     short *r_match_phr_N, short *r_no_match_ch_N);
diff --git a/src/plugins/platforminputcontexts/hime/include/tsin.c b/src/plugins/platforminputcontexts/hime/include/tsin.c
new file mode 100644
index 0000000..aeaae3e
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/tsin.c
@@ -0,0 +1,2224 @@
+/* Copyright (C) 2004-2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <string.h>
+
+#include "hime.h"
+#include "pho.h"
+#include "tsin.h"
+#include "hime-conf.h"
+#include "tsin-parse.h"
+#include "win-save-phrase.h"
+#include "gst.h"
+#include "gtab.h"
+#include "pho-status.h"
+
+extern int ph_key_sz;
+extern GtkWidget *gwin1;
+gboolean key_press_alt, key_press_ctrl;
+extern gboolean b_hsu_kbm;
+extern gboolean test_mode;
+
+extern char *pho_chars[];
+
+TSIN_ST tss;
+
+gboolean typ_pho_empty();
+void mask_tone(phokey_t *pho, int plen, char *tone_off);
+
+extern u_short hash_pho[];
+extern PHOKBM phkbm;
+
+extern int hashidx[TSIN_HASH_N];
+// gboolean eng_ph=TRUE;  // english(FALSE) <-> pho(juyin, TRUE)
+
+void clrin_pho(), hide_win0();
+void show_tsin_stat();
+void save_CS_current_to_temp();
+
+gboolean tsin_pho_mode()
+{
+  return current_CS && current_CS->tsin_pho_mode;
+}
+
+void set_tsin_pho_mode0(ClientState *cs)
+{
+  if (!cs)
+    return;
+  cs->tsin_pho_mode = 1;
+  save_CS_current_to_temp();
+}
+
+void set_tsin_pho_mode()
+{
+  set_tsin_pho_mode0(current_CS);
+  show_tsin_stat();
+}
+
+gboolean tsin_cursor_end()
+{
+  return tss.c_idx==tss.c_len;
+}
+
+gboolean tsin_has_input();
+static void clrin_pho_tsin()
+{
+  clrin_pho();
+
+  if (!tsin_has_input() && hime_pop_up_win)
+    hide_win0();
+}
+
+gboolean pho_has_input();
+gboolean hime_edit_display_ap_only();
+
+gboolean tsin_has_input()
+{
+  gboolean v = (!hime_edit_display_ap_only() && tss.c_len) || pho_has_input();
+//  dbg("tsin_has_input %d\n", v);
+  return v;
+}
+
+
+void disp_char(int index, char *ch);
+
+static void disp_char_chbuf(int idx)
+{
+//  dbg("disp_char_chbuf %d '%s' '%s'\n", idx, tss.chpho[idx].ch, tss.chpho[idx].cha);
+  disp_char(idx, tss.chpho[idx].ch);
+}
+
+static void init_chpho_i(int i)
+{
+//  dbg("init_chpho_i %d\n", i);
+  tss.chpho[i].ch = tss.chpho[i].cha;
+  tss.chpho[i].ch[0]=' ';
+  tss.chpho[i].ch[1]=0;
+  tss.chpho[i].flag=0;
+  tss.chpho[i].psta=-1;
+}
+
+void clr_tsin_cursor(int index);
+
+static void clrcursor()
+{
+  clr_tsin_cursor(tss.c_idx);
+}
+
+void set_cursor_tsin(int index);
+
+void drawcursor()
+{
+  clr_tsin_cursor(tss.last_cursor_idx);
+  tss.last_cursor_idx = tss.c_idx;
+
+  if (!tss.c_len)
+    return;
+
+  if (tss.c_idx == tss.c_len) {
+    if (!tsin_pho_mode()) {
+      if (tss.tsin_half_full) {
+        disp_char(tss.c_idx,"  ");
+        set_cursor_tsin(tss.c_idx);
+      } else {
+        disp_char(tss.c_idx, " ");
+        set_cursor_tsin(tss.c_idx);
+      }
+    }
+  }
+  else {
+    set_cursor_tsin(tss.c_idx);
+  }
+}
+
+void chpho_extract(CHPHO *chph, int len, phokey_t *pho, char *ch)
+{
+   int i;
+   int ofs=0;
+   ch[0]=0;
+
+   for(i=0; i < len; i++) {
+      if (pho)
+        pho[i] = chph[i].pho;
+
+      char *str = chph[i].ch;
+      strcat(ch + ofs, str);
+      ofs+=strlen(str);
+   }
+//   dbg("chpho_extract %s\n", ch);
+}
+
+// in tsin db, # of phokey = # of character, use this to extract only the first characer
+static void chpho_extract_cha(CHPHO *chph, int len, phokey_t *pho, char *ch)
+{
+   int i;
+   int ofs=0;
+
+   for(i=0; i < len; i++) {
+      if (pho)
+        pho[i] = chph[i].pho;
+      ofs += u8cpy(ch + ofs, chph[i].ch);
+   }
+
+   ch[ofs]=0;
+//   dbg("chpho_extract %s\n", ch);
+}
+
+void chpho_get_str(int idx, int len, char *ch)
+{
+  int ofs=0, i;
+  for(i=0; i < len; i++) {
+	int u8len = u8cpy(&ch[ofs], tss.chpho[idx+i].ch);
+    ofs+=u8len;
+  }
+
+  ch[ofs]=0;
+}
+
+
+void inc_pho_count(phokey_t key, int ch_idx);
+int ch_key_to_ch_pho_idx(phokey_t phkey, char *big5);
+void inc_dec_tsin_use_count(void *pho, char *ch, int prlen);
+void lookup_gtabn(char *ch, char *);
+
+static void putbuf(int len)
+{
+  u_char tt[CH_SZ * (MAX_PH_BF_EXT+1) + 1];
+  int i,idx;
+
+//  dbg("putbuf:%d\n", len);
+#if 1
+  // update phrase reference count
+  if (len >= 2) {
+    for(i=0; i < len; i++) {
+//      dbg("flag %d %x\n", i, tss.chpho[i].flag);
+      if (!BITON(tss.chpho[i].flag, FLAG_CHPHO_PHRASE_HEAD)) {
+        continue;
+      }
+
+      int j;
+      for(j=i+1; j < len; j++)
+        if (tss.chpho[j].psta != i)
+          break;
+
+      int phrlen = j - i;
+      if (phrlen < 1)
+        continue;
+
+      phokey_t pho[MAX_PHRASE_LEN];
+      char ch[MAX_PHRASE_LEN * CH_SZ * 2];
+
+      chpho_extract(&tss.chpho[i], phrlen, pho, ch);
+
+      inc_dec_tsin_use_count(pho, ch, phrlen);
+    }
+  }
+#endif
+
+  for(idx=i=0;i<len;i++) {
+#if 0
+    int len = utf8_sz(tss.chpho[i].ch);
+#else
+    int len = strlen(tss.chpho[i].ch);
+#endif
+
+    if (tss.chpho[i].pho && len > 1) {
+      int pho_idx = ch_key_to_ch_pho_idx(tss.chpho[i].pho, tss.chpho[i].ch);
+      if (pho_idx >= 0)
+        inc_pho_count(tss.chpho[i].pho, pho_idx);
+    }
+
+    memcpy(&tt[idx], tss.chpho[i].ch, len);
+    idx += len;
+  }
+
+  tt[idx]=0;
+  send_text((char *)tt);
+  lookup_gtabn((char *)tt, NULL);
+}
+
+
+void hide_char(int index);
+
+static void prbuf()
+{
+  int i;
+
+//  dbg("prbuf\n");
+  for(i=0;i<tss.c_len;i++)
+	if (!(tss.chpho[i].flag & FLAG_CHPHO_PHO_PHRASE))
+		tss.chpho[i].ch=tss.chpho[i].cha;
+
+  for(i=0; i < tss.c_len; i++)
+    disp_char_chbuf(i);
+
+  for(i=tss.c_len; i < MAX_PH_BF_EXT; i++) {
+    hide_char(i);
+  }
+
+  drawcursor();
+}
+
+
+void disp_tsin_pho(int index, char *pho);
+
+static void disp_in_area_pho_tsin()
+{
+  int i;
+
+  if (pin_juyin) {
+    for(i=0;i<6;i++) {
+      disp_tsin_pho(i, &poo.inph[i]);
+    }
+  } else {
+    for(i=0;i<4;i++) {
+      if (poo.typ_pho[0]==BACK_QUOTE_NO && i==1)
+        break;
+      disp_tsin_pho(i, &pho_chars[i][poo.typ_pho[i] * PHO_CHAR_LEN]);
+    }
+  }
+}
+
+static int get_in_area_pho_tsin_str(char *out)
+{
+  int i;
+  int outN=0;
+
+  if (pin_juyin) {
+    for(i=0;i<6;i++)
+      if (poo.inph[i])
+        out[outN++] = poo.inph[i];
+  } else {
+    for(i=0;i<4;i++)
+      if (poo.typ_pho[i]) {
+        outN+=u8cpy(out+outN, &pho_chars[i][poo.typ_pho[i] * PHO_CHAR_LEN]);
+      }
+  }
+
+  out[outN]=0;
+  return outN;
+}
+
+void clear_chars_all();
+
+static void clear_match()
+{
+  tss.ph_sta=-1;
+}
+
+static void clr_ch_buf()
+{
+  int i;
+  for(i=0; i < MAX_PH_BF_EXT; i++) {
+    init_chpho_i(i);
+  }
+
+  clear_match();
+}
+
+
+static void clear_ch_buf_sel_area()
+{
+  clear_chars_all();
+  tss.c_len=tss.c_idx=0; tss.ph_sta=-1;
+  tss.full_match = FALSE;
+  clr_ch_buf();
+  drawcursor();
+}
+
+static void close_selection_win();
+
+static void clear_tsin_buffer()
+{
+  clear_ch_buf_sel_area();
+  close_selection_win();
+  tss.pre_selN = 0;
+  tss.tsin_buffer_editing = 0; //buffer editing is finished
+}
+
+void clr_in_area_pho_tsin();
+void close_win_pho_near();
+void compact_win0();
+
+#if USE_TSIN
+void tsin_reset_in_pho0()
+{
+//  prbuf();
+  clr_in_area_pho_tsin();
+  close_selection_win();
+  tss.pre_selN = 0;
+//  tss.pho_menu_idx = 0;
+  drawcursor();
+  close_win_pho_near();
+}
+#endif
+
+
+#if USE_TSIN
+void tsin_reset_in_pho()
+{
+  clrin_pho_tsin();
+  tsin_reset_in_pho0();
+}
+#endif
+
+
+void flush_tsin_buffer()
+{
+  tsin_reset_in_pho();
+
+  if (hime_pop_up_win)
+    hide_win0();
+
+  if (tss.c_len) {
+    putbuf(tss.c_len);
+    compact_win0();
+    clear_ch_buf_sel_area();
+    clear_tsin_buffer();
+    return;
+  }
+
+  return;
+}
+
+
+void disp_tsin_eng_pho(int eng_pho);
+#if TRAY_ENABLED
+void disp_tray_icon();
+#endif
+
+void show_tsin_stat()
+{
+#if TRAY_ENABLED
+  disp_tray_icon();
+#endif
+  disp_tsin_eng_pho(tsin_pho_mode());
+}
+
+void load_tsin_db();
+
+#if 0
+void nputs(u_char *s, u_char len)
+{
+  char tt[16];
+
+  memcpy(tt, s, len*CH_SZ);
+  tt[len*CH_SZ]=0;
+  dbg("%s", tt);
+}
+
+
+static void dump_tsidx(int i)
+{
+  phokey_t pho[MAX_PHRASE_LEN];
+  u_char ch[MAX_PHRASE_LEN*CH_SZ];
+  usecount_t usecount;
+  u_char len;
+
+  load_tsin_entry(i, &len, &usecount, pho, ch);
+
+  int j;
+  for(j=0; j < len; j++) {
+    prph(pho[j]);
+    dbg(" ");
+  }
+
+  nputs(ch, len);
+  dbg("\n");
+}
+
+
+static void dump_tsidx_all()
+{
+  int i;
+
+  for(i=0; i < phcount; i++) {
+    dump_tsidx(i);
+  }
+
+  dbg("************************************************\n");
+  for(i=0; i < 254; i++) {
+    dbg("%d]%d ", i, hashidx[i]);
+    dump_tsidx(hashidx[i]);
+  }
+}
+
+#endif
+
+void load_tab_pho_file();
+void show_win0();
+
+void init_pre_sel()
+{
+  if (!tss.pre_sel)
+    tss.pre_sel=tzmalloc(PRE_SEL, 10);
+}
+
+void init_tab_pp(gboolean init)
+{
+  if (!tss.chpho)
+    tss.chpho=tzmalloc(CHPHO, MAX_PH_BF_EXT);
+
+//  tss.ph_sta_last = -1;
+
+  init_pre_sel();
+
+  if (!ch_pho)
+    load_tab_pho_file();
+
+  load_tsin_db();
+
+  if (init)
+    clr_ch_buf();
+
+  show_tsin_stat();
+  if (init)
+    clear_ch_buf_sel_area();
+
+  if (!hime_pop_up_win)
+    show_win0();
+}
+
+
+static void move_cursor_end()
+{
+  clrcursor();
+  tss.c_idx=tss.c_len;
+  drawcursor();
+}
+
+gboolean save_phrase_to_db2(CHPHO *chph, int len);
+
+void save_phrase(int save_frm, int len)
+{
+  int save_to = save_frm + len -1;
+  if (len <= 0 || len > MAX_PHRASE_LEN)
+    return;
+
+  int i;
+  for(i=save_frm;i<=save_to;i++) {
+    if (tss.chpho[i].pho)
+      continue;
+    phokey_t tpho[32];
+    tpho[0]=0;
+
+    utf8_pho_keys(tss.chpho[i].ch, tpho);
+
+    if (!tpho[0])
+      return;
+
+    tss.chpho[i].pho = tpho[0];
+  }
+
+  if (!save_phrase_to_db2(&tss.chpho[save_frm], len)) {
+    bell();
+  }
+
+  tss.ph_sta=-1;
+  move_cursor_end();
+  return;
+}
+
+
+static void set_fixed(int idx, int len)
+{
+  int i;
+  for(i=idx; i < idx+len; i++) {
+    tss.chpho[i].flag |= FLAG_CHPHO_FIXED;
+    tss.chpho[i].flag &= ~FLAG_CHPHO_PHRASE_USER_HEAD;
+  }
+}
+
+#define PH_SHIFT_N (tsin_buffer_size - 1)
+
+static void shift_ins()
+{
+   int j;
+//   dbg("shift_ins()\n");
+
+   if (!tss.c_idx && tss.c_len >= PH_SHIFT_N) {
+     tss.c_len--;
+   }
+   else
+   if (tss.c_len >= PH_SHIFT_N) {
+     int ofs;
+
+     // set it fixed so that it will not cause partial phrase in the beginning
+     int fixedlen = tss.c_len - 10;
+     if (fixedlen <= 0)
+       fixedlen = 1;
+     set_fixed(0, fixedlen);
+
+     ofs = 1;
+     putbuf(ofs);
+
+     tss.ph_sta-=ofs;
+     for(j=0; j < tss.c_len - ofs; j++) {
+       tss.chpho[j] = tss.chpho[j+ofs];
+#if 0
+	   if (!(tss.chpho[j].flag & FLAG_CHPHO_PHO_PHRASE))
+		 tss.chpho[j].ch = tss.chpho[j].cha;
+#endif
+     }
+     tss.c_idx-=ofs;
+     tss.c_len-=ofs;
+     prbuf();
+   }
+
+
+   init_chpho_i(tss.c_len);
+
+   if (tss.c_idx < tss.c_len) {
+     for(j=tss.c_len-1; j>=tss.c_idx; j--) {
+       tss.chpho[j+1] = tss.chpho[j];
+#if 0
+	   if (!(tss.chpho[j+1].flag & FLAG_CHPHO_PHO_PHRASE)) {
+		 tss.chpho[j+1].ch = tss.chpho[j+1].cha;
+//		 dbg("copy %d %s\n", j+1, tss.chpho[j+1].ch);
+	   }
+#endif
+     }
+   }
+
+   tss.c_len++;
+   compact_win0();
+
+#if 0
+   prbuf();
+   dbg("leave shift_ins\n");
+#endif
+}
+
+
+static void put_u8_char(int pho_idx, phokey_t key, gboolean b_tone)
+{
+   shift_ins();
+   int is_phrase;
+   char *str = pho_idx_str2(pho_idx, &is_phrase);
+
+   init_chpho_i(tss.c_idx);
+
+//   dbg("put_b5_char %d] %d\n", tss.c_idx, b_tone);
+
+   if (is_phrase) {
+     dbg("is_phrase %s\n", str);
+     tss.chpho[tss.c_idx].ch = str;
+     tss.chpho[tss.c_idx].flag |= FLAG_CHPHO_PHO_PHRASE;
+   }
+   else {
+     bzero(tss.chpho[tss.c_idx].cha, sizeof(tss.chpho[0].cha));
+     bchcpy(tss.chpho[tss.c_idx].cha, str);
+     tss.chpho[tss.c_idx].ch = tss.chpho[tss.c_idx].cha;
+//     dbg("wwww %s\n",tss.chpho[tss.c_idx].ch);
+   }
+
+   if (b_tone)
+     tss.chpho[tss.c_idx].flag |= FLAG_CHPHO_PINYIN_TONE;
+
+   disp_char_chbuf(tss.c_idx);
+
+   tss.chpho[tss.c_idx].pho=key;
+   tss.c_idx++;
+
+#if 0
+   if (tss.c_idx < tss.c_len) {
+     prbuf();
+   }
+#endif
+}
+
+
+#define MAX_PHRASE_SEL_N 10
+
+static u_char selstr[MAX_PHRASE_SEL_N][MAX_PHRASE_LEN * CH_SZ];
+static u_char sellen[MAX_PHRASE_SEL_N];
+
+static u_short phrase_count;
+static u_short pho_count;
+
+static gboolean chpho_eq_pho(int idx, phokey_t *phos, int len)
+{
+  int i;
+
+  for(i=0; i < len; i++)
+    if (tss.chpho[idx+i].pho != phos[i])
+       return FALSE;
+
+  return TRUE;
+}
+
+
+char *get_chpho_pinyin_set(char *set_arr)
+{
+  if (!pin_juyin)
+    return NULL;
+  int i;
+  for(i=0; i < tss.c_len; i++) {
+    if (tss.chpho[i].flag & FLAG_CHPHO_PINYIN_TONE)
+      set_arr[i]=TRUE;
+    else
+      set_arr[i]=FALSE;
+
+//    dbg("pin %d] %d\n", i, set_arr[i]);
+  }
+  return set_arr;
+}
+
+
+static void get_sel_phrase0(int selidx, gboolean eqlen)
+{
+  int sti,edi;
+  u_char len, mlen;
+
+  mlen=tss.c_len-selidx;
+
+  if (!mlen)
+    return;
+
+  if (mlen > MAX_PHRASE_LEN)
+    mlen=MAX_PHRASE_LEN;
+
+  phokey_t pp[MAX_PHRASE_LEN + 1];
+  extract_pho(selidx, mlen, pp);
+
+  char *pinyin_s = NULL;
+  char pinyin_set[MAX_PH_BF_EXT];
+
+  if (pin_juyin)
+    pinyin_s = get_chpho_pinyin_set(pinyin_set) + selidx;
+
+  if (!tsin_seek(pp, 2, &sti, &edi, pinyin_s))
+    return;
+
+  while (sti < edi && phrase_count < phkbm.selkeyN) {
+    phokey_t stk[MAX_PHRASE_LEN];
+    usecount_t usecount;
+    u_char stch[MAX_PHRASE_LEN * CH_SZ + 1];
+
+    load_tsin_entry(sti, (char *)&len, &usecount, stk, stch);
+    mask_tone(stk, mlen, pinyin_s);
+
+    if ((eqlen && len!=mlen) || (!eqlen && len > mlen) || len==1) {
+      sti++;
+      continue;
+    }
+
+    if (chpho_eq_pho(selidx, stk, len)) {
+      sellen[phrase_count]=len;
+      utf8cpyN((char *)selstr[phrase_count++], (char *)stch, len);
+    }
+
+    sti++;
+  }
+}
+
+static void get_sel_phrase_end()
+{
+  int stidx = tss.c_idx - 5;
+  if (stidx < 0)
+    stidx = 0;
+
+  phrase_count = 0;
+  int i;
+  for(i=stidx; i < tss.c_len - 1; i++) {
+    get_sel_phrase0(i, TRUE);
+  }
+}
+
+static void get_sel_phrase()
+{
+  phrase_count = 0;
+  get_sel_phrase0(tss.c_idx, FALSE);
+}
+
+static void get_sel_pho()
+{
+  int idx = tss.c_idx==tss.c_len?tss.c_idx-1:tss.c_idx;
+  phokey_t key = tss.chpho[idx].pho;
+
+  if (!key)
+    return;
+
+  char need_mask = pin_juyin && !(tss.chpho[idx].flag & FLAG_CHPHO_PINYIN_TONE);
+//  dbg("need_mask %d\n", need_mask);
+
+  int i=hash_pho[key>>9];
+  phokey_t ttt;
+
+  while (i<idxnum_pho) {
+    ttt=idx_pho[i].key;
+    if (need_mask)
+      ttt &= ~7;
+
+    if (ttt>=key)
+      break;
+    i++;
+  }
+
+  if (ttt!=key) {
+    return;
+  }
+
+  tss.startf = idx_pho[i].start;
+  int end;
+
+  if (need_mask) {
+    while (i<idxnum_pho) {
+      ttt=idx_pho[i].key;
+
+      if (need_mask)
+        ttt &= ~7;
+
+      if (ttt>key)
+        break;
+      i++;
+    }
+    end = idx_pho[i].start;
+//    dbg("end %d\n", i);
+  } else
+    end = idx_pho[i+1].start;
+
+  pho_count = end - tss.startf;
+//  dbg("pho_count %d\n", pho_count);
+}
+
+
+void clear_sele();
+void set_sele_text(int tN, int i, char *text, int len);
+void disp_arrow_up(), disp_arrow_down();
+void disp_tsin_select(int index);
+
+static void disp_current_sel_page()
+{
+  int i;
+
+  clear_sele();
+
+  for(i=0; i < phkbm.selkeyN; i++) {
+    int idx = tss.current_page + i;
+
+    if (idx < phrase_count) {
+      int tlen = utf8_tlen((char *)selstr[i], sellen[i]);
+      set_sele_text(phrase_count + pho_count, i, (char *)selstr[i], tlen);
+    } else
+    if (idx < phrase_count + pho_count) {
+      int v = idx - phrase_count + tss.startf;
+      char *tstr = pho_idx_str(v);
+      set_sele_text(phrase_count + pho_count, i, tstr, -1);
+    } else
+      break;
+  }
+
+  if (tss.current_page + phkbm.selkeyN < phrase_count + pho_count) {
+    disp_arrow_down();
+  }
+
+  if (tss.current_page > 0)
+    disp_arrow_up();
+
+  disp_tsin_select(tss.c_idx==tss.c_len?tss.c_idx-1:tss.c_idx);
+}
+
+static int fetch_user_selection(int val, char **seltext, int *is_pho_phrase)
+{
+  int idx = tss.current_page + val;
+  int len = 0;
+
+  *is_pho_phrase = FALSE;
+  if (idx < phrase_count) {
+    len = sellen[idx];
+    *seltext = (char *)selstr[idx];
+  } else
+  if (idx < phrase_count + pho_count) {
+    int v = idx - phrase_count + tss.startf;
+    *seltext = pho_idx_str2(v, is_pho_phrase);
+    len = utf8_str_N(*seltext);
+  }
+
+  return len;
+}
+
+
+void extract_pho(int chpho_idx, int plen, phokey_t *pho)
+{
+  int i;
+
+  for(i=0; i < plen; i++) {
+    pho[i] = tss.chpho[chpho_idx + i].pho;
+  }
+}
+
+
+gboolean check_fixed_mismatch(int chpho_idx, char *mtch, int plen)
+{
+  int j;
+  char *p = mtch;
+
+  for(j=0; j < plen; j++) {
+    int u8sz = utf8_sz(p);
+    if (!(tss.chpho[chpho_idx+j].flag & FLAG_CHPHO_FIXED))
+      continue;
+
+    if (memcmp(tss.chpho[chpho_idx+j].ch, p, u8sz))
+      return TRUE;
+
+    p+= u8sz;
+  }
+
+  return FALSE;
+}
+
+#if 0
+static u_char scanphr(int chpho_idx, int plen, gboolean pho_incr)
+{
+  return scanphr_e(chpho_idx, plen, pho_incr, NULL);
+}
+#endif
+
+void hide_selections_win();
+
+void disp_pre_sel_page()
+{
+  int i;
+
+  if (!tsin_phrase_pre_select) {
+    return;
+  }
+
+  if (!tss.pre_selN)
+    return;
+
+  clear_sele();
+
+  for(i=0; i < tss.pre_selN; i++) {
+    int tlen = utf8_tlen(tss.pre_sel[i].str, tss.pre_sel[i].len);
+
+    set_sele_text(tss.pre_selN, i, tss.pre_sel[i].str, tlen);
+  }
+
+#if 0
+  dbg("tss.ph_sta:%d\n", tss.ph_sta);
+#endif
+  disp_tsin_select(tss.ph_sta);
+}
+
+static void close_selection_win()
+{
+  hide_selections_win();
+  tss.current_page=tss.sel_pho=tss.ctrl_pre_sel = 0;
+  tss.pre_selN = 0;
+}
+
+void show_button_pho(gboolean bshow);
+
+void show_win_gtab();
+void tsin_set_eng_ch(int nmod)
+{
+//  dbg("tsin_set_eng_ch %d\n", nmod);
+  if (current_CS) {
+    current_CS->tsin_pho_mode = nmod;
+    save_CS_current_to_temp();
+  }
+
+  if (current_method_type()==method_type_TSIN) {
+    show_tsin_stat();
+    drawcursor();
+
+    if (!tsin_pho_mode())
+      clrin_pho_tsin();
+
+    show_button_pho(tsin_pho_mode());
+  }
+  else
+    show_win_gtab();
+
+  show_tsin_stat();
+}
+
+void tsin_toggle_eng_ch()
+{
+//  dbg("tsin_toggle_eng_ch\n");
+  compact_win0();
+  tsin_set_eng_ch(!tsin_pho_mode());
+}
+
+
+#if USE_TSIN
+void tsin_toggle_half_full()
+{
+    tss.tsin_half_full^=1;
+    key_press_alt = FALSE;
+    drawcursor();
+#if TRAY_ENABLED
+    disp_tray_icon();
+#endif
+}
+#endif
+
+
+#if 0
+static char ochars[]="<,>.?/:;\"'{[}]_-+=|\\~`";
+#else
+static char ochars[]="<,>.?/:;\"'{[}]_-+=|\\";
+#endif
+
+void hide_pre_sel()
+{
+  tss.pre_selN = 0;
+  hide_selections_win();
+}
+
+
+static void call_tsin_parse()
+{
+  prbuf();
+  tsin_parse();
+  prbuf();
+}
+
+void disp_ph_sta_idx(int idx)
+{
+}
+
+void disp_ph_sta()
+{
+  disp_ph_sta_idx(tss.ph_sta);
+}
+
+void ch_pho_cpy(CHPHO *pchpho, char *utf8, phokey_t *phos, int len)
+{
+  int i;
+
+  for(i=0; i < len; i++) {
+    int len = utf8cpy(pchpho[i].cha, utf8);
+    utf8+=len;
+    pchpho[i].pho = phos[i];
+	pchpho[i].flag &= ~FLAG_CHPHO_PHO_PHRASE;
+  }
+}
+
+
+void set_chpho_ch(CHPHO *pchpho, char *utf8, int len, gboolean is_pho_phrase)
+{
+  int i;
+
+  for(i=0; i < len; i++) {
+    int u8len;
+    if (is_pho_phrase) {
+      pchpho[i].ch = utf8;
+	  pchpho[i].flag |= FLAG_CHPHO_PHO_PHRASE;
+	} else {
+      u8len = utf8cpy(pchpho[i].cha, utf8);
+      pchpho[i].ch = pchpho[i].cha;
+	  pchpho[i].flag &= ~FLAG_CHPHO_PHO_PHRASE;
+    }
+
+    utf8+=u8len;
+  }
+}
+
+
+gboolean add_to_tsin_buf(char *str, phokey_t *pho, int len)
+{
+    int i;
+
+    if (tss.c_idx < 0 || tss.c_len + len >= MAX_PH_BF_EXT)
+      return 0;
+
+    if (tss.c_idx < tss.c_len) {
+      for(i=tss.c_len-1; i >= tss.c_idx; i--) {
+        tss.chpho[i+len] = tss.chpho[i];
+      }
+    }
+
+    ch_pho_cpy(&tss.chpho[tss.c_idx], str, pho, len);
+
+    if (tss.c_idx == tss.c_len)
+      tss.c_idx +=len;
+
+    tss.c_len+=len;
+
+    clrin_pho_tsin();
+    disp_in_area_pho_tsin();
+
+    prbuf();
+
+    set_fixed(tss.c_idx, len);
+#if 1
+    for(i=1;i < len; i++) {
+      tss.chpho[tss.c_idx+i].psta= tss.c_idx;
+    }
+#endif
+#if 0
+    if (len > 0)
+      tss.chpho[tss.c_idx].flag |= FLAG_CHPHO_PHRASE_HEAD;
+#endif
+    drawcursor();
+    disp_ph_sta();
+    hide_pre_sel();
+    tss.ph_sta=-1;
+
+    if (hime_pop_up_win)
+      show_win0();
+
+    return TRUE;
+}
+
+#if 1
+static void set_phrase_link(int idx, int len)
+{
+    int j;
+
+    if (len < 1)
+      return;
+
+    for(j=1;j < len; j++) {
+      tss.chpho[idx+j].psta=idx;
+    }
+
+    tss.chpho[idx].flag |= FLAG_CHPHO_PHRASE_HEAD;
+}
+#endif
+
+
+// should be used only if it is a real phrase
+gboolean add_to_tsin_buf_phsta(char *str, phokey_t *pho, int len)
+{
+    int idx = tss.ph_sta;
+#if 0
+    dbg("idx:%d  tss.ph_sta:%d tss.ph_sta_last:%d tss.c_idx:%d  tss.c_len:%d\n",
+       idx, tss.ph_sta, tss.ph_sta_last, tss.c_idx, tss.c_len);
+#endif
+    if (idx < 0)
+      return 0;
+
+    if (idx + len >= MAX_PH_BF_EXT)
+      flush_tsin_buffer();
+
+    if (tss.c_idx < tss.c_len) {
+      int avlen = tss.c_idx - tss.ph_sta;
+//      dbg("avlen:%d %d\n", avlen, len);
+      if (avlen < len) {
+        int d = len - avlen;
+
+        memmove(&tss.chpho[tss.c_idx + d], &tss.chpho[tss.c_idx], sizeof(CHPHO) * (tss.c_len - tss.c_idx));
+        tss.c_len += d;
+      }
+    } else
+      tss.c_len = idx + len;
+
+    ch_pho_cpy(&tss.chpho[idx], str, pho, len);
+    set_chpho_ch(&tss.chpho[idx], str, len, FALSE);
+    set_fixed(idx, len);
+    tss.chpho[idx].flag |= FLAG_CHPHO_PHRASE_USER_HEAD;
+    tss.c_idx=idx + len;
+    tss.chpho[tss.c_idx - 1].flag |= FLAG_CHPHO_PHRASE_TAIL;
+
+    clrin_pho_tsin();
+    disp_in_area_pho_tsin();
+
+    prbuf();
+#if 1
+    set_phrase_link(idx, len);
+#endif
+    drawcursor();
+    disp_ph_sta();
+    hide_pre_sel();
+    tss.ph_sta=-1;
+    call_tsin_parse();
+
+    return 1;
+}
+
+
+void add_to_tsin_buf_str(char *str)
+{
+  char *pp = str;
+  char *endp = pp+strlen(pp);
+  int N = 0;
+
+
+  while (*pp) {
+    int u8sz = utf8_sz(pp);
+    N++;
+    pp += u8sz;
+
+    if (pp >= endp) // bad utf8 string
+      break;
+  }
+
+  dbg("add_to_tsin_buf_str %s %d\n",str, N);
+
+  phokey_t pho[MAX_PHRASE_LEN];
+  bzero(pho, sizeof(pho));
+  add_to_tsin_buf(str, pho, N);
+}
+
+int tsin_pho_sel(int c);
+
+int tsin_sele_by_idx(int c)
+{
+  if (tss.sel_pho) {
+    tsin_pho_sel(c);
+    return 0;
+  }
+
+  int len = tss.pre_sel[c].len;
+
+#if 0
+    dbg("eqlenN:%d %d\n", c, tss.pre_selN);
+#endif
+
+  if (c >= tss.pre_selN)
+    return 0;
+
+  tss.full_match = FALSE;
+  gboolean b_added = add_to_tsin_buf_phsta(tss.pre_sel[c].str, (phokey_t*)tss.pre_sel[c].phkey, len);
+
+  return b_added;
+}
+
+static char shift_sele[]="!@#$%^&*()asdfghjkl:zxcvbnm<>?qwertyuiop";
+static char noshi_sele[]="1234567890asdfghjkl;zxcvbnm,./qwertyuiop";
+int shift_key_idx(char *s, KeySym xkey)
+{
+  if (xkey >= 0x7f)
+    return -1;
+
+  if (isupper(xkey))
+    xkey = xkey - 'A' + 'a';
+
+//  dbg("pre_sel_handler aa\n");
+
+  char *p;
+  if (!(p=strchr(shift_sele, xkey)))
+    return -1;
+
+  int c = p - shift_sele;
+  char noshi = noshi_sele[c];
+
+  if (!(p=strchr(s, noshi)))
+    return -1;
+
+  c = p - s;
+  return c;
+}
+
+
+static gboolean pre_sel_handler(KeySym xkey)
+{
+  if (!tss.pre_selN || !tsin_phrase_pre_select)
+    return FALSE;
+
+  int c = shift_key_idx(pho_selkey, xkey);
+  if (c < 0) {
+    close_selection_win();
+    return FALSE;
+  }
+  return tsin_sele_by_idx(c);
+}
+
+static gboolean pre_punctuation_sub(KeySym xkey, char shift_punc[], unich_t *chars[])
+{
+  char *p;
+  if (xkey > 0x7e)
+    return FALSE;
+
+  if ((p=strchr(shift_punc, xkey))) {
+    int c = p - shift_punc;
+    char *pchar = _(chars[c]);
+
+    if (current_method_type() == method_type_PHO) {
+      char tt[CH_SZ+1];
+      utf8cpy(tt, pchar);
+      send_text(tt);
+    } else {
+      phokey_t keys[64];
+      keys[0]=0;
+      utf8_pho_keys(pchar, keys);
+      add_to_tsin_buf(pchar, &keys[0], 1);
+      if (hime_punc_auto_send && tsin_cursor_end())
+        flush_tsin_buffer();
+    }
+    return 1;
+  }
+
+  return 0;
+}
+
+
+gboolean pre_punctuation(KeySym xkey)
+{
+  static char shift_punc[]="<>?:\"{}!_()";
+  static unich_t *chars[] = { "", "", "", "", "", "", "", "", "", "", "" };
+  return pre_punctuation_sub(xkey, shift_punc, chars);
+}
+
+static char hsu_punc[]=",./;'";
+gboolean pre_punctuation_hsu(KeySym xkey)
+{
+  static unich_t *chars[] = { "", "", "", "", "" };
+  return pre_punctuation_sub(xkey, hsu_punc, chars);
+}
+
+
+int inph_typ_pho(KeySym newkey);
+
+KeySym keypad_proc(KeySym xkey)
+{
+  if (xkey <= XK_KP_9 && xkey >= XK_KP_0)
+    xkey=xkey-XK_KP_0+'0';
+  else {
+    switch (xkey) {
+      case XK_KP_Add:
+        xkey = '+';
+        break;
+      case XK_KP_Subtract:
+        xkey = '-';
+        break;
+      case XK_KP_Multiply:
+        xkey = '*';
+        break;
+      case XK_KP_Divide:
+        xkey = '/';
+        break;
+      case XK_KP_Decimal:
+        xkey = '.';
+        break;
+      default:
+        return 0;
+    }
+  }
+
+  return xkey;
+}
+
+static int cursor_left()
+{
+//  dbg("cursor left %d %d\n", tss.c_idx, tss.c_len);
+  close_selection_win();
+  if (tss.c_idx) {
+    clrcursor();
+    tss.c_idx--;
+    drawcursor();
+    return 1;
+  }
+  // Thanks to PCMan.bbs@bbs.sayya.org for the suggestion
+  return tss.c_len;
+}
+static int cursor_right()
+{
+//  dbg("cursor right %d %d\n", tss.c_idx, tss.c_len);
+  close_selection_win();
+  if (tss.c_idx < tss.c_len) {
+    clrcursor();
+    tss.c_idx++;
+    drawcursor();
+    return 1;
+  }
+
+  return tss.c_len;
+}
+
+void tsin_scan_pre_select(gboolean b_incr);
+
+static int cursor_backspace()
+{
+        close_selection_win();
+        poo.ityp3_pho=0;
+        tss.pre_selN = 0;
+        gboolean pho_cleared;
+        pho_cleared=FALSE;
+		int j;
+
+        if (pin_juyin) {
+          for(j=sizeof(poo.inph)-1;j>=0;j--) {
+            if (poo.inph[j]) {
+              poo.inph[j]=0;
+              pho_cleared = TRUE;
+			  if (j==0)
+				clrin_pho();
+              break;
+            }
+          }
+        } else {
+          for(j=3;j>=0;j--)
+            if (poo.typ_pho[j]) {
+              poo.typ_pho[j]=0;
+              poo.inph[j]=0;
+              pho_cleared = TRUE;
+              break;
+            }
+        }
+
+        if (pho_cleared) {
+//          dbg("pho cleared %d %d %d\n",tss.c_len, hime_pop_up_win, typ_pho_empty());
+		  if (typ_pho_empty())
+			  bzero(poo.inph, sizeof(poo.inph));
+
+          disp_in_area_pho_tsin();
+          tsin_scan_pre_select(TRUE);
+
+          if (!tss.c_len && hime_pop_up_win && typ_pho_empty())
+            hide_win0();
+          return 1;
+        }
+
+        if (!tss.c_idx)
+          return 0;
+
+        clrcursor();
+        tss.c_idx--;
+//        pst=k=tss.chpho[tss.c_idx].psta;
+
+		int k;
+        for(k=tss.c_idx;k<tss.c_len;k++) {
+          tss.chpho[k]=tss.chpho[k+1];
+          if (tss.chpho[k+1].ch == tss.chpho[k+1].cha)
+            tss.chpho[k].ch = tss.chpho[k].cha;
+        }
+
+        tss.c_len--;
+        init_chpho_i(tss.c_len);
+		call_tsin_parse();
+		compact_win0();
+
+        if (!tss.c_idx) {
+          clear_match();
+        } else {
+          tsin_scan_pre_select(TRUE);
+        }
+
+        disp_ph_sta();
+
+        if (!tss.c_len && hime_pop_up_win)
+          hide_win0();
+
+        return 1;
+}
+
+
+static int cursor_delete()
+{
+	if (tss.c_idx>=tss.c_len)
+		return FALSE;
+	tss.c_idx++;
+	return cursor_backspace();
+}
+
+void case_inverse(KeySym *xkey, int shift_m);
+void pho_play(phokey_t key);
+
+int tsin_pho_sel(int c)
+{
+  char *sel_text;
+  int is_pho_phrase;
+  int len = fetch_user_selection(c, &sel_text, &is_pho_phrase);
+  int sel_idx = tss.c_idx;
+  if (tss.c_idx == tss.c_len)
+    sel_idx = tss.c_len - len;
+
+  set_chpho_ch(&tss.chpho[sel_idx], sel_text, len, is_pho_phrase);
+
+  set_fixed(sel_idx, len);
+
+  call_tsin_parse();
+
+  if (tss.c_idx + len == tss.c_len) {
+    tss.ph_sta = -1;
+//    draw_ul(tss.c_idx, tss.c_len);
+  }
+
+  if (len) {
+    prbuf();
+    tss.current_page=tss.sel_pho=poo.ityp3_pho=0;
+    if (len == 1) {
+      hide_selections_win();
+      tss.ph_sta = -1;
+      return 0;
+    }
+    else
+      tss.ph_sta=-1;
+
+    hide_selections_win();
+  }
+
+  return 1;
+}
+
+
+gboolean tsin_page_up()
+{
+  if (!tss.sel_pho)
+    return tss.c_len;
+
+  tss.current_page = tss.current_page - phkbm.selkeyN;
+  if (tss.current_page < 0)
+    tss.current_page = 0;
+
+  tss.pho_menu_idx = 0;
+  disp_current_sel_page();
+  return TRUE;
+}
+
+gboolean tsin_page_down()
+{
+  if (!tss.sel_pho)
+    return tss.c_len;
+
+  tss.pho_menu_idx = 0;
+  tss.current_page = tss.current_page + phkbm.selkeyN;
+  if (tss.current_page >= phrase_count + pho_count)
+    tss.current_page = 0;
+
+  disp_current_sel_page();
+
+  return TRUE;
+}
+
+void open_select_pho()
+{
+  if (tss.c_idx==tss.c_len) {
+    get_sel_phrase_end();
+  } else
+    get_sel_phrase();
+
+  get_sel_pho();
+  tss.sel_pho=1;
+  tss.pho_menu_idx = tss.current_page = 0;
+  disp_current_sel_page();
+}
+
+gboolean win_sym_page_up(), win_sym_page_down();
+
+static void tsin_create_win_save_phrase(int idx0, int len)
+{
+  WSP_S wsp[MAX_PHRASE_LEN];
+  int i;
+  for(i=0;i<len;i++) {
+    memcpy(wsp[i].ch, tss.chpho[i+idx0].ch, CH_SZ);
+    wsp[i].key = tss.chpho[i+idx0].pho;
+  }
+  create_win_save_phrase(wsp, len);
+}
+
+
+int feedkey_pp(KeySym xkey, int kbstate)
+{
+  char ctyp=0;
+  static u_int ii;
+  static u_short key;
+  int shift_m=kbstate&ShiftMask;
+  int ctrl_m=kbstate&ControlMask;
+  int jj,kk, idx;
+  char kno;
+  int caps_eng_tog = tsin_chinese_english_toggle_key == TSIN_CHINESE_ENGLISH_TOGGLE_KEY_CapsLock;
+  int status=0;
+
+
+//  dbg("feedkey_pp %x %x\n", xkey, kbstate);
+//  if (xkey=='1')
+//    dbg("aaa\n");
+
+  if (caps_eng_tog) {
+    gboolean new_tsin_pho_mode = ! gdk_keymap_get_caps_lock_state(gdk_keymap_get_default());
+    if (current_CS->tsin_pho_mode != new_tsin_pho_mode) {
+      close_selection_win();
+      tsin_set_eng_ch(new_tsin_pho_mode);
+    }
+  }
+
+   if (kbstate & (Mod1Mask|Mod4Mask|Mod5Mask)) {
+//     dbg("ret\n");
+     return 0;
+   }
+
+   // Shift has autorepeat on win32
+   if ((xkey==XK_Shift_L||xkey==XK_Shift_R) && !key_press_alt) {
+//	  dbg("feedkey_pp\n");
+     key_press_alt = TRUE;
+     key_press_ctrl = FALSE;
+   } else
+   if ((xkey==XK_Control_L||xkey==XK_Control_R) && !key_press_ctrl && tss.pre_selN) {
+//	  dbg("feedkey_pp\n");
+     key_press_ctrl = TRUE;
+     key_press_alt = FALSE;
+     return TRUE;
+   } else {
+     key_press_alt = FALSE;
+     key_press_ctrl = FALSE;
+   }
+
+   if (!tsin_pho_mode() && !tss.c_len && hime_pop_up_win && xkey!=XK_Caps_Lock) {
+     hide_win0();
+     gboolean is_ascii = (xkey>=' ' && xkey<0x7f) && !ctrl_m;
+
+     if (caps_eng_tog && is_ascii) {
+       if (hime_capslock_lower)
+         case_inverse(&xkey, shift_m);
+       send_ascii(xkey);
+       return 1;
+     }
+     else {
+       if (tss.tsin_half_full && is_ascii) {
+         send_text(half_char_to_full_char(xkey));
+         return 1;
+       }
+       else {
+         return 0;
+       }
+     }
+   }
+
+   int o_sel_pho = tss.sel_pho;
+   close_win_pho_near();
+
+   switch (xkey) {
+     case XK_Escape:
+       tsin_reset_in_pho0();
+       if (typ_pho_empty()) {
+         if (!tss.c_len)
+           return 0;
+         if (!o_sel_pho && tsin_tab_phrase_end) {
+           goto tab_phrase_end;
+         }
+       }
+       tsin_reset_in_pho();
+       return 1;
+     case XK_Return:
+     case XK_KP_Enter:
+        if (shift_m) {
+          if (!tss.c_len)
+            return 0;
+          int idx0 = tss.c_idx;
+          if (tss.c_len == tss.c_idx)
+            idx0 = 0;
+          int len = tss.c_len - idx0;
+          if (len > MAX_PHRASE_LEN)
+            return 0;
+          tsin_create_win_save_phrase(idx0, len);
+          move_cursor_end();
+          return 1;
+        } else {
+          if (tss.sel_pho) {
+            tsin_sele_by_idx(tss.pho_menu_idx);
+          } else {
+            if (tss.c_len)
+              flush_tsin_buffer();
+            else
+            if (typ_pho_empty())
+              return 0;
+          }
+          return 1;
+        }
+     case XK_Home:
+     case XK_KP_Home:
+        close_selection_win();
+        if (!tss.c_len)
+          return 0;
+        clrcursor();
+        tss.c_idx=0;
+        drawcursor();
+        return 1;
+     case XK_End:
+     case XK_KP_End:
+        close_selection_win();
+        if (!tss.c_len)
+          return 0;
+        move_cursor_end();
+        return 1;
+     case XK_Left:
+     case XK_KP_Left:
+        return cursor_left();
+     case XK_Right:
+     case XK_KP_Right:
+        return cursor_right();
+     case XK_Caps_Lock:
+        if (caps_eng_tog) {
+#if 0
+          close_selection_win();
+          tsin_toggle_eng_ch();
+#endif
+          return 1;
+        } else
+          return 0;
+     case XK_Tab:
+        close_selection_win();
+        if (tsin_chinese_english_toggle_key == TSIN_CHINESE_ENGLISH_TOGGLE_KEY_Tab) {
+          tsin_toggle_eng_ch();
+          return 1;
+        }
+
+        if (tsin_tab_phrase_end && tss.c_len > 1) {
+tab_phrase_end:
+          if (tss.c_idx==tss.c_len)
+            tss.chpho[tss.c_idx-1].flag |= FLAG_CHPHO_PHRASE_USER_HEAD;
+          else
+            tss.chpho[tss.c_idx].flag |= FLAG_CHPHO_PHRASE_USER_HEAD;
+           call_tsin_parse();
+          return 1;
+        } else {
+          if (tss.c_len) {
+            flush_tsin_buffer();
+            return 1;
+          }
+        }
+        return 0;
+     case XK_Delete:
+     case XK_KP_Delete:
+        return cursor_delete();
+     case XK_BackSpace:
+		return cursor_backspace();
+     case XK_Up:
+     case XK_KP_Up:
+       if (!tss.sel_pho) {
+         if (tsin_use_pho_near && tss.c_len && tss.c_idx == tss.c_len) {
+           int idx = tss.c_len-1;
+           phokey_t pk = tss.chpho[idx].pho;
+
+           if (pk) {
+             void create_win_pho_near(phokey_t pho);
+             create_win_pho_near(pk);
+           }
+
+           return 1;
+         }
+
+         return tss.c_len>0;
+       }
+
+       int N;
+       N = phrase_count + pho_count - tss.current_page;
+       if (N > phkbm.selkeyN)
+         N = phkbm.selkeyN;
+       if (tss.pho_menu_idx == 0)
+         tsin_page_up();
+       else {
+         tss.pho_menu_idx--;
+         if (tss.pho_menu_idx < 0)
+           tss.pho_menu_idx = N-1;
+         disp_current_sel_page();
+       }
+       return 1;
+     case XK_Prior:
+     case XK_KP_Prior:
+     case XK_KP_Subtract:
+       if (!tss.sel_pho && tss.c_len && xkey == XK_KP_Subtract) {
+         add_to_tsin_buf_str("-");
+         return TRUE;
+       } else {
+         if (tss.c_len && !tss.sel_pho)
+           return win_sym_page_up();
+         if (tsin_page_up())
+           return TRUE;
+         return win_sym_page_up();
+       }
+     case XK_space:
+       if (!tss.c_len && !poo.ityp3_pho && !poo.typ_pho[0] && !poo.typ_pho[1] && !poo.typ_pho[2]
+           && tss.tsin_half_full) {
+         send_text("");	 /* Full width space */
+         return 1;
+       }
+
+       if (tsin_space_opt == TSIN_SPACE_OPT_INPUT && !poo.typ_pho[0] && !poo.typ_pho[1] && !poo.typ_pho[2] && !poo.ityp3_pho && !tss.sel_pho) {
+         if (tss.c_len)
+           flush_tsin_buffer();
+
+         close_selection_win();
+         goto asc_char;
+       }
+
+       if (!tsin_pho_mode())
+           goto asc_char;
+     case XK_Down:
+     case XK_KP_Down:
+       if (xkey==XK_space && !poo.ityp3_pho && (poo.typ_pho[0]||poo.typ_pho[1]||poo.typ_pho[2])) {
+         kno=0;
+#if 1
+         ctyp=3;
+//         status = inph_typ_pho(xkey);
+#endif
+         goto llll1;
+       }
+
+change_char:
+       if (!tss.c_len)
+         return 0;
+
+       idx = tss.c_idx==tss.c_len ? tss.c_idx - 1 : tss.c_idx;
+       if (!tss.chpho[idx].pho)
+         return 1;
+
+       if (!tss.sel_pho) {
+         open_select_pho();
+       } else {
+         int N = phrase_count + pho_count - tss.current_page;
+         if (N > phkbm.selkeyN)
+           N = phkbm.selkeyN;
+         if (tss.pho_menu_idx == N-1 || xkey == XK_space)
+           tsin_page_down();
+         else {
+           tss.pho_menu_idx = (tss.pho_menu_idx+1) % N;
+           disp_current_sel_page();
+         }
+       }
+       return 1;
+     case XK_Next:
+     case XK_KP_Next:
+     case XK_KP_Add:
+       if (!tss.sel_pho && tss.c_len && xkey == XK_KP_Add) {
+         add_to_tsin_buf_str("+");
+         return TRUE;
+       } else {
+         if (tss.c_len && !tss.sel_pho)
+           return win_sym_page_down();
+		 if (tsin_page_down())
+           return TRUE;
+		 return win_sym_page_down();
+	   }
+     case '\'':  // single quote
+       if (phkbm.phokbm[xkey][0].num && !pin_juyin)
+         goto other_keys;
+       else {
+	 return pre_punctuation_hsu(xkey);
+       }
+     case 'q':
+     case 'Q':
+       if (b_hsu_kbm && tsin_pho_mode())
+         goto change_char;
+     default:
+other_keys:
+       if ((kbstate & ControlMask)) {
+         if (xkey=='u') {
+           if (tss.c_len) {
+             clear_tsin_buffer();
+             if (hime_pop_up_win)
+               hide_win0();
+             return 1;
+           } else
+             return 0;
+         } else if (tsin_buffer_editing_mode && xkey == 'e') { //ctrl+e only works when user enabled tsin_buffer_editing_mode
+           //toggler
+           tss.tsin_buffer_editing ^= 1;
+           return 1;
+         } else if (xkey>='1' && xkey<='9') {
+           if (!tss.c_len)
+             return 0;
+           if (!tss.c_idx)
+             return 1;
+
+           int len = xkey - '0';
+           int idx0 = tss.c_idx - len;
+
+           if (idx0 < 0)
+             return 1;
+
+           tsin_create_win_save_phrase(idx0, len);
+           return 1;
+         } else {
+           return 0;
+         }
+       }
+
+       char xkey_lcase = xkey;
+       if ('A' <= xkey && xkey <= 'Z') {
+         xkey_lcase = tolower(xkey);
+       }
+
+
+       if (tsin_buffer_editing_mode && xkey == '\\') {
+         tss.tsin_buffer_editing ^= 1;
+         if (tss.tsin_buffer_editing && tss.c_idx==tss.c_len)
+           cursor_left();
+         return TRUE;
+       }
+
+       if (!tss.c_len)
+         tss.tsin_buffer_editing = FALSE;
+
+       if (tss.tsin_buffer_editing && !tss.sel_pho) {
+         if (xkey_lcase=='h' || xkey_lcase=='j')
+           return cursor_left();
+         else
+         if (xkey_lcase=='l' || xkey_lcase=='k')
+           return cursor_right();
+         else
+         if (xkey_lcase=='x')
+           return cursor_delete();
+         else
+           return TRUE;
+       }
+
+       if (xkey >= XK_KP_0 && xkey<=XK_KP_9)
+         xkey_lcase = xkey - XK_KP_0 + '0';
+
+       gboolean use_pre_sel;
+       use_pre_sel = tss.pre_selN && !tss.sel_pho && xkey < 127 && !phkbm.phokbm[xkey][0].num;
+
+       char *pp;
+       if ((pp=strchr(pho_selkey,xkey_lcase)) && (tss.sel_pho || tss.ctrl_pre_sel || use_pre_sel)) {
+         int c=pp-pho_selkey;
+
+         if (tss.sel_pho) {
+           if (tsin_pho_sel(c))
+             return 1;
+         } else
+         if (tss.ctrl_pre_sel || use_pre_sel) {
+           tss.ctrl_pre_sel = FALSE;
+           if (tsin_sele_by_idx(c))
+             return TRUE;
+           else {
+             close_selection_win();
+           }
+         }
+
+         goto scan_it;
+       }
+
+       tss.sel_pho=tss.current_page=0;
+   }
+
+   KeySym key_pad;
+   key_pad = keypad_proc(xkey);
+
+   if (!xkey || (xkey > 0x7e && !key_pad))
+     return 0;
+
+   if (key_pad && !tss.c_len && !tss.tsin_half_full)
+     return 0;
+
+   if (!tsin_pho_mode() || (poo.typ_pho[0]!=BACK_QUOTE_NO && (shift_m || key_pad ||
+       (!phkbm.phokbm[xkey][0].num && !phkbm.phokbm[xkey][0].typ)))) {
+       if (tsin_pho_mode() && !shift_m && strchr(hsu_punc, xkey) && !phkbm.phokbm[xkey][0].num) {
+         if (pre_punctuation_hsu(xkey))
+           return 1;
+       }
+
+       if (key_pad)
+         xkey = key_pad;
+asc_char:
+        if (shift_m) {
+          if (pre_sel_handler(xkey)) {
+            call_tsin_parse();
+            return 1;
+          }
+
+          if (tsin_pho_mode() && pre_punctuation(xkey))
+            return 1;
+        }
+
+        if (shift_m && tsin_pho_mode())  {
+          char *ppp=strchr(ochars,xkey);
+
+          if (!(kbstate&LockMask) && ppp && !((ppp-ochars) & 1))
+            xkey=*(ppp+1);
+
+        } else {
+          if (!tsin_pho_mode() && caps_eng_tog && hime_capslock_lower) {
+            case_inverse(&xkey, shift_m);
+          }
+        }
+
+        if (xkey > 127)
+          return 0;
+        char tstr[CH_SZ + 1];
+        bzero(tstr, sizeof(tstr));
+
+        u_char tt=xkey;
+
+        if (tss.tsin_half_full) {
+          strcpy(tstr, half_char_to_full_char(xkey));
+        } else {
+          tstr[0] = tt;
+        }
+
+        if (!tss.c_len) {
+          send_text(tstr);
+          return 1;
+        }
+
+        shift_ins();
+
+        memcpy(tss.chpho[tss.c_idx].ch, tstr, CH_SZ);
+
+        set_fixed(tss.c_idx, 1);
+        phokey_t tphokeys[32];
+        tphokeys[0]=0;
+        utf8_pho_keys(tss.chpho[tss.c_idx].ch, tphokeys);
+
+        disp_char_chbuf(tss.c_idx);
+        tss.chpho[tss.c_idx].pho=tphokeys[0];
+        tss.c_idx++;
+        if (tss.c_idx < tss.c_len)
+          prbuf();
+
+        if (hime_pop_up_win)
+          show_win0();
+
+        drawcursor();
+        return 1;
+   }
+
+
+     if (xkey > 127) {
+       return 0;
+     }
+
+     // for hsu & et26
+     if (xkey >= 'A' && xkey <='Z' && poo.typ_pho[0]!=BACK_QUOTE_NO)
+       xkey+=0x20;
+//     printf("bbbb %c\n", xkey);
+
+llll1:
+     status = inph_typ_pho(xkey);
+     if (hime_pop_up_win)
+         show_win0();
+
+     if (poo.typ_pho[3] || (status&PHO_STATUS_OK_NEW))
+       ctyp = 3;
+
+//     dbg("status %d %d\n", status, ctyp);
+     jj=0;
+     kk=1;
+llll2:
+     if (ctyp==3) {
+       poo.ityp3_pho=1;  /* last key is entered */
+
+       if (!tsin_tone_char_input && !poo.typ_pho[0] && !poo.typ_pho[1] && !poo.typ_pho[2]) {
+         clrin_pho_tsin();
+         dbg("no pho input\n");
+         return TRUE;
+       }
+     }
+
+     disp_in_area_pho_tsin();
+
+     key = pho2key(poo.typ_pho);
+
+     pho_play(key);
+
+     int vv=hash_pho[(int)poo.typ_pho[0]];
+
+     phokey_t ttt=0xffff;
+     while (vv<idxnum_pho) {
+       ttt=idx_pho[vv].key;
+       if (poo.typ_pho[0]!=BACK_QUOTE_NO) {
+         if (!poo.typ_pho[0]) ttt &= ~(31<<9);
+         if (!poo.typ_pho[1]) ttt &= ~(3<<7);
+         if (!poo.typ_pho[2]) ttt &= ~(15<<3);
+         if (!poo.typ_pho[3]) ttt &= ~(7);
+       }
+       if (ttt>=key) break;
+       else
+       vv++;
+     }
+#if 0
+     printf("aaaa vv:%d  idxnum_pho:%d   ttt:%x key:%x\n",vv, idxnum_pho, ttt, key);
+#endif
+     if (!pin_juyin && (ttt > key || (poo.ityp3_pho && idx_pho[vv].key!=key))) {
+       while (jj<4) {
+         while(kk<3)
+         if (phkbm.phokbm[(int)poo.inph[jj]][kk].num ) {
+           if (kk) {
+             ctyp=phkbm.phokbm[(int)poo.inph[jj]][kk-1].typ;
+             poo.typ_pho[(int)ctyp]=0;
+           }
+           kno=phkbm.phokbm[(int)poo.inph[jj]][kk].num;
+           ctyp=phkbm.phokbm[(int)poo.inph[jj]][kk].typ;
+           poo.typ_pho[(int)ctyp]=kno;
+           kk++;
+           goto llll2;
+         } else kk++;
+         jj++;
+         kk=1;
+       }
+
+       bell(); poo.ityp3_pho=poo.typ_pho[3]=0;
+       disp_in_area_pho_tsin();
+//       dbg("not found ...\n");
+       return 1;
+     }
+
+     if (poo.typ_pho[0]==L_BRACKET_NO||poo.typ_pho[0]==R_BRACKET_NO || (poo.typ_pho[0]==BACK_QUOTE_NO && poo.typ_pho[1]))
+       poo.ityp3_pho = 1;
+
+     if (key==0 || !poo.ityp3_pho) {
+       if (key)
+         tsin_scan_pre_select(TRUE);
+//       dbg("ret a\n");
+       return 1;
+     }
+
+     ii=idx_pho[vv].start;
+     poo.start_idx=ii;
+     poo.stop_idx = idx_pho[vv+1].start;
+#if 0
+     printf("%x %x %d vv:%d idxnum_pho:%d-->", ttt, key, poo.start_idx, vv, idxnum_pho);
+     utf8_putchar(pho_idx_str(poo.start_idx));
+     puts("<---");
+#endif
+
+   if (!tss.c_len && poo.typ_pho[0]==BACK_QUOTE_NO && poo.stop_idx - poo.start_idx == 1)
+     send_text(pho_idx_str(poo.start_idx));  // it's ok since ,. are 3 byte, last one \0
+   else
+     put_u8_char(poo.start_idx, key, (status&PHO_STATUS_TONE)>0);
+
+   call_tsin_parse();
+
+   disp_ph_sta();
+   if (status & PHO_STATUS_PINYIN_LEFT) {
+     poo.ityp3_pho=0;
+     disp_in_area_pho_tsin();
+   } else {
+     clrin_pho_tsin();
+     clr_in_area_pho_tsin();
+   }
+   drawcursor();
+   hide_pre_sel();
+
+scan_it:
+   tsin_scan_pre_select(FALSE);
+
+   return 1;
+}
+
+
+int feedkey_pp_release(KeySym xkey, int kbstate)
+{
+  switch (xkey) {
+     case XK_Shift_L:
+     case XK_Shift_R:
+// dbg("release xkey %x\n", xkey);
+        if (((tsin_chinese_english_toggle_key == TSIN_CHINESE_ENGLISH_TOGGLE_KEY_Shift) ||
+             (tsin_chinese_english_toggle_key == TSIN_CHINESE_ENGLISH_TOGGLE_KEY_ShiftL && xkey == XK_Shift_L) ||
+             (tsin_chinese_english_toggle_key == TSIN_CHINESE_ENGLISH_TOGGLE_KEY_ShiftR && xkey == XK_Shift_R)) &&
+	    key_press_alt) {
+          if (!test_mode) {
+            close_selection_win();
+            tsin_toggle_eng_ch();
+          }
+	  key_press_alt = FALSE;
+          return 1;
+	} else
+          return 0;
+     case XK_Control_L:
+     case XK_Control_R:
+        if (key_press_ctrl && tss.pre_selN) {
+          if (!test_mode)
+	    tss.ctrl_pre_sel = TRUE;
+	  key_press_ctrl = FALSE;
+          return 1;
+	} else
+          return 0;
+     default:
+        return 0;
+  }
+}
+
+
+void tsin_remove_last()
+{
+  if (!tss.c_len)
+    return;
+  tss.c_len--;
+  tss.c_idx--;
+}
+
+
+gboolean save_phrase_to_db2(CHPHO *chph, int len)
+{
+   phokey_t pho[MAX_PHRASE_LEN];
+   char ch[MAX_PHRASE_LEN * CH_SZ * 2];
+
+   chpho_extract_cha(chph, len, pho, ch);
+
+   return save_phrase_to_db(pho, ch, len, 1);
+}
+
+#include "im-client/hime-im-client-attr.h"
+
+
+int tsin_get_preedit(char *str, HIME_PREEDIT_ATTR attr[], int *cursor, int *comp_flag)
+{
+  int i;
+  int tn=0;
+  int attrN=0;
+#if DEBUG && 0
+  dbg("tsin_get_preedit\n");
+#endif
+
+  gboolean ap_only = hime_edit_display_ap_only();
+
+  for(i=0; i<tss.c_len; i++) {
+    if (tn>=HIME_PREEDIT_MAX_STR-4*CH_SZ-1)
+      goto fin;
+    if (i==tss.c_idx && hime_display_on_the_spot_key()) {
+      tn += get_in_area_pho_tsin_str(str+tn);
+    }
+
+    strcpy(str+tn, tss.chpho[i].ch);
+    tn+=strlen(tss.chpho[i].ch);
+  }
+
+fin:
+  str[tn]=0;
+
+  if (i==tss.c_idx && hime_display_on_the_spot_key())
+    get_in_area_pho_tsin_str(str+tn);
+
+#if DEBUG && 0
+  dbg("'%s'\n", str);
+#endif
+  if (tss.c_len) {
+    attr[0].flag=HIME_PREEDIT_ATTR_FLAG_UNDERLINE;
+    attr[0].ofs0=0;
+    attr[0].ofs1=tss.c_len;
+    attrN++;
+
+
+    // for firefox 4
+    if (ap_only && tss.c_idx < tss.c_len) {
+      attr[1].ofs0=tss.c_idx;
+      attr[1].ofs1=tss.c_idx+1;
+      attr[1].flag=HIME_PREEDIT_ATTR_FLAG_REVERSE;
+      attrN++;
+    }
+  }
+
+  *cursor = tss.c_idx;
+  *comp_flag = !typ_pho_empty();
+  if (gwin1 && GTK_WIDGET_VISIBLE(gwin1))
+    *comp_flag|=2;
+#if 1
+  if (tss.c_len && !ap_only)
+	*comp_flag|=4;
+#endif
+
+  return attrN;
+}
+
+int tsin_reset()
+{
+//  dbg("tsin_reset\n");
+  if (!gwin0)
+    return 0;
+  int v = tss.c_len > 0;
+  tsin_reset_in_pho0();
+  clear_tsin_buffer();
+
+  return v;
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/tsin.h b/src/plugins/platforminputcontexts/hime/include/tsin.h
new file mode 100644
index 0000000..0055e42
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/tsin.h
@@ -0,0 +1,68 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+extern int phcount;
+extern int hashidx[];
+//extern int *phidx;
+//extern FILE *fph;
+
+typedef struct CHPHO {
+  char *ch;
+  char cha[CH_SZ+1];
+  phokey_t pho;
+  u_short flag;
+  char psta; // phrase start index
+} CHPHO;
+
+enum {
+  FLAG_CHPHO_FIXED=1,    // user selected the char, so it should not be changed
+  FLAG_CHPHO_PHRASE_HEAD=2,
+  FLAG_CHPHO_PHRASE_USER_HEAD=4,
+  FLAG_CHPHO_PHRASE_VOID=8,
+  FLAG_CHPHO_PHRASE_BODY=16,
+  FLAG_CHPHO_PHO_PHRASE=32,
+  FLAG_CHPHO_PINYIN_TONE=64,
+  FLAG_CHPHO_GTAB_BUF_EN_NO_SPC=128,
+  FLAG_CHPHO_PHRASE_TAIL=0x100,
+};
+
+void extract_pho(int chpho_idx, int plen, phokey_t *pho);
+gboolean tsin_seek(void *pho, int plen, int *r_sti, int *r_edi, char *tone_off);
+void load_tsin_entry(int idx, char *len, usecount_t *usecount, void *pho, u_char *ch);
+gboolean check_fixed_mismatch(int chpho_idx, char *mtch, int plen);
+gboolean tsin_pho_mode();
+char *get_chpho_pinyin_set(char *set_arr);
+
+#define TSIN_GTAB_KEY "!!!!gtab-keys"
+
+typedef struct {
+  char signature[32];
+  int version, flag;
+  int keybits, maxkey;
+  char keymap[128];
+} TSIN_GTAB_HEAD;
+
+typedef struct PRE_SEL {
+  u_int64_t phkey[MAX_PHRASE_LEN];  // gtab 4-byte is actually stored as u_int not u_int64_t
+//  int phidx;
+  char str[MAX_PHRASE_LEN*CH_SZ+1];
+  int len;
+  usecount_t usecount;
+} PRE_SEL;
+
+extern gboolean tsin_is_gtab;
+extern int ph_key_sz;
diff --git a/src/plugins/platforminputcontexts/hime/include/util.c b/src/plugins/platforminputcontexts/hime/include/util.c
new file mode 100644
index 0000000..0d81b1b
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/util.c
@@ -0,0 +1,150 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "hime.h"
+#include <errno.h>
+
+#if !CLIENT_LIB && DEBUG
+static FILE *out_fp;
+#endif
+
+void p_err(char *fmt,...)
+{
+  va_list args;
+  char out[4096];
+
+  va_start(args, fmt);
+  vsprintf(out, fmt, args);
+  va_end(args);
+
+  fprintf(stderr, "%s\n", out);
+
+#if DEBUG && 1
+  abort();
+#else
+  if (getenv("HIME_ERR_COREDUMP"))
+    abort();
+  exit(-1);
+#endif
+}
+
+#if !CLIENT_LIB && DEBUG
+static void init_out_fp()
+{
+  if (!out_fp) {
+    if (getenv("HIME_DBG_TMP") || 0) {
+      char fname[64];
+      sprintf(fname, "%s/himedbg-%d-%d", g_get_tmp_dir(), getuid(), getpid());
+      out_fp = fopen(fname, "w");
+    }
+
+    if (!out_fp)
+      out_fp = stdout;
+  }
+}
+#endif
+
+#if !CLIENT_LIB
+void dbg_time(char *fmt,...)
+{
+#if DEBUG
+  va_list args;
+  time_t t;
+
+  init_out_fp();
+
+  time(&t);
+  struct tm *ltime = localtime(&t);
+  dbg("%02d:%02d:%02d ", ltime->tm_hour, ltime->tm_min, ltime->tm_sec);
+
+  va_start(args, fmt);
+  vfprintf(out_fp, fmt, args);
+  fflush(out_fp);
+  va_end(args);
+#endif
+}
+#endif
+
+#if DEBUG
+void __hime_dbg_(char *fmt,...)
+{
+  va_list args;
+
+  init_out_fp();
+
+  va_start(args, fmt);
+  vfprintf(out_fp, fmt, args);
+  fflush(out_fp);
+  va_end(args);
+}
+#endif
+
+char *sys_err_strA()
+{
+  return (char *)strerror(errno);
+}
+
+void *zmalloc(int n)
+{
+  void *p =  malloc(n);
+  bzero(p, n);
+  return p;
+}
+#if !HIME_IME
+
+void *memdup(void *p, int n)
+{
+  if (!p || !n)
+    return NULL;
+  void *q;
+  q = malloc(n);
+  memcpy(q, p, n);
+  return q;
+}
+
+// can handle eol with \n \r \n\r \r\n
+char *myfgets(char *buf, int bufN, FILE *fp)
+{
+	char *out = buf;
+//	int rN = 0;
+	while (!feof(fp) && out - buf < bufN) {
+		char a, b;
+		a = 0;
+		if (fread(&a, 1, 1, fp) != 1)
+			break;
+		if (a =='\n') {
+			b = 0;
+			if (fread(&b, 1, 1, fp)==1)
+				if (b!='\r')
+					fseek(fp, -1, SEEK_CUR);
+			break;
+		} else
+		if (a =='\r') {
+			b = 0;
+			if (fread(&b, 1, 1, fp)==1)
+				if (b!='\n')
+					fseek(fp, -1, SEEK_CUR);
+			break;
+		}
+
+		*(out++) = a;
+	}
+
+	*out = 0;
+	return buf;
+}
+#endif
diff --git a/src/plugins/platforminputcontexts/hime/include/util.h b/src/plugins/platforminputcontexts/hime/include/util.h
new file mode 100644
index 0000000..62fbfc9
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/util.h
@@ -0,0 +1,12 @@
+void p_err(char *fmt,...);
+
+#ifndef DEBUG
+#define DEBUG 0
+#endif
+
+#if DEBUG
+void __hime_dbg_(char *fmt,...);
+#define dbg(fmt,...) __hime_dbg_("%s:%d: " fmt, __func__, __LINE__, ## __VA_ARGS__)
+#else
+#define dbg(...) do {} while (0)
+#endif
diff --git a/src/plugins/platforminputcontexts/hime/include/win-save-phrase.c b/src/plugins/platforminputcontexts/hime/include/win-save-phrase.c
new file mode 100644
index 0000000..3e54b17
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/win-save-phrase.c
@@ -0,0 +1,226 @@
+/* Copyright (C) 2011 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "hime.h"
+#include "pho.h"
+#include "win-save-phrase.h"
+#include "gtab.h"
+
+extern int c_len;
+extern gboolean test_mode;
+
+
+typedef struct {
+  WSP_S *mywsp;
+  int mywspN;
+  GtkWidget *label_countdown, *win;
+  int countdown, countdown_handle;
+} SAVE_SESS;
+
+static void wsp_str(WSP_S *wsp, int wspN, char *out)
+{
+  int i;
+  int ofs=0;
+
+  for(i=0;i<wspN;i++) {
+//    utf8_putchar(wsp[i].ch);
+	int n = utf8cpy(out+ofs, wsp[i].ch);
+	ofs+=n;
+  }
+
+//  out[ofs]=0;
+//  dbg(" c_len:%d wsp %s\n", c_len, out);
+}
+
+
+static void free_mywsp(SAVE_SESS *sess)
+{
+  free(sess->mywsp); sess->mywsp=NULL;
+  free(sess);
+}
+
+
+static gboolean close_win_save_phrase(GtkWidget *widget, gpointer data)
+{
+  SAVE_SESS *sess = (SAVE_SESS *)data;
+
+  g_source_remove(sess->countdown_handle);
+  gtk_widget_destroy(sess->win);
+  free_mywsp(sess);
+  return TRUE;
+}
+
+#if 0
+static gint delete_event( GtkWidget *widget,
+                   GdkEvent  *event,
+                   gpointer   data)
+{
+  free_mywsp(data);
+  return FALSE;
+}
+#endif
+
+extern int ph_key_sz;
+
+static gboolean cb_ok(GtkWidget *widget, gpointer data)
+{
+  SAVE_SESS *sess = (SAVE_SESS *)data;
+  g_source_remove(sess->countdown_handle);
+
+  int i;
+  phokey_t pho[MAX_PHRASE_LEN];
+  u_int pho32[MAX_PHRASE_LEN];
+  u_int64_t pho64[MAX_PHRASE_LEN];
+  char tt[512];
+  void *dat = NULL;
+  wsp_str(sess->mywsp, sess->mywspN, tt);
+
+  if (ph_key_sz==2) {
+    for(i=0;i<sess->mywspN;i++)
+      pho[i] = sess->mywsp[i].key;
+    dat = pho;
+  }
+  else
+  if (ph_key_sz==4) {
+    for(i=0;i< sess->mywspN;i++) {
+      pho32[i] = sess->mywsp[i].key;
+    }
+    dat = pho32;
+  }
+  else
+  if (ph_key_sz==8) {
+    for(i=0;i< sess->mywspN;i++)
+      pho64[i] = sess->mywsp[i].key;
+    dat = pho64;
+  }
+
+  save_phrase_to_db(dat, tt, sess->mywspN, 1);
+
+  gtk_widget_destroy(sess->win);
+
+  free_mywsp(sess);
+  return TRUE;
+}
+
+static void disp_countdown(SAVE_SESS *sess)
+{
+  char tt[64];
+
+  sprintf(tt, _("%d "), sess->countdown);
+  gtk_label_set_text(GTK_LABEL(sess->label_countdown), tt);
+}
+
+
+gboolean timeout_countdown(gpointer data)
+{
+  SAVE_SESS *sess = (SAVE_SESS *)data;
+
+  if (!sess->countdown) {
+    cb_ok(NULL, data);
+    return FALSE;
+  }
+
+  sess->countdown--;
+  disp_countdown(sess);
+  return TRUE;
+}
+
+
+void create_win_save_phrase(WSP_S *wsp, int wspN)
+{
+  if (!wspN)
+    return;
+
+  SAVE_SESS *sess = tzmalloc(SAVE_SESS, 1);
+
+  GtkWidget *main_window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+  gtk_window_set_has_resize_grip(GTK_WINDOW(main_window), FALSE);
+  sess->win = main_window;
+
+  gtk_window_set_default_size(GTK_WINDOW (main_window), 20, 10);
+
+  gtk_window_set_title(GTK_WINDOW(main_window), _(""));
+
+#if 0
+  g_signal_connect (G_OBJECT (main_window), "delete_event",
+                     G_CALLBACK (delete_event), sess);
+#endif
+
+  GtkWidget *vbox = gtk_vbox_new (FALSE, 0);
+  gtk_orientable_set_orientation(GTK_ORIENTABLE(vbox), GTK_ORIENTATION_VERTICAL);
+  gtk_container_add (GTK_CONTAINER (main_window), vbox);
+
+  char tt[512];
+  tt[0] = 0;
+  wsp_str(wsp, wspN, tt);
+
+  gtk_box_pack_start (GTK_BOX (vbox), gtk_label_new(tt), FALSE, FALSE, 0);
+
+  int i;
+  for(i=0; i<wspN; i++) {
+    if (ph_key_sz==2)
+      strcat(tt, phokey_to_str(wsp[i].key));
+    strcat(tt, " ");
+  }
+
+  if (tt[0])
+    gtk_box_pack_start (GTK_BOX (vbox), gtk_label_new(tt), FALSE, FALSE, 0);
+
+  sess->mywsp = tmemdup(wsp, WSP_S, wspN);
+  sess->mywspN = wspN;
+
+  GtkWidget *hbox_cancel_ok = gtk_hbox_new (FALSE, 10);
+  gtk_box_pack_start (GTK_BOX (vbox), hbox_cancel_ok , FALSE, FALSE, 5);
+
+  GtkWidget *button_ok = gtk_button_new_from_stock (GTK_STOCK_OK);
+  gtk_box_pack_start (GTK_BOX (hbox_cancel_ok), button_ok, TRUE, TRUE, 5);
+
+  GtkWidget *button_cancel = gtk_button_new_from_stock (GTK_STOCK_CANCEL);
+  gtk_box_pack_start (GTK_BOX (hbox_cancel_ok), button_cancel, TRUE, TRUE, 0);
+
+  sess->label_countdown = gtk_label_new(NULL);
+  gtk_box_pack_start (GTK_BOX (vbox), sess->label_countdown, FALSE, FALSE, 5);
+
+  gtk_widget_realize(main_window);
+  set_no_focus(main_window);
+
+//  dbg("mmmmmmmmmmmmm\n");
+
+  GTK_WIDGET_SET_FLAGS (button_ok, GTK_CAN_DEFAULT);
+  gtk_widget_grab_default (button_ok);
+
+
+#if 1
+//  dbg("main_window %x\n", main_window);
+  g_signal_connect (G_OBJECT (button_cancel), "clicked",
+                            G_CALLBACK (close_win_save_phrase),
+                            sess);
+
+  g_signal_connect (G_OBJECT (button_ok), "clicked",
+                            G_CALLBACK (cb_ok),
+                            sess);
+#endif
+
+  gtk_window_present(GTK_WINDOW(main_window));
+  gtk_window_set_keep_above(GTK_WINDOW(main_window), TRUE);
+//  gtk_window_set_modal(GTK_WINDOW(main_window), TRUE);
+
+  sess->countdown = 3;
+  disp_countdown(sess);
+  sess->countdown_handle = g_timeout_add(1000, timeout_countdown, sess);
+  gtk_widget_show_all(main_window);
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/win-save-phrase.h b/src/plugins/platforminputcontexts/hime/include/win-save-phrase.h
new file mode 100644
index 0000000..4af2578
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/win-save-phrase.h
@@ -0,0 +1,7 @@
+typedef struct {
+	u_int64_t key;
+	char ch[CH_SZ];
+	GtkWidget *opt;
+} WSP_S;
+
+void create_win_save_phrase(WSP_S *wsp, int wspN);
diff --git a/src/plugins/platforminputcontexts/hime/include/win1.c b/src/plugins/platforminputcontexts/hime/include/win1.c
new file mode 100644
index 0000000..5f9959a
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/win1.c
@@ -0,0 +1,432 @@
+/* Copyright (C) 2004-2012 Edward Der-Hua Liu, Hsin-Chu, Taiwan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation version 2.1
+ * of the License.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include "hime.h"
+#include "pho.h"
+#include "gst.h"
+#include "win1.h"
+
+GtkWidget *gwin1;
+static GtkWidget *frame;
+static char wselkey[16];
+static int wselkeyN;
+//Window xwin1;
+
+#define SELEN (15)
+
+static GtkWidget *labels_sele[SELEN], *labels_seleR[SELEN];
+static GtkWidget *eve_sele[SELEN], *eve_seleR[SELEN];
+static GtkWidget *arrow_up, *arrow_down;
+
+void hide_selections_win();
+static cb_page_ud_t cb_page_up, cb_page_down;
+static int c_config;
+
+static int current_config()
+{
+  return (tsin_tail_select_key<<9) | (pho_candicate_col_N<<5) | wselkeyN << 1|
+    pho_candicate_R2L;
+}
+
+static int idx_to_x(int tN, int i)
+{
+    if (tN > pho_candicate_col_N)
+      tN = pho_candicate_col_N;
+
+    int x = i % tN;
+    if (pho_candicate_R2L)
+      x = tN - 1 - x;
+    return x;
+}
+
+static gboolean button_scroll_event_tsin(GtkWidget *widget,GdkEventScroll *event, gpointer user_data)
+{
+  switch (event->direction) {
+    case GDK_SCROLL_UP:
+      if (cb_page_up)
+        cb_page_up();
+      break;
+    case GDK_SCROLL_DOWN:
+      if (cb_page_down)
+        cb_page_down();
+      break;
+    default:
+      break;
+  }
+
+  return TRUE;
+}
+
+
+
+void create_win1()
+{
+  if (gwin1)
+    return;
+
+  gwin1 = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+  gtk_window_set_has_resize_grip(GTK_WINDOW(gwin1), FALSE);
+  gtk_widget_realize (gwin1);
+
+  set_no_focus(gwin1);
+
+  g_signal_connect (G_OBJECT (gwin1), "scroll-event", G_CALLBACK (button_scroll_event_tsin), NULL);
+}
+
+
+void change_win1_font(), force_preedit_shift();
+
+
+static cb_selec_by_idx_t cb_sele_by_idx;
+
+static void mouse_button_callback( GtkWidget *widget,GdkEventButton *event, gpointer data)
+{
+  int v;
+  switch (event->button) {
+    case 1:
+      v = GPOINTER_TO_INT(data);
+      if (cb_sele_by_idx)
+        cb_sele_by_idx(v);
+      force_preedit_shift();
+      break;
+  }
+}
+
+
+static void cb_arrow_up (GtkWidget *button, gpointer user_data)
+{
+  if (cb_page_up)
+    cb_page_up();
+}
+static void cb_arrow_down (GtkWidget *button, gpointer user_data)
+{
+  if (cb_page_down)
+   cb_page_down();
+}
+
+void set_win1_cb(cb_selec_by_idx_t sele_by_idx, cb_page_ud_t page_up, cb_page_ud_t page_down)
+{
+  cb_sele_by_idx = sele_by_idx;
+  cb_page_up = page_up;
+  cb_page_down = page_down;
+}
+
+void create_win1_gui()
+{
+  if (frame)
+    return;
+//  dbg("create_win1_gui %s\n", wselkey);
+
+  frame = gtk_frame_new(NULL);
+  gtk_container_add (GTK_CONTAINER(gwin1), frame);
+
+  GtkWidget *vbox_top = gtk_vbox_new (FALSE, 0);
+  gtk_orientable_set_orientation(GTK_ORIENTABLE(vbox_top), GTK_ORIENTATION_VERTICAL);
+  gtk_container_add (GTK_CONTAINER(frame), vbox_top);
+
+  GtkWidget *eve_box_up = gtk_event_box_new();
+  gtk_event_box_set_visible_window (GTK_EVENT_BOX(eve_box_up), FALSE);
+  gtk_box_pack_start (GTK_BOX (vbox_top), eve_box_up, FALSE, FALSE, 0);
+  arrow_up = gtk_arrow_new (GTK_ARROW_UP, GTK_SHADOW_IN);
+  gtk_container_add(GTK_CONTAINER(eve_box_up), arrow_up);
+  g_signal_connect (G_OBJECT (eve_box_up), "button-press-event",
+                      G_CALLBACK (cb_arrow_up), NULL);
+
+  int c_rowN = (wselkeyN + pho_candicate_col_N - 1) / pho_candicate_col_N * pho_candicate_col_N;
+  int tablecolN = pho_candicate_col_N;
+
+  if (!tsin_tail_select_key)
+    tablecolN *= 2;
+
+  c_config = current_config();
+
+  GtkWidget *table = gtk_table_new(c_rowN, tablecolN, FALSE);
+  gtk_box_pack_start (GTK_BOX (vbox_top), table, FALSE, FALSE, 0);
+
+  int i;
+  for(i=0; i < wselkeyN; i++)
+  {
+    int y = i/pho_candicate_col_N;
+    int x = idx_to_x(SELEN+1, i);
+
+    if (!tsin_tail_select_key)
+      x*=2;
+
+    GtkWidget *align = gtk_alignment_new(0,0,0,0);
+    gtk_table_attach_defaults(GTK_TABLE(table),align, x,x+1,y,y+1);
+    GtkWidget *event_box_pho = gtk_event_box_new();
+    gtk_event_box_set_visible_window (GTK_EVENT_BOX(event_box_pho), FALSE);
+    GtkWidget *label = gtk_label_new(NULL);
+    gtk_container_add (GTK_CONTAINER (event_box_pho), label);
+    labels_sele[i] = label;
+    eve_sele[i] = event_box_pho;
+    gtk_container_add (GTK_CONTAINER (align), event_box_pho);
+    gtk_label_set_justify(GTK_LABEL(labels_sele[i]),GTK_JUSTIFY_LEFT);
+    set_label_font_size(labels_sele[i], hime_font_size_tsin_presel);
+    g_signal_connect(G_OBJECT(event_box_pho),"button-press-event",
+                   G_CALLBACK(mouse_button_callback), GINT_TO_POINTER(i));
+
+    if (!tsin_tail_select_key) {
+      GtkWidget *alignR = gtk_alignment_new(0,0,0,0);
+      gtk_table_attach_defaults(GTK_TABLE(table), alignR, x+1,x+2,y,y+1);
+      GtkWidget *event_box_phoR = gtk_event_box_new();
+      gtk_event_box_set_visible_window (GTK_EVENT_BOX(event_box_phoR), FALSE);
+      GtkWidget *labelR = gtk_label_new(NULL);
+      gtk_container_add (GTK_CONTAINER (event_box_phoR), labelR);
+      labels_seleR[i] = labelR;
+      eve_seleR[i] = event_box_phoR;
+      gtk_container_add (GTK_CONTAINER (alignR), event_box_phoR);
+      gtk_label_set_justify(GTK_LABEL(labels_sele[i]),GTK_JUSTIFY_LEFT);
+      set_label_font_size(labels_seleR[i], hime_font_size_tsin_presel);
+      g_signal_connect(G_OBJECT(event_box_phoR),"button-press-event",
+                     G_CALLBACK(mouse_button_callback), GINT_TO_POINTER(i));
+    }
+  }
+
+  GtkWidget *eve_box_down = gtk_event_box_new();
+  gtk_event_box_set_visible_window (GTK_EVENT_BOX(eve_box_down), FALSE);
+  gtk_box_pack_start (GTK_BOX (vbox_top), eve_box_down, FALSE, FALSE, 0);
+  arrow_down = gtk_arrow_new (GTK_ARROW_DOWN, GTK_SHADOW_IN);
+  gtk_container_add(GTK_CONTAINER(eve_box_down), arrow_down);
+  g_signal_connect (G_OBJECT (eve_box_down), "button-press-event",
+                      G_CALLBACK (cb_arrow_down), NULL);
+
+  gtk_widget_show_all(gwin1);
+//  gdk_flush();
+  gtk_widget_hide(gwin1);
+
+  change_win1_font();
+}
+
+void init_tsin_selection_win()
+{
+  create_win1();
+  create_win1_gui();
+}
+
+void clear_sele()
+{
+  int i;
+
+  if (!gwin1)
+    return;
+
+  for(i=0; i < wselkeyN; i++) {
+    gtk_widget_hide(labels_sele[i]);
+    if (labels_seleR[i])
+      gtk_widget_hide(labels_seleR[i]);
+  }
+
+  gtk_widget_hide(arrow_up);
+  gtk_widget_hide(arrow_down);
+  hide_selections_win();
+}
+
+char *htmlspecialchars(char *s, char out[]);
+
+void set_sele_text(int tN, int i, char *text, int len)
+{
+  if (len < 0)
+    len=strlen(text);
+
+  char tt[128];
+  char utf8[128];
+
+  memcpy(utf8, text, len);
+  utf8[len]=0;
+  char uu[32], selma[128];
+
+  char cc[2];
+  cc[0]=wselkey[i];
+  cc[1]=0;
+  char ul[128];
+  ul[0]=0;
+
+#if 0
+  if (tss.sel_pho && i==tss.pho_menu_idx)
+    strcpy(ul, " foreground=\"yellow\" background=\"black\"");
+  else
+    sprintf(ul, "foreground=\"%s\"", hime_sel_key_color);
+#endif
+  if (tss.sel_pho && i==tss.pho_menu_idx) {
+    if (hime_win_color_use)
+      sprintf(ul, "foreground=\"white\" background=\"%s\"", tsin_cursor_color);
+    else
+      strcpy(ul, "foreground=\"white\" background=\""TSIN_CURSOR_COLOR_DEFAULT"\"");
+  } else {
+    if (hime_win_color_use)
+      sprintf(ul, "foreground=\"%s\"", hime_sel_key_color);
+    else
+      strcpy(ul, "foreground=\""HIME_SEL_KEY_COLOR_DEFAULT"\"");
+  }
+
+  sprintf(selma, "<span %s>%s</span>", ul, htmlspecialchars(cc, uu));
+
+  int x = idx_to_x(tN, i);
+  char *sep= x?" ":"";
+
+  if (tsin_tail_select_key) {
+    char vv[128];
+    snprintf(tt, sizeof(tt), "%s%s%s", sep, htmlspecialchars(utf8, vv), selma);
+  } else {
+    gtk_label_set_text(GTK_LABEL(labels_seleR[i]), utf8);
+    gtk_widget_show(labels_seleR[i]);
+    snprintf(tt, sizeof(tt), "%s%s",sep, selma);
+  }
+
+  gtk_widget_show(labels_sele[i]);
+//  dbg("tt %s\n", tt);
+  gtk_label_set_markup(GTK_LABEL(labels_sele[i]), tt);
+}
+
+void raise_tsin_selection_win()
+{
+  if (gwin1 && GTK_WIDGET_VISIBLE(gwin1))
+    gtk_window_present(GTK_WINDOW(gwin1));
+}
+
+
+void getRootXY(Window win, int wx, int wy, int *tx, int *ty);
+void disp_selections(int x, int y)
+{
+  if (!gwin1)
+    p_err("disp_selections !gwin1");
+
+  if (y < 0) {
+	 int tx;
+	 if (hime_edit_display_ap_only())
+		getRootXY(current_CS->client_win, current_CS->spot_location.x, current_CS->spot_location.y, &tx, &y);
+	 else
+		 y = win_y + win_yl;
+  }
+
+
+  int win1_xl, win1_yl;
+  get_win_size(gwin1, &win1_xl, &win1_yl);
+
+  if (x < 0) {
+    x = win_x + win_xl - win1_xl;
+    if (x < win_x)
+      x = win_x;
+  }
+
+  if (x + win1_xl > dpy_xl)
+    x = dpy_xl - win1_xl;
+
+  if (y + win1_yl > dpy_yl)
+    y = win_y - win1_yl;
+
+  gtk_window_move(GTK_WINDOW(gwin1), x, y);
+
+  if (!GTK_WIDGET_VISIBLE(gwin1)) {
+    gtk_widget_show(gwin1);
+  }
+}
+
+void hide_selections_win()
+{
+  if (!gwin1)
+    return;
+  gtk_widget_hide(gwin1);
+}
+
+void disp_arrow_up()
+{
+  gtk_widget_show(arrow_up);
+}
+
+void disp_arrow_down()
+{
+  gtk_widget_show(arrow_down);
+}
+
+#if USE_TSIN
+void destroy_win1()
+{
+  if (!gwin1)
+    return;
+  gtk_widget_destroy(gwin1);
+  frame=NULL;
+  gwin1 = NULL;
+}
+#endif
+
+void change_win1_font()
+{
+  int i;
+  if (!frame)
+    return;
+
+  GdkColor fg;
+  gdk_color_parse(hime_win_color_fg, &fg);
+#if GTK_CHECK_VERSION(2,91,6)
+  GdkRGBA rgbfg;
+  gdk_rgba_parse(&rgbfg, gdk_color_to_string(&fg));
+#endif
+
+  for(i=0; i < wselkeyN; i++) {
+    set_label_font_size(labels_sele[i], hime_font_size_tsin_presel);
+    set_label_font_size(labels_seleR[i], hime_font_size_tsin_presel);
+#if !GTK_CHECK_VERSION(2,91,6)
+    if (labels_sele[i])
+      gtk_widget_modify_fg(labels_sele[i], GTK_STATE_NORMAL, hime_win_color_use?&fg:NULL);
+    if (labels_seleR[i])
+      gtk_widget_modify_fg(labels_seleR[i], GTK_STATE_NORMAL, hime_win_color_use?&fg:NULL);
+#else
+    if (labels_sele[i])
+      gtk_widget_override_color(labels_sele[i], GTK_STATE_FLAG_NORMAL, hime_win_color_use?&rgbfg:NULL);
+    if (labels_seleR[i])
+      gtk_widget_override_color(labels_seleR[i], GTK_STATE_FLAG_NORMAL, hime_win_color_use?&rgbfg:NULL);
+#endif
+    change_win_bg(eve_sele[i]);
+    if (eve_seleR[i])
+      change_win_bg(eve_seleR[i]);
+  }
+
+  change_win_bg(gwin1);
+}
+
+void recreate_win1_if_nessary()
+{
+//  dbg("%x %x\n", current_config(), c_config);
+
+  if (!gwin1)
+    return;
+
+  if (current_config() != c_config) {
+    c_config = current_config();
+//    dbg("destroy frame\n");
+    bzero(labels_sele, sizeof(labels_sele));
+    bzero(labels_seleR, sizeof(labels_seleR));
+    bzero(eve_sele, sizeof(eve_sele));
+    bzero(eve_seleR, sizeof(eve_seleR));
+    gtk_widget_destroy(frame); frame = NULL;
+    create_win1_gui();
+  }
+}
+
+
+void set_wselkey(char *s)
+{
+  if (strcmp (wselkey, s))
+  {
+    memset (wselkey, 0x00, 16);
+    memcpy (wselkey, s, strlen (s));
+    wselkeyN = strlen (s);
+    recreate_win1_if_nessary ();
+  }
+}
diff --git a/src/plugins/platforminputcontexts/hime/include/win1.h b/src/plugins/platforminputcontexts/hime/include/win1.h
new file mode 100644
index 0000000..1907861
--- /dev/null
+++ b/src/plugins/platforminputcontexts/hime/include/win1.h
@@ -0,0 +1,3 @@
+typedef void (*cb_selec_by_idx_t)(int);
+typedef void (*cb_page_ud_t)();
+void set_win1_cb(cb_selec_by_idx_t selc_by_idx, cb_page_ud_t cb_page_up, cb_page_ud_t cb_page_down);
diff --git a/src/plugins/platforminputcontexts/platforminputcontexts.pro b/src/plugins/platforminputcontexts/platforminputcontexts.pro
index faea54b..0f96509 100644
--- a/src/plugins/platforminputcontexts/platforminputcontexts.pro
+++ b/src/plugins/platforminputcontexts/platforminputcontexts.pro
@@ -1,7 +1,8 @@
 TEMPLATE = subdirs
 
 qtHaveModule(dbus) {
-!mac:!win32:SUBDIRS += ibus
+# Patch: Adding fcitx/hime input context plugin to our static build.
+!mac:!win32:SUBDIRS += ibus fcitx hime
 }
 
 contains(QT_CONFIG, xcb-plugin): SUBDIRS += compose
diff --git a/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.mm b/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.mm
index caa8884..9dc3bc1 100644
--- a/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.mm
+++ b/src/plugins/platforms/cocoa/qcocoaapplicationdelegate.mm
@@ -210,7 +210,8 @@ QT_END_NAMESPACE
     if (reflectionDelegate) {
         if ([reflectionDelegate respondsToSelector:@selector(applicationShouldTerminate:)])
             return [reflectionDelegate applicationShouldTerminate:sender];
-        return NSTerminateNow;
+        // Patch: Don't terminate if reflectionDelegate does not respond to that selector, just use the default.
+        //return NSTerminateNow;
     }
 
     if ([self canQuit]) {
@@ -287,11 +288,15 @@ QT_END_NAMESPACE
 
 - (void)applicationDidFinishLaunching:(NSNotification *)aNotification
 {
+    // Patch: We need to catch that notification in delegate.
+    if (reflectionDelegate
+        && [reflectionDelegate respondsToSelector:@selector(applicationDidFinishLaunching:)])
+        [reflectionDelegate applicationDidFinishLaunching:aNotification];
+
     Q_UNUSED(aNotification);
     inLaunch = false;
     // qt_release_apple_event_handler();
 
-
     // Insert code here to initialize your application
 }
 
diff --git a/src/plugins/platforms/cocoa/qcocoabackingstore.h b/src/plugins/platforms/cocoa/qcocoabackingstore.h
index 934f68a..3ece698 100644
--- a/src/plugins/platforms/cocoa/qcocoabackingstore.h
+++ b/src/plugins/platforms/cocoa/qcocoabackingstore.h
@@ -64,6 +64,9 @@ public:
 private:
     QImage m_qImage;
     QSize m_requestedSize;
+
+    // Patch: Optimize redraw - don't clear image if it will be fully redrawn.
+    bool m_qImageNeedsClear;
 };
 
 QT_END_NAMESPACE
diff --git a/src/plugins/platforms/cocoa/qcocoabackingstore.mm b/src/plugins/platforms/cocoa/qcocoabackingstore.mm
index ca92103..f27ea15 100644
--- a/src/plugins/platforms/cocoa/qcocoabackingstore.mm
+++ b/src/plugins/platforms/cocoa/qcocoabackingstore.mm
@@ -38,7 +38,8 @@
 QT_BEGIN_NAMESPACE
 
 QCocoaBackingStore::QCocoaBackingStore(QWindow *window)
-    : QPlatformBackingStore(window)
+    // Patch: Optimize redraw - don't clear image if it will be fully redrawn.
+    : QPlatformBackingStore(window), m_qImageNeedsClear(false)
 {
 }
 
@@ -59,9 +60,12 @@ QPaintDevice *QCocoaBackingStore::paintDevice()
     if (m_qImage.size() != effectiveBufferSize) {
         QImage::Format format = (window()->format().hasAlpha() || cocoaWindow->m_drawContentBorderGradient)
                 ? QImage::Format_ARGB32_Premultiplied : QImage::Format_RGB32;
+
+        // Patch: Optimize redraw - don't clear image if it will be fully redrawn.
+        m_qImageNeedsClear = window()->requestedFormat().hasAlpha() || cocoaWindow->m_drawContentBorderGradient;
         m_qImage = QImage(effectiveBufferSize, format);
         m_qImage.setDevicePixelRatio(windowDevicePixelRatio);
-        if (format == QImage::Format_ARGB32_Premultiplied)
+        if (m_qImageNeedsClear)
             m_qImage.fill(Qt::transparent);
     }
     return &m_qImage;
@@ -100,7 +104,8 @@ bool QCocoaBackingStore::scroll(const QRegion &area, int dx, int dy)
 
 void QCocoaBackingStore::beginPaint(const QRegion &region)
 {
-    if (m_qImage.hasAlphaChannel()) {
+    // Patch: Optimize redraw - don't clear image if it will be fully redrawn.
+    if (m_qImageNeedsClear && m_qImage.hasAlphaChannel()) {
         QPainter p(&m_qImage);
         p.setCompositionMode(QPainter::CompositionMode_Source);
         const QVector<QRect> rects = region.rects();
diff --git a/src/plugins/platforms/cocoa/qcocoakeymapper.mm b/src/plugins/platforms/cocoa/qcocoakeymapper.mm
index c2d206f..9b97398 100644
--- a/src/plugins/platforms/cocoa/qcocoakeymapper.mm
+++ b/src/plugins/platforms/cocoa/qcocoakeymapper.mm
@@ -384,6 +384,12 @@ bool QCocoaKeyMapper::updateKeyboard()
         keyboardInputLocale = QLocale::c();
         keyboardInputDirection = Qt::LeftToRight;
     }
+
+    // Patch: Fix layout-independent global shortcuts.
+    const auto newMode = keyboard_mode;
+    deleteLayouts();
+    keyboard_mode = newMode;
+
     return true;
 }
 
@@ -466,7 +472,8 @@ QList<int> QCocoaKeyMapper::possibleKeys(const QKeyEvent *event) const
         Qt::KeyboardModifiers neededMods = ModsTbl[i];
         int key = kbItem->qtKey[i];
         if (key && key != baseKey && ((keyMods & neededMods) == neededMods)) {
-            ret << int(key + (keyMods & ~neededMods));
+            // Patch: Fix layout-independent global shortcuts.
+            ret << int(key + neededMods);
         }
     }
     return ret;
diff --git a/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm b/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm
index 8152c57..5ddd7b3 100644
--- a/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm
+++ b/src/plugins/platforms/cocoa/qcocoasystemtrayicon.mm
@@ -94,6 +94,8 @@ QT_USE_NAMESPACE
     QCocoaSystemTrayIcon *systray;
     NSStatusItem *item;
     QCocoaMenu *menu;
+    // Patch: Create a rich os x tray icon (pixel-perfect, theme switching).
+    bool menuVisible, iconSelected;
     QIcon icon;
     QT_MANGLE_NAMESPACE(QNSImageView) *imageCell;
 }
@@ -197,7 +199,9 @@ void QCocoaSystemTrayIcon::updateIcon(const QIcon &icon)
     // (device independent pixels). The menu height on past and
     // current OS X versions is 22 points. Provide some future-proofing
     // by deriving the icon height from the menu height.
-    const int padding = 4;
+
+    // Patch: Create a rich os x tray icon (pixel-perfect, theme switching).
+    const int padding = 0;
     const int menuHeight = [[NSStatusBar systemStatusBar] thickness];
     const int maxImageHeight = menuHeight - padding;
 
@@ -207,8 +211,11 @@ void QCocoaSystemTrayIcon::updateIcon(const QIcon &icon)
     // devicePixelRatio for the "best" screen on the system.
     qreal devicePixelRatio = qApp->devicePixelRatio();
     const int maxPixmapHeight = maxImageHeight * devicePixelRatio;
+
+    // Patch: Create a rich os x tray icon (pixel-perfect, theme switching).
+    const QIcon::Mode mode = m_sys->item->iconSelected ? QIcon::Selected : QIcon::Normal;
     QSize selectedSize;
-    Q_FOREACH (const QSize& size, sortByHeight(icon.availableSizes())) {
+    Q_FOREACH (const QSize& size, sortByHeight(icon.availableSizes(mode))) {
         // Select a pixmap based on the height. We want the largest pixmap
         // with a height smaller or equal to maxPixmapHeight. The pixmap
         // may rectangular; assume it has a reasonable size. If there is
@@ -224,9 +231,9 @@ void QCocoaSystemTrayIcon::updateIcon(const QIcon &icon)
 
     // Handle SVG icons, which do not return anything for availableSizes().
     if (!selectedSize.isValid())
-        selectedSize = icon.actualSize(QSize(maxPixmapHeight, maxPixmapHeight));
+        selectedSize = icon.actualSize(QSize(maxPixmapHeight, maxPixmapHeight), mode);
 
-    QPixmap pixmap = icon.pixmap(selectedSize);
+    QPixmap pixmap = icon.pixmap(selectedSize, mode);
 
     // Draw a low-resolution icon if there is not enough pixels for a retina
     // icon. This prevents showing a small icon on retina displays.
@@ -374,6 +381,11 @@ QT_END_NAMESPACE
     Q_UNUSED(notification);
     down = NO;
 
+    // Patch: Create a rich os x tray icon (pixel-perfect, theme switching).
+    parent->iconSelected = false;
+    parent->systray->updateIcon(parent->icon);
+    parent->menuVisible = false;
+
     [self setNeedsDisplay:YES];
 }
 
@@ -383,6 +395,10 @@ QT_END_NAMESPACE
     int clickCount = [mouseEvent clickCount];
     [self setNeedsDisplay:YES];
 
+    // Patch: Create a rich os x tray icon (pixel-perfect, theme switching).
+    parent->iconSelected = (clickCount != 2) && parent->menu;
+    parent->systray->updateIcon(parent->icon);
+
     if (clickCount == 2) {
         [self menuTrackingDone:nil];
         [parent doubleClickSelector:self];
@@ -399,6 +415,11 @@ QT_END_NAMESPACE
 -(void)mouseUp:(NSEvent *)mouseEvent
 {
     Q_UNUSED(mouseEvent);
+
+    // Patch: Create a rich os x tray icon (pixel-perfect, theme switching).
+    parent->iconSelected = false;
+    parent->systray->updateIcon(parent->icon);
+
     [self menuTrackingDone:nil];
 }
 
@@ -410,6 +431,11 @@ QT_END_NAMESPACE
 -(void)rightMouseUp:(NSEvent *)mouseEvent
 {
     Q_UNUSED(mouseEvent);
+
+    // Patch: Create a rich os x tray icon (pixel-perfect, theme switching).
+    parent->iconSelected = false;
+    parent->systray->updateIcon(parent->icon);
+
     [self menuTrackingDone:nil];
 }
 
@@ -425,7 +451,8 @@ QT_END_NAMESPACE
 }
 
 -(void)drawRect:(NSRect)rect {
-    [[parent item] drawStatusBarBackgroundInRect:rect withHighlight:down];
+    // Patch: Create a rich os x tray icon (pixel-perfect, theme switching).
+    [[parent item] drawStatusBarBackgroundInRect:rect withHighlight:parent->menu ? down : NO];
     [super drawRect:rect];
 }
 @end
@@ -438,6 +465,10 @@ QT_END_NAMESPACE
     if (self) {
         item = [[[NSStatusBar systemStatusBar] statusItemWithLength:NSSquareStatusItemLength] retain];
         menu = 0;
+
+        // Patch: Create a rich os x tray icon (pixel-perfect, theme switching).
+        menuVisible = false;
+
         systray = sys;
         imageCell = [[QNSImageView alloc] initWithParent:self];
         [item setView: imageCell];
@@ -482,6 +513,10 @@ QT_END_NAMESPACE
          selector:@selector(menuTrackingDone:)
              name:NSMenuDidEndTrackingNotification
                  object:m];
+
+        // Patch: Create a rich os x tray icon (pixel-perfect, theme switching).
+        menuVisible = true;
+
         [item popUpStatusItemMenu: m];
     }
 }
diff --git a/src/plugins/platforms/cocoa/qcocoawindow.mm b/src/plugins/platforms/cocoa/qcocoawindow.mm
index c0d5904..f3c2047 100644
--- a/src/plugins/platforms/cocoa/qcocoawindow.mm
+++ b/src/plugins/platforms/cocoa/qcocoawindow.mm
@@ -141,7 +141,8 @@ static bool isMouseEvent(NSEvent *ev)
     if (!self.window.delegate)
         return; // Already detached, pending NSAppKitDefined event
 
-    if (pw && pw->frameStrutEventsEnabled() && isMouseEvent(theEvent)) {
+    // Patch: Fix restore after minimize or close by window buttons.
+    if (pw && pw->frameStrutEventsEnabled() && pw->m_synchedWindowState != Qt::WindowMinimized && pw->m_isExposed && isMouseEvent(theEvent)) {
         NSPoint loc = [theEvent locationInWindow];
         NSRect windowFrame = [self.window convertRectFromScreen:[self.window frame]];
         NSRect contentFrame = [[self.window contentView] frame];
@@ -811,6 +812,16 @@ NSUInteger QCocoaWindow::windowStyleMask(Qt::WindowFlags flags)
 {
     Qt::WindowType type = static_cast<Qt::WindowType>(int(flags & Qt::WindowType_Mask));
     NSInteger styleMask = NSBorderlessWindowMask;
+
+    // Patch: allow creating panels floating on all spaces in macOS.
+    // If you call "setCollectionBehavior:NSWindowCollectionBehaviorFullScreenAuxiliary" before
+    // setting the "NSNonactivatingPanelMask" bit in the style mask it won't work after that.
+    // So we need a way to set that bit before Qt sets collection behavior the way it does.
+    QVariant nonactivatingPanelMask = window()->property("_td_macNonactivatingPanelMask");
+    if (nonactivatingPanelMask.isValid() && nonactivatingPanelMask.toBool()) {
+        styleMask |= NSNonactivatingPanelMask;
+    }
+
     if (flags & Qt::FramelessWindowHint)
         return styleMask;
     if ((type & Qt::Popup) == Qt::Popup) {
@@ -943,6 +954,19 @@ void QCocoaWindow::setWindowFilePath(const QString &filePath)
     [m_nsWindow setRepresentedFilename: fi.exists() ? QCFString::toNSString(filePath) : @""];
 }
 
+// Patch: Create a good os x window icon (pixel-perfect).
+namespace {
+
+qreal getDevicePixelRatio() {
+    qreal result = 1.0;
+    foreach (QScreen *screen, QGuiApplication::screens()) {
+        result = qMax(result, screen->devicePixelRatio());
+    }
+    return result;
+}
+
+} // namespace
+
 void QCocoaWindow::setWindowIcon(const QIcon &icon)
 {
     QMacAutoReleasePool pool;
@@ -958,7 +982,9 @@ void QCocoaWindow::setWindowIcon(const QIcon &icon)
     if (icon.isNull()) {
         [iconButton setImage:nil];
     } else {
-        QPixmap pixmap = icon.pixmap(QSize(22, 22));
+        // Patch: Create a good os x window icon (pixel-perfect).
+        CGFloat hgt = 16. * getDevicePixelRatio();
+        QPixmap pixmap = icon.pixmap(QSize(hgt, hgt));
         NSImage *image = static_cast<NSImage *>(qt_mac_create_nsimage(pixmap));
         [iconButton setImage:image];
         [image release];
diff --git a/src/plugins/platforms/cocoa/qnsview.mm b/src/plugins/platforms/cocoa/qnsview.mm
index c67bcfd..4498a17 100644
--- a/src/plugins/platforms/cocoa/qnsview.mm
+++ b/src/plugins/platforms/cocoa/qnsview.mm
@@ -1431,7 +1431,9 @@ static QTabletEvent::TabletDevice wacomTabletDevice(NSEvent *theEvent)
 #if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_8
     if (QSysInfo::QSysInfo::MacintoshVersion >= QSysInfo::MV_10_8) {
         // On 10.8 and above, MayBegin is likely to happen.  We treat it the same as an actual begin.
-        if (phase == NSEventPhaseMayBegin) {
+
+        // Patch: Fix actual begin handle of swipe on trackpad.
+        if (phase == NSEventPhaseMayBegin || phase == NSEventPhaseBegan) {
             m_scrolling = true;
             ph = Qt::ScrollBegin;
         }
@@ -1496,14 +1498,14 @@ static QTabletEvent::TabletDevice wacomTabletDevice(NSEvent *theEvent)
     quint32 nativeVirtualKey = [nsevent keyCode];
 
     QChar ch = QChar::ReplacementCharacter;
-    int keyCode = Qt::Key_unknown;
-    if ([characters length] != 0) {
-        if (((modifiers & Qt::MetaModifier) || (modifiers & Qt::AltModifier)) && ([charactersIgnoringModifiers length] != 0))
-            ch = QChar([charactersIgnoringModifiers characterAtIndex:0]);
-        else
-            ch = QChar([characters characterAtIndex:0]);
-        keyCode = [self convertKeyCode:ch];
-    }
+
+    // Patch: Fix Alt+.. shortcuts in OS X. See https://bugreports.qt.io/browse/QTBUG-42584 at the end.
+    if ([characters length] != 0)
+        ch = QChar([characters characterAtIndex:0]);
+    else if ([charactersIgnoringModifiers length] != 0 && ((modifiers & Qt::MetaModifier) || (modifiers & Qt::AltModifier)))
+        ch = QChar([charactersIgnoringModifiers characterAtIndex:0]);
+
+    int keyCode = [self convertKeyCode:ch];
 
     // we will send a key event unless the input method sets m_sendKeyEvent to false
     m_sendKeyEvent = true;
@@ -1569,6 +1571,23 @@ static QTabletEvent::TabletDevice wacomTabletDevice(NSEvent *theEvent)
     [self handleKeyEvent:nsevent eventType:int(QEvent::KeyRelease)];
 }
 
+// Patch: Enable Ctrl+Tab and Ctrl+Shift+Tab / Ctrl+Backtab handle in-app.
+- (BOOL)performKeyEquivalent:(NSEvent *)nsevent
+{
+    NSString *chars = [nsevent charactersIgnoringModifiers];
+
+    if ([nsevent type] == NSKeyDown && [chars length] > 0) {
+        QChar ch = [chars characterAtIndex:0];
+        Qt::Key qtKey = qt_mac_cocoaKey2QtKey(ch);
+        if ([nsevent modifierFlags] & NSControlKeyMask
+                && (qtKey == Qt::Key_Tab || qtKey == Qt::Key_Backtab)) {
+            [self handleKeyEvent:nsevent eventType:int(QEvent::KeyPress)];
+            return YES;
+        }
+    }
+    return [super performKeyEquivalent:nsevent];
+}
+
 - (void)cancelOperation:(id)sender
 {
     Q_UNUSED(sender);
diff --git a/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp b/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
index 94bb71e..16ab51e 100644
--- a/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
+++ b/src/plugins/platforms/windows/qwindowsdialoghelpers.cpp
@@ -716,12 +716,20 @@ public:
     void setSelectedFiles(const QList<QUrl> &);
     QString selectedFile() const;
 
+    // Patch: Adding select-by-url for Windows file dialog.
+    void setSelectedRemoteContent(const QByteArray &);
+    QByteArray selectedRemoteContent() const;
+
 private:
     class Data : public QSharedData {
     public:
         QUrl directory;
         QString selectedNameFilter;
         QList<QUrl> selectedFiles;
+
+        // Patch: Adding select-by-url for Windows file dialog.
+        QByteArray selectedRemoteContent;
+
         QMutex mutex;
     };
     QExplicitlySharedDataPointer<Data> m_data;
@@ -775,6 +783,21 @@ inline void QWindowsFileDialogSharedData::setSelectedFiles(const QList<QUrl> &ur
     m_data->selectedFiles = urls;
 }
 
+// Patch: Adding select-by-url for Windows file dialog.
+inline QByteArray QWindowsFileDialogSharedData::selectedRemoteContent() const
+{
+    m_data->mutex.lock();
+    const QByteArray result = m_data->selectedRemoteContent;
+    m_data->mutex.unlock();
+    return result;
+}
+
+inline void QWindowsFileDialogSharedData::setSelectedRemoteContent(const QByteArray &c)
+{
+    QMutexLocker(&m_data->mutex);
+    m_data->selectedRemoteContent = c;
+}
+
 inline void QWindowsFileDialogSharedData::fromOptions(const QSharedPointer<QFileDialogOptions> &o)
 {
     QMutexLocker locker(&m_data->mutex);
@@ -899,6 +922,9 @@ public:
     // example by appended default suffixes, etc.
     virtual QList<QUrl> dialogResult() const = 0;
 
+    // Patch: Adding select-by-url for Windows file dialog.
+    virtual QByteArray dialogRemoteContent() const { return QByteArray(); }
+
     inline void onFolderChange(IShellItem *);
     inline void onSelectionChange();
     inline void onTypeChange();
@@ -1338,7 +1364,14 @@ void QWindowsNativeFileDialogBase::selectFile(const QString &fileName) const
     // Hack to prevent CLSIDs from being set as file name due to
     // QFileDialogPrivate::initialSelection() being QString-based.
     if (!isClsid(fileName))
-        m_fileDialog->SetFileName((wchar_t*)fileName.utf16());
+    // Patch: Fix handle of full fileName.
+    {
+        QString file = QDir::toNativeSeparators(fileName);
+        int lastBackSlash = file.lastIndexOf(QChar::fromLatin1('\\'));
+        if (lastBackSlash >= 0)
+            file = file.mid(lastBackSlash + 1);
+        m_fileDialog->SetFileName((wchar_t*)file.utf16());;
+    }
 }
 
 // Return the index of the selected filter, accounting for QFileDialog
@@ -1408,6 +1441,10 @@ bool QWindowsNativeFileDialogBase::onFileOk()
 {
     // Store selected files as GetResults() returns invalid data after the dialog closes.
     m_data.setSelectedFiles(dialogResult());
+
+    // Patch: Adding select-by-url for Windows file dialog.
+    m_data.setSelectedRemoteContent(dialogRemoteContent());
+
     return true;
 }
 
@@ -1542,6 +1579,9 @@ public:
     QList<QUrl> selectedFiles() const Q_DECL_OVERRIDE;
     QList<QUrl> dialogResult() const Q_DECL_OVERRIDE;
 
+    // Patch: Adding select-by-url for Windows file dialog.
+    QByteArray dialogRemoteContent() const Q_DECL_OVERRIDE;
+
 private:
     inline IFileOpenDialog *openFileDialog() const
         { return static_cast<IFileOpenDialog *>(fileDialog()); }
@@ -1556,6 +1596,62 @@ QList<QUrl> QWindowsNativeOpenFileDialog::dialogResult() const
     return result;
 }
 
+// Patch: Adding select-by-url for Windows file dialog.
+QByteArray QWindowsNativeOpenFileDialog::dialogRemoteContent() const
+{
+    QByteArray result;
+    IShellItemArray *items = 0;
+    if (FAILED(openFileDialog()->GetResults(&items)) || !items)
+        return result;
+    DWORD itemCount = 0;
+    if (FAILED(items->GetCount(&itemCount)) || !itemCount)
+        return result;
+    for (DWORD i = 0; i < itemCount; ++i)
+    {
+        IShellItem *item = 0;
+        if (SUCCEEDED(items->GetItemAt(i, &item))) {
+            SFGAOF attributes = 0;
+            // Check whether it has a file system representation?
+            if (FAILED(item->GetAttributes(SFGAO_FILESYSTEM, &attributes)) || (attributes & SFGAO_FILESYSTEM))
+            {
+                LPWSTR name = 0;
+                if (SUCCEEDED(item->GetDisplayName(SIGDN_FILESYSPATH, &name)))
+                {
+                    CoTaskMemFree(name);
+                    continue;
+                }
+            }
+            if (FAILED(item->GetAttributes(SFGAO_STREAM, &attributes)) || !(attributes & SFGAO_STREAM))
+                continue;
+
+            IBindCtx *bind = 0;
+            if (FAILED(CreateBindCtx(0, &bind)))
+                continue;
+
+            IStream *stream = 0;
+            if (FAILED(item->BindToHandler(bind, BHID_Stream, IID_IStream, reinterpret_cast<void **>(&stream))))
+                continue;
+
+            STATSTG stat = { 0 };
+            if (FAILED(stream->Stat(&stat, STATFLAG_NONAME)) || !stat.cbSize.QuadPart)
+                continue;
+
+            quint64 fullSize = stat.cbSize.QuadPart;
+            if (fullSize <= 64 * 1024 * 1024)
+            {
+                result.resize(fullSize);
+                ULONG read = 0;
+                HRESULT r = stream->Read(result.data(), fullSize, &read);
+                if (r == S_FALSE || r == S_OK)
+                    return result;
+
+                result.clear();
+            }
+        }
+    }
+    return result;
+}
+
 QList<QUrl> QWindowsNativeOpenFileDialog::selectedFiles() const
 {
     QList<QUrl> result;
@@ -1614,6 +1710,10 @@ public:
     virtual QUrl directory() const Q_DECL_OVERRIDE;
     virtual void selectFile(const QUrl &filename) Q_DECL_OVERRIDE;
     virtual QList<QUrl> selectedFiles() const Q_DECL_OVERRIDE;
+
+    // Patch: Adding select-by-url for Windows file dialog.
+    virtual QByteArray selectedRemoteContent() const Q_DECL_OVERRIDE;
+
     virtual void setFilter() Q_DECL_OVERRIDE;
     virtual void selectNameFilter(const QString &filter) Q_DECL_OVERRIDE;
     virtual QString selectedNameFilter() const Q_DECL_OVERRIDE;
@@ -1707,6 +1807,12 @@ QList<QUrl> QWindowsFileDialogHelper::selectedFiles() const
     return m_data.selectedFiles();
 }
 
+// Patch: Adding select-by-url for Windows file dialog.
+QByteArray QWindowsFileDialogHelper::selectedRemoteContent() const
+{
+    return m_data.selectedRemoteContent();
+}
+
 void QWindowsFileDialogHelper::setFilter()
 {
     qCDebug(lcQpaDialogs) << __FUNCTION__;
@@ -1996,6 +2102,10 @@ public:
     QUrl directory() const Q_DECL_OVERRIDE;
     void selectFile(const QUrl &url) Q_DECL_OVERRIDE;
     QList<QUrl> selectedFiles() const Q_DECL_OVERRIDE;
+
+    // Patch: Adding select-by-url for Windows file dialog.
+    QByteArray selectedRemoteContent() const Q_DECL_OVERRIDE;
+
     void setFilter() Q_DECL_OVERRIDE {}
     void selectNameFilter(const QString &) Q_DECL_OVERRIDE;
     QString selectedNameFilter() const Q_DECL_OVERRIDE;
@@ -2039,6 +2149,12 @@ QList<QUrl> QWindowsXpFileDialogHelper::selectedFiles() const
     return m_data.selectedFiles();
 }
 
+// Patch: Adding select-by-url for Windows file dialog.
+QByteArray QWindowsXpFileDialogHelper::selectedRemoteContent() const
+{
+    return m_data.selectedRemoteContent();
+}
+
 void QWindowsXpFileDialogHelper::selectNameFilter(const QString &f)
 {
     m_data.setSelectedNameFilter(f); // Dialog cannot be updated at run-time.
diff --git a/src/plugins/platforms/windows/qwindowskeymapper.cpp b/src/plugins/platforms/windows/qwindowskeymapper.cpp
index 1e58b9b..1741c21 100644
--- a/src/plugins/platforms/windows/qwindowskeymapper.cpp
+++ b/src/plugins/platforms/windows/qwindowskeymapper.cpp
@@ -1268,6 +1268,10 @@ QList<int> QWindowsKeyMapper::possibleKeys(const QKeyEvent *e) const
     if (nativeVirtualKey > 255)
         return result;
 
+    // Patch: This must not happen, but there are crash reports on the next line.
+    if (e->nativeVirtualKey() > 0xFF)
+        return result;
+
     const KeyboardLayoutItem &kbItem = keyLayout[nativeVirtualKey];
     if (!kbItem.exists)
         return result;
diff --git a/src/plugins/platforms/windows/qwindowsservices.cpp b/src/plugins/platforms/windows/qwindowsservices.cpp
index 1d23a9d..640cd42 100644
--- a/src/plugins/platforms/windows/qwindowsservices.cpp
+++ b/src/plugins/platforms/windows/qwindowsservices.cpp
@@ -127,6 +127,10 @@ static inline bool launchMail(const QUrl &url)
             command.prepend(doubleQuote);
         }
     }
+
+    // Patch: Fix mail launch if no param is expected in this command.
+    if (command.indexOf(QStringLiteral("%1")) < 0) return false;
+
     // Pass the url as the parameter. Should use QProcess::startDetached(),
     // but that cannot handle a Windows command line [yet].
     command.replace(QStringLiteral("%1"), url.toString(QUrl::FullyEncoded));
diff --git a/src/plugins/platforms/windows/qwindowswindow.cpp b/src/plugins/platforms/windows/qwindowswindow.cpp
index b38d7c2..34f19c4 100644
--- a/src/plugins/platforms/windows/qwindowswindow.cpp
+++ b/src/plugins/platforms/windows/qwindowswindow.cpp
@@ -1020,7 +1020,8 @@ void QWindowsWindow::destroyWindow()
         // Clear any transient child relationships as Windows will otherwise destroy them (QTBUG-35499, QTBUG-36666)
         if (QWindow *transientChild = findTransientChild(window()))
             if (QWindowsWindow *tw = QWindowsWindow::baseWindowOf(transientChild))
-                tw->updateTransientParent();
+                // Patch: Fix possibility of add / remove taskbar icon of the window.
+                tw->clearTransientParent();
         QWindowsContext *context = QWindowsContext::instance();
         if (context->windowUnderMouse() == window())
             context->clearWindowUnderMouse();
@@ -1235,6 +1236,21 @@ void QWindowsWindow::updateTransientParent() const
         if (const QWindowsWindow *tw = QWindowsWindow::baseWindowOf(tp))
             if (!tw->testFlag(WithinDestroy)) // Prevent destruction by parent window (QTBUG-35499, QTBUG-36666)
                 newTransientParent = tw->handle();
+    // Patch: Fix possibility of add / remove taskbar icon of the window.
+    if (newTransientParent && newTransientParent != oldTransientParent)
+        SetWindowLongPtr(m_data.hwnd, GWL_HWNDPARENT, (LONG_PTR)newTransientParent);
+#endif // !Q_OS_WINCE
+}
+
+// Patch: Fix possibility of add / remove taskbar icon of the window.
+void QWindowsWindow::clearTransientParent() const
+{
+#ifndef Q_OS_WINCE
+    if (window()->type() == Qt::Popup)
+        return; // QTBUG-34503, // a popup stays on top, no parent, see also WindowCreationData::fromWindow().
+    // Update transient parent.
+    const HWND oldTransientParent = transientParentHwnd(m_data.hwnd);
+    HWND newTransientParent = 0;
     if (newTransientParent != oldTransientParent)
         SetWindowLongPtr(m_data.hwnd, GWL_HWNDPARENT, (LONG_PTR)newTransientParent);
 #endif // !Q_OS_WINCE
@@ -1448,10 +1464,14 @@ void QWindowsWindow::handleResized(int wParam)
         handleGeometryChange();
         break;
     case SIZE_RESTORED:
-        if (isFullScreen_sys())
-            handleWindowStateChange(Qt::WindowFullScreen);
-        else if (m_windowState != Qt::WindowNoState && !testFlag(MaximizeToFullScreen))
+        // Patch: When resolution is changed for a frameless fullscreen widget
+        // handleWindowStateChange call prevents correct geometry get in handleGeometryChange().
+        if (isFullScreen_sys()) {
+            if (m_windowState != Qt::WindowFullScreen)
+                handleWindowStateChange(Qt::WindowFullScreen);
+        } else if (m_windowState != Qt::WindowNoState && !testFlag(MaximizeToFullScreen)) {
             handleWindowStateChange(Qt::WindowNoState);
+        }
         handleGeometryChange();
         break;
     }
diff --git a/src/plugins/platforms/windows/qwindowswindow.h b/src/plugins/platforms/windows/qwindowswindow.h
index 6fffa1e..cb1c9c1 100644
--- a/src/plugins/platforms/windows/qwindowswindow.h
+++ b/src/plugins/platforms/windows/qwindowswindow.h
@@ -265,6 +265,10 @@ private:
     inline void setWindowState_sys(Qt::WindowState newState);
     inline void setParent_sys(const QPlatformWindow *parent);
     inline void updateTransientParent() const;
+
+    // Patch: Fix possibility of add / remove taskbar icon of the window.
+    inline void clearTransientParent() const;
+
     void destroyWindow();
     inline bool isDropSiteEnabled() const { return m_dropTarget != 0; }
     void setDropSiteEnabled(bool enabled);
diff --git a/src/plugins/platforms/xcb/qxcbnativeinterface.cpp b/src/plugins/platforms/xcb/qxcbnativeinterface.cpp
index 09e7ecf..c0f15a4 100644
--- a/src/plugins/platforms/xcb/qxcbnativeinterface.cpp
+++ b/src/plugins/platforms/xcb/qxcbnativeinterface.cpp
@@ -79,7 +79,10 @@ static int resourceType(const QByteArray &key)
         QByteArrayLiteral("rootwindow"),
         QByteArrayLiteral("subpixeltype"), QByteArrayLiteral("antialiasingenabled"),
         QByteArrayLiteral("nofonthinting"),
-        QByteArrayLiteral("atspibus")
+        QByteArrayLiteral("atspibus"),
+
+        // Patch: Backport compositing manager check from Qt 5.7
+        QByteArrayLiteral("compositingenabled")
     };
     const QByteArray *end = names + sizeof(names) / sizeof(names[0]);
     const QByteArray *result = std::find(names, end, key);
@@ -252,6 +255,13 @@ void *QXcbNativeInterface::nativeResourceForScreen(const QByteArray &resourceStr
     case RootWindow:
         result = reinterpret_cast<void *>(xcbScreen->root());
         break;
+
+    // Patch: Backport compositing manager check from Qt 5.7
+    case CompositingEnabled:
+        if (QXcbVirtualDesktop *vd = xcbScreen->virtualDesktop())
+            result = vd->compositingActive() ? this : Q_NULLPTR;
+        break;
+
     default:
         break;
     }
diff --git a/src/plugins/platforms/xcb/qxcbnativeinterface.h b/src/plugins/platforms/xcb/qxcbnativeinterface.h
index f88b710..6f818a5 100644
--- a/src/plugins/platforms/xcb/qxcbnativeinterface.h
+++ b/src/plugins/platforms/xcb/qxcbnativeinterface.h
@@ -68,7 +68,10 @@ public:
         ScreenSubpixelType,
         ScreenAntialiasingEnabled,
         NoFontHinting,
-        AtspiBus
+        AtspiBus,
+
+        // Patch: Backport compositing manager check from Qt 5.7
+        CompositingEnabled
     };
 
     QXcbNativeInterface();
diff --git a/src/widgets/dialogs/qfiledialog.cpp b/src/widgets/dialogs/qfiledialog.cpp
index bc2de89..aa8f8df 100644
--- a/src/widgets/dialogs/qfiledialog.cpp
+++ b/src/widgets/dialogs/qfiledialog.cpp
@@ -1200,6 +1200,15 @@ QList<QUrl> QFileDialogPrivate::userSelectedFiles() const
     return files;
 }
 
+// Patch: Adding select-by-url for Windows file dialog.
+QByteArray QFileDialogPrivate::userSelectedRemoteContent() const
+{
+    if (nativeDialogInUse)
+        return selectedRemoteContent_sys();
+
+    return QByteArray();
+}
+
 QStringList QFileDialogPrivate::addDefaultSuffixToFiles(const QStringList &filesToFix) const
 {
     QStringList files;
@@ -1267,6 +1276,14 @@ QStringList QFileDialog::selectedFiles() const
     return files;
 }
 
+// Patch: Adding select-by-url for Windows file dialog.
+QByteArray QFileDialog::selectedRemoteContent() const
+{
+    Q_D(const QFileDialog);
+
+    return d->userSelectedRemoteContent();
+}
+
 /*!
     Returns a list of urls containing the selected files in the dialog.
     If no files are selected, or the mode is not ExistingFiles or
diff --git a/src/widgets/dialogs/qfiledialog.h b/src/widgets/dialogs/qfiledialog.h
index ffe49a2..42dc563 100644
--- a/src/widgets/dialogs/qfiledialog.h
+++ b/src/widgets/dialogs/qfiledialog.h
@@ -108,6 +108,9 @@ public:
     void selectFile(const QString &filename);
     QStringList selectedFiles() const;
 
+    // Patch: Adding select-by-url for Windows file dialog.
+    QByteArray selectedRemoteContent() const;
+
     void selectUrl(const QUrl &url);
     QList<QUrl> selectedUrls() const;
 
diff --git a/src/widgets/dialogs/qfiledialog_p.h b/src/widgets/dialogs/qfiledialog_p.h
index f610e46..547a646 100644
--- a/src/widgets/dialogs/qfiledialog_p.h
+++ b/src/widgets/dialogs/qfiledialog_p.h
@@ -123,6 +123,10 @@ public:
     static QString initialSelection(const QUrl &path);
     QStringList typedFiles() const;
     QList<QUrl> userSelectedFiles() const;
+
+    // Patch: Adding select-by-url for Windows file dialog.
+    QByteArray userSelectedRemoteContent() const;
+
     QStringList addDefaultSuffixToFiles(const QStringList &filesToFix) const;
     QList<QUrl> addDefaultSuffixToUrls(const QList<QUrl> &urlsToFix) const;
     bool removeDirectory(const QString &path);
@@ -256,6 +260,10 @@ public:
     QUrl directory_sys() const;
     void selectFile_sys(const QUrl &filename);
     QList<QUrl> selectedFiles_sys() const;
+
+    // Patch: Adding select-by-url for Windows file dialog.
+    QByteArray selectedRemoteContent_sys() const;
+
     void setFilter_sys();
     void selectNameFilter_sys(const QString &filter);
     QString selectedNameFilter_sys() const;
@@ -393,6 +401,14 @@ inline QList<QUrl> QFileDialogPrivate::selectedFiles_sys() const
     return QList<QUrl>();
 }
 
+// Patch: Adding select-by-url for Windows file dialog.
+inline QByteArray QFileDialogPrivate::selectedRemoteContent_sys() const
+{
+    if (QPlatformFileDialogHelper *helper = platformFileDialogHelper())
+        return helper->selectedRemoteContent();
+    return QByteArray();
+}
+
 inline void QFileDialogPrivate::setFilter_sys()
 {
     if (QPlatformFileDialogHelper *helper = platformFileDialogHelper())
diff --git a/src/widgets/kernel/qwidget.cpp b/src/widgets/kernel/qwidget.cpp
index b1d80d7..42e32fd 100644
--- a/src/widgets/kernel/qwidget.cpp
+++ b/src/widgets/kernel/qwidget.cpp
@@ -5138,6 +5138,17 @@ void QWidget::render(QPainter *painter, const QPoint &targetOffset,
         return; // Fully transparent.
 
     Q_D(QWidget);
+
+    // Patch: save and restore dirtyOpaqueChildren field.
+    //
+    // Just like in QWidget::grab() this field should be restored
+    // after the d->render() call, because it will be set to 1 and
+    // opaqueChildren field will be filled with empty region in
+    // case the widget is hidden (because all the opaque children
+    // will be skipped in isVisible() check).
+    //
+    const bool oldDirtyOpaqueChildren = d->dirtyOpaqueChildren;
+
     const bool inRenderWithPainter = d->extra && d->extra->inRenderWithPainter;
     const QRegion toBePainted = !inRenderWithPainter ? d->prepareToRender(sourceRegion, renderFlags)
                                                      : sourceRegion;
@@ -5159,6 +5170,10 @@ void QWidget::render(QPainter *painter, const QPoint &targetOffset,
     if (!inRenderWithPainter && (opacity < 1.0 || (target->devType() == QInternal::Printer))) {
         d->render_helper(painter, targetOffset, toBePainted, renderFlags);
         d->extra->inRenderWithPainter = inRenderWithPainter;
+
+        // Patch: save and restore dirtyOpaqueChildren field.
+        d->dirtyOpaqueChildren = oldDirtyOpaqueChildren;
+
         return;
     }
 
@@ -5190,6 +5205,9 @@ void QWidget::render(QPainter *painter, const QPoint &targetOffset,
     d->setSharedPainter(oldPainter);
 
     d->extra->inRenderWithPainter = inRenderWithPainter;
+
+    // Patch: save and restore dirtyOpaqueChildren field.
+    d->dirtyOpaqueChildren = oldDirtyOpaqueChildren;
 }
 
 static void sendResizeEvents(QWidget *target)
@@ -8769,7 +8787,8 @@ bool QWidget::event(QEvent *event)
     case QEvent::KeyPress: {
         QKeyEvent *k = (QKeyEvent *)event;
         bool res = false;
-        if (!(k->modifiers() & (Qt::ControlModifier | Qt::AltModifier))) {  //### Add MetaModifier?
+        // Patch: Enable Ctrl+Tab and Ctrl+Shift+Tab / Ctrl+Backtab handle in-app.
+        if (!(k->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier))) {  //### Add MetaModifier?
             if (k->key() == Qt::Key_Backtab
                 || (k->key() == Qt::Key_Tab && (k->modifiers() & Qt::ShiftModifier)))
                 res = focusNextPrevChild(false);
diff --git a/src/widgets/util/qsystemtrayicon.cpp b/src/widgets/util/qsystemtrayicon.cpp
index 704142f..7c4340e 100644
--- a/src/widgets/util/qsystemtrayicon.cpp
+++ b/src/widgets/util/qsystemtrayicon.cpp
@@ -709,6 +709,10 @@ void QSystemTrayIconPrivate::updateMenu_sys_qpa()
     if (menu) {
         addPlatformMenu(menu);
         qpa_sys->updateMenu(menu->platformMenu());
+
+    // Patch: Create a rich os x tray icon (pixel-perfect, theme switching).
+    } else {
+        qpa_sys->updateMenu(nullptr);
     }
 }
 
diff --git a/src/widgets/widgets/qabstractscrollarea.cpp b/src/widgets/widgets/qabstractscrollarea.cpp
index 2e2a042..472e377 100644
--- a/src/widgets/widgets/qabstractscrollarea.cpp
+++ b/src/widgets/widgets/qabstractscrollarea.cpp
@@ -640,15 +640,22 @@ scrolling range.
 QSize QAbstractScrollArea::maximumViewportSize() const
 {
     Q_D(const QAbstractScrollArea);
-    int hsbExt = d->hbar->sizeHint().height();
-    int vsbExt = d->vbar->sizeHint().width();
+    // Patch: Count the sizeHint of the bar only if it is displayed.
+    //int hsbExt = d->hbar->sizeHint().height();
+    //int vsbExt = d->vbar->sizeHint().width();
 
     int f = 2 * d->frameWidth;
     QSize max = size() - QSize(f + d->left + d->right, f + d->top + d->bottom);
-    if (d->vbarpolicy == Qt::ScrollBarAlwaysOn)
+
+    // Patch: Count the sizeHint of the bar only if it is displayed.
+    if (d->vbarpolicy == Qt::ScrollBarAlwaysOn) {
+        int vsbExt = d->vbar->sizeHint().width();
         max.rwidth() -= vsbExt;
-    if (d->hbarpolicy == Qt::ScrollBarAlwaysOn)
+    }
+    if (d->hbarpolicy == Qt::ScrollBarAlwaysOn) {
+        int hsbExt = d->hbar->sizeHint().height();
         max.rheight() -= hsbExt;
+    }
     return max;
 }
 
diff --git a/src/widgets/widgets/qwidgetlinecontrol.cpp b/src/widgets/widgets/qwidgetlinecontrol.cpp
index daf9f00..57499dc 100644
--- a/src/widgets/widgets/qwidgetlinecontrol.cpp
+++ b/src/widgets/widgets/qwidgetlinecontrol.cpp
@@ -40,6 +40,11 @@
 #include <private/qguiapplication_p.h>
 #include <qpa/qplatformtheme.h>
 #include <qstylehints.h>
+
+// Patch: Enable Ctrl+key and Ctrl+Shift+key in all locales except German.
+// See https://github.com/telegramdesktop/tdesktop/pull/1185.
+#include <QtCore/QLocale>
+
 #ifndef QT_NO_ACCESSIBILITY
 #include "qaccessible.h"
 #endif
@@ -1882,11 +1887,21 @@ void QWidgetLineControl::processKeyEvent(QKeyEvent* event)
     }
 
     // QTBUG-35734: ignore Ctrl/Ctrl+Shift; accept only AltGr (Alt+Ctrl) on German keyboards
-    if (unknown && !isReadOnly()
-        && event->modifiers() != Qt::ControlModifier
-        && event->modifiers() != (Qt::ControlModifier | Qt::ShiftModifier)) {
+
+    // Patch: Enable Ctrl+key and Ctrl+Shift+key in all locales except German.
+    // See https://github.com/telegramdesktop/tdesktop/pull/1185.
+    bool skipCtrlAndCtrlShift = false;
+    if (QGuiApplication::inputMethod()->locale().language() == QLocale::German) {
+        if (event->modifiers() == Qt::ControlModifier
+            || event->modifiers() == (Qt::ControlModifier | Qt::ShiftModifier)) {
+            skipCtrlAndCtrlShift = true;
+        }
+    }
+    if (unknown && !isReadOnly() && !skipCtrlAndCtrlShift) {
         QString t = event->text();
-        if (!t.isEmpty() && t.at(0).isPrint()) {
+
+        // Patch: Enable ZWJ and ZWNJ characters to be in text input.
+        if (!t.isEmpty() && (t.at(0).isPrint() || t.at(0).unicode() == 0x200C || t.at(0).unicode() == 0x200D)) {
             insert(t);
 #ifndef QT_NO_COMPLETER
             complete(event->key());
diff --git a/src/widgets/widgets/qwidgettextcontrol.cpp b/src/widgets/widgets/qwidgettextcontrol.cpp
index deca002..8a2023f 100644
--- a/src/widgets/widgets/qwidgettextcontrol.cpp
+++ b/src/widgets/widgets/qwidgettextcontrol.cpp
@@ -71,6 +71,11 @@
 #include <qinputmethod.h>
 #include <qtooltip.h>
 #include <qstyleoption.h>
+
+// Patch: Enable Ctrl+key and Ctrl+Shift+key in all locales except German.
+// See https://github.com/telegramdesktop/tdesktop/pull/1185.
+#include <QtCore/QLocale>
+
 #include <QtWidgets/qlineedit.h>
 #include <QtGui/qaccessible.h>
 #include <QtCore/qmetaobject.h>
@@ -1343,13 +1348,24 @@ void QWidgetTextControlPrivate::keyPressEvent(QKeyEvent *e)
 process:
     {
         // QTBUG-35734: ignore Ctrl/Ctrl+Shift; accept only AltGr (Alt+Ctrl) on German keyboards
-        if (e->modifiers() == Qt::ControlModifier
-            || e->modifiers() == (Qt::ShiftModifier | Qt::ControlModifier)) {
+
+        // Patch: Enable Ctrl+key and Ctrl+Shift+key in all locales except German.
+        // See https://github.com/telegramdesktop/tdesktop/pull/1185.
+        bool skipCtrlAndCtrlShift = false;
+        if (QGuiApplication::inputMethod()->locale().language() == QLocale::German) {
+            if (e->modifiers() == Qt::ControlModifier
+                || e->modifiers() == (Qt::ControlModifier | Qt::ShiftModifier)) {
+                skipCtrlAndCtrlShift = true;
+            }
+        }
+        if (skipCtrlAndCtrlShift) {
             e->ignore();
             return;
         }
         QString text = e->text();
-        if (!text.isEmpty() && (text.at(0).isPrint() || text.at(0) == QLatin1Char('\t'))) {
+
+        // Patch: Enable ZWJ and ZWNJ characters to be in text input.
+        if (!text.isEmpty() && (text.at(0).isPrint() || text.at(0) == QLatin1Char('\t') || text.at(0).unicode() == 0x200C || text.at(0).unicode() == 0x200D)) {
             if (overwriteMode
                 // no need to call deleteChar() if we have a selection, insertText
                 // does it already
